diff --git a/.tarball-version b/.tarball-version
new file mode 100644
index 0000000..145050b
--- /dev/null
+++ b/.tarball-version
@@ -0,0 +1,1 @@
+20160827
diff --git a/ChangeLog.neomutt b/ChangeLog.neomutt
new file mode 100644
index 0000000..145050b
--- /dev/null
+++ b/ChangeLog.neomutt
@@ -0,0 +1,194 @@
+2016-08-27  Richard Russon  <rich@flatcap.org>
+* NeoMutt for Mutt 1.7.0
+* Build
+  - Disable fmemopen until bug is fixed
+* Contrib
+  - Keybase portability improvements
+    Joshua Jordi (JakkinStewart)
+
+2016-08-21  Richard Russon  <rich@flatcap.org>
+* Contrib
+  - Updates to Keybase Support
+    Joshua Jordi (JakkinStewart)
+* Bug Fixes
+  - Fix data-loss when appending a compressed file
+  - Don't paint invisible progress bars
+  - Revert to Mutt keybindings
+  - Don't de-tag emails after labelling them
+  - Don't whine if getrandom() fails
+    Adam Borowski (kilobyte)
+  - Fix display when 'from' field is invalid
+* Config
+  - Support for $XDG_CONFIG_HOME and $XDG_CONFIG_DIRS
+    Marco Hinz (mhinz)
+* Docs
+  - Fix DocBook validation
+  - Document NotMuch queries
+* Build
+  - More Autoconf improvements
+    Darshit Shah (darnir)
+  - Create Distribution Tarballs with autogen sources
+    Darshit Shah (darnir)
+
+2016-08-08  Richard Russon  <rich@flatcap.org>
+* New Features
+  - Timeout Hook - Run a command periodically
+  - Multiple fcc - Save multiple copies of outgoing mail
+* Contrib
+  - Keybase Integration
+    Joshua Jordi (JakkinStewart)
+* Devel
+  - Attached - Prevent missing attachments
+    Darshit Shah (darnir)
+  - Virtual Unmailboxes - Remove unwanted virtual mailboxes
+    Richard Russon (flatcap)
+* Bug Fixes
+  - Sidebar's inbox occasionally shows zero/wrong value
+  - Fix crash opening a second compressed mailbox
+* Config
+  - Look for /etc/NeoMuttrc and ~/.neomuttrc
+* Docs
+  - Fix broken links, typos
+  - Update project link
+  - Fix version string in the manual
+* Build
+  - Add option to disable fmemopen
+  - Install all the READMEs and contribs
+  - Big overhaul of the build
+    Darshit Shah (darnir)
+
+2016-07-23  Richard Russon  <rich@flatcap.org>
+* New Motto: "Teaching an Old Dog New Tricks"
+  - Thanks to Alok Singh
+* New Features
+  - New Mail Command - Execute a command on receipt of new mail
+  - vim-keybindings - Mutt config for vim users
+  - LMDB: In-memory header caching database
+  - SMIME Encrypt to Self - Secure storage of sensitive email
+* Bug Fixes
+  - rework mutt_draw_statusline()
+  - fix cursor position after sidebar redraw
+  - Add sidebar_format flag '%n' to display 'N' on new mail.
+  - fix index_format truncation problem
+  - Fix compiler warnings due to always true condition
+  - Change sidebar next/prev-new to look at buffy->new too.
+  - Change the default for sidebar_format to use %n.
+  - sidebar "unsorted" order to match Buffy list order.
+  - Include ncurses tinfo library if found.
+  - Sidebar width problem
+  - sidebar crash for non-existent mailbox
+  - Temporary compatibility workaround
+  - Reset buffy->new for the current mailbox in IMAP.
+  - version.sh regression
+  - crash when notmuch tries to read a message
+  - status line wrapping
+* Docs
+  - Mass tidy up of the docs
+  - Fix xml validation
+  - Add missing docs for new features
+* Travis
+  - New build system:
+    https://github.com/neomutt/travis-build
+    Now we have central control over what gets built
+
+2016-07-09  Richard Russon  <rich@flatcap.org>
+* Bug-fixes
+  - This release was a temporary measure
+
+2016-06-11  Richard Russon  <rich@flatcap.org>
+* Change in behaviour
+  - Temporarily disable $sidebar_refresh_time
+    Unfortunately, this was causing too many problems.
+    It will be fixed and re-enabled as soon as possible.
+* Bug Fixes
+  - Fix several crashes, on startup, in Keywords
+  - Reflow text now works as it should
+  - Lots of typos fixed
+  - Compress config bug prevented it working
+  - Some minor bug-fixes from mutt/default
+  - Single quote at line beginning misinterpreted by groff
+  - Setting $sidebar_width to more than 128 would cause bad things to happen.
+  - Fix alignment in the compose menu.
+  - Fix sidebar buffy stats updating on mailbox close.
+* Build Changes
+  - Sync whitespace to mutt/default
+  - Alter ChangeLog date format to simplify Makefiles
+  - Use the new notmuch functions that return a status
+  - Rename sidebar functions sb_* -> mutt_sb_*
+
+2016-05-23  Richard Russon  <rich@flatcap.org>
+* New Features:
+  - Keywords: Email Label/Keywords/Tagging
+  - Compress: Compressed mailboxes support
+  - NNTP: Talk to a usenet news server
+  - Separate mappings for <enter> and <return>
+  - New configure option: --enable-quick-build
+  - Various build fixes
+
+2016-05-02  Richard Russon  <rich@flatcap.org>
+* Update for Mutt-1.6.0
+* Bug Fixes:
+  - Build for Notmuch works if Sidebar is disabled
+  - Sidebar functions work even if the Sidebar is hidden
+  - sidebar-next-new, etc, only find *new* mail, as documented
+  - Notmuch supports *very* long queries
+
+2016-04-16  Richard Russon  <rich@flatcap.org>
+* Big Bugfix Release
+* Bug Fixes:
+  - Fix crash caused by sidebar_folder_indent
+  - Allow the user to change mailboxes again
+  - Correct sidebar's messages counts
+  - Only sort the sidebar if we're asked to
+  - Fix refresh of pager when toggling the sidebar
+  - Compose mode: make messages respect the TITLE_FMT
+  - Conditional include if sys/syscall.h
+  - Build fix for old compilers
+  - Try harder to keep track of the open mailbox
+* Changes to Features
+  - Allow sidebar_divider_char to be longer
+    (it was limited to one character)
+  - Ignore case when sorting the sidebar alphabetically
+* Other Changes
+  - Numerous small tweaks to the docs
+  - Lots of minor code tidy-ups
+  - Enabling NotMuch now forcibly enables Sidebar
+    (it is dependent on it, for now)
+  - A couple of bug fixes from mutt/stable
+
+2016-04-04  Richard Russon  <rich@flatcap.org>
+* Update for Mutt-1.6.0
+* No other changes in this release
+
+2016-03-28  Richard Russon  <rich@flatcap.org>
+* New Features
+  - skip-quoted          - skip quoted text
+  - limit-current-thread - limit index view to current thread
+* Sidebar Intro - A Gentle Introduction to the Sidebar (with pictures).
+
+2016-03-20  Richard Russon  <rich@flatcap.org>
+* Numerous small bugfixes
+* TravisCI integration
+
+2016-03-17  Richard Russon  <rich@flatcap.org>
+* New Features
+  - notmuch - email search support
+  - ifdef   - improvements
+
+2016-03-07  Richard Russon  <rich@flatcap.org>
+* First NeoMutt release
+* List of Features:
+  - bug-fixes    - various bug fixes
+  - cond-date    - use rules to choose date format
+  - fmemopen     - use memory buffers instead of files
+  - ifdef        - conditional config options
+  - index-color  - theme the email index
+  - initials     - expando for author's initials
+  - nested-if    - allow deeply nested conditions
+  - progress     - show a visual progress bar
+  - quasi-delete - mark emails to be hidden
+  - sidebar      - overview of mailboxes
+  - status-color - theming the status bar
+  - tls-sni      - negotiate for a certificate
+  - trash        - move 'deleted' emails to a trash bin
+
diff --git a/ChangeLog.nntp b/ChangeLog.nntp
new file mode 100644
index 0000000..1452e86
--- /dev/null
+++ b/ChangeLog.nntp
@@ -0,0 +1,416 @@
+* Wed Apr  6 2016 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.6.0
+- %R changed to %x in format strings
+
+* Wed Nov 25 2015 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed memory leaks
+- fixed SIGSEGV when reading hcache in some cases
+
+* Tue Nov 10 2015 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed error compiling with nntp and without imap or pop3
+- fixed error loading articles after <change-newsgroup> and <quit>
+
+* Wed Sep  2 2015 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.24
+- new option nntp_listgroup
+- use range in LISTGROUP command if possible
+
+* Thu Mar 13 2014 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.23
+
+* Tue Oct 29 2013 Vsevolod Volkov <vvv@mutt.org.ua>
+- minor bug fixed while removing new articles
+
+* Fri Oct 18 2013 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.22
+
+* Tue Nov 27 2012 Vsevolod Volkov <vvv@mutt.org.ua>
+- SASL authentication
+- new option nntp_authenticators
+
+* Fri Nov 16 2012 Vsevolod Volkov <vvv@mutt.org.ua>
+- support of NNTP commands: CAPABILITIES, STARTTLS, LIST NEWSGROUPS,
+  LIST OVERVIEW.FMT, OVER, DATE
+- added bcache support
+- newss URI scheme renamed to snews
+- removed option nntp_reconnect
+
+* Sun Sep 16 2012 Vsevolod Volkov <vvv@mutt.org.ua>
+- internal header caching replaced with hcache
+- new option newsgroups_charset
+
+* Wed Sep 16 2010 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.21
+
+* Thu Aug 13 2009 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed writting references in nntp_save_cache_group()
+
+* Tue Jun 15 2009 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.20
+
+* Tue Mar 20 2009 Vsevolod Volkov <vvv@mutt.org.ua>
+- save Date: header of recorded outgoing articles
+
+* Tue Jan  6 2009 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.19
+
+* Mon May 19 2008 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.18
+- fixed SIGSEGV when followup or forward to newsgroup
+
+* Sun Nov  4 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.17
+
+* Tue Jul  3 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed arguments of nntp_format_str()
+
+* Fri Jun 15 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed error selecting news group
+
+* Tue Jun 12 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.16
+
+* Wed Apr 11 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed posting error if $smtp_url is set
+- added support of print-style sequence %R (x-comment-to)
+
+* Sun Apr  8 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.15
+- nntp://... url changed to news://...
+- added indicator of fetching descriptions progress
+
+* Tue Feb 28 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.14
+
+* Tue Aug 15 2006 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.13
+
+* Mon Jul 17 2006 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.12
+- fixed reading empty .newsrc
+
+* Sat Sep 17 2005 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.11
+
+* Sat Aug 13 2005 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.10
+
+* Sun Mar 13 2005 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.9
+
+* Sun Feb 13 2005 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.8
+
+* Sat Feb  5 2005 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.7
+- function mutt_update_list_file() moved to newsrc.c and changed algorithm
+
+* Thu Jul  8 2004 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed error in nntp_logout_all()
+
+* Sat Apr  3 2004 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed debug output in mutt_newsrc_update()
+- added optional support of LISTGROUP command
+- fixed typo in nntp_parse_xref()
+
+* Tue Feb  3 2004 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.6
+
+* Thu Dec 18 2003 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed compose menu
+
+* Thu Nov  6 2003 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.5.1
+
+* Wed Nov  5 2003 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.5
+- added space after newsgroup name in .newsrc file
+
+* Sun May 18 2003 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed SIGSEGV when posting article
+
+* Sat Mar 22 2003 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.4
+
+* Sat Dec 21 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.3
+- replace safe_free calls by the FREE macro
+
+* Fri Dec  6 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.2
+- nntp authentication can be passed after any command
+
+* Sat May  4 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.1
+
+* Thu May  2 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.99
+
+* Wed Mar 13 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.28
+- fixed SIGSEGV in <get-message>, <get-parent>, <get-children>,
+  <reconstruct-thread> functions
+- fixed message about nntp reconnect
+- fixed <attach-news-message> function using browser
+- added support of Followup-To: poster
+- added %n (new articles) in group_index_format
+- posting articles without inews by default
+
+* Wed Jan 23 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.27
+
+* Fri Jan 18 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.26
+
+* Thu Jan  3 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.25
+- accelerated speed of access to news->newsgroups hash (by <gul@gul.kiev.ua>)
+- added default content disposition
+
+* Mon Dec  3 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.24
+
+* Fri Nov  9 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.23.2
+- fixed segfault if mutt_conn_find() returns null
+
+* Wed Oct 31 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.23.1
+- added support of LISTGROUP command
+- added support for servers with broken overview
+- disabled <flag-message> function on news server
+- fixed error storing bad authentication information
+
+* Wed Oct 10 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.23
+- fixed typo in buffy.c
+- added substitution of %s parameter in $inews variable
+
+* Fri Aug 31 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.22.1
+- update to 1.3.22
+
+* Thu Aug 23 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.21
+
+* Wed Jul 25 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.20
+- removed 'server-hook', use 'account-hook' instead
+- fixed error opening NNTP server without newsgroup using -f option
+
+* Fri Jun  8 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.19
+
+* Sat May  5 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.18
+- fixed typo in nntp_attempt_features()
+- changed algorithm of XGTITLE command testing
+- disabled writing of NNTP password in debug file
+- fixed reading and writing of long newsrc lines
+- changed checking of last line while reading lines from server
+- fixed possible buffer overrun in nntp_parse_newsrc_line()
+- removed checking of XHDR command
+- compare NNTP return codes without trailing space
+
+* Thu Mar 29 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.17
+- support for 'LIST NEWSGROUPS' command to read descriptions
+
+* Fri Mar  2 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.16
+
+* Wed Feb 14 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.15
+
+* Sun Jan 28 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.14
+- show number of tagged messages patch from Felix von Leitner <leitner@fefe.de>
+
+* Sun Dec 31 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.13
+
+* Sat Dec 30 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- Fixed problem if last article in group is deleted
+
+* Fri Dec 22 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- Fixed checking of XGTITLE command on some servers
+
+* Mon Dec 18 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- Added \r in AUTHINFO commands
+
+* Mon Nov 27 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.12
+
+* Wed Nov  1 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.11
+- fixed error opening newsgroup from mutt started with -g or -G
+
+* Thu Oct 12 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.10
+- hotkey 'G' (get-message) replaced with '^G'
+
+* Thu Sep 21 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.9
+- changed delay displaying error messages from 1 to 2 seconds
+- fixed error compiling with nntp and without imap
+
+* Wed Sep  6 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed catchup in index
+- fixed nntp_open_mailbox()
+
+* Sat Sep  2 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- functions <edit> and <delete-entry> disabled
+- format of news mailbox names changed to url form
+- option nntp_attempts removed
+- option reconnect_news renamed to nntp_reconnect
+- default value of nntp_poll changed from 30 to 60
+- error handling improved
+
+* Wed Aug 30 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.8
+- new option show_only_unread
+- add newsgroup completion
+
+* Fri Aug  4 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.7
+
+* Sat Jul 29 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.6
+
+* Sun Jul  9 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.5
+- authentication code update
+- fix for changing to newsgroup from mailbox with read messages
+- socket code optimization
+
+* Wed Jun 21 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.4
+
+* Wed Jun 14 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- don't substitute current newsgroup with deleted new messages
+
+* Mon Jun 12 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.3
+- fix for substitution of newsgroup after reconnection
+- fix for loading newsgroups with very long names
+- fix for loading more than 32768 newsgroups
+
+* Wed May 24 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.2
+
+* Sat May 20 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.1
+
+* Fri May 12 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3
+
+* Thu May 11 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.2
+
+* Thu May  4 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.14
+
+* Sun Apr 23 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.12
+
+* Fri Apr  7 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- add substitution of newsgroup with new messages by default
+
+* Wed Apr  5 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- add attach message from newsgroup
+- add one-line help in newsreader mode
+- disable 'change-dir' command in newsgroups browser
+- add -G option
+
+* Tue Apr  4 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- get default news server name from file /etc/nntpserver
+- use case insensitive server names
+- add print-style sequence %s to $newsrc
+- add -g option
+
+* Sat Apr  1 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- remove 'X-FTN-Origin' header processing
+
+* Thu Mar 30 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.11
+- update to 1.1.10
+
+* Thu Mar 23 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix mutt_select_newsserver()
+- remove 'toggle-mode' function
+- add 'change-newsgroup' function
+
+* Wed Mar 22 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix server-hook
+
+* Tue Mar 21 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix error 'bounce' function after 'post'
+- add 'forward to newsgroup' function
+
+* Mon Mar 20 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- 'forward' function works in newsreader mode
+- add 'post' and 'followup' functions to pager and attachment menu
+- fix active descriptions and allowed flag reload
+
+* Tue Mar 14 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.9
+- remove deleted newsgroups from list
+
+* Mon Mar 13 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update .newsrc in browser
+
+* Sun Mar 12 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- reload .newsrc if externally modified
+- fix active cache update
+
+* Sun Mar  5 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.8
+
+* Sat Mar  4 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- patch *.update_list_file is not required
+- count lines when loading descriptions
+- remove cache of unsubscribed newsgroups
+
+* Thu Mar  2 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- load list of newsgroups from cache faster
+
+* Wed Mar  1 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.7
+
+* Tue Feb 29 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix unread messages in browser
+- fix newsrc_gen_entries()
+
+* Mon Feb 28 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix mutt_newsgroup_stat()
+- fix nntp_delete_cache()
+- fix nntp_get_status()
+- fix check_children()
+- fix nntp_fetch_headers()
+
+* Fri Feb 25 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.5
+
+* Thu Feb 24 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix updating new messages in cache
+
+* Mon Feb 21 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- change default cache filenames
+- fix updating new messages in cache
+
+* Fri Feb 18 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix segmentation fault in news groups browser
+
+* Tue Feb 15 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.4
+
+* Thu Feb 10 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.3
+
+* Sun Jan 30 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- add X-Comment-To editing
+- add my_hdr support for Newsgroups:, Followup-To: and X-Comment-To: headers
+- add variables $ask_followup_to and $ask_x_comment_to
+
+* Fri Jan 28 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.2
diff --git a/GPL b/GPL
index b6f92f3..0daa041 100644
--- a/GPL
+++ b/GPL
@@ -1,73 +1,74 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
+GNU General Public License
+==========================
 
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-                 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
+_Version 2, June 1991_  
+_Copyright © 1989, 1991 Free Software Foundation, Inc.,_  
+_51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA_
 
-			    Preamble
+Everyone is permitted to copy and distribute verbatim copies
+of this license document, but changing it is not allowed.
 
-  The licenses for most software are designed to take away your
+### Preamble
+
+The licenses for most software are designed to take away your
 freedom to share and change it.  By contrast, the GNU General Public
 License is intended to guarantee your freedom to share and change free
 software--to make sure the software is free for all its users.  This
 General Public License applies to most of the Free Software
 Foundation's software and to any other program whose authors commit to
 using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
+the GNU Lesser General Public License instead.)  You can apply it to
 your programs, too.
 
-  When we speak of free software, we are referring to freedom, not
+When we speak of free software, we are referring to freedom, not
 price.  Our General Public Licenses are designed to make sure that you
 have the freedom to distribute copies of free software (and charge for
 this service if you wish), that you receive source code or can get it
 if you want it, that you can change the software or use pieces of it
 in new free programs; and that you know you can do these things.
 
-  To protect your rights, we need to make restrictions that forbid
+To protect your rights, we need to make restrictions that forbid
 anyone to deny you these rights or to ask you to surrender the rights.
 These restrictions translate to certain responsibilities for you if you
 distribute copies of the software, or if you modify it.
 
-  For example, if you distribute copies of such a program, whether
+For example, if you distribute copies of such a program, whether
 gratis or for a fee, you must give the recipients all the rights that
 you have.  You must make sure that they, too, receive or can get the
 source code.  And you must show them these terms so they know their
 rights.
 
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
+We protect your rights with two steps: **(1)** copyright the software, and
+**(2)** offer you this license which gives you legal permission to copy,
 distribute and/or modify the software.
 
-  Also, for each author's protection and ours, we want to make certain
+Also, for each author's protection and ours, we want to make certain
 that everyone understands that there is no warranty for this free
 software.  If the software is modified by someone else and passed on, we
 want its recipients to know that what they have is not the original, so
 that any problems introduced by others will not reflect on the original
 authors' reputations.
 
-  Finally, any free program is threatened constantly by software
+Finally, any free program is threatened constantly by software
 patents.  We wish to avoid the danger that redistributors of a free
 program will individually obtain patent licenses, in effect making the
 program proprietary.  To prevent this, we have made it clear that any
 patent must be licensed for everyone's free use or not licensed at all.
 
-  The precise terms and conditions for copying, distribution and
+The precise terms and conditions for copying, distribution and
 modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 
-  0. This License applies to any program or other work which contains
+### TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+**0.** This License applies to any program or other work which contains
 a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
+under the terms of this General Public License.  The “Program”, below,
+refers to any such program or work, and a “work based on the Program”
 means either the Program or any derivative work under copyright law:
 that is to say, a work containing the Program or a portion of it,
 either verbatim or with modifications and/or translated into another
 language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
+the term “modification”.)  Each licensee is addressed as “you”.
 
 Activities other than copying, distribution and modification are not
 covered by this License; they are outside its scope.  The act of
@@ -76,7 +77,7 @@ is covered only if its contents constitute a work based on the
 Program (independent of having been made by running the Program).
 Whether that is true depends on what the Program does.
 
-  1. You may copy and distribute verbatim copies of the Program's
+**1.** You may copy and distribute verbatim copies of the Program's
 source code as you receive it, in any medium, provided that you
 conspicuously and appropriately publish on each copy an appropriate
 copyright notice and disclaimer of warranty; keep intact all the
@@ -87,30 +88,28 @@ along with the Program.
 You may charge a fee for the physical act of transferring a copy, and
 you may at your option offer warranty protection in exchange for a fee.
 
-  2. You may modify your copy or copies of the Program or any portion
+**2.** You may modify your copy or copies of the Program or any portion
 of it, thus forming a work based on the Program, and copy and
 distribute such modifications or work under the terms of Section 1
 above, provided that you also meet all of these conditions:
 
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
+* **a)** You must cause the modified files to carry prominent notices
+stating that you changed the files and the date of any change.
+* **b)** You must cause any work that you distribute or publish, that in
+whole or in part contains or is derived from the Program or any
+part thereof, to be licensed as a whole at no charge to all third
+parties under the terms of this License.
+* **c)** If the modified program normally reads commands interactively
+when run, you must cause it, when started running for such
+interactive use in the most ordinary way, to print or display an
+announcement including an appropriate copyright notice and a
+notice that there is no warranty (or else, saying that you provide
+a warranty) and that users may redistribute the program under
+these conditions, and telling the user how to view a copy of this
+License.  (Exception: if the Program itself is interactive but
+does not normally print such an announcement, your work based on
+the Program is not required to print an announcement.)
+
 These requirements apply to the modified work as a whole.  If
 identifiable sections of that work are not derived from the Program,
 and can be reasonably considered independent and separate works in
@@ -131,26 +130,24 @@ with the Program (or with a work based on the Program) on a volume of
 a storage or distribution medium does not bring the other work under
 the scope of this License.
 
-  3. You may copy and distribute the Program (or a work based on it,
+**3.** You may copy and distribute the Program (or a work based on it,
 under Section 2) in object code or executable form under the terms of
 Sections 1 and 2 above provided that you also do one of the following:
 
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
+* **a)** Accompany it with the complete corresponding machine-readable
+source code, which must be distributed under the terms of Sections
+1 and 2 above on a medium customarily used for software interchange; or,
+* **b)** Accompany it with a written offer, valid for at least three
+years, to give any third party, for a charge no more than your
+cost of physically performing source distribution, a complete
+machine-readable copy of the corresponding source code, to be
+distributed under the terms of Sections 1 and 2 above on a medium
+customarily used for software interchange; or,
+* **c)** Accompany it with the information you received as to the offer
+to distribute corresponding source code.  (This alternative is
+allowed only for noncommercial distribution and only if you
+received the program in object code or executable form with such
+an offer, in accord with Subsection b above.)
 
 The source code for a work means the preferred form of the work for
 making modifications to it.  For an executable work, complete source
@@ -168,8 +165,8 @@ access to copy from a designated place, then offering equivalent
 access to copy the source code from the same place counts as
 distribution of the source code, even though third parties are not
 compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
+
+**4.** You may not copy, modify, sublicense, or distribute the Program
 except as expressly provided under this License.  Any attempt
 otherwise to copy, modify, sublicense or distribute the Program is
 void, and will automatically terminate your rights under this License.
@@ -177,7 +174,7 @@ However, parties who have received copies, or rights, from you under
 this License will not have their licenses terminated so long as such
 parties remain in full compliance.
 
-  5. You are not required to accept this License, since you have not
+**5.** You are not required to accept this License, since you have not
 signed it.  However, nothing else grants you permission to modify or
 distribute the Program or its derivative works.  These actions are
 prohibited by law if you do not accept this License.  Therefore, by
@@ -186,7 +183,7 @@ Program), you indicate your acceptance of this License to do so, and
 all its terms and conditions for copying, distributing or modifying
 the Program or works based on it.
 
-  6. Each time you redistribute the Program (or any work based on the
+**6.** Each time you redistribute the Program (or any work based on the
 Program), the recipient automatically receives a license from the
 original licensor to copy, distribute or modify the Program subject to
 these terms and conditions.  You may not impose any further
@@ -194,7 +191,7 @@ restrictions on the recipients' exercise of the rights granted herein.
 You are not responsible for enforcing compliance by third parties to
 this License.
 
-  7. If, as a consequence of a court judgment or allegation of patent
+**7.** If, as a consequence of a court judgment or allegation of patent
 infringement or for any other reason (not limited to patent issues),
 conditions are imposed on you (whether by court order, agreement or
 otherwise) that contradict the conditions of this License, they do not
@@ -225,8 +222,8 @@ impose that choice.
 
 This section is intended to make thoroughly clear what is believed to
 be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
+
+**8.** If the distribution and/or use of the Program is restricted in
 certain countries either by patents or by copyrighted interfaces, the
 original copyright holder who places the Program under this License
 may add an explicit geographical distribution limitation excluding
@@ -234,20 +231,20 @@ those countries, so that distribution is permitted only in or among
 countries not thus excluded.  In such case, this License incorporates
 the limitation as if written in the body of this License.
 
-  9. The Free Software Foundation may publish revised and/or new versions
+**9.** The Free Software Foundation may publish revised and/or new versions
 of the General Public License from time to time.  Such new versions will
 be similar in spirit to the present version, but may differ in detail to
 address new problems or concerns.
 
 Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
+specifies a version number of this License which applies to it and “any
+later version”, you have the option of following the terms and conditions
 either of that version or of any later version published by the Free
 Software Foundation.  If the Program does not specify a version number of
 this License, you may choose any version ever published by the Free Software
 Foundation.
 
-  10. If you wish to incorporate parts of the Program into other free
+**10.** If you wish to incorporate parts of the Program into other free
 programs whose distribution conditions are different, write to the author
 to ask for permission.  For software which is copyrighted by the Free
 Software Foundation, write to the Free Software Foundation; we sometimes
@@ -255,19 +252,19 @@ make exceptions for this.  Our decision will be guided by the two goals
 of preserving the free status of all derivatives of our free software and
 of promoting the sharing and reuse of software generally.
 
-			    NO WARRANTY
+### NO WARRANTY
 
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+**11.** BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
 FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
 OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+PROVIDE THE PROGRAM “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
 OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
 TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
 PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
 REPAIR OR CORRECTION.
 
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+**12.** IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
 REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
 INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
@@ -277,36 +274,35 @@ YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
 PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 POSSIBILITY OF SUCH DAMAGES.
 
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
+END OF TERMS AND CONDITIONS
 
-  If you develop a new program, and you want it to be of the greatest
+### How to Apply These Terms to Your New Programs
+
+If you develop a new program, and you want it to be of the greatest
 possible use to the public, the best way to achieve this is to make it
 free software which everyone can redistribute and change under these terms.
 
-  To do so, attach the following notices to the program.  It is safest
+To do so, attach the following notices to the program.  It is safest
 to attach them to the start of each source file to most effectively
 convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
+the “copyright” line and a pointer to where the full notice is found.
 
     <one line to give the program's name and a brief idea of what it does.>
     Copyright (C) <year>  <name of author>
-
+    
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
-
+    
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
-
+    
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
 Also add information on how to contact you by electronic and paper mail.
 
@@ -318,23 +314,23 @@ when it starts in an interactive mode:
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.
 
-The hypothetical commands `show w' and `show c' should show the appropriate
+The hypothetical commands `show w` and `show c` should show the appropriate
 parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
+be called something other than `show w` and `show c`; they could even be
 mouse-clicks or menu items--whatever suits your program.
 
 You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
+school, if any, to sign a “copyright disclaimer” for the program, if
 necessary.  Here is a sample; alter the names:
 
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
+    Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+    `Gnomovision' (which makes passes at compilers) written by James Hacker.
+    
+    <signature of Ty Coon>, 1 April 1989
+    Ty Coon, President of Vice
 
 This General Public License does not permit incorporating your program into
 proprietary programs.  If your program is a subroutine library, you may
 consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
+library.  If this is what you want to do, use the GNU Lesser General
 Public License instead of this License.
diff --git a/Makefile.am b/Makefile.am
index a052495..bf8c591 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -12,13 +12,13 @@ endif
 
 SUBDIRS = m4 po intl doc contrib $(IMAP_SUBDIR)
 
-bin_SCRIPTS = muttbug flea $(SMIMEAUX_TARGET)
+bin_SCRIPTS = $(SMIMEAUX_TARGET)
 
 if BUILD_HCACHE
 HCVERSION = hcversion.h
 endif
 
-BUILT_SOURCES = keymap_defs.h patchlist.c reldate.h conststrings.c $(HCVERSION)
+BUILT_SOURCES = keymap_defs.h patchlist.c oldmutt_ver.h conststrings.c hcachever.sh $(HCVERSION) $(top_srcdir)/.version
 
 bin_PROGRAMS = mutt $(DOTLOCK_TARGET) $(PGPAUX_TARGET)
 mutt_SOURCES = \
@@ -34,7 +34,7 @@ mutt_SOURCES = \
 	score.c send.c sendlib.c signal.c sort.c \
 	status.c system.c thread.c charset.c history.c lib.c \
 	muttlib.c editmsg.c mbyte.c \
-	url.c ascii.c crypt-mod.c crypt-mod.h safe_asprintf.c
+	url.c ascii.c crypt-mod.c crypt-mod.h safe_asprintf.c version.c
 
 nodist_mutt_SOURCES = $(BUILT_SOURCES)
 
@@ -50,33 +50,46 @@ DEFS=-DPKGDATADIR=\"$(pkgdatadir)\" -DSYSCONFDIR=\"$(sysconfdir)\" \
 
 AM_CPPFLAGS=-I. -I$(top_srcdir) $(IMAP_INCLUDES) $(GPGME_CFLAGS) -Iintl
 
-EXTRA_mutt_SOURCES = account.c bcache.c crypt-gpgme.c crypt-mod-pgp-classic.c \
+EXTRA_mutt_SOURCES = account.c bcache.c compress.c crypt-gpgme.c crypt-mod-pgp-classic.c \
 	crypt-mod-pgp-gpgme.c crypt-mod-smime-classic.c \
 	crypt-mod-smime-gpgme.c dotlock.c gnupgparse.c hcache.c md5.c \
 	mutt_idna.c mutt_sasl.c mutt_socket.c mutt_ssl.c mutt_ssl_gnutls.c \
 	mutt_tunnel.c pgp.c pgpinvoke.c pgpkey.c pgplib.c pgpmicalg.c \
 	pgppacket.c pop.c pop_auth.c pop_lib.c remailer.c resize.c sha1.c \
+	nntp.c newsrc.c \
 	sidebar.c smime.c smtp.c utf8.c wcwidth.c \
 	bcache.h browser.h hcache.h mbyte.h mutt_idna.h remailer.h url.h
 
 EXTRA_DIST = COPYRIGHT GPL OPS OPS.PGP OPS.CRYPT OPS.SMIME TODO UPDATING \
-	configure account.h \
-	attach.h buffy.h charset.h copy.h crypthash.h dotlock.h functions.h gen_defs \
+	account.h \
+	attach.h buffy.h charset.h compress.h copy.h crypthash.h dotlock.h functions.h gen_defs \
 	globals.h hash.h history.h init.h keymap.h mutt_crypt.h \
 	mailbox.h mapping.h md5.h mime.h mutt.h mutt_curses.h mutt_menu.h \
 	mutt_regex.h mutt_sasl.h mutt_socket.h mutt_ssl.h mutt_tunnel.h \
 	mx.h pager.h pgp.h pop.h protos.h rfc1524.h rfc2047.h \
-	rfc2231.h rfc822.h rfc3676.h sha1.h sort.h mime.types VERSION prepare \
+	rfc2231.h rfc822.h rfc3676.h sha1.h sort.h mime.types \
+	nntp.h ChangeLog.nntp \
 	_regex.h OPS.MIX README.SECURITY remailer.c remailer.h browser.h \
 	mbyte.h lib.h extlib.c pgpewrap.c smime_keys.pl pgplib.h \
-	README.SSL smime.h group.h \
-	muttbug pgppacket.h depcomp ascii.h BEWARE PATCHES patchlist.sh \
-	ChangeLog mkchangelog.sh mutt_idna.h sidebar.h OPS.SIDEBAR \
+	README.SSL README.md README.neomutt smime.h group.h \
+	pgppacket.h depcomp ascii.h PATCHES patchlist.sh \
+	ChangeLog ChangeLog.neomutt mutt_idna.h sidebar.h OPS.SIDEBAR \
 	snprintf.c regex.c crypt-gpgme.h hcachever.sh.in \
-	txt2c.c txt2c.sh version.sh check_sec.sh
+	txt2c.c txt2c.sh version.h \
+	$(top_srcdir)/.version git-version-gen
 
 EXTRA_SCRIPTS = smime_keys
 
+if BUILD_NOTMUCH
+mutt_SOURCES += mutt_notmuch.c mutt_notmuch.h
+mutt_LDADD += $(NOTMUCH_LIBS)
+endif
+
+# kz
+EXTRA_DIST += UPDATING.kz OPS.NOTMUCH
+
+
+
 mutt_dotlock_SOURCES = mutt_dotlock.c
 mutt_dotlock_LDADD = $(LIBOBJS)
 mutt_dotlock_DEPENDENCIES = $(LIBOBJS)
@@ -112,15 +125,17 @@ conststrings.c: txt2c config.status
 
 CLEANFILES = mutt_dotlock.c keymap_alldefs.h $(BUILT_SOURCES)
 
-DISTCLEANFILES= flea smime_keys txt2c po/$(PACKAGE).pot
+DISTCLEANFILES= smime_keys txt2c po/$(PACKAGE).pot
 
 ACLOCAL_AMFLAGS = -I m4
 
 LDADD = $(LIBOBJS) $(INTLLIBS)
 
-flea:	muttbug.sh
-	cp muttbug.sh flea
-	chmod +x flea
+$(top_srcdir)/.version:
+	echo $(VERSION) > $@-t && mv $@-t $@
+
+dist-hook:
+	echo $(VERSION) > $(distdir)/.tarball-version
 
 smime_keys: $(srcdir)/smime_keys.pl
 	cp $(srcdir)/smime_keys.pl smime_keys
@@ -129,16 +144,22 @@ smime_keys: $(srcdir)/smime_keys.pl
 keymap_defs.h: $(OPS) $(srcdir)/gen_defs
 	$(srcdir)/gen_defs $(OPS) > keymap_defs.h
 
-keymap_alldefs.h: $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.PGP $(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME $(srcdir)/gen_defs
+keymap_alldefs.h: $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.NOTMUCH $(srcdir)/OPS.PGP $(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME $(srcdir)/gen_defs
 	rm -f $@
-	$(srcdir)/gen_defs $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.PGP \
+	$(srcdir)/gen_defs $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.NOTMUCH $(srcdir)/OPS.PGP \
 		$(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME \
 			> keymap_alldefs.h
 
-reldate.h: $(srcdir)/ChangeLog
-	echo 'const char *ReleaseDate = "'`head -n 1 $(srcdir)/ChangeLog | LC_ALL=C cut -d ' ' -f 1`'";' > reldate.h.tmp; \
-	cmp -s reldate.h.tmp reldate.h || cp reldate.h.tmp reldate.h; \
-	rm reldate.h.tmp
+oldmutt_ver.h:
+	version=`git tag | grep ^mutt- | sort -V | tail -1 | LC_ALL=C cut -b 6-` && \
+	echo 'const char *OldMuttVer = "'$$version'";' > oldmutt_ver.h.tmp; \
+	cmp -s oldmutt_ver.h.tmp oldmutt_ver.h || mv oldmutt_ver.h.tmp oldmutt_ver.h
+
+# reldate.h:
+# 	date=`head -n 1 $(top_srcdir)/ChangeLog.neomutt | LC_ALL=C cut -b 1-10` && \
+# 	echo 'const char *ReleaseDate = "'$$date'";' > reldate.h.tmp; \
+# 	cmp -s reldate.h.tmp reldate.h || cp reldate.h.tmp reldate.h; \
+# 	rm reldate.h.tmp
 
 # The '#undef ENABLE_NLS' is to work around an automake ordering issue:
 # BUILT_SOURCES are processed before SUBDIRS.
@@ -184,17 +205,6 @@ pclean:
 check-security:
 	(cd $(top_srcdir) && ./check_sec.sh)
 
-commit:
-	@echo "make commit is obsolete; use hg-commit"; false
-
-update-changelog:
-	(cd $(top_srcdir); \
-	sh ./mkchangelog.sh | cat  - ChangeLog > ChangeLog.$$$$ && mv ChangeLog.$$$$ ChangeLog; \
-	$${VISUAL:-vi} ChangeLog)
-
-mutt-dist:
-	(cd $(srcdir) && ./build-release )
-
 update-doc:
 	(cd doc && $(MAKE) update-doc)
 
diff --git a/OPS b/OPS
index 02cea8e..76d2672 100644
--- a/OPS
+++ b/OPS
@@ -8,14 +8,16 @@ OP_BOUNCE_MESSAGE "remail a message to another user"
 OP_BROWSER_NEW_FILE "select a new file in this directory"
 OP_BROWSER_VIEW_FILE "view file"
 OP_BROWSER_TELL "display the currently selected file's name"
-OP_BROWSER_SUBSCRIBE "subscribe to current mailbox (IMAP only)"
-OP_BROWSER_UNSUBSCRIBE "unsubscribe from current mailbox (IMAP only)"
+OP_BROWSER_SUBSCRIBE "subscribe to current mbox (IMAP/NNTP only)"
+OP_BROWSER_UNSUBSCRIBE "unsubscribe from current mbox (IMAP/NNTP only)"
 OP_BROWSER_TOGGLE_LSUB "toggle view all/subscribed mailboxes (IMAP only)"
 OP_BUFFY_LIST "list mailboxes with new mail"
+OP_CATCHUP "mark all articles in newsgroup as read"
 OP_CHANGE_DIRECTORY "change directories"
 OP_CHECK_NEW "check mailboxes for new mail"
 OP_COMPOSE_ATTACH_FILE "attach file(s) to this message"
 OP_COMPOSE_ATTACH_MESSAGE "attach message(s) to this message"
+OP_COMPOSE_ATTACH_NEWS_MESSAGE "attach news article(s) to this message"
 OP_COMPOSE_EDIT_BCC "edit the BCC list"
 OP_COMPOSE_EDIT_CC "edit the CC list"
 OP_COMPOSE_EDIT_DESCRIPTION "edit attachment description"
@@ -26,7 +28,10 @@ OP_COMPOSE_EDIT_FROM "edit the from field"
 OP_COMPOSE_EDIT_HEADERS "edit the message with headers"
 OP_COMPOSE_EDIT_MESSAGE "edit the message"
 OP_COMPOSE_EDIT_MIME "edit attachment using mailcap entry"
+OP_COMPOSE_EDIT_NEWSGROUPS "edit the newsgroups list"
 OP_COMPOSE_EDIT_REPLY_TO "edit the Reply-To field"
+OP_COMPOSE_EDIT_FOLLOWUP_TO "edit the Followup-To field"
+OP_COMPOSE_EDIT_X_COMMENT_TO "edit the X-Comment-To field"
 OP_COMPOSE_EDIT_SUBJECT "edit the subject of this message"
 OP_COMPOSE_EDIT_TO "edit the TO list"
 OP_CREATE_MAILBOX "create a new mailbox (IMAP only)"
@@ -56,6 +61,7 @@ OP_DELETE_THREAD "delete all messages in thread"
 OP_DISPLAY_ADDRESS "display full address of sender"
 OP_DISPLAY_HEADERS "display message and toggle header weeding"
 OP_DISPLAY_MESSAGE "display a message"
+OP_EDIT_LABEL "add, change, or delete a message's label"
 OP_EDIT_MESSAGE "edit the raw message"
 OP_EDITOR_BACKSPACE "delete the char in front of the cursor"
 OP_EDITOR_BACKWARD_CHAR "move the cursor one character to the left"
@@ -85,8 +91,13 @@ OP_EXIT "exit this menu"
 OP_FILTER "filter attachment through a shell command"
 OP_FIRST_ENTRY "move to the first entry"
 OP_FLAG_MESSAGE "toggle a message's 'important' flag"
+OP_FOLLOWUP "followup to newsgroup"
+OP_FORWARD_TO_GROUP "forward to newsgroup"
 OP_FORWARD_MESSAGE "forward a message with comments"
 OP_GENERIC_SELECT_ENTRY "select the current entry"
+OP_GET_CHILDREN "get all children of the current message"
+OP_GET_MESSAGE "get message with Message-Id"
+OP_GET_PARENT "get parent of the current message"
 OP_GROUP_REPLY "reply to all recipients"
 OP_HALF_DOWN "scroll down 1/2 page"
 OP_HALF_UP "scroll up 1/2 page"
@@ -94,11 +105,14 @@ OP_HELP "this screen"
 OP_JUMP "jump to an index number"
 OP_LAST_ENTRY "move to the last entry"
 OP_LIST_REPLY "reply to specified mailing list"
+OP_LOAD_ACTIVE "load list of all newsgroups from NNTP server"
 OP_MACRO "execute a macro"
 OP_MAIL "compose a new mail message"
 OP_MAIN_BREAK_THREAD "break the thread in two"
 OP_MAIN_CHANGE_FOLDER "open a different folder"
 OP_MAIN_CHANGE_FOLDER_READONLY "open a different folder in read only mode"
+OP_MAIN_CHANGE_GROUP "open a different newsgroup"
+OP_MAIN_CHANGE_GROUP_READONLY "open a different newsgroup in read only mode"
 OP_MAIN_CLEAR_FLAG "clear a status flag from a message"
 OP_MAIN_DELETE_PATTERN "delete messages matching a pattern"
 OP_MAIN_IMAP_FETCH "force retrieval of mail from IMAP server"
@@ -127,6 +141,7 @@ OP_MAIN_READ_SUBTHREAD "mark the current subthread as read"
 OP_MAIN_SET_FLAG "set a status flag on a message"
 OP_MAIN_SYNC_FOLDER "save changes to mailbox"
 OP_MAIN_TAG_PATTERN "tag messages matching a pattern"
+OP_MAIN_QUASI_DELETE "delete from mutt, don't touch on disk"
 OP_MAIN_UNDELETE_PATTERN "undelete messages matching a pattern"
 OP_MAIN_UNTAG_PATTERN "untag messages matching a pattern"
 OP_MIDDLE_PAGE "move to the middle of the page"
@@ -138,6 +153,7 @@ OP_PAGER_HIDE_QUOTED "toggle display of quoted text"
 OP_PAGER_SKIP_QUOTED "skip beyond quoted text"
 OP_PAGER_TOP "jump to the top of the message"
 OP_PIPE "pipe message/attachment to a shell command"
+OP_POST "post message to newsgroup"
 OP_PREV_ENTRY "move to the previous entry"
 OP_PREV_LINE "scroll up one line"
 OP_PREV_PAGE "move to the previous page"
@@ -147,6 +163,7 @@ OP_QUERY "query external program for addresses"
 OP_QUERY_APPEND "append new query results to current results"
 OP_QUIT "save changes to mailbox and quit"
 OP_RECALL_MESSAGE "recall a postponed message"
+OP_RECONSTRUCT_THREAD "reconstruct thread containing current message"
 OP_REDRAW "clear and redraw the screen"
 OP_REFORMAT_WINCH "{internal}"
 OP_RENAME_MAILBOX "rename the current mailbox (IMAP only)"
@@ -161,22 +178,27 @@ OP_SEARCH_TOGGLE "toggle search pattern coloring"
 OP_SHELL_ESCAPE "invoke a command in a subshell"
 OP_SORT "sort messages"
 OP_SORT_REVERSE "sort messages in reverse order"
+OP_SUBSCRIBE_PATTERN "subscribe to newsgroups matching a pattern"
 OP_TAG "tag the current entry"
 OP_TAG_PREFIX "apply next function to tagged messages"
 OP_TAG_PREFIX_COND "apply next function ONLY to tagged messages"
 OP_TAG_SUBTHREAD "tag the current subthread"
 OP_TAG_THREAD "tag the current thread"
 OP_TOGGLE_NEW "toggle a message's 'new' flag"
+OP_TOGGLE_READ "toggle view of read messages"
 OP_TOGGLE_WRITE "toggle whether the mailbox will be rewritten"
 OP_TOGGLE_MAILBOXES "toggle whether to browse mailboxes or all files"
 OP_TOP_PAGE "move to the top of the page"
+OP_UNCATCHUP "mark all articles in newsgroup as unread"
 OP_UNDELETE "undelete the current entry"
 OP_UNDELETE_THREAD "undelete all messages in thread"
 OP_UNDELETE_SUBTHREAD "undelete all messages in subthread"
+OP_UNSUBSCRIBE_PATTERN "unsubscribe from newsgroups matching a pattern"
 OP_VERSION "show the Mutt version number and date"
 OP_VIEW_ATTACH "view attachment using mailcap entry if necessary"
 OP_VIEW_ATTACHMENTS "show MIME attachments"
 OP_WHAT_KEY "display the keycode for a key press"
+OP_LIMIT_CURRENT_THREAD "limit view to current thread"
 OP_MAIN_SHOW_LIMIT "show currently active limit pattern"
 OP_MAIN_COLLAPSE_THREAD "collapse/uncollapse current thread"
 OP_MAIN_COLLAPSE_ALL "collapse/uncollapse all threads"
diff --git a/OPS.NOTMUCH b/OPS.NOTMUCH
new file mode 100644
index 0000000..4508e4e
--- /dev/null
+++ b/OPS.NOTMUCH
@@ -0,0 +1,5 @@
+OP_MAIN_CHANGE_VFOLDER "open a different virtual folder"
+OP_MAIN_VFOLDER_FROM_QUERY "generate virtual folder from query"
+OP_MAIN_MODIFY_LABELS "modify (notmuch) tags"
+OP_MAIN_MODIFY_LABELS_THEN_HIDE "modify labels and then hide message"
+OP_MAIN_ENTIRE_THREAD "read entire thread of the current message"
diff --git a/OPS.SIDEBAR b/OPS.SIDEBAR
index 7e5b504..e39f80c 100644
--- a/OPS.SIDEBAR
+++ b/OPS.SIDEBAR
@@ -5,4 +5,5 @@ OP_SIDEBAR_PAGE_DOWN "scroll the sidebar down 1 page"
 OP_SIDEBAR_PAGE_UP "scroll the sidebar up 1 page"
 OP_SIDEBAR_PREV "move the highlight to previous mailbox"
 OP_SIDEBAR_PREV_NEW "move the highlight to previous mailbox with new mail"
+OP_SIDEBAR_TOGGLE_VIRTUAL "toggle between mailboxes and virtual mailboxes"
 OP_SIDEBAR_TOGGLE_VISIBLE "make the sidebar (in)visible"
diff --git a/PATCHES b/PATCHES
index e69de29..675387e 100644
--- a/PATCHES
+++ b/PATCHES
@@ -0,0 +1,22 @@
+patch-compress-neomutt
+patch-cond-date-neomutt
+patch-fmemopen-neomutt
+patch-ifdef-neomutt
+patch-index-color-neomutt
+patch-initials-neomutt
+patch-keywords-neomutt
+patch-limit-current-thread-neomutt
+patch-lmdb-neomutt
+patch-multiple-fcc-neomutt
+patch-nested-if-neomutt
+patch-new-mail-neomutt
+patch-nntp-neomutt
+patch-notmuch-neomutt
+patch-progress-neomutt
+patch-quasi-delete-neomutt
+patch-sidebar-neomutt
+patch-skip-quoted-neomutt
+patch-smime-encrypt-self-neomutt
+patch-status-color-neomutt
+patch-timeout-neomutt
+patch-tls-sni-neomutt
diff --git a/README.SSL b/README.SSL
index 75cac80..90290e0 100644
--- a/README.SSL
+++ b/README.SSL
@@ -5,7 +5,7 @@ Compilation
 -----------
 If you want to have SSL support in mutt, you need to install OpenSSL
 (http://www.openssl.org) libraries and headers before compiling.
-OpenSSL versions 0.9.3 through 0.9.6a have been tested.
+OpenSSL versions 0.9.3 through 1.0.1c have been tested.
 
 For SSL support to be enabled, you need to run the ``configure''
 script with ``--enable-imap --with-ssl[=PFX]'' parameters.  If the
@@ -65,6 +65,12 @@ certificate, the connection will be established. Accepted certificates
 can also be saved so that further connections to the server are
 automatically accepted. 
 
+If OpenSSL was built with support for ServerNameIndication (SNI) and TLS
+is used in the negotiation, mutt will send its idea of the server-name
+as part of the TLS negotiation.  This allows the server to select an
+appropriate certificate, in the event that one server handles multiple
+hostnames with different certificates.
+
 If your organization has several equivalent IMAP-servers, each of them
 should have a unique certificate which is signed with a common
 certificate.  If you want to use all of those servers, you don't need to
@@ -102,9 +108,15 @@ you know which options do not work, you can set the variables for non-working
 protocols to know.  The variables for the protocols are ssl_use_tlsv1, 
 ssl_use_sslv2, and ssl_use_sslv3.
 
+To verify TLS SNI support by a server, you can use:
+    openssl s_client -host <imap server> -port <port> \
+        -tls1 -servername <imap server>
+
+
 -- 
 Tommi Komulainen
 Tommi.Komulainen@iki.fi
 
-Updated by Jeremy Katz
-katzj@linuxpower.org
+Updated by:
+  Jeremy Katz <katzj@linuxpower.org>
+  Phil Pennock <mutt-dev@spodhuis.org>
diff --git a/README.md b/README.md
new file mode 120000
index 0000000..716afb5
--- /dev/null
+++ b/README.md
@@ -0,0 +1 @@
+README.neomutt
\ No newline at end of file
diff --git a/README.neomutt b/README.neomutt
new file mode 100644
index 0000000..bab3795
--- /dev/null
+++ b/README.neomutt
@@ -0,0 +1,93 @@
+# This is the NeoMutt Project
+
+## What is NeoMutt?
+
+* NeoMutt is a project of projects.
+* A place to gather all the patches against Mutt.
+* A place for all the developers to gather.
+
+Hopefully this will build the community and reduce duplicated effort.
+
+NeoMutt was created when Richard Russon (FlatCap) took all the old Mutt patches,
+sorted through them, fixed them up and documented them.
+
+## What Features does NeoMutt have?
+
+| Name                 | Description
+|----------------------|-------------------------------------------------------
+| Compressed Folders   | Read from/write to compressed mailboxes
+| Conditional Dates    | Conditional Date Formatting
+| Fmemopen             | Use fmemopen(3) for speedier temporary files
+| Ifdef                | Conditional config options
+| Index Color          | Theming of the Index List
+| Initials Expando     | Expando for Author's Initials
+| Keywords             | Labels/Tagging for emails
+| Limit-Current-Thread | Limit Index View to Current Thread
+| LMDB                 | LMDB backend for the header cache
+| Multiple fcc         | Save multiple copies of outgoing mail
+| Nested If            | Allow deeply nested conditionals in format strings
+| New Mail Command     | Run a command when new mail arrives
+| NNTP                 | Talk to a Usenet news server
+| Notmuch              | Powerful email search engine
+| Progress Bar         | Colourful Progress Bar
+| Quasi-Delete         | Hide emails from view, but don't delete them
+| Sidebar              | Panel containing list of Mailboxes
+| Skip-Quoted          | Skip Quoted Text
+| SMIME Encrypt Self   | Save an self-encrypted copy of emails
+| Status Color         | Theming of the Status Bar
+| Timeout Hook         | Run a command periodically
+| TLS-SNI              | Negotiate with a Server for a Certificate
+
+## Contributed Scripts and Config
+
+- Keybase Integration
+  Joshua Jordi (JakkinStewart)
+- vim-keybindings - Mutt config for vim users
+  Ivan Tham (pickfire)
+
+## Where is NeoMutt?
+
+- Source Code:     https://github.com/neomutt/neomutt
+- Releases:        https://github.com/neomutt/neomutt/releases/latest
+- Questions/Bugs:  https://github.com/neomutt/neomutt/issues
+- Website:         http://www.neomutt.org/
+- IRC              irc://irc.freenode.net/neomutt
+- Development:     http://www.neomutt.org/devel/
+
+## NeoMutt Developers
+
+Here's a list of everyone who's helped NeoMutt:
+
+Alex Pearce, Ander Punnar, Antonio Radici, Chris Salzberg, Christoph Berg,
+Darshit Shah, David Sterba, Elimar Riesebieter, Evgeni Golov, Fabian Groffen,
+Fabio Alessandro Locati, Faidon Liambotis, Ivan Tham, Johannes Frankenau,
+Joshua Jordi, Karel Zak, Kurt Jaeger, Matteo Vescovi, Richard Hartmann,
+Richard Russon, Santiago Torres, Udo Schweigert, Werner Fink,
+Yoshiki Vázquez Baeza.
+
+## Original Patch Authors
+
+Without the original patch authors, there would be nothing.
+So, a Big Thank You to:
+
+Aaron Schrab, Alain Penders, Benjamin Kuperman, Cedric Duval, Chris Mason,
+Christian Aichinger, Christoph Berg, Christoph Rissner, David Champion,
+David Riebenbauer, David Sterba, David Wilson, Don Zickus, Elimar Riesebieter,
+Eric Davis, Evgeni Golov, Fabian Groffen, Felix von Leitner, Jan Synacek,
+Jason DeTiberus, Jeremiah Foster, Jeremy Katz, Josh Poimboeuf, Julius Plenz,
+Justin Hibbits, Karel Zak, Kirill Shutemov, Luke Macken, Mantas Mikulenas,
+Matteo Vescovi, Patrick Brisbin, Paul Miller, Phil Pennock,
+Philippe Le Brouster, Richard Russon, Rocco Rutte, Roland Rosenfeld, Sami Farin,
+Stefan Assmann, Stefan Kuhn, Steve Kemp, Terry Chan, Thomas Glanzmann,
+Thomer Gil, Tim Stoakes, Tyler Earnest, Victor Manuel Jaquez Leal,
+Vincent Lefevre, Vladimir Marek, Vsevolod Volkov.
+
+## Original Mutt Authors
+
+And of course, we should thank the original Mutt authors, including the original
+author Michael Elkins and all the people that have contributed to Mutt during
+its long history, see the Acknowledgements section of the user manual for a
+detailed list.
+
+http://www.neomutt.org/manual/miscellany.html#acknowledgements
+
diff --git a/README.notmuch b/README.notmuch
new file mode 100644
index 0000000..b106727
--- /dev/null
+++ b/README.notmuch
@@ -0,0 +1,402 @@
+notmuch support for mutt
+------------------------
+
+ * notmuch is e-mail fulltext indexing and tagging engine; see
+   http://notmuchmail.org/ for more information.
+
+ * home page (wiki) and git:
+
+   https://github.com/karelzak/mutt-kz
+
+   Note that the master branch is rebased to be up to date with mutt upstream. Use
+   stable/v<version> branches for downstream packaging.
+
+ * mailing list:
+
+   https://admin.fedoraproject.org/mailman/listinfo/mutt-kz
+
+ * requirements:
+
+   notmuch >= 0.9
+
+ * compile:
+
+  $ git clone git://github.com/karelzak/mutt-kz.git
+  $ cd mutt-kz
+  $ ./prepare
+  $ ./configure --enable-notmuch [--enable-debug]
+  $ make
+
+ * Folders URI
+
+   notmuch://[<path>][?<item>=<name>[& ...]]
+
+   The <path> is an absolute path to the directory where the notmuch database
+   is found as returned by 'notmuch config get database.path' command. Note that
+   the <path> should NOT include .notmuch directory name.
+
+   If the "<path>" is not defined then $nm_default_uri or $folder is used,
+   for example:
+
+	set nm_default_uri = "notmuch:///home/foo/maildir"
+	virtual-mailboxes "My INBOX" "notmuch://?query=tag:inbox"
+
+   Items:
+
+      query=<string>
+
+	 See SEARCH SYNTAX in notmuch man page. Don't forget to use "and" and
+         "or" operators in your queries.
+
+      Note that proper URI should not contain blank space and all "bad" chars
+      should be encoded, for example
+
+	 "tag:AAA and tag:BBB" --encoding-> tag:AAA%20and%20tag:BBB
+
+      but mutt config file parser is smart enough to accept space in quoted
+      strings. It means that you can use
+
+         "notmuch:///foo?query=tag:AAA and tag:BBB"
+
+      in your config files to keep things readable.
+
+      See http://xapian.org/docs/queryparser.html for more details about Xapian
+      queries.
+
+
+      limit=<number>
+
+         Restricts number of messages/threads in the result. The default limit
+         is nm_db_limit.
+
+      type=<threads|messages>
+
+         Reads all matching messages or whole-threads. The default is 'messages'
+         or nm_query_type.
+
+
+ * commands:
+
+   change-vfolder:
+      - switch to another virtual folder, a new folder maybe be specified by
+        vfolder description (see virtual-mailboxes) or URI
+      - the default is next vfolder with unread messages
+      - default key: X
+
+   vfolder-from-query:
+      - generate new virtual folder from notmuch search query
+      - default key: <Esc>X
+      - note: TAB completion of 'tag:' names is available
+
+   modify-labels:
+      - add or remove notmuch tags; [+]<tag> to add, -<tag> to remove
+      - default key: `
+      - note: TAB completion of tag names is available
+      - example: "+AAA +BBB -CCC"
+
+   modify-labels-then-hide:
+      - same as <modify-labels> but message is marked by <quasi-delete>
+      - not mapped to any key
+      - note: TAB completion of tag names is available
+      - example (add "archive" notmuch tag and remove message from screen):
+
+       macro index A "<modify-labels-then-hide>+archive -inbox\n<sync-mailbox>"
+       macro index I "<modify-labels-then-hide>-inbox\n<sync-mailbox>"
+
+   quasi-delete:
+      - delete message from mutt (usually after <sync-mailbox> function), but
+        don't touch message on disk
+
+   entire-thread:
+      - add to the current list of the messages all messages that belongs to the same thread
+        as the current message. This command is useful when you have a new email in your INBOX
+        and you want to see the rest of the archived thread.
+      - default key: +
+
+ * Pattern modifiers:
+
+   Many of Mutt's commands allow you to specify a pattern to match (limit,
+   tag-pattern, delete-pattern, color, etc.). The following notmuch specific
+   mutt pattern modifiers are available:
+
+   - '~Y EXPR': Messages which contain EXPR in the list of labels.
+     Example:
+        # Color red all messages labeled as 'spam'.
+        color index    red      default        "~Y '\W?spam\W?'"
+
+ * muttrc:
+
+   Note that you can use notmuch specific mutt config file, see -F <config> in
+   mutt docs.
+
+
+   virtual-mailboxes <description> <uri> [ ...]
+
+      This command specifies one or more virtual folder. The folders are
+      accessible by command 'X'. It's possible to use the virtual mailbox
+      description as a sort key (e.g set sort_sidebar=desc)
+
+      example:
+
+      virtual-mailboxes "Linux Kernel" "notmuch:///whereis/db?query=tag:lkml&limit=1000" \
+                        "Filesystems"  "notmuch:///whereis/db?query=tag:fs" \
+                        "Music"        "notmuch:///another/db?query=tag:hard and tag:heavy"
+
+      The folder description is used for status line, folders browser, sidebar
+      and <change-vfolder> command (this command also accepts vfolder URI). The
+      folder-hook regex uses the URI.
+
+   virtual_spoolfile = <boolean>
+
+      When set, mutt will use the first virtual mailbox (see virtual-mailboxes)
+      as a spoolfile.
+
+      When set together with sidebar, mutt will use list of virtual folders in
+      the sidebar. It's possible to toggle between virtual and normal folders by
+      sidebar-toggle command.
+
+   tag-transforms <tag> <transform> [ ...]
+
+      This command specifies text transforms to be shown instead of the actual
+      tag names with '%g' in the index and pager formats. Note that Unicode
+      symbols can be used for transforms.
+
+      example:
+
+      tag-transforms "inbox"   "i"   \
+                     "unread"  "u"   \
+                     "replied" "↻ "  \
+                     "sent"    "➥ "  \
+                     "todo"    "T"   \
+                     "deleted" "DEL" \
+                     "invites" "CAL"
+
+   tag-formats <tag> <format sequence> [ ...]
+
+      Specify index formatting sequences for individual tags for direct
+      placement in the $index_format. The formats must start with 'G' and
+      the entire sequence is case sensitive.
+
+      example:
+
+      tag-formats "inbox"   "GI" \
+                  "unread"  "GU" \
+                  "replied" "GR" \
+                  "sent"    "GS" \
+                  "todo"    "Gt" \
+                  "deleted" "GD" \
+                  "invites" "Gi"
+
+      Now instead of using '%g' in your $index_format, which lists all tags
+      in a non-deterministic order, you can something like the following which puts
+      a transformed tag name in a specific spot on the index line:
+
+      set index_format='4C %S %[%y.%m.%d] %-18.18n %?GU?%GU& ? %?GR?%GR& ? %?GI?%GI& ? %s'
+
+      The %G formatting sequence may display all tags including tags hidden by
+      nm_hidden_tags.
+
+   nm_record = <boolean>
+
+      Add messages stored to the mutt record (see $record in the mutt docs)
+      also to notmuch DB. If you reply to an email then the new email inherits
+      tags from the original email.
+
+   nm_record_tags = <comma delimited list>
+
+      Tags that should be removed or added to the to the messages stored in the mutt record.
+
+      example:
+
+      set record = "~/sent-mails"
+      set nm_record = yes
+      set nm_record_tags = "-inbox,archive,me"
+
+   nm_open_timeout = <seconds>
+
+      This option specifies timeout for Notmuch database. Default is 5 seconds.
+
+   nm_default_uri = <uri>
+
+      This variable specifies the default Notmuch database in format
+      notmuch://<absolute path>, the URI is used for notmuch queries (ESC+X) when the
+      current folder is not based on notmuch. If the default URI is not specified
+      then mutt will try to use $folder variable (see mutt manual for more details).
+
+   nm_hidden_tags = <comma delimited list>
+
+      This variable specifies private notmuch tags which should not be printed
+      on screen (index, pager).
+
+      Default is "unread,draft,flagged,passed,replied,attachment".
+
+   nm_exclude_tags = <comma delimited list>
+
+      The messages tagged with these tags are excluded and not loaded
+      from notmuch DB to mutt unless specified explicitly.
+
+      Not set by default.
+
+   nm_unread_tag = <name>
+
+      This variable specifies notmuch tag which is used for unread messages. The
+      variable is used to count unread messages in DB only. All other mutt
+      commands use standard (e.g. maildir) flags.
+
+      Default is "unread".
+
+   nm_db_limit = <num>
+
+     This variable specifies notmuch query limit.
+
+     Default is unlimited.
+
+   nm_query_type = <threads|messages>
+
+     This variable specifies notmuch query type, supported types: 'threads' and
+     'messages'.
+
+     Default is 'messages'.
+
+   vfolder_format = <string>
+
+      This variable allows you to customize the file browser display for virtual
+      folders to your personal taste.  This string is similar to $index_format,
+      but has its own set of printf(3)-like sequences:
+
+	%f   folder name (description)
+	%n   number of all messages
+	%N   number of new messages
+	%>X  right justify the rest of the string and pad with character ``X''
+	%|X  pad to the end of the line with character ``X''
+	%*X  soft-fill with character ``X'' as pad
+
+      Default is "%6n(%6N) %f ".
+
+   index_format and pager_format
+
+        %g   notmuch tags (labels)
+        %Gx  specific notmuch tag defined by tag-formats (see above)
+
+        for example:
+
+        tag-formats "inbox" "GI"
+        set index_format = "%4C %Z %?GI?%GI? ?  %[%d/%b]  %-16.15F %s %> %?g?(%g)?"
+        set pager_format = "-%Z- %C/%m: %-20.20n   %s%*  -- %?g?(%g)? - (%P)"
+
+
+* .muttrc example:
+
+	set record="~/Mail/Maildir/sent-mail"
+	set nm_record = yes
+	set nm_record_tags ="-inbox me archive"
+
+	set nm_default_uri="notmuch:///home/kzak/Mail/Maildir"
+	set virtual_spoolfile	= yes
+	set sort_browser        = unsorted
+
+	# normal folders
+	set mbox_type=Maildir
+	set folder="~/Mail/Maildir"
+	mailboxes =rh =fedora =misc
+
+	set sidebar_width	 = 35
+	set sidebar_visible	 = yes
+	set sidebar_sort_method  = unsorted
+	set sidebar_divider_char = │
+
+	color sidebar_new yellow default
+	color progress default magenta
+
+	bind index <left> sidebar-prev
+	bind index <right> sidebar-next
+	bind index <space> sidebar-open
+	bind index <Esc>S sidebar-toggle-virtual
+
+	set index_format="%4C %Z %?GI?%GI& ? %[%d/%b]  %-16.15F %?M?(%3M)&     ? %s %> %?g?%g?"
+
+        # virtual folders
+	virtual-mailboxes \
+	   "INBOX"                "notmuch://?query=tag:inbox and NOT tag:archive" \
+	   "Util-linux"           "notmuch://?query=tag:ul and NOT tag:archive" \
+	   "Bugs"                 "notmuch://?query=tag:bug NOT tag:archive" \
+	   "RH"                   "notmuch://?query=tag:rh and NOT tag:archive" \
+	   "Fedora"               "notmuch://?query=tag:fed and NOT tag:archive" \
+	   "Linux"                "notmuch://?query=tag:lk and NOT tag:archive" \
+	   "NFS"                  "notmuch://?query=tag:nfs and NOT tag:archive" \
+	   "Filesystems"          "notmuch://?query=tag:fs and NOT tag:archive" \
+	   "Security"             "notmuch://?query=tag:sec" \
+	   "Partitioning"         "notmuch://?query=tag:part" \
+	   "GNU"                  "notmuch://?query=tag:gnu" \
+	   "udev"                 "notmuch://?query=tag:udev" \
+	   "initrd"               "notmuch://?query=tag:initrd" \
+	   "Linux CZ"             "notmuch://?query=tag:cz" \
+	   "Notmuch"              "notmuch://?query=tag:nm" \
+	   "Procps"               "notmuch://?query=tag:proc" \
+	\
+	   " Util-linux  [archive]" "notmuch://?query=tag:ul and tag:archive" \
+	   " Bugs        [archive]" "notmuch://?query=tag:bug and tag:archive" \
+	   " RH          [archive]" "notmuch://?query=tag:rh and tag:archive" \
+	   " Fedora      [archive]" "notmuch://?query=tag:fed and tag:archive" \
+	   " Linux       [archive]" "notmuch://?query=tag:lk and tag:archive" \
+	   " Filesystems [archive]" "notmuch://?query=tag:fs and tag:archive" \
+
+	# move message to archive
+	macro index A "<modify-labels-then-hide>+archive -inbox\n<sync-mailbox>"
+
+	# remove message from inbox
+	macro index I "<modify-labels-then-hide>-inbox\n<sync-mailbox>"
+
+	# mark emails for git-am
+	# (e.g. "git am -i -3 $(notmuch search --output=files tag:PATCH)"
+	#
+	macro index P "<modify-labels>PATCH\n"
+	macro index <Esc>P "<modify-labels>-PATCH\n"
+
+
+* .procmailrc example:
+
+	NOINBOX="-r inbox"
+
+	### Add 'kw' (keyword) tag to all interesting e-mails and make the emails
+	### visible in inbox.
+	:0
+	* ^Subject:.*(mount|umount|libmount|losetup|util-linux|blkid|hwclock|mkswap|fdisk|parted|partition|gpt|topology)
+	{
+		TAGS="-t kw"
+		NOINBOX=""
+	}
+
+	### Deliver emails to maildirs by notmuch-deliver
+	### from notmuch contrib/
+	###
+	###    notmuch-deliver -t <tags> [-t ...] <maildir>
+
+	:0:notmuch.lock
+	* ^List-Id:.*linux.linux.cz
+	| notmuch-deliver $NOINBOX -t cz $TAGS linux.cz
+
+	:0:notmuch.lock
+	* ^X-Mailing-List:.*util-linux@vger.kernel.org
+	| notmuch-deliver -t ul $TAGS util-linux
+
+	:0:notmuch.lock
+	* ^List-Id:.*parted-devel.lists.alioth.debian.org
+	| notmuch-deliver $NOINBOX -t part $TAGS parted
+
+	### [...cut to make the example short...] ###
+
+	### All unmatched mails
+	:0:notmuch.lock
+	* ^From
+	| notmuch-deliver $TAGS misc
+
+	### fallback if notmuch does not work
+	:0:
+	* ^From
+	Mail/Maildir/misc/
+
+
+* another example:
+
+  http://notmuchmail.org/mutttips/
diff --git a/UPDATING.kz b/UPDATING.kz
new file mode 100644
index 0000000..1df36c0
--- /dev/null
+++ b/UPDATING.kz
@@ -0,0 +1,68 @@
+1.6.0.1:
+
++ rebase to mutt upstream 1.6.0
++ update to the new sidebar implementation. Note that all .muttrc options 
+  are prefixed by "sidebar_" now.
+
++ rebase is based on neomutt project (see https://github.com/neomutt) where are
+  maintained all non-upstream mutt changes, so it's easy to merge another
+  features like "trash", "ifdef", ... to mutt-kz.
+
++ the stable mutt-kz releases and tags are maintained in stable/v<version> branches, 
+  the master branch is going to be *rebased*. This development model help us to be 
+  up to date with mutt upstream.
+
+
+1.5.23.1:
+
++ integrated color status patch (original from Thomas Glanzmann)
+  https://thomas.glanzmann.de//mutt/#cstatus
++ integrated TLS Server Name Indication support patch (original from Phil Pennock)
++ improved sidebar functionality to optinaly show only folders with new emails
+  (sidebar-new, sitebar-next, ...)
+
++ fix notmuch DB usage
++ use unlocked libc IO in improve performance
++ security bug fix from original mutt
+
++ sync with the original mutt upstream
++ add sidebar_whitelist option
++ oppenc & pgp upstream sync and improvements
+
+
+1.5.22.1:
+
++ use git and github rather than hg to maintain source code
+
++ virtual folders based on notmuch queries
++ merge sidebar patch
++ merge index-color patch
+
++ <change-vfolder> command
++ <vfolder-from-query> command
++ <modify-labels> command to set/unset notmuch tags
++ <modify-labels-then-hide> command to set/unset notmuch tags and hide email
+  from the current view
++ <quasi-delete> command to delete message from mutt, but don't touch message
+  on the disk
++ <entire-thread> command to add to the current list of the messages all
+  messages that belongs to the same thread as the current message
++ ~Y EXPR  pattern modifier for notmuch labels for limit, tag-pattern,
+  delete-pattern, color etc.
++ virtual-mailboxes <desc> <uri> [...]  to specify list of the virtual mailboxes
++ virtual_spoolfile = <boolean> to use the first virtual mailbox as a spoolfile
++ tag-transforms <tag> <transform> to transform tag name to another name
++ tag-formats <tag> <format sequence> [ ...] to define tag specific formatting
+  sequence for $index_format
++ nm_record = <boolean> to add sent emails (mutt record) to notmuch DB
++ nm_record_tags = <comma delimited list> to specify tags for nm_record
++ nm_open_timeout = <seconds> to specify timeout for notmuch database
++ nm_default_uri = <uri>  the default URI to connect notmuch
++ nm_hidden_tags = <comma delimited list> to make some tags invisible for mutt user
++ nm_exclude_tags = <comma delimited list> - messages tagged with these tags
+  are excluded and not loaded from notmuch DB to mutt unless specified explicitly
++ nm_unread_tag = <name> to specify unread messages
++ nm_db_limit = <num> to specify notmuch query limit
++ nm_query_type = <threads|messages> to specify what to load from DB
++ vfolder_format = <string> to specify vfolders browser entry format
++ %g and %Gx index_format and pager_format formatting sequences
diff --git a/VERSION b/VERSION
deleted file mode 100644
index bd8bf88..0000000
--- a/VERSION
+++ /dev/null
@@ -1 +0,0 @@
-1.7.0
diff --git a/account.c b/account.c
index ce71180..ca0ee8e 100644
--- a/account.c
+++ b/account.c
@@ -51,8 +51,17 @@ int mutt_account_match (const ACCOUNT* a1, const ACCOUNT* a2)
     user = PopUser;
 #endif
   
+#ifdef USE_NNTP
+  if (a1->type == MUTT_ACCT_TYPE_NNTP && NntpUser)
+    user = NntpUser;
+#endif
+
   if (a1->flags & a2->flags & MUTT_ACCT_USER)
     return (!strcmp (a1->user, a2->user));
+#ifdef USE_NNTP
+  if (a1->type == MUTT_ACCT_TYPE_NNTP)
+    return a1->flags & MUTT_ACCT_USER && a1->user[0] ? 0 : 1;
+#endif
   if (a1->flags & MUTT_ACCT_USER)
     return (!strcmp (a1->user, user));
   if (a2->flags & MUTT_ACCT_USER)
@@ -130,6 +139,16 @@ void mutt_account_tourl (ACCOUNT* account, ciss_url_t* url)
   }
 #endif
 
+#ifdef USE_NNTP
+  if (account->type == MUTT_ACCT_TYPE_NNTP)
+  {
+    if (account->flags & MUTT_ACCT_SSL)
+      url->scheme = U_NNTPS;
+    else
+      url->scheme = U_NNTP;
+  }
+#endif
+
   url->host = account->host;
   if (account->flags & MUTT_ACCT_PORT)
     url->port = account->port;
@@ -155,6 +174,10 @@ int mutt_account_getuser (ACCOUNT* account)
   else if ((account->type == MUTT_ACCT_TYPE_POP) && PopUser)
     strfcpy (account->user, PopUser, sizeof (account->user));
 #endif
+#ifdef USE_NNTP
+  else if ((account->type == MUTT_ACCT_TYPE_NNTP) && NntpUser)
+    strfcpy (account->user, NntpUser, sizeof (account->user));
+#endif
   else if (option (OPTNOCURSES))
     return -1;
   /* prompt (defaults to unix username), copy into account->user */
@@ -217,6 +240,10 @@ int mutt_account_getpass (ACCOUNT* account)
   else if ((account->type == MUTT_ACCT_TYPE_SMTP) && SmtpPass)
     strfcpy (account->pass, SmtpPass, sizeof (account->pass));
 #endif
+#ifdef USE_NNTP
+  else if ((account->type == MUTT_ACCT_TYPE_NNTP) && NntpPass)
+    strfcpy (account->pass, NntpPass, sizeof (account->pass));
+#endif
   else if (option (OPTNOCURSES))
     return -1;
   else
diff --git a/account.h b/account.h
index f7932bf..653b7cc 100644
--- a/account.h
+++ b/account.h
@@ -29,7 +29,8 @@ enum
   MUTT_ACCT_TYPE_NONE = 0,
   MUTT_ACCT_TYPE_IMAP,
   MUTT_ACCT_TYPE_POP,
-  MUTT_ACCT_TYPE_SMTP
+  MUTT_ACCT_TYPE_SMTP,
+  MUTT_ACCT_TYPE_NNTP
 };
 
 /* account flags */
diff --git a/alias.c b/alias.c
index baeafb3..131629a 100644
--- a/alias.c
+++ b/alias.c
@@ -27,6 +27,7 @@
 
 #include <string.h>
 #include <ctype.h>
+#include <errno.h>
 
 ADDRESS *mutt_lookup_alias (const char *s)
 {
@@ -379,8 +380,10 @@ retry_name:
     recode_buf (buf, sizeof (buf));
     write_safe_address (rc, buf);
     fputc ('\n', rc);
-    safe_fclose (&rc);
-    mutt_message _("Alias added.");
+    if (safe_fsync_close(&rc) != 0)
+      mutt_message ("Trouble adding alias: %s.", strerror(errno));
+    else
+      mutt_message _("Alias added.");
   }
   else
     mutt_perror (buf);
diff --git a/attach.c b/attach.c
index 84cdf6d..d50d54a 100644
--- a/attach.c
+++ b/attach.c
@@ -765,7 +765,7 @@ int mutt_save_attachment (FILE *fp, BODY *m, char *path, int flags, HEADER *hdr)
       fseeko ((s.fpin = fp), m->offset, 0);
       mutt_decode_attachment (m, &s);
       
-      if (fclose (s.fpout) != 0)
+      if (safe_fsync_close (&s.fpout) != 0)
       {
 	mutt_perror ("fclose");
 	mutt_sleep (2);
@@ -800,7 +800,10 @@ int mutt_save_attachment (FILE *fp, BODY *m, char *path, int flags, HEADER *hdr)
       return (-1);
     }
     safe_fclose (&ofp);
-    safe_fclose (&nfp);
+    if (safe_fsync_close (&nfp) != 0) {
+      mutt_error _("Write fault!");
+      return (-1);
+    }
   }
 
   return 0;
@@ -814,6 +817,7 @@ int mutt_decode_save_attachment (FILE *fp, BODY *m, char *path,
   unsigned int saved_encoding = 0;
   BODY *saved_parts = NULL;
   HEADER *saved_hdr = NULL;
+  int ret = 0;
 
   memset (&s, 0, sizeof (s));
   s.flags = displaying;
@@ -871,7 +875,10 @@ int mutt_decode_save_attachment (FILE *fp, BODY *m, char *path,
 
   mutt_body_handler (m, &s);
 
-  safe_fclose (&s.fpout);
+  if (safe_fsync_close (&s.fpout) != 0) {
+    mutt_perror("fclose");
+    ret = -1;
+  }
   if (fp == NULL)
   {
     m->length = 0;
@@ -885,7 +892,7 @@ int mutt_decode_save_attachment (FILE *fp, BODY *m, char *path,
     safe_fclose (&s.fpin);
   }
 
-  return (0);
+  return ret;
 }
 
 /* Ok, the difference between send and receive:
diff --git a/attach.h b/attach.h
index 928408a..071f22c 100644
--- a/attach.h
+++ b/attach.h
@@ -50,7 +50,7 @@ void mutt_print_attachment_list (FILE *fp, int tag, BODY *top);
 
 void mutt_attach_bounce (FILE *, HEADER *, ATTACHPTR **, short, BODY *);
 void mutt_attach_resend (FILE *, HEADER *, ATTACHPTR **, short, BODY *);
-void mutt_attach_forward (FILE *, HEADER *, ATTACHPTR **, short, BODY *);
+void mutt_attach_forward (FILE *, HEADER *, ATTACHPTR **, short, BODY *, int);
 void mutt_attach_reply (FILE *, HEADER *, ATTACHPTR **, short, BODY *, int);
 
 #endif /* _ATTACH_H_ */
diff --git a/browser.c b/browser.c
index 15eccc5..a83852d 100644
--- a/browser.c
+++ b/browser.c
@@ -29,9 +29,16 @@
 #include "sort.h"
 #include "mailbox.h"
 #include "browser.h"
+#include "mx.h"
 #ifdef USE_IMAP
 #include "imap.h"
 #endif
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
 
 #include <stdlib.h>
 #include <dirent.h>
@@ -50,6 +57,19 @@ static const struct mapping_t FolderHelp[] = {
   { NULL,	 0 }
 };
 
+#ifdef USE_NNTP
+static struct mapping_t FolderNewsHelp[] = {
+  { N_("Exit"),        OP_EXIT },
+  { N_("List"),        OP_TOGGLE_MAILBOXES },
+  { N_("Subscribe"),   OP_BROWSER_SUBSCRIBE },
+  { N_("Unsubscribe"), OP_BROWSER_UNSUBSCRIBE },
+  { N_("Catchup"),     OP_CATCHUP },
+  { N_("Mask"),        OP_ENTER_MASK },
+  { N_("Help"),        OP_HELP },
+  { NULL,              0 }
+};
+#endif
+
 typedef struct folder_t
 {
   struct folder_file *ff;
@@ -85,6 +105,16 @@ static int browser_compare_subject (const void *a, const void *b)
   return ((BrowserSort & SORT_REVERSE) ? -r : r);
 }
 
+static int browser_compare_desc (const void *a, const void *b)
+{
+  struct folder_file *pa = (struct folder_file *) a;
+  struct folder_file *pb = (struct folder_file *) b;
+
+  int r = mutt_strcoll (pa->desc, pb->desc);
+
+  return ((BrowserSort & SORT_REVERSE) ? -r : r);
+}
+
 static int browser_compare_date (const void *a, const void *b)
 {
   struct folder_file *pa = (struct folder_file *) a;
@@ -105,6 +135,30 @@ static int browser_compare_size (const void *a, const void *b)
   return ((BrowserSort & SORT_REVERSE) ? -r : r);
 }
 
+static int browser_compare_count (const void *a, const void *b)
+{
+  struct folder_file *pa = (struct folder_file *) a;
+  struct folder_file *pb = (struct folder_file *) b;
+
+  int r = 0;
+  if (pa->has_buffy && pb->has_buffy)
+    r = pa->msg_count - pb->msg_count;
+
+  return ((BrowserSort & SORT_REVERSE) ? -r : r);
+}
+
+static int browser_compare_count_new (const void *a, const void *b)
+{
+  struct folder_file *pa = (struct folder_file *) a;
+  struct folder_file *pb = (struct folder_file *) b;
+
+  int r = 0;
+  if (pa->has_buffy && pb->has_buffy)
+    r = pa->msg_unread - pb->msg_unread;
+
+  return ((BrowserSort & SORT_REVERSE) ? -r : r);
+}
+
 static void browser_sort (struct browser_state *state)
 {
   int (*f) (const void *, const void *);
@@ -114,11 +168,28 @@ static void browser_sort (struct browser_state *state)
     case SORT_ORDER:
       return;
     case SORT_DATE:
+#ifdef USE_NNTP
+      if (option (OPTNEWS))
+	return;
+#endif
       f = browser_compare_date;
       break;
     case SORT_SIZE:
+#ifdef USE_NNTP
+      if (option (OPTNEWS))
+	return;
+#endif
       f = browser_compare_size;
       break;
+    case SORT_DESC:
+      f = browser_compare_desc;
+      break;
+    case SORT_COUNT:
+      f = browser_compare_count;
+      break;
+    case SORT_COUNT_NEW:
+      f = browser_compare_count_new;
+      break;
     case SORT_SUBJECT:
     default:
       f = browser_compare_subject;
@@ -191,6 +262,12 @@ folder_format_str (char *dest, size_t destlen, size_t col, int cols, char op, co
     case 'f':
     {
       char *s;
+
+#ifdef USE_NOTMUCH
+      if (mx_is_notmuch(folder->ff->name))
+        s = NONULL (folder->ff->desc);
+      else
+#endif
 #ifdef USE_IMAP
       if (folder->ff->imap)
 	s = NONULL (folder->ff->desc);
@@ -276,6 +353,18 @@ folder_format_str (char *dest, size_t destlen, size_t col, int cols, char op, co
       break;
 
     case 'N':
+#ifdef USE_NOTMUCH
+      if (mx_is_notmuch (folder->ff->name))
+      {
+	if (!optional)
+	{
+	  snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	  snprintf (dest, destlen, tmp, folder->ff->new);
+	} else if (!folder->ff->new)
+	  optional = 0;
+	break;
+      }
+#endif
       snprintf (tmp, sizeof (tmp), "%%%sc", fmt);
       snprintf (dest, destlen, tmp, folder->ff->new ? 'N' : ' ');
       break;
@@ -340,8 +429,112 @@ folder_format_str (char *dest, size_t destlen, size_t col, int cols, char op, co
   return (src);
 }
 
+#ifdef USE_NNTP
+static const char *
+newsgroup_format_str (char *dest, size_t destlen, size_t col, int cols, char op, const char *src,
+		      const char *fmt, const char *ifstring, const char *elsestring,
+		      unsigned long data, format_flag flags)
+{
+  char fn[SHORT_STRING], tmp[SHORT_STRING];
+  FOLDER *folder = (FOLDER *) data;
+
+  switch (op)
+  {
+    case 'C':
+      snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+      snprintf (dest, destlen, tmp, folder->num + 1);
+      break;
+
+    case 'f':
+      strncpy (fn, folder->ff->name, sizeof(fn) - 1);
+      snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+      snprintf (dest, destlen, tmp, fn);
+      break;
+
+    case 'N':
+      snprintf (tmp, sizeof (tmp), "%%%sc", fmt);
+      if (folder->ff->nd->subscribed)
+	snprintf (dest, destlen, tmp, ' ');
+      else
+	snprintf (dest, destlen, tmp, folder->ff->new ? 'N' : 'u');
+      break;
+
+    case 'M':
+      snprintf (tmp, sizeof (tmp), "%%%sc", fmt);
+      if (folder->ff->nd->deleted)
+	snprintf (dest, destlen, tmp, 'D');
+      else
+	snprintf (dest, destlen, tmp, folder->ff->nd->allowed ? ' ' : '-');
+      break;
+
+    case 's':
+      if (flags & MUTT_FORMAT_OPTIONAL)
+      {
+	if (folder->ff->nd->unread != 0)
+	  mutt_FormatString (dest, destlen, col, cols, ifstring, newsgroup_format_str,
+		data, flags);
+	else
+	  mutt_FormatString (dest, destlen, col, cols, elsestring, newsgroup_format_str,
+		data, flags);
+      }
+      else if (Context && Context->data == folder->ff->nd)
+      {
+	snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	snprintf (dest, destlen, tmp, Context->unread);
+      }
+      else
+      {
+	snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	snprintf (dest, destlen, tmp, folder->ff->nd->unread);
+      }
+      break;
+
+    case 'n':
+      if (Context && Context->data == folder->ff->nd)
+      {
+	snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	snprintf (dest, destlen, tmp, Context->new);
+      }
+      else if (option (OPTMARKOLD) &&
+		folder->ff->nd->lastCached >= folder->ff->nd->firstMessage &&
+		folder->ff->nd->lastCached <= folder->ff->nd->lastMessage)
+      {
+	snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	snprintf (dest, destlen, tmp, folder->ff->nd->lastMessage - folder->ff->nd->lastCached);
+      }
+      else
+      {
+	snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	snprintf (dest, destlen, tmp, folder->ff->nd->unread);
+      }
+      break;
+
+    case 'd':
+      if (folder->ff->nd->desc != NULL)
+      {
+	char *buf = safe_strdup (folder->ff->nd->desc);
+	if (NewsgroupsCharset && *NewsgroupsCharset)
+	  mutt_convert_string (&buf, NewsgroupsCharset, Charset, MUTT_ICONV_HOOK_FROM);
+	mutt_filter_unprintable (&buf);
+
+	snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+	snprintf (dest, destlen, tmp, buf);
+	FREE (&buf);
+      }
+      else
+      {
+	snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+	snprintf (dest, destlen, tmp, "");
+      }
+      break;
+  }
+  return (src);
+}
+#endif /* USE_NNTP */
+
 static void add_folder (MUTTMENU *m, struct browser_state *state,
-			const char *name, const struct stat *s, BUFFY *b)
+			const char *name, const char *desc, const struct stat *s, BUFFY *b,
+			void *data)
 {
   if (state->entrylen == state->entrymax)
   {
@@ -365,6 +558,8 @@ static void add_folder (MUTTMENU *m, struct browser_state *state,
     
     (state->entry)[state->entrylen].local = 1;
   }
+  else
+    (state->entry)[state->entrylen].local = 0;
 
   if (b)
   {
@@ -375,10 +570,14 @@ static void add_folder (MUTTMENU *m, struct browser_state *state,
   }
 
   (state->entry)[state->entrylen].name = safe_strdup (name);
-  (state->entry)[state->entrylen].desc = safe_strdup (name);
+  (state->entry)[state->entrylen].desc = safe_strdup(desc ? desc : name);
 #ifdef USE_IMAP
   (state->entry)[state->entrylen].imap = 0;
 #endif
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+    (state->entry)[state->entrylen].nd = (NNTP_DATA *)data;
+#endif
   (state->entrylen)++;
 }
 
@@ -394,9 +593,35 @@ static void init_state (struct browser_state *state, MUTTMENU *menu)
     menu->data = state->entry;
 }
 
+/* get list of all files/newsgroups with mask */
 static int examine_directory (MUTTMENU *menu, struct browser_state *state,
 			      char *d, const char *prefix)
 {
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    NNTP_SERVER *nserv = CurrentNewsSrv;
+    unsigned int i;
+
+/*  mutt_buffy_check (0); */
+    init_state (state, menu);
+
+    for (i = 0; i < nserv->groups_num; i++)
+    {
+      NNTP_DATA *nntp_data = nserv->groups_list[i];
+      if (!nntp_data)
+	continue;
+      if (prefix && *prefix &&
+	  strncmp (prefix, nntp_data->group, strlen (prefix)))
+	continue;
+      if (!((regexec (Mask.rx, nntp_data->group, 0, NULL, 0) == 0) ^ Mask.not))
+	continue;
+      add_folder (menu, state, nntp_data->group, NULL, NULL, NULL, nntp_data);
+    }
+  }
+  else
+#endif /* USE_NNTP */
+  {
   struct stat s;
   DIR *dp;
   struct dirent *de;
@@ -463,17 +688,67 @@ static int examine_directory (MUTTMENU *menu, struct browser_state *state,
       tmp->msg_count = Context->msgcount;
       tmp->msg_unread = Context->unread;
     }
-    add_folder (menu, state, de->d_name, &s, tmp);
+    add_folder (menu, state, de->d_name, NULL, &s, tmp, NULL);
   }
   closedir (dp);  
+  }
   browser_sort (state);
   return 0;
 }
 
+#ifdef USE_NOTMUCH
+static int examine_vfolders (MUTTMENU *menu, struct browser_state *state)
+{
+  BUFFY *tmp = VirtIncoming;
+
+  if (!VirtIncoming)
+    return (-1);
+  mutt_buffy_check (0);
+
+  init_state (state, menu);
+
+  do
+  {
+    if (mx_is_notmuch (tmp->path))
+    {
+      nm_nonctx_get_count(tmp->path, &tmp->msg_count, &tmp->msg_unread);
+      add_folder (menu, state, tmp->path, tmp->desc, NULL, tmp, NULL);
+      continue;
+    }
+  }
+  while ((tmp = tmp->next));
+  browser_sort (state);
+  return 0;
+}
+#endif
+
+/* get list of mailboxes/subscribed newsgroups */
 static int examine_mailboxes (MUTTMENU *menu, struct browser_state *state)
 {
   struct stat s;
   char buffer[LONG_STRING];
+
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    NNTP_SERVER *nserv = CurrentNewsSrv;
+    unsigned int i;
+
+/*  mutt_buffy_check (0); */
+    init_state (state, menu);
+
+    for (i = 0; i < nserv->groups_num; i++)
+    {
+      NNTP_DATA *nntp_data = nserv->groups_list[i];
+      if (nntp_data && (nntp_data->new || (nntp_data->subscribed &&
+	 (nntp_data->unread || !option (OPTSHOWONLYUNREAD)))))
+	add_folder (menu, state, nntp_data->group, NULL, NULL,
+		    NULL, nntp_data);
+    }
+  }
+  else
+#endif
+  {
   BUFFY *tmp = Incoming;
 
   if (!Incoming)
@@ -494,14 +769,21 @@ static int examine_mailboxes (MUTTMENU *menu, struct browser_state *state)
 #ifdef USE_IMAP
     if (mx_is_imap (tmp->path))
     {
-      add_folder (menu, state, tmp->path, NULL, tmp);
+      add_folder (menu, state, tmp->path, NULL, NULL, tmp, NULL);
       continue;
     }
 #endif
 #ifdef USE_POP
     if (mx_is_pop (tmp->path))
     {
-      add_folder (menu, state, tmp->path, NULL, tmp);
+      add_folder (menu, state, tmp->path, NULL, NULL, tmp, NULL);
+      continue;
+    }
+#endif
+#ifdef USE_NNTP
+    if (mx_is_nntp (tmp->path))
+    {
+      add_folder (menu, state, tmp->path, NULL, NULL, tmp, NULL);
       continue;
     }
 #endif
@@ -530,18 +812,30 @@ static int examine_mailboxes (MUTTMENU *menu, struct browser_state *state)
     strfcpy (buffer, NONULL(tmp->path), sizeof (buffer));
     mutt_pretty_mailbox (buffer, sizeof (buffer));
 
-    add_folder (menu, state, buffer, &s, tmp);
+    add_folder (menu, state, buffer, NULL, &s, tmp, NULL);
   }
   while ((tmp = tmp->next));
+  }
   browser_sort (state);
   return 0;
 }
 
 static int select_file_search (MUTTMENU *menu, regex_t *re, int n)
 {
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+    return (regexec (re, ((struct folder_file *) menu->data)[n].desc, 0, NULL, 0));
+#endif
   return (regexec (re, ((struct folder_file *) menu->data)[n].name, 0, NULL, 0));
 }
 
+#ifdef USE_NOTMUCH
+static int select_vfolder_search (MUTTMENU *menu, regex_t *re, int n)
+{
+  return (regexec (re, ((struct folder_file *) menu->data)[n].desc, 0, NULL, 0));
+}
+#endif
+
 static void folder_entry (char *s, size_t slen, MUTTMENU *menu, int num)
 {
   FOLDER folder;
@@ -549,10 +843,29 @@ static void folder_entry (char *s, size_t slen, MUTTMENU *menu, int num)
   folder.ff = &((struct folder_file *) menu->data)[num];
   folder.num = num;
   
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+    mutt_FormatString (s, slen, 0, MuttIndexWindow->cols, NONULL(GroupFormat), newsgroup_format_str, 
+      (unsigned long) &folder, MUTT_FORMAT_ARROWCURSOR);
+  else
+#endif
   mutt_FormatString (s, slen, 0, MuttIndexWindow->cols, NONULL(FolderFormat), folder_format_str, 
       (unsigned long) &folder, MUTT_FORMAT_ARROWCURSOR);
 }
 
+#ifdef USE_NOTMUCH
+static void vfolder_entry (char *s, size_t slen, MUTTMENU *menu, int num)
+{
+  FOLDER folder;
+
+  folder.ff = &((struct folder_file *) menu->data)[num];
+  folder.num = num;
+
+  mutt_FormatString (s, slen, 0, MuttIndexWindow->cols, NONULL(VirtFolderFormat), folder_format_str,
+      (unsigned long) &folder, MUTT_FORMAT_ARROWCURSOR);
+}
+#endif
+
 static void init_menu (struct browser_state *state, MUTTMENU *menu, char *title,
 		       size_t titlelen, int buffy)
 {
@@ -569,6 +882,17 @@ static void init_menu (struct browser_state *state, MUTTMENU *menu, char *title,
 
   menu->tagged = 0;
   
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    if (buffy)
+      snprintf (title, titlelen, _("Subscribed newsgroups"));
+    else
+      snprintf (title, titlelen, _("Newsgroups on server [%s]"),
+		CurrentNewsSrv->conn->account.host);
+  }
+  else
+#endif
   if (buffy)
     snprintf (title, titlelen, _("Mailboxes [%d]"), mutt_buffy_check (0));
   else
@@ -624,6 +948,31 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
   if (!folder)
     strfcpy (LastDirBackup, LastDir, sizeof (LastDirBackup));
 
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    if (*f)
+      strfcpy (prefix, f, sizeof (prefix));
+    else
+    {
+      NNTP_SERVER *nserv = CurrentNewsSrv;
+      unsigned int i;
+
+      /* default state for news reader mode is browse subscribed newsgroups */
+      buffy = 0;
+      for (i = 0; i < nserv->groups_num; i++)
+      {
+	NNTP_DATA *nntp_data = nserv->groups_list[i];
+	if (nntp_data && nntp_data->subscribed)
+	{
+	  buffy = 1;
+	  break;
+	}
+      }
+    }
+  }
+  else
+#endif
   if (*f)
   {
     mutt_expand_path (f, flen);
@@ -671,7 +1020,11 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
     }
 #endif
   }
+#ifdef USE_NOTMUCH
+  else if (!(flags & MUTT_SEL_VFOLDER))
+#else
   else 
+#endif
   {
     if (!folder)
       getcwd (LastDir, sizeof (LastDir));
@@ -699,6 +1052,12 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 
   *f = 0;
 
+#ifdef USE_NOTMUCH
+  if (flags & MUTT_SEL_VFOLDER) {
+    if (examine_vfolders (NULL, &state) == -1)
+      goto bail;
+  } else
+#endif
   if (buffy)
   {
     if (examine_mailboxes (NULL, &state) == -1)
@@ -708,9 +1067,10 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 #ifdef USE_IMAP
   if (!state.imap_browse)
 #endif
+  {
   if (examine_directory (NULL, &state, LastDir, prefix) == -1)
     goto bail;
-
+  }
   menu = mutt_new_menu (MENU_FOLDER);
   menu->make_entry = folder_entry;
   menu->search = select_file_search;
@@ -719,7 +1079,18 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
   if (multiple)
     menu->tag = file_tag;
 
+#ifdef USE_NOTMUCH
+  if (flags & MUTT_SEL_VFOLDER) {
+    menu->make_entry = vfolder_entry;
+    menu->search = select_vfolder_search;
+  } else
+#endif
+    menu->make_entry = folder_entry;
+
   menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_FOLDER,
+#ifdef USE_NNTP
+    option (OPTNEWS) ? FolderNewsHelp :
+#endif
     FolderHelp);
 
   init_menu (&state, menu, title, sizeof (title), buffy);
@@ -858,7 +1229,11 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	  }
 	}
 
+#ifdef USE_NNTP
+	if (buffy || option (OPTNEWS))
+#else
 	if (buffy)
+#endif
 	{
 	  strfcpy (f, state.entry[menu->current].name, flen);
 	  mutt_expand_path (f, flen);
@@ -867,6 +1242,10 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	else if (state.imap_browse)
           strfcpy (f, state.entry[menu->current].name, flen);
 #endif
+#ifdef USE_NOTMUCH
+	else if (mx_is_notmuch(state.entry[menu->current].name))
+	  strfcpy (f, state.entry[menu->current].name, flen);
+#endif
 	else
 	  mutt_concat_path (f, LastDir, state.entry[menu->current].name, flen);
 
@@ -916,14 +1295,6 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
         break;
 
 #ifdef USE_IMAP
-      case OP_BROWSER_SUBSCRIBE:
-	imap_subscribe (state.entry[menu->current].name, 1);
-	break;
-
-      case OP_BROWSER_UNSUBSCRIBE:
-	imap_subscribe (state.entry[menu->current].name, 0);
-	break;
-
       case OP_BROWSER_TOGGLE_LSUB:
 	if (option (OPTIMAPLSUB))
 	  unset_option (OPTIMAPLSUB);
@@ -1026,6 +1397,11 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
       
       case OP_CHANGE_DIRECTORY:
 
+#ifdef USE_NNTP
+	if (option (OPTNEWS))
+	  break;
+#endif
+
 	strfcpy (buf, LastDir, sizeof (buf));
 #ifdef USE_IMAP
 	if (!state.imap_browse)
@@ -1172,9 +1548,9 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	  int reverse = (i == OP_SORT_REVERSE);
 	  
 	  switch (mutt_multi_choice ((reverse) ?
-	      _("Reverse sort by (d)ate, (a)lpha, si(z)e or do(n)'t sort? ") :
-	      _("Sort by (d)ate, (a)lpha, si(z)e or do(n)'t sort? "),
-	      _("dazn")))
+	      _("Reverse sort by (d)ate, (a)lpha, si(z)e, d(e)scription, (c)ount, ne(w) count, or do(n)'t sort? ") :
+	      _("Sort by (d)ate, (a)lpha, si(z)e, d(e)scription, (c)ount, ne(w) count, or do(n)'t sort? "),
+	      _("dazecwn")))
 	  {
 	    case -1: /* abort */
 	      resort = 0;
@@ -1192,7 +1568,19 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	      BrowserSort = SORT_SIZE;
 	      break;
 
-            case 4: /* do(n)'t sort */
+            case 4: /* d(e)scription */
+	      BrowserSort = SORT_DESC;
+	      break;
+
+            case 5: /* (c)ount */
+	      BrowserSort = SORT_COUNT;
+	      break;
+
+            case 6: /* ne(w) count */
+	      BrowserSort = SORT_COUNT_NEW;
+	      break;
+
+            case 7: /* do(n)'t sort */
 	      BrowserSort = SORT_ORDER;
 	      resort = 0;
 	      break;
@@ -1291,6 +1679,209 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	  else
 	    mutt_error _("Error trying to view file");
 	}
+	break;
+
+#ifdef USE_NNTP
+      case OP_CATCHUP:
+      case OP_UNCATCHUP:
+	if (option (OPTNEWS))
+	{
+	  struct folder_file *f = &state.entry[menu->current];
+	  int rc;
+	  NNTP_DATA *nntp_data;
+
+	  rc = nntp_newsrc_parse (CurrentNewsSrv);
+	  if (rc < 0)
+	    break;
+
+	  if (i == OP_CATCHUP)
+	    nntp_data = mutt_newsgroup_catchup (CurrentNewsSrv, f->name);
+	  else
+	    nntp_data = mutt_newsgroup_uncatchup (CurrentNewsSrv, f->name);
+
+	  if (nntp_data)
+	  {
+/*	    FOLDER folder;
+	    struct folder_file ff;
+	    char buffer[_POSIX_PATH_MAX + SHORT_STRING];
+
+	    folder.ff = &ff;
+	    folder.ff->name = f->name;
+	    folder.ff->st = NULL;
+	    folder.ff->is_new = nntp_data->new;
+	    folder.ff->nntp_data = nntp_data;
+	    FREE (&f->desc);
+	    mutt_FormatString (buffer, sizeof (buffer), 0, NONULL(GroupFormat),
+		  newsgroup_format_str, (unsigned long) &folder,
+		  MUTT_FORMAT_ARROWCURSOR);
+	    f->desc = safe_strdup (buffer); */
+	    nntp_newsrc_update (CurrentNewsSrv);
+	    if (menu->current + 1 < menu->max)
+	      menu->current++;
+	    menu->redraw = REDRAW_MOTION_RESYNCH;
+	  }
+	  if (rc)
+	    menu->redraw = REDRAW_INDEX;
+	  nntp_newsrc_close (CurrentNewsSrv);
+	}
+	break;
+
+      case OP_LOAD_ACTIVE:
+	if (option (OPTNEWS))
+	{
+	  NNTP_SERVER *nserv = CurrentNewsSrv;
+	  unsigned int i;
+
+	  if (nntp_newsrc_parse (nserv) < 0)
+	    break;
+
+	  for (i = 0; i < nserv->groups_num; i++)
+	  {
+	    NNTP_DATA *nntp_data = nserv->groups_list[i];
+	    if (nntp_data)
+	      nntp_data->deleted = 1;
+	  }
+	  nntp_active_fetch (nserv);
+	  nntp_newsrc_update (nserv);
+	  nntp_newsrc_close (nserv);
+
+	  destroy_state (&state);
+	  if (buffy)
+	    examine_mailboxes (menu, &state);
+	  else
+	    examine_directory (menu, &state, NULL, NULL);
+	  init_menu (&state, menu, title, sizeof (title), buffy);
+	}
+	break;
+#endif /* USE_NNTP */
+
+#if defined USE_IMAP || defined USE_NNTP
+      case OP_BROWSER_SUBSCRIBE:
+      case OP_BROWSER_UNSUBSCRIBE:
+#endif
+#ifdef USE_NNTP
+      case OP_SUBSCRIBE_PATTERN:
+      case OP_UNSUBSCRIBE_PATTERN:
+	if (option (OPTNEWS))
+	{
+	  NNTP_SERVER *nserv = CurrentNewsSrv;
+	  NNTP_DATA *nntp_data;
+	  regex_t *rx = (regex_t *) safe_malloc (sizeof (regex_t));
+	  char *s = buf;
+	  int rc, j = menu->current;
+
+	  if (i == OP_SUBSCRIBE_PATTERN || i == OP_UNSUBSCRIBE_PATTERN)
+	  {
+	    char tmp[STRING];
+	    int err;
+
+	    buf[0] = 0;
+	    if (i == OP_SUBSCRIBE_PATTERN)
+	      snprintf (tmp, sizeof (tmp), _("Subscribe pattern: "));
+	    else
+	      snprintf (tmp, sizeof (tmp), _("Unsubscribe pattern: "));
+	    if (mutt_get_field (tmp, buf, sizeof (buf), 0) != 0 || !buf[0])
+	    {
+	      FREE (&rx);
+	      break;
+	    }
+
+	    err = REGCOMP (rx, s, REG_NOSUB);
+	    if (err)
+	    {
+	      regerror (err, rx, buf, sizeof (buf));
+	      regfree (rx);
+	      FREE (&rx);
+	      mutt_error ("%s", buf);
+	      break;
+	    }
+	    menu->redraw = REDRAW_FULL;
+	    j = 0;
+	  }
+	  else if (!state.entrylen)
+	  {
+	    mutt_error _("No newsgroups match the mask");
+	    break;
+	  }
+
+	  rc = nntp_newsrc_parse (nserv);
+	  if (rc < 0)
+	    break;
+
+	  for ( ; j < state.entrylen; j++)
+	  {
+	    struct folder_file *f = &state.entry[j];
+
+	    if (i == OP_BROWSER_SUBSCRIBE || i == OP_BROWSER_UNSUBSCRIBE ||
+		  regexec (rx, f->name, 0, NULL, 0) == 0)
+	    {
+	      if (i == OP_BROWSER_SUBSCRIBE || i == OP_SUBSCRIBE_PATTERN)
+		nntp_data = mutt_newsgroup_subscribe (nserv, f->name);
+	      else
+		nntp_data = mutt_newsgroup_unsubscribe (nserv, f->name);
+/*	      if (nntp_data)
+	      {
+		FOLDER folder;
+		char buffer[_POSIX_PATH_MAX + SHORT_STRING];
+
+		folder.name = f->name;
+		folder.f = NULL;
+		folder.new = nntp_data->new;
+		folder.nd = nntp_data;
+		FREE (&f->desc);
+		mutt_FormatString (buffer, sizeof (buffer), 0, NONULL(GroupFormat),
+			newsgroup_format_str, (unsigned long) &folder,
+			MUTT_FORMAT_ARROWCURSOR);
+		f->desc = safe_strdup (buffer);
+	      } */
+	    }
+	    if (i == OP_BROWSER_SUBSCRIBE || i == OP_BROWSER_UNSUBSCRIBE)
+	    {
+	      if (menu->current + 1 < menu->max)
+		menu->current++;
+	      menu->redraw = REDRAW_MOTION_RESYNCH;
+	      break;
+	    }
+	  }
+	  if (i == OP_SUBSCRIBE_PATTERN)
+	  {
+	    unsigned int i;
+
+	    for (i = 0; nserv && i < nserv->groups_num; i++)
+	    {
+	      nntp_data = nserv->groups_list[i];
+	      if (nntp_data && nntp_data->group && !nntp_data->subscribed)
+	      {
+		if (regexec (rx, nntp_data->group, 0, NULL, 0) == 0)
+		{
+		  mutt_newsgroup_subscribe (nserv, nntp_data->group);
+		  add_folder (menu, &state, nntp_data->group, NULL, NULL, NULL, nntp_data);
+		}
+	      }
+	    }
+	    init_menu (&state, menu, title, sizeof (title), buffy);
+	  }
+	  if (rc > 0)
+	    menu->redraw = REDRAW_FULL;
+	  nntp_newsrc_update (nserv);
+	  nntp_clear_cache (nserv);
+	  nntp_newsrc_close (nserv);
+	  if (i != OP_BROWSER_SUBSCRIBE && i != OP_BROWSER_UNSUBSCRIBE)
+	    regfree (rx);
+	  FREE (&rx);
+	}
+#ifdef USE_IMAP
+	else
+#endif /* USE_IMAP && USE_NNTP */
+#endif /* USE_NNTP */
+#ifdef USE_IMAP
+	{
+	  if (i == OP_BROWSER_SUBSCRIBE)
+	    imap_subscribe (state.entry[menu->current].name, 1);
+	  else
+	    imap_subscribe (state.entry[menu->current].name, 0);
+	}
+#endif /* USE_IMAP */
     }
   }
   
diff --git a/browser.h b/browser.h
index 67e62ea..439be9d 100644
--- a/browser.h
+++ b/browser.h
@@ -19,6 +19,10 @@
 #ifndef _BROWSER_H
 #define _BROWSER_H 1
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
+
 struct folder_file
 {
   mode_t mode;
@@ -43,6 +47,9 @@ struct folder_file
   unsigned inferiors : 1;
 #endif
   unsigned has_buffy : 1;
+#ifdef USE_NNTP
+  NNTP_DATA *nd;
+#endif
   unsigned local : 1; /* folder is on local filesystem */
   unsigned tagged : 1;
 };
diff --git a/buffy.c b/buffy.c
index 1306297..8d488f7 100644
--- a/buffy.c
+++ b/buffy.c
@@ -36,6 +36,10 @@
 #include "imap.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include <string.h>
 #include <sys/stat.h>
 #include <dirent.h>
@@ -217,6 +221,8 @@ static BUFFY *buffy_new (const char *path)
 
 static void buffy_free (BUFFY **mailbox)
 {
+  if (mailbox && *mailbox)
+    FREE (&(*mailbox)->desc);
   FREE (mailbox); /* __FREE_CHECKED__ */
 }
 
@@ -462,63 +468,64 @@ static int buffy_mbox_check (BUFFY* mailbox, struct stat *sb, int check_stats)
   return rc;
 }
 
-/* Check all Incoming for new mail and total/new/flagged messages
- * force: if true, ignore BuffyTimeout and check for new mail anyway
- */
-int mutt_buffy_check (int force)
+#ifdef USE_NOTMUCH
+int mutt_parse_virtual_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *err)
 {
-  BUFFY *tmp;
-  struct stat sb;
-  struct stat contex_sb;
-  time_t t;
-  int check_stats = 0;
-#ifdef USE_SIDEBAR
-  short orig_new;
-  int orig_count, orig_unread, orig_flagged;
-#endif
+  BUFFY **tmp;
+  char buf[_POSIX_PATH_MAX + LONG_STRING + 32];   /* path to DB + query + URI "decoration" */
 
-  sb.st_size=0;
-  contex_sb.st_dev=0;
-  contex_sb.st_ino=0;
+  while (MoreArgs (s))
+  {
+    char *desc;
 
-#ifdef USE_IMAP
-  /* update postponed count as well, on force */
-  if (force)
-    mutt_update_num_postponed ();
-#endif
+    mutt_extract_token (path, s, 0);
+    if (path->data && *path->data)
+      desc = safe_strdup( path->data);
+    else
+      continue;
 
-  /* fastest return if there are no mailboxes */
-  if (!Incoming)
-    return 0;
-  t = time (NULL);
-  if (!force && (t - BuffyTime < BuffyTimeout))
-    return BuffyCount;
+    mutt_extract_token (path, s, 0);
+    strfcpy (buf, path->data, sizeof (buf));
 
-  if (option (OPTMAILCHECKSTATS) &&
-      (t - BuffyStatsTime >= BuffyCheckStatsInterval))
-  {
-    check_stats = 1;
-    BuffyStatsTime = t;
-  }
+    /* Skip empty tokens. */
+    if(!*buf) {
+	    FREE(&desc);
+	    continue;
+    }
 
-  BuffyTime = t;
-  BuffyCount = 0;
-  BuffyNotify = 0;
+    /* avoid duplicates */
+    for (tmp = &VirtIncoming; *tmp; tmp = &((*tmp)->next))
+    {
+      if (mutt_strcmp (buf, (*tmp)->path) == 0)
+      {
+	dprint(3,(debugfile,"virtual mailbox '%s' already registered as '%s'\n", buf, (*tmp)->path));
+	break;
+      }
+    }
 
-#ifdef USE_IMAP
-  BuffyCount += imap_buffy_check (force, check_stats);
-#endif
+    if (!*tmp)
+      *tmp = buffy_new (buf);
 
-  /* check device ID and serial number instead of comparing paths */
-  if (!Context || Context->magic == MUTT_IMAP || Context->magic == MUTT_POP
-      || stat (Context->path, &contex_sb) != 0)
-  {
-    contex_sb.st_dev=0;
-    contex_sb.st_ino=0;
+    (*tmp)->new = 0;
+    (*tmp)->notified = 1;
+    (*tmp)->newly_created = 0;
+    (*tmp)->size = 0;
+    (*tmp)->desc = desc;
   }
-  
-  for (tmp = Incoming; tmp; tmp = tmp->next)
-  {
+  return 0;
+}
+#endif
+
+static void buffy_check (BUFFY *tmp, struct stat *contex_sb, int check_stats)
+{
+    struct stat sb;
+#ifdef USE_SIDEBAR
+    short orig_new;
+    int orig_count, orig_unread, orig_flagged;
+#endif
+
+    sb.st_size=0;
+
 #ifdef USE_SIDEBAR
     orig_new = tmp->new;
     orig_count = tmp->msg_count;
@@ -534,6 +541,15 @@ int mutt_buffy_check (int force)
 	tmp->magic = MUTT_POP;
       else
 #endif
+#ifdef USE_NNTP
+      if ((tmp->magic == MUTT_NNTP) || mx_is_nntp (tmp->path))
+	tmp->magic = MUTT_NNTP;
+#endif
+#ifdef USE_NOTMUCH
+      if (mx_is_notmuch (tmp->path))
+	tmp->magic = MUTT_NOTMUCH;
+      else
+#endif
       if (stat (tmp->path, &sb) != 0 || (S_ISREG(sb.st_mode) && sb.st_size == 0) ||
 	  (!tmp->magic && (tmp->magic = mx_get_magic (tmp->path)) <= 0))
       {
@@ -542,16 +558,20 @@ int mutt_buffy_check (int force)
 	tmp->newly_created = 1;
 	tmp->magic = 0;
 	tmp->size = 0;
-	continue;
+	return;
       }
     }
 
     /* check to see if the folder is the currently selected folder
      * before polling */
     if (!Context || !Context->path ||
-	(( tmp->magic == MUTT_IMAP || tmp->magic == MUTT_POP )
+#ifdef USE_NNTP
+	(( tmp->magic == MUTT_IMAP || tmp->magic == MUTT_POP || tmp->magic == MUTT_NNTP )
+#else
+	(( tmp->magic == MUTT_IMAP || tmp->magic == MUTT_POP || tmp->magic == MUTT_NOTMUCH)
+#endif
 	    ? mutt_strcmp (tmp->path, Context->path) :
-	      (sb.st_dev != contex_sb.st_dev || sb.st_ino != contex_sb.st_ino)))
+	      (sb.st_dev != contex_sb->st_dev || sb.st_ino != contex_sb->st_ino)))
     {
       switch (tmp->magic)
       {
@@ -570,6 +590,18 @@ int mutt_buffy_check (int force)
           if (mh_buffy (tmp, check_stats) > 0)
             BuffyCount++;
           break;
+#ifdef USE_NOTMUCH
+        case MUTT_NOTMUCH:
+          tmp->msg_count = 0;
+          tmp->msg_unread = 0;
+          tmp->msg_flagged = 0;
+          nm_nonctx_get_count(tmp->path, &tmp->msg_count, &tmp->msg_unread);
+          if (tmp->msg_unread > 0) {
+            BuffyCount++;
+            tmp->new = 1;
+          }
+          break;
+#endif
       }
     }
     else if (option(OPTCHECKMBOXSIZE) && Context && Context->path)
@@ -587,8 +619,72 @@ int mutt_buffy_check (int force)
       tmp->notified = 0;
     else if (!tmp->notified)
       BuffyNotify++;
+}
+
+/* Check all Incoming for new mail and total/new/flagged messages
+ * force: if true, ignore BuffyTimeout and check for new mail anyway
+ */
+int mutt_buffy_check (int force)
+{
+  BUFFY *tmp;
+  struct stat contex_sb;
+  time_t t;
+  int check_stats = 0;
+  contex_sb.st_dev=0;
+  contex_sb.st_ino=0;
+
+#ifdef USE_IMAP
+  /* update postponed count as well, on force */
+  if (force)
+    mutt_update_num_postponed ();
+#endif
+
+  /* fastest return if there are no mailboxes */
+#ifdef USE_NOTMUCH
+  if (!Incoming && !VirtIncoming)
+    return 0;
+#else
+  if (!Incoming)
+    return 0;
+#endif
+  t = time (NULL);
+  if (!force && (t - BuffyTime < BuffyTimeout))
+    return BuffyCount;
+
+  if (option (OPTMAILCHECKSTATS) &&
+      (t - BuffyStatsTime >= BuffyCheckStatsInterval))
+  {
+    check_stats = 1;
+    BuffyStatsTime = t;
   }
 
+  BuffyTime = t;
+  BuffyCount = 0;
+  BuffyNotify = 0;
+
+#ifdef USE_IMAP
+  BuffyCount += imap_buffy_check (force, check_stats);
+#endif
+
+  /* check device ID and serial number instead of comparing paths */
+  if (!Context || Context->magic == MUTT_IMAP || Context->magic == MUTT_POP
+#ifdef USE_NNTP
+      || Context->magic == MUTT_NNTP
+#endif
+      || stat (Context->path, &contex_sb) != 0)
+  {
+    contex_sb.st_dev=0;
+    contex_sb.st_ino=0;
+  }
+
+  for (tmp = Incoming; tmp; tmp = tmp->next)
+    buffy_check(tmp, &contex_sb, check_stats);
+
+#ifdef USE_NOTMUCH
+  for (tmp = VirtIncoming; tmp; tmp = tmp->next)
+    buffy_check(tmp, &contex_sb, check_stats);
+#endif
+
   BuffyDoneTime = BuffyTime;
   return (BuffyCount);
 }
@@ -704,6 +800,35 @@ void mutt_buffy (char *s, size_t slen)
   *s = '\0';
 }
 
+#ifdef USE_NOTMUCH
+void mutt_buffy_vfolder (char *s, size_t slen)
+{
+  BUFFY *tmp;
+  int pass, found = 0;
+
+  if (mutt_buffy_check (0))
+  {
+    for (pass = 0; pass < 2; pass++) {
+      for (tmp = VirtIncoming; tmp; tmp = tmp->next)
+      {
+	if ((found || pass) && tmp->new)
+	{
+	  strfcpy (s, tmp->desc, slen);
+	  return;
+	}
+	if (mutt_strcmp (s, tmp->path) == 0)
+	  found = 1;
+      }
+    }
+
+    mutt_buffy_check (1); /* buffy was wrong - resync things */
+  }
+
+  /* no folders with new mail */
+  *s = '\0';
+}
+#endif
+
 /* fetch buffy object for given path, if present */
 static BUFFY* buffy_get (const char *path)
 {
diff --git a/buffy.h b/buffy.h
index 561f5e7..a042484 100644
--- a/buffy.h
+++ b/buffy.h
@@ -28,6 +28,7 @@ typedef struct buffy_t
   char path[_POSIX_PATH_MAX];
   char realpath[_POSIX_PATH_MAX]; /* used for duplicate detection, context comparison,
                                      and the sidebar */
+  char *desc;
   off_t size;
   struct buffy_t *next;
   short new;			/* mailbox has new mail */
@@ -49,6 +50,11 @@ WHERE BUFFY *Incoming INITVAL (0);
 WHERE short BuffyTimeout INITVAL (3);
 WHERE short BuffyCheckStatsInterval INITVAL (60);
 
+#ifdef USE_NOTMUCH
+WHERE BUFFY *VirtIncoming INITVAL (0);
+void mutt_buffy_vfolder (char *s, size_t slen);
+#endif
+
 extern time_t BuffyDoneTime;	/* last time we knew for sure how much mail there was */
 
 BUFFY *mutt_find_mailbox (const char *path);
diff --git a/color.c b/color.c
index c33d41e..a9542ef 100644
--- a/color.c
+++ b/color.c
@@ -34,7 +34,14 @@ int ColorQuoteUsed;
 int ColorDefs[MT_COLOR_MAX];
 COLOR_LINE *ColorHdrList = NULL;
 COLOR_LINE *ColorBodyList = NULL;
+COLOR_LINE *ColorStatusList = NULL;
 COLOR_LINE *ColorIndexList = NULL;
+COLOR_LINE *ColorIndexAuthorList = NULL;
+COLOR_LINE *ColorIndexFlagsList = NULL;
+COLOR_LINE *ColorIndexSubjectList = NULL;
+#ifdef USE_NOTMUCH
+COLOR_LINE *ColorIndexTagList = NULL;
+#endif
 
 /* local to this file */
 static int ColorQuoteSize;
@@ -93,6 +100,19 @@ static const struct mapping_t Fields[] =
   { "bold",		MT_COLOR_BOLD },
   { "underline",	MT_COLOR_UNDERLINE },
   { "index",		MT_COLOR_INDEX },
+  { "progress",		MT_COLOR_PROGRESS },
+  { "index_author",	MT_COLOR_INDEX_AUTHOR },
+  { "index_collapsed",	MT_COLOR_INDEX_COLLAPSED },
+  { "index_date",	MT_COLOR_INDEX_DATE },
+  { "index_flags",	MT_COLOR_INDEX_FLAGS },
+  { "index_label",	MT_COLOR_INDEX_LABEL },
+  { "index_number",	MT_COLOR_INDEX_NUMBER },
+  { "index_size",	MT_COLOR_INDEX_SIZE },
+  { "index_subject",	MT_COLOR_INDEX_SUBJECT },
+#ifdef USE_NOTMUCH
+  { "index_tag",	MT_COLOR_INDEX_TAG },
+  { "index_tags",	MT_COLOR_INDEX_TAGS },
+#endif
   { "prompt",		MT_COLOR_PROMPT },
 #ifdef USE_SIDEBAR
   { "sidebar_divider",	MT_COLOR_DIVIDER },
@@ -395,12 +415,64 @@ int mutt_parse_unmono (BUFFER *buf, BUFFER *s, unsigned long data,
   return _mutt_parse_uncolor(buf, s, data, err, 0);
 }
 
+/**
+ * mutt_do_uncolor - XXX
+ */
+static void
+mutt_do_uncolor (BUFFER *buf, BUFFER *s, COLOR_LINE **ColorList,
+                 int *do_cache, int parse_uncolor)
+{
+  COLOR_LINE *tmp, *last = NULL;
+
+  do
+  {
+    mutt_extract_token (buf, s, 0);
+    if (mutt_strcmp ("*", buf->data) == 0)
+    {
+      for (tmp = *ColorList; tmp; )
+      {
+        if (!*do_cache)
+	{
+          *do_cache = 1;
+        }
+        last = tmp;
+        tmp = tmp->next;
+        mutt_free_color_line (&last, parse_uncolor);
+      }
+      *ColorList = NULL;
+    }
+    else
+    {
+      for (last = NULL, tmp = *ColorList; tmp; last = tmp, tmp = tmp->next)
+      {
+        if (mutt_strcmp (buf->data, tmp->pattern) == 0)
+	{
+          if (!*do_cache)
+	  {
+            *do_cache = 1;
+          }
+          dprint (1, (debugfile,"Freeing pattern \"%s\" from ColorList\n",
+                               tmp->pattern));
+          if (last)
+	  {
+            last->next = tmp->next;
+          }
+	  else
+	  {
+            *ColorList = tmp->next;
+          }
+          mutt_free_color_line (&tmp, parse_uncolor);
+          break;
+        }
+      }
+    }
+  } while (MoreArgs (s));
+}
+
 static int _mutt_parse_uncolor (BUFFER *buf, BUFFER *s, unsigned long data,
 				BUFFER *err, short parse_uncolor)
 {
   int object = 0, do_cache = 0;
-  COLOR_LINE *tmp, *last = NULL;
-  COLOR_LINE **list;
 
   mutt_extract_token (buf, s, 0);
 
@@ -410,13 +482,15 @@ static int _mutt_parse_uncolor (BUFFER *buf, BUFFER *s, unsigned long data,
     return (-1);
   }
 
-  if (mutt_strncmp (buf->data, "index", 5) == 0)
-    list = &ColorIndexList;
-  else if (mutt_strncmp (buf->data, "body", 4) == 0)
-    list = &ColorBodyList;
-  else if (mutt_strncmp (buf->data, "header", 7) == 0)
-    list = &ColorHdrList;
-  else
+  if (object > MT_COLOR_INDEX_SUBJECT) { /* uncolor index column */
+    ColorDefs[object] = 0;
+    set_option (OPTFORCEREDRAWINDEX);
+    return 0;
+  }
+
+  if ((mutt_strncmp (buf->data, "body",   4) != 0) &&
+      (mutt_strncmp (buf->data, "header", 6) != 0) &&
+      (mutt_strncmp (buf->data, "index",  5) != 0))
   {
     snprintf (err->data, err->dsize,
 	      _("%s: command valid only for index, body, header objects"),
@@ -453,43 +527,22 @@ static int _mutt_parse_uncolor (BUFFER *buf, BUFFER *s, unsigned long data,
     return 0;
   }
 
-  do
-  {
-    mutt_extract_token (buf, s, 0);
-    if (!mutt_strcmp ("*", buf->data))
-    {
-      for (tmp = *list; tmp; )
-      {
-        if (!do_cache)
-	  do_cache = 1;
-	last = tmp;
-	tmp = tmp->next;
-	mutt_free_color_line(&last, parse_uncolor);
-      }
-      *list = NULL;
-    }
-    else
-    {
-      for (last = NULL, tmp = *list; tmp; last = tmp, tmp = tmp->next)
-      {
-	if (!mutt_strcmp (buf->data, tmp->pattern))
-	{
-          if (!do_cache)
-	    do_cache = 1;
-	  dprint(1,(debugfile,"Freeing pattern \"%s\" from color list\n",
-	                       tmp->pattern));
-	  if (last)
-	    last->next = tmp->next;
-	  else
-	    *list = tmp->next;
-	  mutt_free_color_line(&tmp, parse_uncolor);
-	  break;
-	}
-      }
-    }
-  }
-  while (MoreArgs (s));
-
+  if (object == MT_COLOR_BODY)
+    mutt_do_uncolor (buf, s, &ColorBodyList, &do_cache, parse_uncolor);
+  else if (object == MT_COLOR_HEADER)
+    mutt_do_uncolor (buf, s, &ColorHdrList, &do_cache, parse_uncolor);
+  else if (object == MT_COLOR_INDEX)
+    mutt_do_uncolor (buf, s, &ColorIndexList, &do_cache, parse_uncolor);
+  else if (object == MT_COLOR_INDEX_AUTHOR)
+    mutt_do_uncolor (buf, s, &ColorIndexAuthorList, &do_cache, parse_uncolor);
+  else if (object == MT_COLOR_INDEX_FLAGS)
+    mutt_do_uncolor (buf, s, &ColorIndexFlagsList, &do_cache, parse_uncolor);
+  else if (object == MT_COLOR_INDEX_SUBJECT)
+    mutt_do_uncolor (buf, s, &ColorIndexSubjectList, &do_cache, parse_uncolor);
+#ifdef USE_NOTMUCH
+  else if (object == MT_COLOR_INDEX_TAG)
+    mutt_do_uncolor(buf, s, &ColorIndexTagList, &do_cache, parse_uncolor);
+#endif
 
   if (do_cache && !option (OPTNOCURSES))
   {
@@ -506,7 +559,7 @@ static int _mutt_parse_uncolor (BUFFER *buf, BUFFER *s, unsigned long data,
 static int 
 add_pattern (COLOR_LINE **top, const char *s, int sensitive,
 	     int fg, int bg, int attr, BUFFER *err,
-	     int is_index)
+	     int is_index, int match)
 {
 
   /* is_index used to store compiled pattern
@@ -577,6 +630,7 @@ add_pattern (COLOR_LINE **top, const char *s, int sensitive,
     }
     tmp->next = *top;
     tmp->pattern = safe_strdup (s);
+    tmp->match = match;
 #ifdef HAVE_COLOR
     if(fg != -1 && bg != -1)
     {
@@ -719,7 +773,7 @@ _mutt_parse_color (BUFFER *buf, BUFFER *s, BUFFER *err,
 		   parser_callback_t callback, short dry_run)
 {
   int object = 0, attr = 0, fg = 0, bg = 0, q_level = 0;
-  int r = 0;
+  int r = 0, match = 0;
 
   if(parse_object(buf, s, &object, &q_level, err) == -1)
     return -1;
@@ -729,18 +783,25 @@ _mutt_parse_color (BUFFER *buf, BUFFER *s, BUFFER *err,
 
   /* extract a regular expression if needed */
   
-  if (object == MT_COLOR_HEADER || object == MT_COLOR_BODY || object == MT_COLOR_INDEX)
-  {
+  if ((object == MT_COLOR_BODY) ||
+      (object == MT_COLOR_HEADER) ||
+      (object == MT_COLOR_INDEX) ||
+      (object == MT_COLOR_INDEX_AUTHOR) ||
+      (object == MT_COLOR_INDEX_FLAGS) ||
+#ifdef USE_NOTMUCH
+      (object == MT_COLOR_INDEX_TAG) ||
+#endif
+      (object == MT_COLOR_INDEX_SUBJECT)) {
     if (!MoreArgs (s))
     {
       strfcpy (err->data, _("too few arguments"), err->dsize);
-      return (-1);
+      return -1;
     }
 
     mutt_extract_token (buf, s, 0);
   }
    
-  if (MoreArgs (s))
+  if (MoreArgs (s) && (object != MT_COLOR_STATUS))
   {
     strfcpy (err->data, _("too many arguments"), err->dsize);
     return (-1);
@@ -765,14 +826,65 @@ _mutt_parse_color (BUFFER *buf, BUFFER *s, BUFFER *err,
 #endif
   
   if (object == MT_COLOR_HEADER)
-    r = add_pattern (&ColorHdrList, buf->data, 0, fg, bg, attr, err,0);
+    r = add_pattern (&ColorHdrList, buf->data, 0, fg, bg, attr, err, 0, match);
   else if (object == MT_COLOR_BODY)
-    r = add_pattern (&ColorBodyList, buf->data, 1, fg, bg, attr, err, 0);
+    r = add_pattern (&ColorBodyList, buf->data, 1, fg, bg, attr, err, 0, match);
+  else if ((object == MT_COLOR_STATUS) && MoreArgs (s)) {
+    /* 'color status fg bg' can have up to 2 arguments:
+     * 0 arguments: sets the default status color (handled below by else part)
+     * 1 argument : colorize pattern on match
+     * 2 arguments: colorize nth submatch of pattern
+     */
+    mutt_extract_token (buf, s, 0);
+
+    if (MoreArgs (s)) {
+      BUFFER temporary;
+      memset (&temporary, 0, sizeof (BUFFER));
+      mutt_extract_token (&temporary, s, 0);
+      match = atoi (temporary.data);
+      FREE(&temporary.data);
+    }
+
+    if (MoreArgs (s)) {
+      strfcpy (err->data, _("too many arguments"), err->dsize);
+      return -1;
+    }
+
+    r = add_pattern (&ColorStatusList, buf->data, 1,
+		    fg, bg, attr, err, 0, match);
+  }
   else if (object == MT_COLOR_INDEX)
   {
-    r = add_pattern (&ColorIndexList, buf->data, 1, fg, bg, attr, err, 1);
+    r = add_pattern (&ColorIndexList, buf->data, 1,
+		    fg, bg, attr, err, 1, match);
+    set_option (OPTFORCEREDRAWINDEX);
+  }
+  else if (object == MT_COLOR_INDEX_AUTHOR)
+  {
+    r = add_pattern (&ColorIndexAuthorList, buf->data, 1,
+		    fg, bg, attr, err, 1, match);
+    set_option (OPTFORCEREDRAWINDEX);
+  }
+  else if (object == MT_COLOR_INDEX_FLAGS)
+  {
+    r = add_pattern (&ColorIndexFlagsList, buf->data, 1,
+		    fg, bg, attr, err, 1, match);
     set_option (OPTFORCEREDRAWINDEX);
   }
+  else if (object == MT_COLOR_INDEX_SUBJECT)
+  {
+    r = add_pattern (&ColorIndexSubjectList, buf->data, 1,
+		    fg, bg, attr, err, 1, match);
+    set_option (OPTFORCEREDRAWINDEX);
+  }
+#ifdef USE_NOTMUCH
+  else if (object == MT_COLOR_INDEX_TAG)
+  {
+    r = add_pattern (&ColorIndexTagList, buf->data, 1,
+		    fg, bg, attr, err, 1, match);
+    set_option (OPTFORCEREDRAWINDEX);
+  }
+#endif
   else if (object == MT_COLOR_QUOTED)
   {
     if (q_level >= ColorQuoteSize)
@@ -798,7 +910,11 @@ _mutt_parse_color (BUFFER *buf, BUFFER *s, BUFFER *err,
       ColorQuote[q_level] = fgbgattr_to_color(fg, bg, attr);
   }
   else
+  {
     ColorDefs[object] = fgbgattr_to_color(fg, bg, attr);
+    if (object > MT_COLOR_INDEX_AUTHOR)
+      set_option (OPTFORCEREDRAWINDEX);
+  }
 
   return (r);
 }
diff --git a/commands.c b/commands.c
index 2202a67..839d8aa 100644
--- a/commands.c
+++ b/commands.c
@@ -40,6 +40,10 @@
 #include "imap.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include "buffy.h"
 
 #include <errno.h>
@@ -61,6 +65,7 @@ int mutt_display_message (HEADER *cur)
   char tempfile[_POSIX_PATH_MAX], buf[LONG_STRING];
   int rc = 0, builtin = 0;
   int cmflags = MUTT_CM_DECODE | MUTT_CM_DISPLAY | MUTT_CM_CHARCONV;
+  int chflags;
   FILE *fpout = NULL;
   FILE *fpfilterout = NULL;
   pid_t filterpid = -1;
@@ -145,8 +150,14 @@ int mutt_display_message (HEADER *cur)
     fputs ("\n\n", fpout);
   }
 
-  res = mutt_copy_message (fpout, Context, cur, cmflags,
-       	(option (OPTWEED) ? (CH_WEED | CH_REORDER) : 0) | CH_DECODE | CH_FROM | CH_DISPLAY);
+  chflags = (option (OPTWEED) ? (CH_WEED | CH_REORDER) : 0)
+           | CH_DECODE | CH_FROM | CH_DISPLAY;
+#ifdef USE_NOTMUCH
+  if (Context->magic == MUTT_NOTMUCH)
+    chflags |= CH_VIRTUAL;
+#endif
+  res = mutt_copy_message (fpout, Context, cur, cmflags, chflags);
+
   if ((safe_fclose (&fpout) != 0 && errno != EPIPE) || res < 0)
   {
     mutt_error (_("Could not copy message"));
@@ -533,9 +544,9 @@ int mutt_select_sort (int reverse)
   int method = Sort; /* save the current method in case of abort */
 
   switch (mutt_multi_choice (reverse ?
-			     _("Rev-Sort (d)ate/(f)rm/(r)ecv/(s)ubj/t(o)/(t)hread/(u)nsort/si(z)e/s(c)ore/s(p)am?: ") :
-			     _("Sort (d)ate/(f)rm/(r)ecv/(s)ubj/t(o)/(t)hread/(u)nsort/si(z)e/s(c)ore/s(p)am?: "),
-			     _("dfrsotuzcp")))
+			     _("Rev-Sort Date/Frm/Recv/Subj/tO/Thread/Unsort/siZe/sCore/sPam/Label?: ") :
+			     _("Sort Date/Frm/Recv/Subj/tO/Thread/Unsort/siZe/sCore/sPam/Label?: "),
+			     _("dfrsotuzcpl")))
   {
   case -1: /* abort - don't resort */
     return -1;
@@ -579,6 +590,10 @@ int mutt_select_sort (int reverse)
   case 10: /* s(p)am */
     Sort = SORT_SPAM;
     break;
+
+  case 11: /* (l)abel */
+    Sort = SORT_LABEL;
+    break;
   }
   if (reverse)
     Sort |= SORT_REVERSE;
@@ -837,6 +852,16 @@ int mutt_save_message (HEADER *h, int delete,
 
   if (mx_open_mailbox (buf, MUTT_APPEND, &ctx) != NULL)
   {
+#ifdef USE_COMPRESSED
+    /* If we're saving to a compressed mailbox, the stats won't be updated
+     * until the next open.  Until then, improvise. */
+    BUFFY *cm = NULL;
+    if (ctx.compress_info)
+      cm = mutt_find_mailbox (ctx.realpath);
+    /* We probably haven't been opened yet */
+    if (cm && (cm->msg_count == 0))
+      cm = NULL;
+#endif
     if (h)
     {
       if (_mutt_save_message(h, &ctx, delete, decode, decrypt) != 0)
@@ -844,9 +869,25 @@ int mutt_save_message (HEADER *h, int delete,
         mx_close_mailbox (&ctx, NULL);
         return -1;
       }
+#ifdef USE_COMPRESSED
+      if (cm)
+      {
+        cm->msg_count++;
+        if (!h->read)
+          cm->msg_unread++;
+        if (h->flagged)
+          cm->msg_flagged++;
+      }
+#endif
     }
     else
     {
+      int rc = 0;
+
+#ifdef USE_NOTMUCH
+      if (Context->magic == MUTT_NOTMUCH)
+        nm_longrun_init(Context, TRUE);
+#endif
       for (i = 0; i < Context->vcount; i++)
       {
 	if (Context->hdrs[Context->v2r[i]]->tagged)
@@ -858,8 +899,30 @@ int mutt_save_message (HEADER *h, int delete,
             mx_close_mailbox (&ctx, NULL);
             return -1;
           }
+#ifdef USE_COMPRESSED
+          if (cm)
+          {
+            HEADER *h = Context->hdrs[Context->v2r[i]];
+            cm->msg_count++;
+            if (!h->read)
+              cm->msg_unread++;
+            if (h->flagged)
+              cm->msg_flagged++;
+          }
+#endif
+	  if ((rc = _mutt_save_message(Context->hdrs[Context->v2r[i]],
+			     &ctx, delete, decode, decrypt) != 0))
+	    break;
 	}
       }
+#ifdef USE_NOTMUCH
+      if (Context->magic == MUTT_NOTMUCH)
+        nm_longrun_done(Context);
+#endif
+      if (rc != 0) {
+	mx_close_mailbox (&ctx, NULL);
+	return -1;
+      }
     }
 
     need_buffy_cleanup = (ctx.magic == MUTT_MBOX || ctx.magic == MUTT_MMDF);
@@ -879,7 +942,7 @@ int mutt_save_message (HEADER *h, int delete,
 
 void mutt_version (void)
 {
-  mutt_message ("Mutt %s (%s)", MUTT_VERSION, ReleaseDate);
+  mutt_message ("NeoMutt %s (%s)", PACKAGE_VERSION, OldMuttVer);
 }
 
 void mutt_edit_content_type (HEADER *h, BODY *b, FILE *fp)
diff --git a/complete.c b/complete.c
index d0ee4af..b383786 100644
--- a/complete.c
+++ b/complete.c
@@ -25,6 +25,9 @@
 #include "mailbox.h"
 #include "imap.h"
 #endif
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
 
 #include <dirent.h>
 #include <string.h>
@@ -48,9 +51,70 @@ int mutt_complete (char *s, size_t slen)
   char filepart[_POSIX_PATH_MAX];
 #ifdef USE_IMAP
   char imap_path[LONG_STRING];
+#endif
 
   dprint (2, (debugfile, "mutt_complete: completing %s\n", s));
 
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    NNTP_SERVER *nserv = CurrentNewsSrv;
+    unsigned int n = 0;
+
+    strfcpy (filepart, s, sizeof (filepart));
+
+    /* special case to handle when there is no filepart yet
+     * find the first subscribed newsgroup */
+    len = mutt_strlen (filepart);
+    if (len == 0)
+    {
+      for (; n < nserv->groups_num; n++)
+      {
+	NNTP_DATA *nntp_data = nserv->groups_list[n];
+
+	if (nntp_data && nntp_data->subscribed)
+	{
+	  strfcpy (filepart, nntp_data->group, sizeof (filepart));
+	  init = 1;
+	  n++;
+	  break;
+	}
+      }
+    }
+
+    for (; n < nserv->groups_num; n++)
+    {
+      NNTP_DATA *nntp_data = nserv->groups_list[n];
+
+      if (nntp_data && nntp_data->subscribed &&
+	  mutt_strncmp (nntp_data->group, filepart, len) == 0)
+      {
+	if (init)
+	{
+	  for (i = 0; filepart[i] && nntp_data->group[i]; i++)
+	  {
+	    if (filepart[i] != nntp_data->group[i])
+	    {
+	      filepart[i] = 0;
+	      break;
+	    }
+	  }
+	  filepart[i] = 0;
+	}
+	else
+	{
+	  strfcpy (filepart, nntp_data->group, sizeof (filepart));
+	  init = 1;
+	}
+      }
+    }
+
+    strfcpy (s, filepart, slen);
+    return (init ? 0 : -1);
+  }
+#endif
+
+#ifdef USE_IMAP
   /* we can use '/' as a delimiter, imap_complete rewrites it */
   if (*s == '=' || *s == '+' || *s == '!')
   {
diff --git a/compose.c b/compose.c
index b4d0c41..e47afff 100644
--- a/compose.c
+++ b/compose.c
@@ -32,11 +32,16 @@
 #include "mailbox.h"
 #include "sort.h"
 #include "charset.h"
+#include "mx.h"
 
 #ifdef MIXMASTER
 #include "remailer.h"
 #endif
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
+
 #include <errno.h>
 #include <string.h>
 #include <sys/stat.h>
@@ -67,11 +72,17 @@ enum
   HDR_CRYPT,
   HDR_CRYPTINFO,
 
+#ifdef USE_NNTP
+  HDR_NEWSGROUPS,
+  HDR_FOLLOWUPTO,
+  HDR_XCOMMENTTO,
+#endif
+
   HDR_ATTACH  = (HDR_FCC + 5) /* where to start printing the attachments */
 };
 
-#define HDR_XOFFSET 10
-#define TITLE_FMT "%10s" /* Used for Prompts, which are ASCII */
+#define HDR_XOFFSET 14
+#define TITLE_FMT "%14s" /* Used for Prompts, which are ASCII */
 #define W (MuttIndexWindow->cols - HDR_XOFFSET)
 
 static const char * const Prompts[] =
@@ -83,6 +94,15 @@ static const char * const Prompts[] =
   "Subject: ",
   "Reply-To: ",
   "Fcc: "
+#ifdef USE_NNTP
+#ifdef MIXMASTER
+  ,""
+#endif
+  ,""
+  ,"Newsgroups: "
+  ,"Followup-To: "
+  ,"X-Comment-To: "
+#endif
 };
 
 static const struct mapping_t ComposeHelp[] = {
@@ -97,6 +117,19 @@ static const struct mapping_t ComposeHelp[] = {
   { NULL,	0 }
 };
 
+#ifdef USE_NNTP
+static struct mapping_t ComposeNewsHelp[] = {
+  { N_("Send"),		OP_COMPOSE_SEND_MESSAGE },
+  { N_("Abort"),	OP_EXIT },
+  { "Newsgroups",	OP_COMPOSE_EDIT_NEWSGROUPS },
+  { "Subj",		OP_COMPOSE_EDIT_SUBJECT },
+  { N_("Attach file"),	OP_COMPOSE_ATTACH_FILE },
+  { N_("Descrip"),	OP_COMPOSE_EDIT_DESCRIPTION },
+  { N_("Help"),		OP_HELP },
+  { NULL,		0 }
+};
+#endif
+
 static void snd_entry (char *b, size_t blen, MUTTMENU *menu, int num)
 {
   mutt_FormatString (b, blen, 0, MuttIndexWindow->cols, NONULL (AttachFormat), mutt_attach_fmt,
@@ -250,9 +283,28 @@ static void draw_envelope_addr (int line, ADDRESS *addr)
 static void draw_envelope (HEADER *msg, char *fcc)
 {
   draw_envelope_addr (HDR_FROM, msg->env->from);
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+  {
+#endif
   draw_envelope_addr (HDR_TO, msg->env->to);
   draw_envelope_addr (HDR_CC, msg->env->cc);
   draw_envelope_addr (HDR_BCC, msg->env->bcc);
+#ifdef USE_NNTP
+  }
+  else
+  {
+    mutt_window_mvprintw (MuttIndexWindow, HDR_TO, 0, TITLE_FMT, Prompts[HDR_NEWSGROUPS - 1]);
+    mutt_paddstr (W, NONULL (msg->env->newsgroups));
+    mutt_window_mvprintw (MuttIndexWindow, HDR_CC, 0, TITLE_FMT, Prompts[HDR_FOLLOWUPTO - 1]);
+    mutt_paddstr (W, NONULL (msg->env->followup_to));
+    if (option (OPTXCOMMENTTO))
+    {
+      mutt_window_mvprintw (MuttIndexWindow, HDR_BCC, 0, TITLE_FMT, Prompts[HDR_XCOMMENTTO - 1]);
+      mutt_paddstr (W, NONULL (msg->env->x_comment_to));
+    }
+  }
+#endif
   mutt_window_mvprintw (MuttIndexWindow, HDR_SUBJECT, 0, TITLE_FMT, Prompts[HDR_SUBJECT]);
   mutt_paddstr (W, NONULL (msg->env->subject));
   draw_envelope_addr (HDR_REPLYTO, msg->env->reply_to);
@@ -448,8 +500,8 @@ compose_format_str (char *buf, size_t buflen, size_t col, int cols, char op, con
       break;
 
     case 'v':
-      snprintf (fmt, sizeof (fmt), "Mutt %%s");
-      snprintf (buf, buflen, fmt, MUTT_VERSION);
+      snprintf (fmt, sizeof (fmt), "NeoMutt %%s");
+      snprintf (buf, buflen, fmt, PACKAGE_VERSION);
       break;
 
     case 0:
@@ -505,6 +557,12 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
   /* Sort, SortAux could be changed in mutt_index_menu() */
   int oldSort, oldSortAux;
   struct stat st;
+#ifdef USE_NNTP
+  int news = 0;		/* is it a news article ? */
+
+  if (option (OPTNEWSSEND))
+    news++;
+#endif
 
   mutt_attach_init (msg->content);
   idx = mutt_gen_attach_list (msg->content, -1, idx, &idxlen, &idxmax, 0, 1);
@@ -515,10 +573,18 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
   menu->make_entry = snd_entry;
   menu->tag = mutt_tag_attach;
   menu->data = idx;
+#ifdef USE_NNTP
+  if (news)
+    menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_COMPOSE, ComposeNewsHelp);
+  else
+#endif
   menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_COMPOSE, ComposeHelp);
 
   while (loop)
   {
+#ifdef USE_NNTP
+    unset_option (OPTNEWS);	/* for any case */
+#endif
     switch (op = mutt_menuLoop (menu))
     {
       case OP_REDRAW:
@@ -531,6 +597,10 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
         mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
 	break;
       case OP_COMPOSE_EDIT_TO:
+#ifdef USE_NNTP
+	if (news)
+	  break;
+#endif
 	menu->redraw = edit_address_list (HDR_TO, &msg->env->to);
 	if (option (OPTCRYPTOPPORTUNISTICENCRYPT))
 	{
@@ -540,6 +610,10 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
         mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
       case OP_COMPOSE_EDIT_BCC:
+#ifdef USE_NNTP
+	if (news)
+	  break;
+#endif
 	menu->redraw = edit_address_list (HDR_BCC, &msg->env->bcc);
 	if (option (OPTCRYPTOPPORTUNISTICENCRYPT))
 	{
@@ -549,6 +623,10 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
         mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
 	break;
       case OP_COMPOSE_EDIT_CC:
+#ifdef USE_NNTP
+	if (news)
+	  break;
+#endif
 	menu->redraw = edit_address_list (HDR_CC, &msg->env->cc);
 	if (option (OPTCRYPTOPPORTUNISTICENCRYPT))
 	{
@@ -557,6 +635,62 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	}
         mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);	
         break;
+#ifdef USE_NNTP
+      case OP_COMPOSE_EDIT_NEWSGROUPS:
+	if (news)
+	{
+	  if (msg->env->newsgroups)
+	    strfcpy (buf, msg->env->newsgroups, sizeof (buf));
+	  else
+	    buf[0] = 0;
+	  if (mutt_get_field ("Newsgroups: ", buf, sizeof (buf), 0) == 0)
+	  {
+	    mutt_str_replace (&msg->env->newsgroups, buf);
+	    mutt_window_move (MuttIndexWindow, HDR_TO, HDR_XOFFSET);
+	    if (msg->env->newsgroups)
+	      mutt_paddstr (W, msg->env->newsgroups);
+	    else
+	      clrtoeol ();
+	  }
+	}
+	break;
+      case OP_COMPOSE_EDIT_FOLLOWUP_TO:
+	if (news)
+	{
+	  if (msg->env->followup_to)
+	    strfcpy (buf, msg->env->followup_to, sizeof (buf));
+	  else
+	    buf[0] = 0;
+	  if (mutt_get_field ("Followup-To: ", buf, sizeof (buf), 0) == 0)
+	  {
+	    mutt_str_replace (&msg->env->followup_to, buf);
+	    mutt_window_move (MuttIndexWindow, HDR_CC, HDR_XOFFSET);
+	    if (msg->env->followup_to)
+	      mutt_paddstr (W, msg->env->followup_to);
+	    else
+	      clrtoeol ();
+	  }
+	}
+	break;
+      case OP_COMPOSE_EDIT_X_COMMENT_TO:
+	if (news && option (OPTXCOMMENTTO))
+	{
+	  if (msg->env->x_comment_to)
+	    strfcpy (buf, msg->env->x_comment_to, sizeof (buf));
+	  else
+	    buf[0] = 0;
+	  if (mutt_get_field ("X-Comment-To: ", buf, sizeof (buf), 0) == 0)
+	  {
+	    mutt_str_replace (&msg->env->x_comment_to, buf);
+	    mutt_window_move (MuttIndexWindow, HDR_BCC, HDR_XOFFSET);
+	    if (msg->env->x_comment_to)
+	      mutt_paddstr (W, msg->env->x_comment_to);
+	    else
+	      clrtoeol ();
+	  }
+	}
+	break;
+#endif
       case OP_COMPOSE_EDIT_SUBJECT:
 	if (msg->env->subject)
 	  strfcpy (buf, msg->env->subject, sizeof (buf));
@@ -687,7 +821,8 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  numfiles = 0;
 	  files = NULL;
 
-	  if (_mutt_enter_fname (prompt, fname, sizeof (fname), &menu->redraw, 0, 1, &files, &numfiles) == -1 ||
+	  if (_mutt_enter_fname (prompt, fname, sizeof (fname),
+			&menu->redraw, 0, 1, &files, &numfiles, 0) == -1 ||
 	      *fname == '\0')
 	    break;
 
@@ -725,6 +860,9 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
         break;
 
       case OP_COMPOSE_ATTACH_MESSAGE:
+#ifdef USE_NNTP
+      case OP_COMPOSE_ATTACH_NEWS_MESSAGE:
+#endif
 	{
 	  char *prompt;
 	  HEADER *h;
@@ -732,7 +870,22 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  fname[0] = 0;
 	  prompt = _("Open mailbox to attach message from");
 
+#ifdef USE_NNTP
+	  unset_option (OPTNEWS);
+	  if (op == OP_COMPOSE_ATTACH_NEWS_MESSAGE)
+	  {
+	    if (!(CurrentNewsSrv = nntp_select_server (NewsServer, 0)))
+	      break;
+
+	    prompt = _("Open newsgroup to attach message from");
+	    set_option (OPTNEWS);
+	  }
+#endif
+
 	  if (Context)
+#ifdef USE_NNTP
+	  if ((op == OP_COMPOSE_ATTACH_MESSAGE) ^ (Context->magic == MUTT_NNTP))
+#endif
 	  {
 	    strfcpy (fname, NONULL (Context->path), sizeof (fname));
 	    mutt_pretty_mailbox (fname, sizeof (fname));
@@ -741,6 +894,11 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  if (mutt_enter_fname (prompt, fname, sizeof (fname), &menu->redraw, 1) == -1 || !fname[0])
 	    break;
 
+#ifdef USE_NNTP
+	  if (option (OPTNEWS))
+	    nntp_expand_path (fname, sizeof (fname), &CurrentNewsSrv->conn->account);
+	  else
+#endif
 	  mutt_expand_path (fname, sizeof (fname));
 #ifdef USE_IMAP
           if (!mx_is_imap (fname))
@@ -748,6 +906,9 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 #ifdef USE_POP
           if (!mx_is_pop (fname))
 #endif
+#ifdef USE_NNTP
+	  if (!mx_is_nntp (fname) && !option (OPTNEWS))
+#endif
 	  /* check to make sure the file exists and is readable */
 	  if (access (fname, R_OK) == -1)
 	  {
@@ -1232,7 +1393,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
          if (msg->content->next)
            msg->content = mutt_make_multipart (msg->content);
 
-         if (mutt_write_fcc (fname, msg, NULL, 0, NULL) < 0)
+         if (mutt_write_fcc (fname, msg, NULL, 0, NULL, NULL) < 0)
            msg->content = mutt_remove_multipart (msg->content);
          else
            mutt_message _("Message written.");
diff --git a/compress.c b/compress.c
new file mode 100644
index 0000000..aadf094
--- /dev/null
+++ b/compress.c
@@ -0,0 +1,918 @@
+/* Copyright (C) 1997 Alain Penders <Alain@Finale-Dev.com>
+ * Copyright (C) 2016 Richard Russon <rich@flatcap.org>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <errno.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include "mutt.h"
+#include "mailbox.h"
+#include "mutt_curses.h"
+#include "mx.h"
+
+/* Notes:
+ * Any references to compressed files also apply to encrypted files.
+ * ctx->path     == plaintext file
+ * ctx->realpath == compressed file
+ */
+
+/**
+ * struct COMPRESS_INFO - Private data for compress
+ *
+ * This object gets attached to the mailbox's CONTEXT.
+ */
+typedef struct
+{
+  const char *append;             /* append-hook command */
+  const char *close;              /* close-hook  command */
+  const char *open;               /* open-hook   command */
+  off_t size;                     /* size of the compressed file */
+  struct mx_ops *child_ops;       /* callbacks of de-compressed file */
+} COMPRESS_INFO;
+
+
+/**
+ * lock_mailbox - Try to lock a mailbox (exclusively)
+ * @ctx:  Mailbox to lock
+ * @fp:   File pointer to the mailbox file
+ * @excl: Lock exclusively?
+ *
+ * Try to (exclusively) lock the mailbox.  If we succeed, then we mark the
+ * mailbox as locked.  If we fail, but we didn't want exclusive rights, then
+ * the mailbox will be marked readonly.
+ *
+ * Returns:
+ *      1: Success (locked or readonly)
+ *      0: Error (can't lock the file)
+ */
+static int
+lock_mailbox (CONTEXT *ctx, FILE *fp, int excl)
+{
+  if (!ctx || !fp)
+    return 0;
+
+  int r = mx_lock_file (ctx->realpath, fileno (fp), excl, 1, 1);
+
+  if (r == 0)
+  {
+    ctx->locked = 1;
+  }
+  else if (excl == 0)
+  {
+    ctx->readonly = 1;
+    return 1;
+  }
+
+  return (r == 0);
+}
+
+/**
+ * unlock_mailbox - Unlock a mailbox
+ * @ctx: Mailbox to unlock
+ * @fp:  File pointer to mailbox file
+ *
+ * Unlock a mailbox previously locked by lock_mailbox().
+ */
+static void
+unlock_mailbox (CONTEXT *ctx, FILE *fp)
+{
+  if (!ctx || !fp)
+    return;
+
+  if (!ctx->locked)
+    return;
+
+  fflush (fp);
+
+  mx_unlock_file (ctx->realpath, fileno (fp), 1);
+  ctx->locked = 0;
+}
+
+/**
+ * setup_paths - Set the mailbox paths
+ * @ctx: Mailbox to modify
+ *
+ * Save the compressed filename in ctx->realpath.
+ * Create a temporary filename and put its name in ctx->path.
+ *
+ * Note: The temporary file is NOT created.
+ * Note: ctx->path will be freed by restore_path()
+ */
+static void
+setup_paths (CONTEXT *ctx)
+{
+  if (!ctx)
+    return;
+
+  char tmppath[_POSIX_PATH_MAX];
+
+  /* Setup the right paths */
+  ctx->realpath = ctx->path;
+
+  /* We will uncompress to /tmp */
+  mutt_mktemp (tmppath, sizeof (tmppath));
+  ctx->path = safe_strdup (tmppath);
+}
+
+/**
+ * restore_path - Put back the original mailbox name
+ * @ctx: Mailbox to modify
+ *
+ * When we use a compressed mailbox, we change the CONTEXT to refer to the
+ * uncompressed file.  We store the original name in ctx->realpath.
+ *      ctx->path     = "/tmp/mailbox"
+ *      ctx->realpath = "mailbox.gz"
+ *
+ * When we have finished with a compressed mailbox, we put back the original
+ * name.
+ *      ctx->path     = "mailbox.gz"
+ *      ctx->realpath = NULL
+ */
+static void
+restore_path (CONTEXT *ctx)
+{
+  if (!ctx)
+    return;
+
+  FREE(&ctx->path);
+  ctx->path = ctx->realpath;
+  ctx->realpath = NULL;
+}
+
+/**
+ * get_size - Get the size of a file
+ * @path: File to measure
+ *
+ * Returns:
+ *      number: Size in bytes
+ *      0:      On error
+ */
+static int
+get_size (const char *path)
+{
+  if (!path)
+    return 0;
+
+  struct stat sb;
+  if (stat (path, &sb) != 0)
+    return 0;
+
+  return sb.st_size;
+}
+
+/**
+ * store_size - Save the size of the compressed file
+ * @ctx: Mailbox
+ *
+ * Save the compressed file size in the compress_info struct.
+ */
+static void
+store_size (const CONTEXT *ctx)
+{
+  if (!ctx)
+    return;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return;
+
+  ci->size = get_size (ctx->realpath);
+}
+
+/**
+ * find_hook - Find a hook to match a path
+ * @type: Type of hook, e.g. MUTT_CLOSEHOOK
+ * @path: Filename to test
+ *
+ * Each hook has a type and a pattern.
+ * Find a command that matches the type and path supplied. e.g.
+ *
+ * User config:
+ *      open-hook '\.gz$' "gzip -cd '%f' > '%t'"
+ *
+ * Call:
+ *      find_hook (MUTT_OPENHOOK, "myfile.gz");
+ *
+ * Returns:
+ *      string: Matching hook command
+ *      NULL:   No matches
+ */
+static const char *
+find_hook (int type, const char *path)
+{
+  if (!path)
+    return NULL;
+
+  const char *c = mutt_find_hook (type, path);
+  if (!c || !*c)
+    return NULL;
+
+  return c;
+}
+
+/**
+ * set_compress_info - Find the compress hooks for a mailbox
+ * @ctx: Mailbox to examine
+ *
+ * When a mailbox is opened, we check if there are any matching hooks.
+ *
+ * Note: Caller must free the COMPRESS_INFO when done.
+ *
+ * Returns:
+ *      COMPRESS_INFO: Hook info for the mailbox's path
+ *      NULL:          On error
+ */
+static COMPRESS_INFO *
+set_compress_info (CONTEXT *ctx)
+{
+  if (!ctx || !ctx->path)
+    return NULL;
+
+  if (ctx->compress_info)
+    return ctx->compress_info;
+
+  /* Open is compulsory */
+  const char *o = find_hook (MUTT_OPENHOOK,   ctx->path);
+  if (!o)
+    return NULL;
+
+  const char *c = find_hook (MUTT_CLOSEHOOK,  ctx->path);
+  const char *a = find_hook (MUTT_APPENDHOOK, ctx->path);
+
+  COMPRESS_INFO *ci = safe_calloc (1, sizeof (COMPRESS_INFO));
+  ctx->compress_info = ci;
+
+  ci->open   = o;
+  ci->close  = c;
+  ci->append = a;
+
+  return ci;
+}
+
+/**
+ * cb_format_str - Expand the filenames in the command string
+ * @dest:        Buffer in which to save string
+ * @destlen:     Buffer length
+ * @col:         Starting column, UNUSED
+ * @cols:        Number of screen columns, UNUSED
+ * @op:          printf-like operator, e.g. 't'
+ * @src:         printf-like format string
+ * @fmt:         Field formatting string, UNUSED
+ * @ifstring:    If condition is met, display this string, UNUSED
+ * @elsestring:  Otherwise, display this string, UNUSED
+ * @data:        Pointer to the mailbox CONTEXT
+ * @flags:       Format flags, UNUSED
+ *
+ * cb_format_str is a callback function for mutt_FormatString.  It understands
+ * two operators. '%f' : 'from' filename, '%t' : 'to' filename.
+ *
+ * Returns: src (unchanged)
+ */
+static const char *
+cb_format_str (char *dest, size_t destlen, size_t col, int cols, char op, const char *src,
+  const char *fmt, const char *ifstring, const char *elsestring,
+  unsigned long data, format_flag flags)
+{
+  if (!dest || (data == 0))
+    return src;
+
+  CONTEXT *ctx = (CONTEXT *) data;
+
+  switch (op)
+  {
+    case 'f':
+      /* Compressed file */
+      snprintf (dest, destlen, "%s", ctx->realpath);
+      break;
+    case 't':
+      /* Plaintext, temporary file */
+      snprintf (dest, destlen, "%s", ctx->path);
+      break;
+  }
+  return src;
+}
+
+/**
+ * expand_command_str - Expand placeholders in command string
+ * @ctx:    Mailbox for paths
+ * @buf:    Buffer to store the command
+ * @buflen: Size of the buffer
+ *
+ * This function takes a hook command and expands the filename placeholders
+ * within it.  The function calls mutt_FormatString() to do the replacement
+ * which calls our callback function cb_format_str(). e.g.
+ *
+ * Template command:
+ *      gzip -cd '%f' > '%t'
+ *
+ * Result:
+ *      gzip -dc '~/mail/abc.gz' > '/tmp/xyz'
+ */
+static void
+expand_command_str (const CONTEXT *ctx, const char *cmd, char *buf, int buflen)
+{
+  if (!ctx || !cmd || !buf)
+    return;
+
+  mutt_FormatString (buf, buflen, 0, buflen, cmd, cb_format_str, (unsigned long) ctx, 0);
+}
+
+/**
+ * execute_command - Run a system command
+ * @ctx:         Mailbox to work with
+ * @command:     Command string to execute
+ * @create_file: Should the tmp file be created?
+ * @progress:    Message to show the user
+ *
+ * Run the supplied command, taking care of all the Mutt requirements,
+ * such as locking files and blocking signals.
+ *
+ * Returns:
+ *      1: Success
+ *      0: Failure
+ */
+static int
+execute_command (CONTEXT *ctx, const char *command, int create_file, const char *progress)
+{
+  if (!ctx || !command || !progress)
+    return 0;
+
+  if (!ctx->quiet)
+    mutt_message (progress, ctx->realpath);
+
+  FILE *fp;
+  if (create_file)
+    fp = fopen (ctx->realpath, "a");
+  else
+    fp = fopen (ctx->realpath, "r");
+
+  if (!fp)
+  {
+    mutt_perror (ctx->realpath);
+    return 0;
+  }
+
+  mutt_block_signals();
+  /* If we're creating the file, lock it exclusively */
+  if (!lock_mailbox (ctx, fp, create_file))
+  {
+    safe_fclose (&fp);
+    mutt_unblock_signals();
+    mutt_error (_("Unable to lock mailbox!"));
+    return 0;
+  }
+
+  endwin();
+  fflush (stdout);
+
+  char sys_cmd[HUGE_STRING];
+
+  expand_command_str (ctx, command, sys_cmd, sizeof (sys_cmd));
+
+  int rc = mutt_system (sys_cmd);
+  if (rc != 0)
+  {
+    mutt_any_key_to_continue (NULL);
+    mutt_error (_("Error executing: %s\n"), sys_cmd);
+  }
+
+  unlock_mailbox (ctx, fp);
+  mutt_unblock_signals();
+  safe_fclose (&fp);
+
+  return 1;
+}
+
+/**
+ * open_read - Open a compressed mailbox for reading
+ * @ctx: Mailbox to open
+ *
+ * Decompress the mailbox and set up the paths and hooks needed.
+ *
+ * Note: The message handling will be delegated to the mbox code.
+ *
+ * Returns:
+ *      1: Success
+ *      0: Failure
+ */
+static int
+open_read (CONTEXT *ctx)
+{
+  if (!ctx)
+    return 0;
+
+  COMPRESS_INFO *ci = set_compress_info (ctx);
+  if (!ci)
+  {
+    ctx->magic = 0;
+    return 0;
+  }
+
+  /* If there's no close-hook, or the file isn't writable */
+  if (!ci->close || (access (ctx->path, W_OK) != 0))
+    ctx->readonly = 1;
+
+  setup_paths (ctx);
+  store_size (ctx);
+
+  int rc = execute_command (ctx, ci->open, 0, _("Decompressing %s"));
+  if (rc == 0)
+  {
+    goto or_fail;
+  }
+
+  ctx->magic = mx_get_magic (ctx->path);
+  if (ctx->magic == 0)
+  {
+    mutt_error (_("Can't identify the contents of the compressed file"));
+    goto or_fail;
+  }
+
+  ci->child_ops = mx_get_ops (ctx->magic);
+  if (!ci->child_ops)
+  {
+    mutt_error (_("Can't find mailbox ops for mailbox type %d"), ctx->magic);
+    goto or_fail;
+  }
+
+  return 1;
+
+or_fail:
+  /* remove the partial uncompressed file */
+  remove (ctx->path);
+  restore_path (ctx);
+  return 0;
+}
+
+
+struct mx_ops mx_comp_ops;
+
+/**
+ * open_mailbox - Open a compressed mailbox
+ * @ctx: Mailbox to open
+ *
+ * Set up a compressed mailbox to be read.
+ * First call open_read() to decompress the file.
+ * Then determine the type of the mailbox so we can delegate the handling of
+ * messages.
+ */
+static int
+open_mailbox (CONTEXT *ctx)
+{
+  if (!ctx || (ctx->magic != MUTT_COMPRESSED))
+    return 1;
+
+  if (!open_read (ctx))
+    return 1;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return 1;
+
+  struct mx_ops *ops = ci->child_ops;
+  if (!ops)
+    return 1;
+
+  /* Delegate */
+  return ops->open (ctx);
+}
+
+/**
+ * open_append_mailbox - Open a compressed mailbox for appending
+ * @ctx:   Mailbox to open
+ * @flags: e.g. Does the file already exist?
+ *
+ * To append to a compressed mailbox we need an append-hook (or both open- and
+ * close-hooks).
+ *
+ * Returns:
+ *       0: Success
+ *      -1: Failure
+ */
+static int
+open_append_mailbox (CONTEXT *ctx, int flags)
+{
+  if (!ctx)
+    return -1;
+
+  /* If this succeeds, we know there's an open-hook */
+  COMPRESS_INFO *ci = set_compress_info (ctx);
+  if (!ci)
+    return -1;
+
+  /* To append we need an append-hook or a close-hook */
+  if (!ci->append && !ci->close)
+  {
+    FREE(&ctx->compress_info);
+    mutt_error (_("Cannot append without an append-hook or close-hook : %s"), ctx->path);
+    return -1;
+  }
+
+  ctx->magic = DefaultMagic;
+  /* We can only deal with mbox and mmdf mailboxes */
+  if ((ctx->magic != MUTT_MBOX) && (ctx->magic != MUTT_MMDF))
+    return -1;
+
+  setup_paths (ctx);
+
+  ctx->mx_ops = &mx_comp_ops;
+  ci->child_ops = mx_get_ops (ctx->magic);
+  if (!ci->child_ops)
+  {
+    mutt_error (_("Can't find mailbox ops for mailbox type %d"), ctx->magic);
+    return -1;
+  }
+
+  if (ci->append)
+  {
+    /* Create an empty temporary file */
+    ctx->fp = safe_fopen (ctx->path, "w");
+    if (!ctx->fp)
+    {
+      mutt_perror (ctx->path);
+      goto oa_fail;
+    }
+  }
+  else
+  {
+    /* Open the existing mailbox */
+    int rc = execute_command (ctx, ci->open, 0, _("Decompressing %s"));
+    if (rc == 0)
+    {
+      mutt_error (_("Compress command failed: %s"), ci->open);
+      goto oa_fail;
+    }
+    ctx->fp = safe_fopen (ctx->path, "a");
+    if (!ctx->fp)
+    {
+      mutt_perror (ctx->path);
+      goto oa_fail;
+    }
+  }
+
+  return 0;
+
+oa_fail:
+  /* remove the partial uncompressed file */
+  remove (ctx->path);
+  restore_path (ctx);
+  return -1;
+}
+
+/**
+ * close_mailbox - Close a compressed mailbox
+ * @ctx: Mailbox to close
+ *
+ * If the mailbox has been changed then re-compress the tmp file.
+ * Then delete the tmp file.
+ *
+ * Returns:
+ *       0: Success
+ *      -1: Failure
+ */
+static int
+close_mailbox (CONTEXT *ctx)
+{
+  if (!ctx)
+    return -1;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return -1;
+
+  safe_fclose (&ctx->fp);
+
+  /* sync has already been called, so we only need to delete some files */
+  if (!ctx->append)
+  {
+    /* If the file was removed, remove the compressed folder too */
+    if ((access (ctx->path, F_OK) != 0) && !option (OPTSAVEEMPTY))
+    {
+      remove (ctx->realpath);
+    }
+    else
+    {
+      remove (ctx->path);
+    }
+
+    restore_path (ctx);
+    FREE(&ctx->compress_info);
+    return 0;
+  }
+
+  const char *append;
+  const char *msg;
+
+  /* The file exists and we can append */
+  if ((access (ctx->realpath, F_OK) == 0) && ci->append)
+  {
+    append = ci->append;
+    msg = _("Compressed-appending to %s...");
+  }
+  else
+  {
+    append = ci->close;
+    msg = _("Compressing %s...");
+  }
+
+  int rc = execute_command (ctx, append, 1, msg);
+  if (rc == 0)
+  {
+    mutt_any_key_to_continue (NULL);
+    mutt_error (_(" %s: Error compressing mailbox!  Uncompressed one kept!\n"), ctx->path);
+  }
+
+  remove (ctx->path);
+  restore_path (ctx);
+  FREE(&ctx->compress_info);
+
+  return 0;
+}
+
+/**
+ * check_mailbox - Check for changes in the compressed file
+ * @ctx: Mailbox
+ *
+ * If the compressed file changes in size but the mailbox hasn't been changed
+ * in Mutt, then we can close and reopen the mailbox.
+ *
+ * If the mailbox has been changed in Mutt, warn the user.
+ *
+ * The return codes are picked to match mx_check_mailbox().
+ *
+ * Returns:
+ *      0:              Mailbox OK
+ *      MUTT_REOPENED:  The mailbox was closed and reopened
+ *      -1:             Mailbox bad
+ */
+static int
+check_mailbox (CONTEXT *ctx, int *index_hint)
+{
+  if (!ctx)
+    return -1;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return -1;
+
+  int size = get_size (ctx->realpath);
+  if (size == ci->size)
+    return 0;
+
+  if (ctx->changed)
+  {
+    FREE(&ctx->compress_info);
+    restore_path (ctx);
+    mutt_error (_("Mailbox was corrupted!"));
+    return -1;
+  }
+
+  close_mailbox (ctx);
+
+  const char *path = ctx->path;
+  ctx->path = NULL;
+
+  mx_open_mailbox (path, 0, ctx);
+  FREE(&path);
+
+  return MUTT_REOPENED;
+}
+
+
+/**
+ * open_message - Delegated to mbox handler
+ */
+static int
+open_message (CONTEXT *ctx,  MESSAGE *msg, int msgno)
+{
+  if (!ctx)
+    return -1;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return -1;
+
+  struct mx_ops *ops = ci->child_ops;
+  if (!ops)
+    return -1;
+
+  /* Delegate */
+  return ops->open_msg (ctx, msg, msgno);
+}
+
+/**
+ * close_message - Delegated to mbox handler
+ */
+static int
+close_message (CONTEXT *ctx, MESSAGE *msg)
+{
+  if (!ctx)
+    return -1;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return -1;
+
+  struct mx_ops *ops = ci->child_ops;
+  if (!ops)
+    return -1;
+
+  /* Delegate */
+  return ops->close_msg (ctx, msg);
+}
+
+/**
+ * commit_message - Delegated to mbox handler
+ */
+static int
+commit_message (CONTEXT *ctx, MESSAGE *msg)
+{
+  if (!ctx)
+    return -1;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return -1;
+
+  struct mx_ops *ops = ci->child_ops;
+  if (!ops)
+    return -1;
+
+  /* Delegate */
+  return ops->commit_msg (ctx, msg);
+}
+
+/**
+ * open_new_message - Delegated to mbox handler
+ */
+static int
+open_new_message (MESSAGE *msg, CONTEXT *ctx, HEADER *hdr)
+{
+  if (!ctx)
+    return -1;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return -1;
+
+  struct mx_ops *ops = ci->child_ops;
+  if (!ops)
+    return -1;
+
+  /* Delegate */
+  return ops->open_new_msg (msg, ctx, hdr);
+}
+
+
+/**
+ * comp_can_append - Can we append to this path?
+ * @path: pathname of file to be tested
+ *
+ * To append to a file we can either use an 'append-hook' or a combination of
+ * 'open-hook' and 'close-hook'.
+ *
+ * A match means it's our responsibility to append to the file.
+ *
+ * Returns:
+ *      1: Yes, we can append to the file
+ *      0: No, appending isn't possible
+ */
+int
+comp_can_append (CONTEXT *ctx)
+{
+  if (!ctx)
+    return 0;
+
+  /* If this succeeds, we know there's an open-hook */
+  COMPRESS_INFO *ci = set_compress_info (ctx);
+  if (!ci)
+    return 0;
+
+  /* We have an open-hook, so to append we need an append-hook,
+   * or a close-hook. */
+  if (ci->append || ci->close)
+    return 1;
+
+  mutt_error (_("Cannot append without an append-hook or close-hook : %s"), ctx->path);
+  return 0;
+}
+
+/**
+ * comp_can_read - Can we read from this file?
+ * @path: Pathname of file to be tested
+ *
+ * Search for an 'open-hook' with a regex that matches the path.
+ *
+ * A match means it's our responsibility to open the file.
+ *
+ * Returns:
+ *      1: Yes, we can read the file
+ *      0: No, we cannot read the file
+ */
+int
+comp_can_read (const char *path)
+{
+  if (!path)
+    return 0;
+
+  if (find_hook (MUTT_OPENHOOK, path))
+    return 1;
+  else
+    return 0;
+}
+
+/**
+ * comp_sync - Save changes to the compressed mailbox file
+ * @ctx: Mailbox to sync
+ *
+ * Changes in Mutt only affect the tmp file.  Calling comp_sync() will commit
+ * them to the compressed file.
+ *
+ * Returns:
+ *       0: Success
+ *      -1: Failure
+ */
+int
+comp_sync (CONTEXT *ctx)
+{
+  if (!ctx)
+    return -1;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return -1;
+
+  if (!ci->close)
+  {
+    mutt_error (_("Can't sync a compressed file without a close-hook"));
+    return -1;
+  }
+
+  int rc = execute_command (ctx, ci->close, 1, _("Compressing %s"));
+  if (rc == 0)
+    return -1;
+
+  store_size (ctx);
+
+  return 0;
+}
+
+/**
+ * comp_valid_command - Is this command string allowed?
+ * @cmd:  Command string
+ *
+ * A valid command string must have both "%f" (from file) and "%t" (to file).
+ * We don't check if we can actually run the command.
+ *
+ * Returns:
+ *      1: Valid command
+ *      0: "%f" and/or "%t" is missing
+ */
+int
+comp_valid_command (const char *cmd)
+{
+  if (!cmd)
+    return 0;
+
+  return (strstr (cmd, "%f") && strstr (cmd, "%t"));
+}
+
+
+/**
+ * mx_comp_ops - Mailbox callback functions
+ *
+ * Compress only uses open, close and check.
+ * The message functions are delegated to mbox.
+ */
+struct mx_ops mx_comp_ops =
+{
+  .open         = open_mailbox,
+  .open_append  = open_append_mailbox,
+  .close        = close_mailbox,
+  .check        = check_mailbox,
+  .open_msg     = open_message,
+  .close_msg    = close_message,
+  .commit_msg   = commit_message,
+  .open_new_msg = open_new_message
+};
+
diff --git a/compress.h b/compress.h
new file mode 100644
index 0000000..26beae6
--- /dev/null
+++ b/compress.h
@@ -0,0 +1,29 @@
+/* Copyright (C) 1997 Alain Penders <Alain@Finale-Dev.com>
+ * Copyright (C) 2016 Richard Russon <rich@flatcap.org>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef _COMPRESS_H_
+#define _COMPRESS_H_
+
+int comp_can_append    (CONTEXT *ctx);
+int comp_can_read      (const char *path);
+int comp_sync          (CONTEXT *ctx);
+int comp_valid_command (const char *cmd);
+
+extern struct mx_ops mx_comp_ops;
+
+#endif /* _COMPRESS_H_ */
diff --git a/configure.ac b/configure.ac
index 75517f6..636d47a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3,15 +3,15 @@ dnl Process this file with autoconf to produce a configure script.
 dnl !!! WHEN ADDING NEW CONFIGURE TESTS, PLEASE ADD CODE TO MAIN.C !!!
 dnl !!! TO DUMP THEIR RESULTS WHEN MUTT -V IS CALLED            !!!
 
-AC_INIT([mutt],[m4_esyscmd(tr -d \\n <VERSION)])
+CFLAGS=$CFLAGS
+LDFLAGS=$LDFLAGS
+
+AC_INIT([NeoMutt], m4_esyscmd(./git-version-gen .tarball-version 's/neomutt-/v/g'), [neomutt-devel@neomutt.org], [neomutt], [http://www.neomutt.org])
 AC_CONFIG_SRCDIR(mutt.h)
 AM_INIT_AUTOMAKE
 AC_CONFIG_HEADERS([config.h])
 
-AC_SUBST([CONFIG_STATUS_DEPENDENCIES], ['$(top_srcdir)/VERSION'])
-
-MUTT_VERSION=`env sh "$srcdir/version.sh"`
-AC_DEFINE_UNQUOTED(MUTT_VERSION,"$MUTT_VERSION", [Full textual version string.])
+AC_SUBST([CONFIG_STATUS_DEPENDENCIES], ['$(top_srcdir)/.version'])
 
 AC_USE_SYSTEM_EXTENSIONS
 
@@ -29,6 +29,10 @@ AC_MSG_RESULT($mutt_cv_prefix)
 
 AC_PROG_CC
 AC_PROG_CC_C99
+if test "$ac_cv_prog_cc_c99" = "no"; then
+  AC_ERROR([Compiler does not support C99. Aborting.])
+fi
+
 AC_SEARCH_LIBS([strerror],[cposix])
 if test "x$U" != "x"; then
   AC_MSG_ERROR(Compiler not ANSI compliant)
@@ -121,20 +125,16 @@ AC_DEFINE_UNQUOTED(SENDMAIL,"$ac_cv_path_SENDMAIL", [Where to find sendmail on y
 OPS='$(srcdir)/OPS'
 
 AC_MSG_CHECKING([whether to build with GPGME support])
-AC_ARG_ENABLE(gpgme, AS_HELP_STRING([--enable-gpgme],[Enable GPGME support]),
-[       if test x$enableval = xyes; then
-		enable_gpgme=yes
-	fi
-])
+AC_ARG_ENABLE(gpgme, AS_HELP_STRING([--enable-gpgme],[Enable GPGME support]), enable_gpgme=$enableval, enable_gpgme=no)
 
-if test x"$enable_gpgme" = xyes; then
-   AC_MSG_RESULT(yes)
+AS_IF([test x$enable_gpgme = "xyes"], [
+   AC_MSG_RESULT([yes])
    AM_PATH_GPGME(1.0.0, AC_DEFINE(CRYPT_BACKEND_GPGME, 1,
 		 [Defined, if GPGME support is enabled]),
 		 [gpgme_found=no])
-   if test x"$gpgme_found" = xno; then
+   AS_IF([test x$gpgme_found = "xno"], [
       AC_MSG_ERROR([*** GPGME not found ***])
-   else
+   ], [
       AM_PATH_GPGME(1.1.1, AC_DEFINE(HAVE_GPGME_PKA_TRUST, 1,
 				  [Define if GPGME supports PKA]))
       #needed to get GPGME_LIBS and al correctly
@@ -146,43 +146,67 @@ if test x"$enable_gpgme" = xyes; then
       AC_CHECK_FUNCS([gpgme_op_export_keys])
       LIBS="$saved_LIBS"
       MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS crypt-gpgme.o crypt-mod-pgp-gpgme.o crypt-mod-smime-gpgme.o"
-   fi
-else
+   ])
+], [
    AC_MSG_RESULT([no])
-fi
+])
 
-AC_ARG_ENABLE(pgp, AS_HELP_STRING([--disable-pgp],[Disable PGP support]),
-[       if test x$enableval = xno ; then
-                have_pgp=no
-        fi
+AC_ARG_ENABLE(pgp, AS_HELP_STRING([--disable-pgp],[Disable PGP support]), enable_pgp=$enableval, enable_pgp=yes)
+AS_IF([test x$enable_pgp != "xno"], [
+	   AC_DEFINE(CRYPT_BACKEND_CLASSIC_PGP, 1, [Define if you want classic PGP Support.])
+	   PGPAUX_TARGET="pgpring\$(EXEEXT) pgpewrap\$(EXEEXT)"
+	   MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS pgp.o pgpinvoke.o pgpkey.o pgplib.o gnupgparse.o pgpmicalg.o pgppacket.o crypt-mod-pgp-classic.o"
 ])
 
-if test x$have_pgp != xno ; then
-        AC_DEFINE(CRYPT_BACKEND_CLASSIC_PGP,1, [Define if you want classic PGP support.])
-        PGPAUX_TARGET="pgpring\$(EXEEXT) pgpewrap\$(EXEEXT)"
-        MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS pgp.o pgpinvoke.o pgpkey.o pgplib.o gnupgparse.o pgpmicalg.o pgppacket.o crypt-mod-pgp-classic.o"
-fi
+AC_ARG_ENABLE(smime, AS_HELP_STRING([--disable-smime],[Disable SMIME support]), enable_smime=$enableval, enable_smime=yes)
+AS_IF([test x$enable_smime != "xno"], [
+       AC_DEFINE(CRYPT_BACKEND_CLASSIC_SMIME, 1, [Define if you want classic S/MIME support.])
+       MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS smime.o crypt-mod-smime-classic.o"
+       SMIMEAUX_TARGET="smime_keys"
+])
 
-AC_ARG_ENABLE(smime, AS_HELP_STRING([--disable-smime],[Disable SMIME support]),
-[	if test x$enableval = xno ; then
-		have_smime=no
-	fi
+AC_ARG_ENABLE(sidebar, AC_HELP_STRING([--enable-sidebar], [Enable Sidebar support]), enable_sidebar=$enableval, enable_sidebar=no)
+AS_IF([test x$enable_sidebar = "xyes"], [
+	   AC_DEFINE(USE_SIDEBAR, 1, [Define if you want support for the sidebar.])
+	   OPS="$OPS \$(srcdir)/OPS.SIDEBAR"
+	   MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS sidebar.o"
 ])
- 
-if test x$have_smime != xno ; then
-	AC_DEFINE(CRYPT_BACKEND_CLASSIC_SMIME, 1, [Define if you want classic S/MIME support.])
-	MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS smime.o crypt-mod-smime-classic.o"
-	SMIMEAUX_TARGET="smime_keys"
-fi
 
-AC_ARG_ENABLE(sidebar, AC_HELP_STRING([--enable-sidebar], [Enable Sidebar support]),
-[       if test x$enableval = xyes ; then
-		AC_DEFINE(USE_SIDEBAR, 1, [Define if you want support for the sidebar.])
-		OPS="$OPS \$(srcdir)/OPS.SIDEBAR"
-                MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS sidebar.o"
-        fi
+AC_ARG_ENABLE(compressed, AC_HELP_STRING([--enable-compressed], [Enable compressed folders support]),
+              enable_compressed=$enableval, enable_compressed=no
+)
+AS_IF([test x$enable_compressed = "xyes"], [
+	   AC_DEFINE(USE_COMPRESSED, 1, [Define to enable compressed folders support.])
+	   MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS compress.o"
+])
+AM_CONDITIONAL(BUILD_COMPRESS, test x$enable_compressed = xyes)
+
+dnl Clean up this code. Maybe also use pkg_config
+AC_ARG_ENABLE(notmuch, AC_HELP_STRING([--enable-notmuch], [Enable NOTMUCH support]), enable_notmuch=$enableval, enable_notmuch=no)
+AS_IF([test x$enable_notmuch = "xyes"], [
+		AC_CHECK_LIB(notmuch, notmuch_database_open,,
+			AC_MSG_ERROR([Unable to find Notmuch library]))
+		AC_DEFINE(USE_NOTMUCH,1,[ Define if you want support for the notmuch. ])
+		NOTMUCH_LIBS="-lnotmuch"
+		OPS="$OPS \$(srcdir)/OPS.NOTMUCH"
+		need_notmuch="yes"
+
+		AC_MSG_CHECKING([for notmuch api version 3])
+		AC_COMPILE_IFELSE( [AC_LANG_PROGRAM(
+					[[#include <notmuch.h>]],
+					[[notmuch_database_open("/path", NOTMUCH_DATABASE_MODE_READ_ONLY, (notmuch_database_t**)NULL);]]
+					)],
+		[notmuch_api_3=yes
+			AC_DEFINE([NOTMUCH_API_3], 1, [Define to 1 if you have the notmuch api version 3.])
+			],
+		[notmuch_api_3=no]
+		)
+		AC_MSG_RESULT([$notmuch_api_3])
 ])
+AM_CONDITIONAL(BUILD_NOTMUCH, test x$need_notmuch = xyes)
 
+
+dnl TODO: Clean this up. Needs some work understanding and fixing the AC_ARG_WITH
 AC_ARG_WITH(mixmaster, AS_HELP_STRING([--with-mixmaster@<:@=PATH@:>@],[Include Mixmaster support]),
   [if test "$withval" != no
    then
@@ -319,10 +343,11 @@ main ()
 AC_HEADER_STDC
 
 AC_CHECK_HEADERS(stdarg.h sys/ioctl.h ioctl.h sysexits.h)
-AC_CHECK_HEADERS(sys/time.h sys/resource.h)
+AC_CHECK_HEADERS(sys/time.h sys/resource.h sys/syscall.h)
 AC_CHECK_HEADERS(unix.h)
 
 AC_CHECK_FUNCS(setrlimit getsid)
+AC_CHECK_FUNCS(fgets_unlocked fgetc_unlocked)
 
 AC_MSG_CHECKING(for sig_atomic_t in signal.h)
 AC_EGREP_HEADER(sig_atomic_t,signal.h,
@@ -364,7 +389,7 @@ AC_CHECK_TYPE(ssize_t, int)
 
 AC_CHECK_FUNCS(fgetpos memmove setegid srand48 strerror)
 
-AC_REPLACE_FUNCS([setenv strcasecmp strdup strsep strtok_r wcscasecmp])
+AC_REPLACE_FUNCS([setenv strcasecmp strdup strndup strnlen strsep strtok_r wcscasecmp])
 AC_REPLACE_FUNCS([strcasestr mkdtemp])
 
 AC_CHECK_FUNC(getopt)
@@ -610,6 +635,15 @@ AC_ARG_ENABLE(imap, AS_HELP_STRING([--enable-imap],[Enable IMAP support]),
 ])
 AM_CONDITIONAL(BUILD_IMAP, test x$need_imap = xyes)
 
+AC_ARG_ENABLE(nntp, AC_HELP_STRING([--enable-nntp],[Enable NNTP support]),
+[	if test x$enableval = xyes ; then
+		AC_DEFINE(USE_NNTP,1,[ Define if you want support for the NNTP protocol. ])
+		MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS nntp.o newsrc.o"
+		need_nntp="yes"
+		need_socket="yes"
+	fi
+])
+
 AC_ARG_ENABLE(smtp, AS_HELP_STRING([--enable-smtp],[include internal SMTP relay support]),
 	[if test $enableval = yes; then
 		AC_DEFINE(USE_SMTP, 1, [Include internal SMTP relay support])
@@ -617,7 +651,7 @@ AC_ARG_ENABLE(smtp, AS_HELP_STRING([--enable-smtp],[include internal SMTP relay
 		need_socket="yes"
 	fi])
 
-if test x"$need_imap" = xyes -o x"$need_pop" = xyes ; then
+if test x"$need_imap" = xyes -o x"$need_pop" = xyes -o x"$need_nntp" = xyes ; then
   MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS bcache.o"
 fi
 
@@ -860,11 +894,13 @@ AC_ARG_ENABLE(exact-address, AS_HELP_STRING([--enable-exact-address],[Enable reg
 dnl -- start cache --
 db_found=no
 db_requested=auto
+hcache_db_used=no
 AC_ARG_ENABLE(hcache, AS_HELP_STRING([--enable-hcache],[Enable header caching]))
 AC_ARG_WITH(tokyocabinet, AS_HELP_STRING([--without-tokyocabinet],[Don't use tokyocabinet even if it is available]))
 AC_ARG_WITH(qdbm, AS_HELP_STRING([--without-qdbm],[Don't use qdbm even if it is available]))
 AC_ARG_WITH(gdbm, AS_HELP_STRING([--without-gdbm],[Don't use gdbm even if it is available]))
 AC_ARG_WITH(bdb, AS_HELP_STRING([--with-bdb@<:@=DIR@:>@],[Use BerkeleyDB4 if gdbm is not available]))
+AC_ARG_WITH(lmdb, AS_HELP_STRING([--with-lmdb@<:@=DIR@:>@],[Use LMDB if gdbm is not available]))
 
 db_found=no
 if test x$enable_hcache = xyes
@@ -880,7 +916,7 @@ then
 
     if test -n "$with_tokyocabinet" && test "$with_tokyocabinet" != "no"
     then
-      db_requested=tc
+      db_requested=TokyoCabinet
     fi
     if test -n "$with_qdbm" && test "$with_qdbm" != "no"
     then
@@ -888,7 +924,7 @@ then
       then
         AC_MSG_ERROR([more than one header cache engine requested.])
       else
-        db_requested=qdbm
+        db_requested=QDBM
       fi
     fi
     if test -n "$with_gdbm" && test "$with_gdbm" != "no"
@@ -897,7 +933,7 @@ then
       then
         AC_MSG_ERROR([more than one header cache engine requested.])
       else
-        db_requested=gdbm
+        db_requested=GDBM
       fi
     fi
     if test -n "$with_bdb" && test "$with_bdb" != "no"
@@ -906,13 +942,22 @@ then
       then
         AC_MSG_ERROR([more than one header cache engine requested.])
       else
-        db_requested=bdb
+        db_requested=BDB
+      fi
+    fi
+    if test -n "$with_lmdb" && test "$with_lmdb" != "no"
+    then
+      if test "$db_requested" != "auto"
+      then
+        AC_MSG_ERROR([more than one header cache engine requested.])
+      else
+        db_requested=LMDB
       fi
     fi
     
     dnl -- Tokyo Cabinet --
     if test "$with_tokyocabinet" != "no" \
-	    && test "$db_requested" = auto -o "$db_requested" = tc
+	    && test "$db_requested" = auto -o "$db_requested" = TokyoCabinet
     then
       if test -n "$with_tokyocabinet" && test "$with_tokyocabinet" != "yes"
       then
@@ -924,7 +969,7 @@ then
       AC_CHECK_LIB(tokyocabinet, tcbdbopen,
         [MUTTLIBS="$MUTTLIBS -ltokyocabinet"
          AC_DEFINE(HAVE_TC, 1, [Tokyo Cabinet Support])
-         db_found=tc],
+         db_found=TokyoCabinet],
         [CPPFLAGS="$OLDCPPFLAGS"
          LDFLAGS="$OLDLDFLAGS"]))
       if test "$db_requested" != auto && test "$db_found" != "$db_requested"
@@ -935,7 +980,7 @@ then
 
     dnl -- QDBM --
     if test "$with_qdbm" != "no" && test $db_found = no \
-	    && test "$db_requested" = auto -o "$db_requested" = qdbm
+	    && test "$db_requested" = auto -o "$db_requested" = QDBM
     then
       if test -n "$with_qdbm" && test "$with_qdbm" != "yes"
       then
@@ -956,7 +1001,7 @@ then
       AC_CHECK_LIB(qdbm, vlopen,
         [MUTTLIBS="$MUTTLIBS -lqdbm"
          AC_DEFINE(HAVE_QDBM, 1, [QDBM Support])
-         db_found=qdbm],
+         db_found=QDBM],
         [CPPFLAGS="$OLDCPPFLAGS"
          LDFLAGS="$OLDLDFLAGS"])
       LIBS="$saved_LIBS"
@@ -968,7 +1013,7 @@ then
 
     dnl -- GDBM --
     if test x$with_gdbm != xno && test $db_found = no \
-	    && test "$db_requested" = auto -o "$db_requested" = gdbm
+	    && test "$db_requested" = auto -o "$db_requested" = GDBM
     then
         if test "$with_gdbm" != "yes"
         then
@@ -986,7 +1031,7 @@ then
         then
           AC_DEFINE(HAVE_GDBM, 1, [GDBM Support])
           MUTTLIBS="$MUTTLIBS -lgdbm"
-          db_found=gdbm
+          db_found=GDBM
         fi
         if test "$db_requested" != auto && test "$db_found" != "$db_requested"
         then
@@ -996,7 +1041,8 @@ then
 
     dnl -- BDB --
     ac_bdb_prefix="$with_bdb"
-    if test x$ac_bdb_prefix != xno && test $db_found = no
+    if test x$with_bdb != xno && test $db_found = no \
+	    && test "$db_requested" = auto -o "$db_requested" = BDB
     then
         if test x$ac_bdb_prefix = xyes || test x$ac_bdb_prefix = x
         then
@@ -1046,17 +1092,46 @@ then
             CPPFLAGS="$OLDCPPFLAGS -I$BDB_INCLUDE_DIR"
             LIBS="$OLDLIBS -L$BDB_LIB_DIR -l$BDB_LIB"
             AC_DEFINE(HAVE_DB4, 1, [Berkeley DB4 Support])
-            db_found=bdb
+            db_found=BDB
         else
             AC_MSG_RESULT(no)
         fi
     fi
 
+    dnl -- LMDB --
+    if test x$with_lmdb != xno && test $db_found = no \
+	    && test "$db_requested" = auto -o "$db_requested" = LMDB
+    then
+        if test "$with_lmdb" != "yes"
+        then
+          CPPFLAGS="$CPPFLAGS -I$with_lmdb/include"
+          LDFLAGS="$LDFLAGS -L$with_lmdb/lib"
+        fi
+        saved_LIBS="$LIBS"
+        LIBS="$LIBS -llmdb"
+        AC_CACHE_CHECK(for mdb_env_create, ac_cv_mdbenvcreate,[
+            ac_cv_mdbenvcreate=no
+            AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <lmdb.h>]], [[mdb_env_create(0);]])],[ac_cv_mdbenvcreate=yes],[])
+        ])
+        LIBS="$saved_LIBS"
+        if test "$ac_cv_mdbenvcreate" = yes
+        then
+          AC_DEFINE(HAVE_LMDB, 1, [LMDB Support])
+          MUTTLIBS="$MUTTLIBS -llmdb"
+          db_found=LMDB
+        fi
+        if test "$db_requested" != auto && test "$db_found" != "$db_requested"
+        then
+          AC_MSG_ERROR([LMDB could not be used. Check config.log for details.])
+        fi
+    fi
+
     if test $db_found = no
     then
-        AC_MSG_ERROR([You need Tokyo Cabinet, QDBM, GDBM or Berkeley DB4 for hcache])
+        AC_MSG_ERROR([You need Tokyo Cabinet, QDBM, GDBM, Berkeley DB4 or LMDB for hcache])
     fi
 fi
+hcache_db_used=$db_found
 dnl -- end cache --
 
 AM_CONDITIONAL(BUILD_HCACHE, test x$db_found != xno)
@@ -1075,6 +1150,7 @@ AC_SUBST(MUTTLIBS)
 AC_SUBST(MUTT_LIB_OBJECTS)
 AC_SUBST(LIBIMAP)
 AC_SUBST(LIBIMAPDEPS)
+AC_SUBST(NOTMUCH_LIBS)
 
 dnl -- iconv/gettext --
 
@@ -1318,6 +1394,13 @@ if test $mutt_cv_langinfo_yesexpr = yes; then
   AC_DEFINE(HAVE_LANGINFO_YESEXPR,1,[ Define if you have <langinfo.h> and nl_langinfo(YESEXPR). ])
 fi
 
+AC_CHECK_FUNCS(fmemopen open_memstream, [
+	AC_ARG_ENABLE(fmemopen, AS_HELP_STRING([--disable-fmemopen],[Do NOT use fmemopen]),
+	[],
+	# Temporarily disable fmemopen, due to a bug
+	[AC_DEFINE(USE_FMEMOPEN, 0, [Use fmemopen])])
+])
+
 dnl Documentation tools
 have_openjade="no"
 AC_PATH_PROG([OSPCAT], [ospcat], [none])
@@ -1353,5 +1436,24 @@ fi
 
 AC_CONFIG_FILES(Makefile contrib/Makefile doc/Makefile imap/Makefile
         intl/Makefile m4/Makefile po/Makefile.in
-        hcachever.sh muttbug.sh doc/instdoc.sh)
+        hcachever.sh doc/instdoc.sh)
 AC_OUTPUT
+
+AC_MSG_NOTICE([Summary of build options:
+
+  Version:           ${PACKAGE_VERSION}
+  Host OS:           ${host_os}
+  Install prefix:    ${prefix}
+  Compiler:          ${CC}
+  CFlags:            ${CFLAGS} ${CPPFLAGS}
+  LDFlags:           ${LDFLAGS}
+  Libs:              ${LIBS}
+
+  GPGME:             $enable_gpgme
+  PGP:               $enable_pgp
+  SMIME:             $enable_smime
+  Sidebar:           $enable_sidebar
+  Notmuch:           $enable_notmuch
+  Compressed Folder: $enable_compressed
+  Header Cache:      $hcache_db_used
+])
diff --git a/contrib/Makefile.am b/contrib/Makefile.am
index 4abd2c7..1891134 100644
--- a/contrib/Makefile.am
+++ b/contrib/Makefile.am
@@ -11,21 +11,40 @@ EXTRA_DIST = language.txt language50.txt  \
 	patch.slang-1.2.2.keypad.1	\
 	$(SAMPLES) \
 	iconv/README \
-	iconv/make.sh
+	iconv/make.sh \
+	vim-keybindings \
+	keybase
+
+CONTRIB_DIRS = vim-keybindings keybase
 
 install-data-local:
-	$(MKDIR_P) $(DESTDIR)$(docdir)/samples $(DESTDIR)$(docdir)/samples/iconv
+	$(INSTALL) -d -m 755 $(DESTDIR)$(docdir)/samples $(DESTDIR)$(docdir)/samples/iconv
 	for f in $(SAMPLES) ; do \
 		$(INSTALL) -m 644 $(srcdir)/$$f $(DESTDIR)$(docdir)/samples ;	\
 	done
 	for f in $(srcdir)/iconv/*.rc ; do					\
 		$(INSTALL) -m 644 $$f $(DESTDIR)$(docdir)/samples/iconv	  ;	\
 	done
+	$(INSTALL) -d -m 755 $(DESTDIR)$(docdir)/keybase $(DESTDIR)$(docdir)/keybase/images
+	for f in $(srcdir)/keybase/images/*.png ; do				\
+		$(INSTALL) -m 644 $$f $(DESTDIR)$(docdir)/keybase/images  ;	\
+	done
+	for d in $(CONTRIB_DIRS); do						\
+		echo "Installing $$d" ;	\
+		$(INSTALL) -d -m 755 $(DESTDIR)$(docdir)/$$d ;\
+		for f in $(srcdir)/$$d/*; do	\
+			echo "Installing $$f" ;	\
+			$(INSTALL) -m 644 $$f $(DESTDIR)$(docdir)/$$d ; \
+		done \
+	done
 
 uninstall-local:
 	for f in $(SAMPLES) ; do \
 		rm -f $(DESTDIR)$(docdir)/samples/$$f ; \
 	done
+	for d in $(CONTRIB_DIRS); do						\
+		rm -fr $(DESTDIR)$(docdir)/$$d;	                		\
+	done
 	-rm -rf $(DESTDIR)$(docdir)/samples/iconv
 	-rmdir $(DESTDIR)$(docdir)/samples
 	-rmdir $(DESTDIR)$(docdir)
diff --git a/contrib/keybase/KeybaseAndMutt.md b/contrib/keybase/KeybaseAndMutt.md
new file mode 100644
index 0000000..f23df9b
--- /dev/null
+++ b/contrib/keybase/KeybaseAndMutt.md
@@ -0,0 +1,39 @@
+To use Keybase in Mutt, the first thing that must be done (before even the macro) is setting your editor. This is important because we can replace the editor with any command we could think of. Mine looks like this.
+
+`set editor = 'echo %s > ~/.mutt/keybaseMutt/.tmp; vim %s'`
+
+It is crucially important, without this line nothing will work.
+
+What is really happening in that line is this. The echo command is echoing the contents of %s into a file. Typically, an editor will use %s to open the temporary file to let you create an email. We've just used it to work with a python script later on.
+
+Next, set a macro in the .muttrc
+
+`macro compose K "<enter-command>unset wait_key<enter><shell-escape>python ~/.mutt/keybaseMutt/keybase.py<enter><enter-command>set wait_key<enter>`
+
+You will need to place the python script in your ~/.mutt/keybaseMutt directory, creating it if it doesn't exist. If you wish to place the script elsewhere, change the macro to point to the script.
+
+The python script will take certain Keybase commands and run them. (Right now it will only let you encrypt or sign a message.)
+
+The output of the script will be written directly into the email. (Thank the devs for using /tmp/mutt* files.) As you may have guessed, the you will only be able to send inline encrypted messages. No MIME attachments.
+
+Creating encrypted email is now quite easy. All you need to do is press "K" and type something to the effect of `keybase encrypt [user]` or `keybase pgp encrypt [user]`.
+
+The script will direct all output into the temporary file and replace your message with an encrypted version.
+
+Signing is done the same way.
+
+Decryption and verification is a bit more tricky. Unfortunately, mutt doesn't use /tmp/mutt* files for emails that you receive, and I don't understand mutt well enough to find the email on the drive.
+
+To work around that, I've created several scripts to decrypt or verify messages. While you are reading an email that's been encrypted, use the pipe command in mutt ("|").
+
+You will be able to pipe the contents of the email into one of the scripts to decrypt or verify the message.
+
+How you do that is up to you, if you want to feed it the explicit location of the script, that will work fine. (Something like this `/home/[user]/path/to/script.sh`.)
+
+Or, if you know how to create paths (or if you put it in the `/bin` directory), you only need to feed it the name of the script (`script.sh`). Look it up if you don't know how. Its fun!
+
+There will be four separate scripts: verify.sh, decrypt.sh, pgpverify.sh, pgpdecrypt.sh
+
+Unfortunately, I wasn't able to find a way to condense them into one script. (Mainly because I'm a little short on time. That may change later.)
+
+Each script should be decently self-explanatory. The verify and decrypt scripts will work on keybase messages, while the pgpverify and pgpdecrypt scripts will work on keybase pgp messages.
diff --git a/contrib/keybase/LICENSE b/contrib/keybase/LICENSE
new file mode 100644
index 0000000..cf1ab25
--- /dev/null
+++ b/contrib/keybase/LICENSE
@@ -0,0 +1,24 @@
+This is free and unencumbered software released into the public domain.
+
+Anyone is free to copy, modify, publish, use, compile, sell, or
+distribute this software, either in source code form or as a compiled
+binary, for any purpose, commercial or non-commercial, and by any
+means.
+
+In jurisdictions that recognize copyright laws, the author or authors
+of this software dedicate any and all copyright interest in the
+software to the public domain. We make this dedication for the benefit
+of the public at large and to the detriment of our heirs and
+successors. We intend this dedication to be an overt act of
+relinquishment in perpetuity of all present and future rights to this
+software under copyright law.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+For more information, please refer to <http://unlicense.org>
diff --git a/contrib/keybase/README.md b/contrib/keybase/README.md
new file mode 100644
index 0000000..60f301b
--- /dev/null
+++ b/contrib/keybase/README.md
@@ -0,0 +1,45 @@
+# KeybaseMutt
+
+A work in progress. KeybaseMutt exists to let its users utilize Keybase within mutt. (Unfortunately, not natively (yet).)
+
+## Quick start
+
+Run the install script. It will set up the directory's and paths for you. Do what it says or suffer the consequences!
+
+Then just throw these into your .muttrc
+
+`set editor = 'echo %s > ~/.mutt/keybaseMutt/.tmp; vim %s'`
+
+`macro compose K "<enter-command>unset wait_key<enter><shell-escape>python ~/.mutt/keybaseMutt/keybase.py<enter><enter-command>set wait_key<enter>`
+
+Done!
+
+## How to use KeybaseMutt
+
+Write an email. In the screen right before you send your email (called the pager mode), press "K".
+
+![](images/pagerMode.png)
+(Press 'K' when you're here)
+
+You can now use four Keybase commands in this "shell". (I thought it best to limit the user to four commands for security reasons. Running unusual commands would overwrite the email, forcing the user to rewrite the email again.)
+
+The commands are:
+- `keybase encrypt [user]`
+- `keybase pgp encrypt [user]`
+- `keybase sign`
+- `keybase pgp sign`
+
+
+## Decrypting and verifying messages
+
+Unfortunately, there isn't an easy way to decrypt or verify messages through a macro. Instead, you'll need to use the pipe feature of mutt.
+
+Opening the email, you'll need to navigate to the actual attachment. (Press "V" when you're reading the email.)
+
+![](images/attachmentView.png)
+
+Then pipe ("|") it through the one of the scripts. (like "pgpverify.sh" or "decrypt.sh")
+
+Please note, using an attachment is very important when decrypting emails that include html. The scripts are unable to seperate html and text.
+
+Make sure that the attachment is "text/plain" rather than "text/html".
diff --git a/contrib/keybase/decrypt.sh b/contrib/keybase/decrypt.sh
new file mode 100755
index 0000000..73d37b2
--- /dev/null
+++ b/contrib/keybase/decrypt.sh
@@ -0,0 +1,2 @@
+#!/bin/sh
+sed -n 's/^.*BEGIN KEYBASE/BEGIN KEYBASE/p' | keybase decrypt
diff --git a/contrib/keybase/images/attachmentView.png b/contrib/keybase/images/attachmentView.png
new file mode 100644
index 0000000..5caf908
--- /dev/null
+++ b/contrib/keybase/images/attachmentView.png
@@ -0,0 +1,957 @@
+Image: /tmp/wi5Fnv_attachmentView.png
+  Format: PNG (Portable Network Graphics)
+  Mime type: image/png
+  Class: DirectClass
+  Geometry: 1920x1080+0+0
+  Resolution: 28.35x28.35
+  Print size: 67.7249x38.0952
+  Units: PixelsPerCentimeter
+  Type: TrueColorAlpha
+  Endianess: Undefined
+  Colorspace: sRGB
+  Depth: 8-bit
+  Channel depth:
+    red: 8-bit
+    green: 8-bit
+    blue: 8-bit
+    alpha: 1-bit
+  Channel statistics:
+    Pixels: 2073600
+    Red:
+      min: 0 (0)
+      max: 252 (0.988235)
+      mean: 9.94406 (0.0389963)
+      standard deviation: 43.0652 (0.168883)
+      kurtosis: 21.4793
+      skewness: 4.76177
+      entropy: 0.0967944
+    Green:
+      min: 0 (0)
+      max: 233 (0.913725)
+      mean: 13.8239 (0.0542114)
+      standard deviation: 48.5369 (0.190341)
+      kurtosis: 12.3828
+      skewness: 3.64861
+      entropy: 0.0989181
+    Blue:
+      min: 0 (0)
+      max: 231 (0.905882)
+      mean: 15.7559 (0.0617879)
+      standard deviation: 52.8322 (0.207185)
+      kurtosis: 8.97564
+      skewness: 3.2382
+      entropy: 0.105655
+    Alpha:
+      min: 255 (1)
+      max: 255 (1)
+      mean: 255 (1)
+      standard deviation: 0 (0)
+      kurtosis: 0
+      skewness: 0
+      entropy: 0
+  Image statistics:
+    Overall:
+      min: 0 (0)
+      max: 252 (0.988235)
+      mean: 9.88097 (0.0387489)
+      standard deviation: 41.838 (0.164071)
+      kurtosis: 19.9752
+      skewness: 4.61451
+      entropy: 0.0753419
+  Colors: 852
+  Histogram:
+   1861266: (  0,  0,  0,255) #000000FF black
+         2: (  0,  0,  1,255) #000001FF srgba(0,0,1,1)
+        57: (  0,  1,  1,255) #000101FF srgba(0,1,1,1)
+        12: (  0,  1,  2,255) #000102FF srgba(0,1,2,1)
+         1: (  0,  1,  3,255) #000103FF srgba(0,1,3,1)
+        59: (  0,  2,  2,255) #000202FF srgba(0,2,2,1)
+        20: (  0,  3,  3,255) #000303FF srgba(0,3,3,1)
+        63: (  0,  4,  4,255) #000404FF srgba(0,4,4,1)
+        50: (  0,  5,  5,255) #000505FF srgba(0,5,5,1)
+        26: (  0,  6,  6,255) #000606FF srgba(0,6,6,1)
+        31: (  0,  7,  7,255) #000707FF srgba(0,7,7,1)
+        24: (  0,  8,  8,255) #000808FF srgba(0,8,8,1)
+        12: (  0,  9,  9,255) #000909FF srgba(0,9,9,1)
+        27: (  0, 10, 10,255) #000A0AFF srgba(0,10,10,1)
+        25: (  0, 11, 11,255) #000B0BFF srgba(0,11,11,1)
+        11: (  0, 12, 12,255) #000C0CFF srgba(0,12,12,1)
+         9: (  0, 13, 13,255) #000D0DFF srgba(0,13,13,1)
+         3: (  0,129,131,255) #008183FF srgba(0,129,131,1)
+         1: (  0,136,138,255) #00888AFF srgba(0,136,138,1)
+         3: (  0,137,139,255) #00898BFF srgba(0,137,139,1)
+         1: (  0,143,145,255) #008F91FF srgba(0,143,145,1)
+         4: (  0,145,147,255) #009193FF srgba(0,145,147,1)
+         1: (  1,  0,  2,255) #010002FF srgba(1,0,2,1)
+         1: (  1,  1,  0,255) #010100FF srgba(1,1,0,1)
+        98: (  1,  1,  1,255) #010101FF srgba(1,1,1,1)
+       238: (  1,  1,  2,255) #010102FF srgba(1,1,2,1)
+         5: (  1,  1,  3,255) #010103FF srgba(1,1,3,1)
+         1: (  1,  2,  1,255) #010201FF srgba(1,2,1,1)
+       222: (  1,  2,  2,255) #010202FF srgba(1,2,2,1)
+       101: (  1,  2,  3,255) #010203FF srgba(1,2,3,1)
+         9: (  1,  2,  4,255) #010204FF srgba(1,2,4,1)
+         2: (  1,  3,  3,255) #010303FF srgba(1,3,3,1)
+         4: (  1,  3,  4,255) #010304FF srgba(1,3,4,1)
+         1: (  1,  3,  5,255) #010305FF srgba(1,3,5,1)
+         4: (  1, 13, 13,255) #010D0DFF srgba(1,13,13,1)
+        15: (  1, 14, 14,255) #010E0EFF srgba(1,14,14,1)
+         7: (  1, 15, 15,255) #010F0FFF srgba(1,15,15,1)
+        11: (  1, 15, 16,255) #010F10FF srgba(1,15,16,1)
+        12: (  1, 16, 16,255) #011010FF srgba(1,16,16,1)
+         3: (  1, 17, 17,255) #011111FF srgba(1,17,17,1)
+         5: (  1, 17, 18,255) #011112FF srgba(1,17,18,1)
+         6: (  1, 18, 18,255) #011212FF srgba(1,18,18,1)
+         2: (  1, 18, 19,255) #011213FF srgba(1,18,19,1)
+        14: (  1, 19, 19,255) #011313FF srgba(1,19,19,1)
+         4: (  1, 20, 20,255) #011414FF srgba(1,20,20,1)
+        10: (  1, 20, 21,255) #011415FF srgba(1,20,21,1)
+        34: (  1, 21, 21,255) #011515FF srgba(1,21,21,1)
+         7: (  1, 21, 22,255) #011516FF srgba(1,21,22,1)
+        10: (  1, 22, 22,255) #011616FF srgba(1,22,22,1)
+         7: (  1, 23, 23,255) #011717FF srgba(1,23,23,1)
+        37: (  1, 23, 24,255) #011718FF srgba(1,23,24,1)
+         6: (  1, 24, 24,255) #011818FF srgba(1,24,24,1)
+        12: (  1, 24, 25,255) #011819FF srgba(1,24,25,1)
+         6: (  1, 25, 25,255) #011919FF srgba(1,25,25,1)
+        15: (  1, 26, 26,255) #011A1AFF srgba(1,26,26,1)
+         8: (  1, 26, 27,255) #011A1BFF srgba(1,26,27,1)
+        19: (  1, 27, 27,255) #011B1BFF srgba(1,27,27,1)
+         8: (  1, 27, 28,255) #011B1CFF srgba(1,27,28,1)
+         7: (  1, 28, 28,255) #011C1CFF srgba(1,28,28,1)
+         7: (  1, 29, 29,255) #011D1DFF srgba(1,29,29,1)
+         3: (  1, 29, 30,255) #011D1EFF srgba(1,29,30,1)
+         6: (  1, 30, 30,255) #011E1EFF srgba(1,30,30,1)
+        13: (  1, 30, 31,255) #011E1FFF srgba(1,30,31,1)
+         6: (  1, 31, 31,255) #011F1FFF srgba(1,31,31,1)
+         9: (  1, 32, 32,255) #012020FF srgba(1,32,32,1)
+        15: (  1, 32, 33,255) #012021FF srgba(1,32,33,1)
+        57: (  1, 33, 33,255) #012121FF srgba(1,33,33,1)
+         9: (  1, 33, 34,255) #012122FF srgba(1,33,34,1)
+         2: (  1, 34, 34,255) #012222FF srgba(1,34,34,1)
+         4: (  1, 35, 35,255) #012323FF srgba(1,35,35,1)
+        22: (  1, 35, 36,255) #012324FF srgba(1,35,36,1)
+         9: (  1, 36, 36,255) #012424FF srgba(1,36,36,1)
+        21: (  1, 36, 37,255) #012425FF srgba(1,36,37,1)
+         2: (  1, 37, 37,255) #012525FF srgba(1,37,37,1)
+        41: (  1, 38, 38,255) #012626FF srgba(1,38,38,1)
+         1: (  2,  1,  2,255) #020102FF srgba(2,1,2,1)
+         1: (  2,  2,  1,255) #020201FF srgba(2,2,1,1)
+       193: (  2,  2,  2,255) #020202FF srgba(2,2,2,1)
+       434: (  2,  2,  3,255) #020203FF srgba(2,2,3,1)
+        75: (  2,  2,  4,255) #020204FF srgba(2,2,4,1)
+       278: (  2,  3,  3,255) #020303FF srgba(2,3,3,1)
+      1301: (  2,  3,  4,255) #020304FF srgba(2,3,4,1)
+       205: (  2,  3,  5,255) #020305FF srgba(2,3,5,1)
+        17: (  2,  4,  4,255) #020404FF srgba(2,4,4,1)
+        98: (  2,  4,  5,255) #020405FF srgba(2,4,5,1)
+        12: (  2,  4,  6,255) #020406FF srgba(2,4,6,1)
+         1: (  2,  4,  7,255) #020407FF srgba(2,4,7,1)
+         1: (  2,  4,  8,255) #020408FF srgba(2,4,8,1)
+         1: (  2,  4, 11,255) #02040BFF srgba(2,4,11,1)
+         6: (  2,  5,  8,255) #020508FF srgba(2,5,8,1)
+         1: (  2,  5, 12,255) #02050CFF srgba(2,5,12,1)
+         2: (  2,  6,  9,255) #020609FF srgba(2,6,9,1)
+         1: (  2,  7, 12,255) #02070CFF srgba(2,7,12,1)
+         1: (  2, 15, 14,255) #020F0EFF srgba(2,15,14,1)
+         7: (  2, 39, 39,255) #022727FF srgba(2,39,39,1)
+         8: (  2, 39, 40,255) #022728FF srgba(2,39,40,1)
+        31: (  2, 40, 40,255) #022828FF srgba(2,40,40,1)
+         6: (  2, 41, 41,255) #022929FF srgba(2,41,41,1)
+         2: (  2, 41, 42,255) #02292AFF srgba(2,41,42,1)
+         1: (  2, 42, 42,255) #022A2AFF srgba(2,42,42,1)
+        16: (  2, 42, 43,255) #022A2BFF srgba(2,42,43,1)
+         6: (  2, 43, 43,255) #022B2BFF srgba(2,43,43,1)
+         9: (  2, 44, 44,255) #022C2CFF srgba(2,44,44,1)
+         7: (  2, 44, 45,255) #022C2DFF srgba(2,44,45,1)
+        74: (  2, 45, 45,255) #022D2DFF srgba(2,45,45,1)
+        15: (  2, 45, 46,255) #022D2EFF srgba(2,45,46,1)
+        13: (  2, 46, 47,255) #022E2FFF srgba(2,46,47,1)
+        13: (  2, 47, 48,255) #022F30FF srgba(2,47,48,1)
+         8: (  2, 48, 48,255) #023030FF srgba(2,48,48,1)
+        10: (  2, 48, 49,255) #023031FF srgba(2,48,49,1)
+        24: (  2, 49, 50,255) #023132FF srgba(2,49,50,1)
+        11: (  2, 50, 51,255) #023233FF srgba(2,50,51,1)
+        12: (  2, 51, 51,255) #023333FF srgba(2,51,51,1)
+         5: (  2, 51, 52,255) #023334FF srgba(2,51,52,1)
+        49: (  2, 52, 53,255) #023435FF srgba(2,52,53,1)
+        10: (  2, 53, 54,255) #023536FF srgba(2,53,54,1)
+         4: (  2, 54, 54,255) #023636FF srgba(2,54,54,1)
+        30: (  2, 54, 55,255) #023637FF srgba(2,54,55,1)
+         5: (  2, 55, 56,255) #023738FF srgba(2,55,56,1)
+         3: (  2, 56, 57,255) #023839FF srgba(2,56,57,1)
+        18: (  2, 57, 57,255) #023939FF srgba(2,57,57,1)
+        17: (  2, 57, 58,255) #02393AFF srgba(2,57,58,1)
+        26: (  2, 58, 59,255) #023A3BFF srgba(2,58,59,1)
+        70: (  2, 59, 60,255) #023B3CFF srgba(2,59,60,1)
+         6: (  2, 60, 61,255) #023C3DFF srgba(2,60,61,1)
+        42: (  2, 61, 62,255) #023D3EFF srgba(2,61,62,1)
+         3: (  2, 62, 63,255) #023E3FFF srgba(2,62,63,1)
+         5: (  2, 63, 63,255) #023F3FFF srgba(2,63,63,1)
+         7: (  2, 63, 64,255) #023F40FF srgba(2,63,64,1)
+         1: (  3,  3,  2,255) #030302FF srgba(3,3,2,1)
+        13: (  3,  3,  3,255) #030303FF grey1
+       365: (  3,  3,  4,255) #030304FF srgba(3,3,4,1)
+       152: (  3,  3,  5,255) #030305FF srgba(3,3,5,1)
+        14: (  3,  3,  6,255) #030306FF srgba(3,3,6,1)
+       254: (  3,  4,  4,255) #030404FF srgba(3,4,4,1)
+      2342: (  3,  4,  5,255) #030405FF srgba(3,4,5,1)
+      1371: (  3,  4,  6,255) #030406FF srgba(3,4,6,1)
+        16: (  3,  4,  7,255) #030407FF srgba(3,4,7,1)
+         1: (  3,  4, 10,255) #03040AFF srgba(3,4,10,1)
+        16: (  3,  5,  5,255) #030505FF srgba(3,5,5,1)
+       351: (  3,  5,  6,255) #030506FF srgba(3,5,6,1)
+       104: (  3,  5,  7,255) #030507FF srgba(3,5,7,1)
+         4: (  3,  5,  8,255) #030508FF srgba(3,5,8,1)
+         1: (  3,  5,  9,255) #030509FF srgba(3,5,9,1)
+         1: (  3,  6,  7,255) #030607FF srgba(3,6,7,1)
+         1: (  3,  6,  8,255) #030608FF srgba(3,6,8,1)
+         6: (  3,  6,  9,255) #030609FF srgba(3,6,9,1)
+         2: (  3,  6, 10,255) #03060AFF srgba(3,6,10,1)
+         6: (  3,  7, 11,255) #03070BFF srgba(3,7,11,1)
+         1: (  3,  7, 12,255) #03070CFF srgba(3,7,12,1)
+         1: (  3,  8, 12,255) #03080CFF srgba(3,8,12,1)
+         2: (  3,  8, 13,255) #03080DFF srgba(3,8,13,1)
+         1: (  3,  9, 14,255) #03090EFF srgba(3,9,14,1)
+         3: (  3,  9, 15,255) #03090FFF srgba(3,9,15,1)
+         1: (  3,  9, 16,255) #030910FF srgba(3,9,16,1)
+         1: (  3, 10, 17,255) #030A11FF srgba(3,10,17,1)
+         1: (  3, 11, 18,255) #030B12FF srgba(3,11,18,1)
+         4: (  3, 11, 19,255) #030B13FF srgba(3,11,19,1)
+         2: (  3, 11, 20,255) #030B14FF srgba(3,11,20,1)
+         4: (  3, 12, 20,255) #030C14FF srgba(3,12,20,1)
+         8: (  3, 12, 21,255) #030C15FF srgba(3,12,21,1)
+         1: (  3, 13, 22,255) #030D16FF srgba(3,13,22,1)
+         6: (  3, 13, 23,255) #030D17FF srgba(3,13,23,1)
+         9: (  3, 13, 24,255) #030D18FF srgba(3,13,24,1)
+        11: (  3, 14, 24,255) #030E18FF srgba(3,14,24,1)
+        98: (  3, 64, 65,255) #034041FF srgba(3,64,65,1)
+         3: (  3, 65, 66,255) #034142FF srgba(3,65,66,1)
+         3: (  3, 66, 66,255) #034242FF srgba(3,66,66,1)
+        22: (  3, 66, 67,255) #034243FF srgba(3,66,67,1)
+         6: (  3, 67, 68,255) #034344FF srgba(3,67,68,1)
+         7: (  3, 68, 69,255) #034445FF srgba(3,68,69,1)
+        10: (  3, 69, 69,255) #034545FF srgba(3,69,69,1)
+         3: (  3, 69, 70,255) #034546FF srgba(3,69,70,1)
+        12: (  3, 70, 71,255) #034647FF srgba(3,70,71,1)
+         7: (  3, 71, 72,255) #034748FF srgba(3,71,72,1)
+         8: (  3, 72, 72,255) #034848FF srgba(3,72,72,1)
+         5: (  3, 72, 73,255) #034849FF srgba(3,72,73,1)
+        19: (  3, 73, 74,255) #03494AFF srgba(3,73,74,1)
+         2: (  3, 74, 75,255) #034A4BFF srgba(3,74,75,1)
+         5: (  3, 75, 75,255) #034B4BFF srgba(3,75,75,1)
+         2: (  3, 75, 76,255) #034B4CFF srgba(3,75,76,1)
+        57: (  3, 76, 77,255) #034C4DFF srgba(3,76,77,1)
+         6: (  3, 77, 78,255) #034D4EFF srgba(3,77,78,1)
+        13: (  3, 77, 79,255) #034D4FFF srgba(3,77,79,1)
+        18: (  3, 78, 79,255) #034E4FFF srgba(3,78,79,1)
+        11: (  3, 79, 80,255) #034F50FF srgba(3,79,80,1)
+         3: (  3, 80, 81,255) #035051FF srgba(3,80,81,1)
+        12: (  3, 80, 82,255) #035052FF srgba(3,80,82,1)
+        12: (  3, 81, 82,255) #035152FF srgba(3,81,82,1)
+        13: (  3, 82, 83,255) #035253FF srgba(3,82,83,1)
+         9: (  3, 83, 84,255) #035354FF srgba(3,83,84,1)
+        11: (  3, 83, 85,255) #035355FF srgba(3,83,85,1)
+         1: (  3, 84, 85,255) #035455FF srgba(3,84,85,1)
+        13: (  3, 85, 86,255) #035556FF srgba(3,85,86,1)
+         1: (  3, 86, 87,255) #035657FF srgba(3,86,87,1)
+        10: (  3, 86, 88,255) #035658FF srgba(3,86,88,1)
+         8: (  3, 87, 88,255) #035758FF srgba(3,87,88,1)
+        16: (  3, 88, 89,255) #035859FF srgba(3,88,89,1)
+         1: (  4,  3,  2,255) #040302FF srgba(4,3,2,1)
+         3: (  4,  4,  4,255) #040404FF srgba(4,4,4,1)
+       190: (  4,  4,  5,255) #040405FF srgba(4,4,5,1)
+       394: (  4,  4,  6,255) #040406FF srgba(4,4,6,1)
+        19: (  4,  4,  7,255) #040407FF srgba(4,4,7,1)
+         1: (  4,  5,  4,255) #040504FF srgba(4,5,4,1)
+        46: (  4,  5,  5,255) #040505FF srgba(4,5,5,1)
+      2302: (  4,  5,  6,255) #040506FF srgba(4,5,6,1)
+      1828: (  4,  5,  7,255) #040507FF srgba(4,5,7,1)
+        68: (  4,  5,  8,255) #040508FF srgba(4,5,8,1)
+        14: (  4,  6,  6,255) #040606FF srgba(4,6,6,1)
+       938: (  4,  6,  7,255) #040607FF srgba(4,6,7,1)
+       886: (  4,  6,  8,255) #040608FF srgba(4,6,8,1)
+        25: (  4,  6,  9,255) #040609FF srgba(4,6,9,1)
+         1: (  4,  6, 10,255) #04060AFF srgba(4,6,10,1)
+        11: (  4,  7,  8,255) #040708FF srgba(4,7,8,1)
+         8: (  4,  7,  9,255) #040709FF srgba(4,7,9,1)
+         1: (  4,  7, 13,255) #04070DFF srgba(4,7,13,1)
+         1: (  4,  8,  9,255) #040809FF srgba(4,8,9,1)
+         1: (  4,  8, 11,255) #04080BFF srgba(4,8,11,1)
+         1: (  4, 15, 14,255) #040F0EFF srgba(4,15,14,1)
+         1: (  4, 15, 15,255) #040F0FFF srgba(4,15,15,1)
+         7: (  4, 89, 90,255) #04595AFF srgba(4,89,90,1)
+        14: (  4, 89, 91,255) #04595BFF srgba(4,89,91,1)
+         1: (  4, 90, 91,255) #045A5BFF srgba(4,90,91,1)
+        11: (  4, 91, 92,255) #045B5CFF srgba(4,91,92,1)
+         8: (  4, 92, 93,255) #045C5DFF srgba(4,92,93,1)
+        10: (  4, 92, 94,255) #045C5EFF srgba(4,92,94,1)
+         5: (  4, 93, 94,255) #045D5EFF srgba(4,93,94,1)
+        13: (  4, 94, 95,255) #045E5FFF srgba(4,94,95,1)
+        16: (  4, 95, 96,255) #045F60FF srgba(4,95,96,1)
+        12: (  4, 95, 97,255) #045F61FF srgba(4,95,97,1)
+         4: (  4, 96, 97,255) #046061FF srgba(4,96,97,1)
+        10: (  4, 97, 98,255) #046162FF srgba(4,97,98,1)
+         3: (  4, 98,100,255) #046264FF srgba(4,98,100,1)
+         8: (  4, 99,100,255) #046364FF srgba(4,99,100,1)
+        20: (  4,100,101,255) #046465FF srgba(4,100,101,1)
+         9: (  4,101,102,255) #046566FF srgba(4,101,102,1)
+        13: (  4,101,103,255) #046567FF srgba(4,101,103,1)
+        85: (  4,102,103,255) #046667FF srgba(4,102,103,1)
+        21: (  4,103,104,255) #046768FF srgba(4,103,104,1)
+         6: (  4,104,105,255) #046869FF srgba(4,104,105,1)
+         5: (  4,104,106,255) #04686AFF srgba(4,104,106,1)
+         9: (  4,105,106,255) #04696AFF srgba(4,105,106,1)
+        30: (  4,106,107,255) #046A6BFF srgba(4,106,107,1)
+        12: (  4,107,108,255) #046B6CFF srgba(4,107,108,1)
+         7: (  4,107,109,255) #046B6DFF srgba(4,107,109,1)
+         3: (  4,108,109,255) #046C6DFF srgba(4,108,109,1)
+         4: (  4,108,110,255) #046C6EFF srgba(4,108,110,1)
+         3: (  4,109,111,255) #046D6FFF srgba(4,109,111,1)
+         5: (  4,110,111,255) #046E6FFF srgba(4,110,111,1)
+        11: (  4,110,112,255) #046E70FF srgba(4,110,112,1)
+        12: (  4,111,112,255) #046F70FF srgba(4,111,112,1)
+         2: (  4,111,113,255) #046F71FF srgba(4,111,113,1)
+         3: (  4,112,114,255) #047072FF srgba(4,112,114,1)
+         8: (  4,113,114,255) #047172FF srgba(4,113,114,1)
+        13: (  4,113,115,255) #047173FF srgba(4,113,115,1)
+        40: (  4,114,115,255) #047273FF srgba(4,114,115,1)
+         1: (  4,136,137,255) #048889FF srgba(4,136,137,1)
+         3: (  4,137,139,255) #04898BFF srgba(4,137,139,1)
+         1: (  4,138,139,255) #048A8BFF srgba(4,138,139,1)
+         2: (  4,138,140,255) #048A8CFF srgba(4,138,140,1)
+         1: (  4,140,141,255) #048C8DFF srgba(4,140,141,1)
+         1: (  4,142,144,255) #048E90FF srgba(4,142,144,1)
+         1: (  4,145,147,255) #049193FF srgba(4,145,147,1)
+         1: (  4,146,148,255) #049294FF srgba(4,146,148,1)
+         1: (  4,147,149,255) #049395FF srgba(4,147,149,1)
+         1: (  4,148,150,255) #049496FF srgba(4,148,150,1)
+         4: (  4,149,151,255) #049597FF srgba(4,149,151,1)
+         1: (  5,  4, 12,255) #05040CFF srgba(5,4,12,1)
+         1: (  5,  5,  4,255) #050504FF srgba(5,5,4,1)
+        15: (  5,  5,  5,255) #050505FF grey2
+        32: (  5,  5,  6,255) #050506FF srgba(5,5,6,1)
+        48: (  5,  5,  7,255) #050507FF srgba(5,5,7,1)
+         9: (  5,  5,  8,255) #050508FF srgba(5,5,8,1)
+         1: (  5,  5,  9,255) #050509FF srgba(5,5,9,1)
+         1: (  5,  6,  5,255) #050605FF srgba(5,6,5,1)
+        17: (  5,  6,  6,255) #050606FF srgba(5,6,6,1)
+       974: (  5,  6,  7,255) #050607FF srgba(5,6,7,1)
+      2398: (  5,  6,  8,255) #050608FF srgba(5,6,8,1)
+       220: (  5,  6,  9,255) #050609FF srgba(5,6,9,1)
+         1: (  5,  6, 10,255) #05060AFF srgba(5,6,10,1)
+         2: (  5,  7,  7,255) #050707FF srgba(5,7,7,1)
+       753: (  5,  7,  8,255) #050708FF srgba(5,7,8,1)
+      1382: (  5,  7,  9,255) #050709FF srgba(5,7,9,1)
+       156: (  5,  7, 10,255) #05070AFF srgba(5,7,10,1)
+         3: (  5,  7, 11,255) #05070BFF srgba(5,7,11,1)
+        11: (  5,  8,  9,255) #050809FF srgba(5,8,9,1)
+        55: (  5,  8, 10,255) #05080AFF srgba(5,8,10,1)
+        18: (  5,  8, 11,255) #05080BFF srgba(5,8,11,1)
+         2: (  5,  8, 12,255) #05080CFF srgba(5,8,12,1)
+         2: (  5,  9, 11,255) #05090BFF srgba(5,9,11,1)
+         1: (  5,  9, 12,255) #05090CFF srgba(5,9,12,1)
+         1: (  5, 15, 15,255) #050F0FFF srgba(5,15,15,1)
+         1: (  5, 16, 28,255) #05101CFF srgba(5,16,28,1)
+        14: (  5,114,116,255) #057274FF srgba(5,114,116,1)
+         3: (  5,115,117,255) #057375FF srgba(5,115,117,1)
+        10: (  5,116,117,255) #057475FF srgba(5,116,117,1)
+        35: (  5,116,118,255) #057476FF srgba(5,116,118,1)
+         8: (  5,117,118,255) #057576FF srgba(5,117,118,1)
+         1: (  5,117,119,255) #057577FF srgba(5,117,119,1)
+         6: (  5,118,120,255) #057678FF srgba(5,118,120,1)
+         4: (  5,119,120,255) #057778FF srgba(5,119,120,1)
+         3: (  5,119,121,255) #057779FF srgba(5,119,121,1)
+         2: (  5,120,121,255) #057879FF srgba(5,120,121,1)
+         2: (  5,120,122,255) #05787AFF srgba(5,120,122,1)
+         5: (  5,121,123,255) #05797BFF srgba(5,121,123,1)
+         7: (  5,123,124,255) #057B7CFF srgba(5,123,124,1)
+         5: (  5,123,125,255) #057B7DFF srgba(5,123,125,1)
+         7: (  5,124,126,255) #057C7EFF srgba(5,124,126,1)
+         1: (  5,125,126,255) #057D7EFF srgba(5,125,126,1)
+         5: (  5,125,127,255) #057D7FFF srgba(5,125,127,1)
+         4: (  5,126,127,255) #057E7FFF srgba(5,126,127,1)
+         3: (  5,126,128,255) #057E80FF srgba(5,126,128,1)
+         6: (  5,127,129,255) #057F81FF srgba(5,127,129,1)
+        10: (  5,128,129,255) #058081FF srgba(5,128,129,1)
+        43: (  5,128,130,255) #058082FF srgba(5,128,130,1)
+         3: (  5,129,130,255) #058182FF srgba(5,129,130,1)
+         1: (  5,129,131,255) #058183FF srgba(5,129,131,1)
+        12: (  5,130,132,255) #058284FF srgba(5,130,132,1)
+         4: (  5,131,132,255) #058384FF srgba(5,131,132,1)
+        20: (  5,131,133,255) #058385FF srgba(5,131,133,1)
+         3: (  5,132,133,255) #058485FF srgba(5,132,133,1)
+         7: (  5,132,134,255) #058486FF srgba(5,132,134,1)
+        74: (  5,133,135,255) #058587FF srgba(5,133,135,1)
+         3: (  5,134,135,255) #058687FF srgba(5,134,135,1)
+         3: (  5,134,136,255) #058688FF srgba(5,134,136,1)
+        13: (  5,135,136,255) #058788FF srgba(5,135,136,1)
+         9: (  5,135,137,255) #058789FF srgba(5,135,137,1)
+         5: (  5,136,138,255) #05888AFF srgba(5,136,138,1)
+         9: (  5,137,138,255) #05898AFF srgba(5,137,138,1)
+         9: (  5,137,139,255) #05898BFF srgba(5,137,139,1)
+        12: (  5,138,140,255) #058A8CFF srgba(5,138,140,1)
+        19: (  5,139,141,255) #058B8DFF srgba(5,139,141,1)
+         6: (  5,143,145,255) #058F91FF srgba(5,143,145,1)
+         8: (  5,144,146,255) #059092FF srgba(5,144,146,1)
+         2: (  5,145,147,255) #059193FF srgba(5,145,147,1)
+         1: (  5,146,147,255) #059293FF srgba(5,146,147,1)
+         2: (  5,147,149,255) #059395FF srgba(5,147,149,1)
+         2: (  5,148,150,255) #059496FF srgba(5,148,150,1)
+         1: (  5,149,151,255) #059597FF srgba(5,149,151,1)
+        27: (  5,150,152,255) #059698FF srgba(5,150,152,1)
+        15: (  5,151,153,255) #059799FF srgba(5,151,153,1)
+         1: (  6,  5,  7,255) #060507FF srgba(6,5,7,1)
+         6: (  6,  6,  6,255) #060606FF srgba(6,6,6,1)
+        11: (  6,  6,  7,255) #060607FF srgba(6,6,7,1)
+        25: (  6,  6,  8,255) #060608FF srgba(6,6,8,1)
+        11: (  6,  6,  9,255) #060609FF srgba(6,6,9,1)
+       319: (  6,  7,  8,255) #060708FF srgba(6,7,8,1)
+      1480: (  6,  7,  9,255) #060709FF srgba(6,7,9,1)
+       329: (  6,  7, 10,255) #06070AFF srgba(6,7,10,1)
+         1: (  6,  7, 11,255) #06070BFF srgba(6,7,11,1)
+         3: (  6,  8,  8,255) #060808FF srgba(6,8,8,1)
+       426: (  6,  8,  9,255) #060809FF srgba(6,8,9,1)
+      2185: (  6,  8, 10,255) #06080AFF srgba(6,8,10,1)
+       501: (  6,  8, 11,255) #06080BFF srgba(6,8,11,1)
+        12: (  6,  8, 12,255) #06080CFF srgba(6,8,12,1)
+        31: (  6,  9, 10,255) #06090AFF srgba(6,9,10,1)
+       109: (  6,  9, 11,255) #06090BFF srgba(6,9,11,1)
+        96: (  6,  9, 12,255) #06090CFF srgba(6,9,12,1)
+         7: (  6,  9, 13,255) #06090DFF srgba(6,9,13,1)
+         1: (  6,  9, 21,255) #060915FF srgba(6,9,21,1)
+         5: (  6, 10, 12,255) #060A0CFF srgba(6,10,12,1)
+         1: (  6, 10, 14,255) #060A0EFF srgba(6,10,14,1)
+         1: (  6, 11, 13,255) #060B0DFF srgba(6,11,13,1)
+         3: (  6,139,141,255) #068B8DFF srgba(6,139,141,1)
+        10: (  6,140,142,255) #068C8EFF srgba(6,140,142,1)
+        26: (  6,141,143,255) #068D8FFF srgba(6,141,143,1)
+        14: (  6,142,144,255) #068E90FF srgba(6,142,144,1)
+        12: (  6,143,145,255) #068F91FF srgba(6,143,145,1)
+        10: (  6,144,146,255) #069092FF srgba(6,144,146,1)
+        33: (  6,145,147,255) #069193FF srgba(6,145,147,1)
+         6: (  6,146,148,255) #069294FF srgba(6,146,148,1)
+        15: (  6,147,149,255) #069395FF srgba(6,147,149,1)
+        23: (  6,148,150,255) #069496FF srgba(6,148,150,1)
+        14: (  6,149,151,255) #069597FF srgba(6,149,151,1)
+       101: (  6,150,152,255) #069698FF srgba(6,150,152,1)
+        57: (  6,151,153,255) #069799FF srgba(6,151,153,1)
+     30834: (  6,152,154,255) #06989AFF srgba(6,152,154,1)
+         1: (  7,  6,  7,255) #070607FF srgba(7,6,7,1)
+         1: (  7,  7,  7,255) #070707FF srgba(7,7,7,1)
+         3: (  7,  7,  8,255) #070708FF srgba(7,7,8,1)
+         4: (  7,  7,  9,255) #070709FF srgba(7,7,9,1)
+        36: (  7,  8,  9,255) #070809FF srgba(7,8,9,1)
+       450: (  7,  8, 10,255) #07080AFF srgba(7,8,10,1)
+       234: (  7,  8, 11,255) #07080BFF srgba(7,8,11,1)
+        10: (  7,  8, 12,255) #07080CFF srgba(7,8,12,1)
+       166: (  7,  9, 10,255) #07090AFF srgba(7,9,10,1)
+      1512: (  7,  9, 11,255) #07090BFF srgba(7,9,11,1)
+       818: (  7,  9, 12,255) #07090CFF srgba(7,9,12,1)
+        26: (  7,  9, 13,255) #07090DFF srgba(7,9,13,1)
+         2: (  7,  9, 14,255) #07090EFF srgba(7,9,14,1)
+        30: (  7, 10, 11,255) #070A0BFF srgba(7,10,11,1)
+       254: (  7, 10, 12,255) #070A0CFF srgba(7,10,12,1)
+       195: (  7, 10, 13,255) #070A0DFF srgba(7,10,13,1)
+        24: (  7, 10, 14,255) #070A0EFF srgba(7,10,14,1)
+         1: (  7, 10, 15,255) #070A0FFF srgba(7,10,15,1)
+         4: (  7, 11, 13,255) #070B0DFF srgba(7,11,13,1)
+         5: (  7, 11, 14,255) #070B0EFF srgba(7,11,14,1)
+         4: (  7, 11, 15,255) #070B0FFF srgba(7,11,15,1)
+         1: (  7, 13, 27,255) #070D1BFF srgba(7,13,27,1)
+         1: (  7, 19, 30,255) #07131EFF srgba(7,19,30,1)
+         2: (  8,  7,  7,255) #080707FF srgba(8,7,7,1)
+         4: (  8,  8,  8,255) #080808FF grey3
+         4: (  8,  8,  9,255) #080809FF srgba(8,8,9,1)
+         5: (  8,  8, 10,255) #08080AFF srgba(8,8,10,1)
+         1: (  8,  8, 12,255) #08080CFF srgba(8,8,12,1)
+         2: (  8,  9,  8,255) #080908FF srgba(8,9,8,1)
+         8: (  8,  9, 10,255) #08090AFF srgba(8,9,10,1)
+       134: (  8,  9, 11,255) #08090BFF srgba(8,9,11,1)
+       106: (  8,  9, 12,255) #08090CFF srgba(8,9,12,1)
+         3: (  8,  9, 13,255) #08090DFF srgba(8,9,13,1)
+        53: (  8, 10, 11,255) #080A0BFF srgba(8,10,11,1)
+      1134: (  8, 10, 12,255) #080A0CFF srgba(8,10,12,1)
+       919: (  8, 10, 13,255) #080A0DFF srgba(8,10,13,1)
+       108: (  8, 10, 14,255) #080A0EFF srgba(8,10,14,1)
+         3: (  8, 10, 15,255) #080A0FFF srgba(8,10,15,1)
+         3: (  8, 11, 12,255) #080B0CFF srgba(8,11,12,1)
+       194: (  8, 11, 13,255) #080B0DFF srgba(8,11,13,1)
+       493: (  8, 11, 14,255) #080B0EFF srgba(8,11,14,1)
+        87: (  8, 11, 15,255) #080B0FFF srgba(8,11,15,1)
+         7: (  8, 11, 16,255) #080B10FF srgba(8,11,16,1)
+        14: (  8, 12, 14,255) #080C0EFF srgba(8,12,14,1)
+        33: (  8, 12, 15,255) #080C0FFF srgba(8,12,15,1)
+        16: (  8, 12, 16,255) #080C10FF srgba(8,12,16,1)
+         1: (  8, 12, 17,255) #080C11FF srgba(8,12,17,1)
+         1: (  8, 13, 16,255) #080D10FF srgba(8,13,16,1)
+         1: (  8, 19, 29,255) #08131DFF srgba(8,19,29,1)
+         1: (  9,  8, 11,255) #09080BFF srgba(9,8,11,1)
+         1: (  9,  9, 10,255) #09090AFF srgba(9,9,10,1)
+         1: (  9,  9, 11,255) #09090BFF srgba(9,9,11,1)
+         1: (  9,  9, 12,255) #09090CFF srgba(9,9,12,1)
+         4: (  9, 10, 11,255) #090A0BFF srgba(9,10,11,1)
+        27: (  9, 10, 12,255) #090A0CFF srgba(9,10,12,1)
+        42: (  9, 10, 13,255) #090A0DFF srgba(9,10,13,1)
+         8: (  9, 10, 14,255) #090A0EFF srgba(9,10,14,1)
+        14: (  9, 11, 12,255) #090B0CFF srgba(9,11,12,1)
+       288: (  9, 11, 13,255) #090B0DFF srgba(9,11,13,1)
+       514: (  9, 11, 14,255) #090B0EFF srgba(9,11,14,1)
+        94: (  9, 11, 15,255) #090B0FFF srgba(9,11,15,1)
+        11: (  9, 11, 16,255) #090B10FF srgba(9,11,16,1)
+         1: (  9, 12, 13,255) #090C0DFF srgba(9,12,13,1)
+       174: (  9, 12, 14,255) #090C0EFF srgba(9,12,14,1)
+       376: (  9, 12, 15,255) #090C0FFF srgba(9,12,15,1)
+       154: (  9, 12, 16,255) #090C10FF srgba(9,12,16,1)
+        19: (  9, 12, 17,255) #090C11FF srgba(9,12,17,1)
+         1: (  9, 12, 18,255) #090C12FF srgba(9,12,18,1)
+         9: (  9, 13, 15,255) #090D0FFF srgba(9,13,15,1)
+        39: (  9, 13, 16,255) #090D10FF srgba(9,13,16,1)
+        36: (  9, 13, 17,255) #090D11FF srgba(9,13,17,1)
+         6: (  9, 13, 18,255) #090D12FF srgba(9,13,18,1)
+         2: (  9, 13, 19,255) #090D13FF srgba(9,13,19,1)
+         1: (  9, 14, 17,255) #090E11FF srgba(9,14,17,1)
+         3: (  9, 14, 18,255) #090E12FF srgba(9,14,18,1)
+         2: (  9, 14, 19,255) #090E13FF srgba(9,14,19,1)
+         1: (  9,153,153,255) #099999FF srgba(9,153,153,1)
+         1: ( 10, 10,  9,255) #0A0A09FF srgba(10,10,9,1)
+         1: ( 10, 10, 10,255) #0A0A0AFF grey4
+         2: ( 10, 10, 12,255) #0A0A0CFF srgba(10,10,12,1)
+         1: ( 10, 11, 11,255) #0A0B0BFF srgba(10,11,11,1)
+         5: ( 10, 11, 12,255) #0A0B0CFF srgba(10,11,12,1)
+        12: ( 10, 11, 13,255) #0A0B0DFF srgba(10,11,13,1)
+         9: ( 10, 11, 14,255) #0A0B0EFF srgba(10,11,14,1)
+         1: ( 10, 11, 15,255) #0A0B0FFF srgba(10,11,15,1)
+         4: ( 10, 12, 13,255) #0A0C0DFF srgba(10,12,13,1)
+        97: ( 10, 12, 14,255) #0A0C0EFF srgba(10,12,14,1)
+       164: ( 10, 12, 15,255) #0A0C0FFF srgba(10,12,15,1)
+        90: ( 10, 12, 16,255) #0A0C10FF srgba(10,12,16,1)
+         9: ( 10, 12, 17,255) #0A0C11FF srgba(10,12,17,1)
+        28: ( 10, 13, 15,255) #0A0D0FFF srgba(10,13,15,1)
+       196: ( 10, 13, 16,255) #0A0D10FF srgba(10,13,16,1)
+       154: ( 10, 13, 17,255) #0A0D11FF srgba(10,13,17,1)
+        19: ( 10, 13, 18,255) #0A0D12FF srgba(10,13,18,1)
+         8: ( 10, 14, 16,255) #0A0E10FF srgba(10,14,16,1)
+        41: ( 10, 14, 17,255) #0A0E11FF srgba(10,14,17,1)
+        50: ( 10, 14, 18,255) #0A0E12FF srgba(10,14,18,1)
+        18: ( 10, 14, 19,255) #0A0E13FF srgba(10,14,19,1)
+         1: ( 10, 14, 20,255) #0A0E14FF srgba(10,14,20,1)
+         1: ( 10, 15, 17,255) #0A0F11FF srgba(10,15,17,1)
+         4: ( 10, 15, 19,255) #0A0F13FF srgba(10,15,19,1)
+         1: ( 10, 26, 30,255) #0A1A1EFF srgba(10,26,30,1)
+         1: ( 10, 27, 30,255) #0A1B1EFF srgba(10,27,30,1)
+         1: ( 10, 30, 29,255) #0A1E1DFF srgba(10,30,29,1)
+         1: ( 10, 30, 30,255) #0A1E1EFF srgba(10,30,30,1)
+         1: ( 10,154,153,255) #0A9A99FF srgba(10,154,153,1)
+         1: ( 11, 11, 11,255) #0B0B0BFF srgba(11,11,11,1)
+         1: ( 11, 11, 12,255) #0B0B0CFF srgba(11,11,12,1)
+         1: ( 11, 11, 13,255) #0B0B0DFF srgba(11,11,13,1)
+         1: ( 11, 12, 13,255) #0B0C0DFF srgba(11,12,13,1)
+         5: ( 11, 12, 14,255) #0B0C0EFF srgba(11,12,14,1)
+         5: ( 11, 12, 15,255) #0B0C0FFF srgba(11,12,15,1)
+         3: ( 11, 12, 16,255) #0B0C10FF srgba(11,12,16,1)
+         1: ( 11, 12, 17,255) #0B0C11FF srgba(11,12,17,1)
+         6: ( 11, 13, 15,255) #0B0D0FFF srgba(11,13,15,1)
+        37: ( 11, 13, 16,255) #0B0D10FF srgba(11,13,16,1)
+        22: ( 11, 13, 17,255) #0B0D11FF srgba(11,13,17,1)
+         7: ( 11, 13, 18,255) #0B0D12FF srgba(11,13,18,1)
+         3: ( 11, 13, 19,255) #0B0D13FF srgba(11,13,19,1)
+        13: ( 11, 14, 16,255) #0B0E10FF srgba(11,14,16,1)
+        67: ( 11, 14, 17,255) #0B0E11FF srgba(11,14,17,1)
+        94: ( 11, 14, 18,255) #0B0E12FF srgba(11,14,18,1)
+        30: ( 11, 14, 19,255) #0B0E13FF srgba(11,14,19,1)
+         2: ( 11, 14, 20,255) #0B0E14FF srgba(11,14,20,1)
+         3: ( 11, 15, 17,255) #0B0F11FF srgba(11,15,17,1)
+        19: ( 11, 15, 18,255) #0B0F12FF srgba(11,15,18,1)
+        37: ( 11, 15, 19,255) #0B0F13FF srgba(11,15,19,1)
+        26: ( 11, 15, 20,255) #0B0F14FF srgba(11,15,20,1)
+         3: ( 11, 15, 21,255) #0B0F15FF srgba(11,15,21,1)
+         4: ( 11, 16, 21,255) #0B1015FF srgba(11,16,21,1)
+         3: ( 12, 12, 12,255) #0C0C0CFF srgba(12,12,12,1)
+         1: ( 12, 12, 15,255) #0C0C0FFF srgba(12,12,15,1)
+         2: ( 12, 13, 15,255) #0C0D0FFF srgba(12,13,15,1)
+         2: ( 12, 13, 16,255) #0C0D10FF srgba(12,13,16,1)
+         1: ( 12, 13, 19,255) #0C0D13FF srgba(12,13,19,1)
+         1: ( 12, 14, 15,255) #0C0E0FFF srgba(12,14,15,1)
+         3: ( 12, 14, 16,255) #0C0E10FF srgba(12,14,16,1)
+         6: ( 12, 14, 17,255) #0C0E11FF srgba(12,14,17,1)
+        16: ( 12, 14, 18,255) #0C0E12FF srgba(12,14,18,1)
+         3: ( 12, 14, 19,255) #0C0E13FF srgba(12,14,19,1)
+         3: ( 12, 15, 17,255) #0C0F11FF srgba(12,15,17,1)
+        23: ( 12, 15, 18,255) #0C0F12FF srgba(12,15,18,1)
+        46: ( 12, 15, 19,255) #0C0F13FF srgba(12,15,19,1)
+        18: ( 12, 15, 20,255) #0C0F14FF srgba(12,15,20,1)
+         2: ( 12, 15, 21,255) #0C0F15FF srgba(12,15,21,1)
+         4: ( 12, 16, 18,255) #0C1012FF srgba(12,16,18,1)
+        17: ( 12, 16, 19,255) #0C1013FF srgba(12,16,19,1)
+        38: ( 12, 16, 20,255) #0C1014FF srgba(12,16,20,1)
+        20: ( 12, 16, 21,255) #0C1015FF srgba(12,16,21,1)
+         3: ( 12, 16, 22,255) #0C1016FF srgba(12,16,22,1)
+         1: ( 12, 17, 18,255) #0C1112FF srgba(12,17,18,1)
+         3: ( 12, 17, 19,255) #0C1113FF srgba(12,17,19,1)
+         4: ( 12, 17, 20,255) #0C1114FF srgba(12,17,20,1)
+         7: ( 12, 17, 21,255) #0C1115FF srgba(12,17,21,1)
+         6: ( 12, 17, 22,255) #0C1116FF srgba(12,17,22,1)
+         1: ( 12, 17, 23,255) #0C1117FF srgba(12,17,23,1)
+         1: ( 12, 18, 22,255) #0C1216FF srgba(12,18,22,1)
+         1: ( 12, 18, 23,255) #0C1217FF srgba(12,18,23,1)
+         2: ( 13, 13, 15,255) #0D0D0FFF srgba(13,13,15,1)
+         2: ( 13, 14, 17,255) #0D0E11FF srgba(13,14,17,1)
+         4: ( 13, 15, 18,255) #0D0F12FF srgba(13,15,18,1)
+         1: ( 13, 15, 20,255) #0D0F14FF srgba(13,15,20,1)
+         1: ( 13, 15, 21,255) #0D0F15FF srgba(13,15,21,1)
+         8: ( 13, 16, 19,255) #0D1013FF srgba(13,16,19,1)
+        20: ( 13, 16, 20,255) #0D1014FF srgba(13,16,20,1)
+        19: ( 13, 16, 21,255) #0D1015FF srgba(13,16,21,1)
+         2: ( 13, 16, 22,255) #0D1016FF srgba(13,16,22,1)
+         1: ( 13, 17, 18,255) #0D1112FF srgba(13,17,18,1)
+        18: ( 13, 17, 20,255) #0D1114FF srgba(13,17,20,1)
+        28: ( 13, 17, 21,255) #0D1115FF srgba(13,17,21,1)
+        17: ( 13, 17, 22,255) #0D1116FF srgba(13,17,22,1)
+         1: ( 13, 17, 23,255) #0D1117FF srgba(13,17,23,1)
+         1: ( 13, 18, 19,255) #0D1213FF srgba(13,18,19,1)
+         2: ( 13, 18, 20,255) #0D1214FF srgba(13,18,20,1)
+         1: ( 13, 18, 21,255) #0D1215FF srgba(13,18,21,1)
+         4: ( 13, 18, 22,255) #0D1216FF srgba(13,18,22,1)
+        15: ( 13, 18, 23,255) #0D1217FF srgba(13,18,23,1)
+         3: ( 13, 18, 24,255) #0D1218FF srgba(13,18,24,1)
+         1: ( 13, 19, 23,255) #0D1317FF srgba(13,19,23,1)
+         1: ( 13, 19, 24,255) #0D1318FF srgba(13,19,24,1)
+         1: ( 14, 14, 18,255) #0E0E12FF srgba(14,14,18,1)
+         1: ( 14, 15, 17,255) #0E0F11FF srgba(14,15,17,1)
+         1: ( 14, 15, 18,255) #0E0F12FF srgba(14,15,18,1)
+         1: ( 14, 15, 19,255) #0E0F13FF srgba(14,15,19,1)
+         1: ( 14, 15, 21,255) #0E0F15FF srgba(14,15,21,1)
+         2: ( 14, 16, 18,255) #0E1012FF srgba(14,16,18,1)
+         1: ( 14, 16, 19,255) #0E1013FF srgba(14,16,19,1)
+         4: ( 14, 16, 20,255) #0E1014FF srgba(14,16,20,1)
+         2: ( 14, 16, 21,255) #0E1015FF srgba(14,16,21,1)
+         1: ( 14, 17, 20,255) #0E1114FF srgba(14,17,20,1)
+         6: ( 14, 17, 21,255) #0E1115FF srgba(14,17,21,1)
+        13: ( 14, 17, 22,255) #0E1116FF srgba(14,17,22,1)
+         1: ( 14, 17, 23,255) #0E1117FF srgba(14,17,23,1)
+         1: ( 14, 18, 21,255) #0E1215FF srgba(14,18,21,1)
+        14: ( 14, 18, 22,255) #0E1216FF srgba(14,18,22,1)
+         9: ( 14, 18, 23,255) #0E1217FF srgba(14,18,23,1)
+         3: ( 14, 18, 24,255) #0E1218FF srgba(14,18,24,1)
+         1: ( 14, 19, 20,255) #0E1314FF srgba(14,19,20,1)
+         1: ( 14, 19, 21,255) #0E1315FF srgba(14,19,21,1)
+         2: ( 14, 19, 22,255) #0E1316FF srgba(14,19,22,1)
+         7: ( 14, 19, 23,255) #0E1317FF srgba(14,19,23,1)
+        11: ( 14, 19, 24,255) #0E1318FF srgba(14,19,24,1)
+         2: ( 14, 20, 22,255) #0E1416FF srgba(14,20,22,1)
+         2: ( 14, 20, 23,255) #0E1417FF srgba(14,20,23,1)
+         2: ( 14, 20, 24,255) #0E1418FF srgba(14,20,24,1)
+         1: ( 14, 30, 30,255) #0E1E1EFF srgba(14,30,30,1)
+         1: ( 15, 15, 18,255) #0F0F12FF srgba(15,15,18,1)
+         1: ( 15, 16, 20,255) #0F1014FF srgba(15,16,20,1)
+         1: ( 15, 17, 18,255) #0F1112FF srgba(15,17,18,1)
+         1: ( 15, 18, 20,255) #0F1214FF srgba(15,18,20,1)
+         1: ( 15, 18, 22,255) #0F1216FF srgba(15,18,22,1)
+         3: ( 15, 18, 23,255) #0F1217FF srgba(15,18,23,1)
+         2: ( 15, 19, 22,255) #0F1316FF srgba(15,19,22,1)
+        10: ( 15, 19, 23,255) #0F1317FF srgba(15,19,23,1)
+         5: ( 15, 19, 24,255) #0F1318FF srgba(15,19,24,1)
+         1: ( 15, 20, 21,255) #0F1415FF srgba(15,20,21,1)
+         1: ( 15, 20, 23,255) #0F1417FF srgba(15,20,23,1)
+         3: ( 15, 20, 24,255) #0F1418FF srgba(15,20,24,1)
+         1: ( 15, 22, 24,255) #0F1618FF srgba(15,22,24,1)
+         1: ( 16, 16, 19,255) #101013FF srgba(16,16,19,1)
+         1: ( 16, 18, 23,255) #101217FF srgba(16,18,23,1)
+         1: ( 16, 19, 21,255) #101315FF srgba(16,19,21,1)
+         1: ( 16, 19, 23,255) #101317FF srgba(16,19,23,1)
+         1: ( 16, 20, 23,255) #101417FF srgba(16,20,23,1)
+         1: ( 16, 20, 24,255) #101418FF srgba(16,20,24,1)
+         4: ( 16, 20, 25,255) #101419FF srgba(16,20,25,1)
+         1: ( 16, 21, 25,255) #101519FF srgba(16,21,25,1)
+         1: ( 16, 21, 26,255) #10151AFF srgba(16,21,26,1)
+         1: ( 16, 22, 24,255) #101618FF srgba(16,22,24,1)
+         1: ( 17, 20, 22,255) #111416FF srgba(17,20,22,1)
+         1: ( 17, 20, 25,255) #111419FF srgba(17,20,25,1)
+         1: ( 17, 21, 26,255) #11151AFF srgba(17,21,26,1)
+         1: ( 17, 22, 25,255) #111619FF srgba(17,22,25,1)
+         1: ( 17, 22, 26,255) #11161AFF srgba(17,22,26,1)
+         1: ( 17, 23, 25,255) #111719FF srgba(17,23,25,1)
+         7: ( 18, 19, 18,255) #121312FF srgba(18,19,18,1)
+         2: ( 18, 20, 22,255) #121416FF srgba(18,20,22,1)
+         1: ( 18, 21, 26,255) #12151AFF srgba(18,21,26,1)
+         1: ( 18, 23, 25,255) #121719FF srgba(18,23,25,1)
+         1: ( 18,156,151,255) #129C97FF srgba(18,156,151,1)
+         1: ( 19, 21, 25,255) #131519FF srgba(19,21,25,1)
+         1: ( 20, 23, 26,255) #14171AFF srgba(20,23,26,1)
+         1: ( 20, 26, 30,255) #141A1EFF srgba(20,26,30,1)
+         1: ( 21, 30, 30,255) #151E1EFF srgba(21,30,30,1)
+         1: ( 22, 29, 30,255) #161D1EFF srgba(22,29,30,1)
+         1: ( 23, 25, 27,255) #17191BFF srgba(23,25,27,1)
+         2: ( 24, 25, 24,255) #181918FF srgba(24,25,24,1)
+         1: ( 24, 26, 28,255) #181A1CFF srgba(24,26,28,1)
+         1: ( 24, 27, 29,255) #181B1DFF srgba(24,27,29,1)
+        26: ( 25, 26, 25,255) #191A19FF srgba(25,26,25,1)
+         1: ( 25, 27, 28,255) #191B1CFF srgba(25,27,28,1)
+         3: ( 25, 28, 30,255) #191C1EFF srgba(25,28,30,1)
+       829: ( 26, 27, 26,255) #1A1B1AFF srgba(26,27,26,1)
+         1: ( 26, 27, 27,255) #1A1B1BFF srgba(26,27,27,1)
+         1: ( 28, 29, 30,255) #1C1D1EFF srgba(28,29,30,1)
+       864: ( 30, 30, 29,255) #1E1E1DFF srgba(30,30,29,1)
+     66332: ( 52,101,164,255) #3465A4FF srgba(52,101,164,1)
+        11: ( 53,102,163,255) #3566A3FF srgba(53,102,163,1)
+         6: ( 54,102,164,255) #3666A4FF srgba(54,102,164,1)
+         8: ( 54,103,163,255) #3667A3FF srgba(54,103,163,1)
+        10: ( 55,103,162,255) #3767A2FF srgba(55,103,162,1)
+         2: ( 56,104,162,255) #3868A2FF srgba(56,104,162,1)
+        10: ( 57,104,162,255) #3968A2FF srgba(57,104,162,1)
+         8: ( 58,104,161,255) #3A68A1FF srgba(58,104,161,1)
+        26: ( 58,105,161,255) #3A69A1FF srgba(58,105,161,1)
+         7: ( 59,105,161,255) #3B69A1FF srgba(59,105,161,1)
+        11: ( 60,106,161,255) #3C6AA1FF srgba(60,106,161,1)
+         3: ( 61,107,160,255) #3D6BA0FF srgba(61,107,160,1)
+        58: ( 62,107,160,255) #3E6BA0FF srgba(62,107,160,1)
+         6: ( 62,108,160,255) #3E6CA0FF srgba(62,108,160,1)
+         2: ( 63,108,159,255) #3F6C9FFF srgba(63,108,159,1)
+         1: ( 64,109,159,255) #406D9FFF srgba(64,109,159,1)
+        15: ( 65,110,159,255) #416E9FFF srgba(65,110,159,1)
+         3: ( 66,110,158,255) #426E9EFF srgba(66,110,158,1)
+         9: ( 67,110,158,255) #436E9EFF srgba(67,110,158,1)
+         8: ( 68,111,157,255) #446F9DFF srgba(68,111,157,1)
+         9: ( 69,112,156,255) #45709CFF srgba(69,112,156,1)
+         1: ( 70,112,157,255) #46709DFF srgba(70,112,157,1)
+         3: ( 70,113,156,255) #46719CFF srgba(70,113,156,1)
+        45: ( 71,113,156,255) #47719CFF srgba(71,113,156,1)
+         2: ( 72,114,156,255) #48729CFF srgba(72,114,156,1)
+         4: ( 73,115,155,255) #49739BFF srgba(73,115,155,1)
+        21: ( 74,116,155,255) #4A749BFF srgba(74,116,155,1)
+         1: ( 75,116,154,255) #4B749AFF srgba(75,116,154,1)
+         7: ( 76,116,154,255) #4C749AFF srgba(76,116,154,1)
+         3: ( 77,117,154,255) #4D759AFF srgba(77,117,154,1)
+         8: ( 78,118,153,255) #4E7699FF srgba(78,118,153,1)
+         5: ( 80,119,152,255) #507798FF srgba(80,119,152,1)
+         3: ( 81,120,151,255) #517897FF srgba(81,120,151,1)
+        19: ( 81,120,152,255) #517898FF srgba(81,120,152,1)
+         1: ( 82,121,152,255) #527998FF srgba(82,121,152,1)
+         2: ( 83,122,150,255) #537A96FF srgba(83,122,150,1)
+         2: ( 83,122,151,255) #537A97FF srgba(83,122,151,1)
+         1: ( 84,122,150,255) #547A96FF srgba(84,122,150,1)
+         3: ( 85,123,149,255) #557B95FF srgba(85,123,149,1)
+        17: ( 86,124,150,255) #567C96FF srgba(86,124,150,1)
+        10: ( 87,124,149,255) #577C95FF srgba(87,124,149,1)
+         3: ( 88,125,148,255) #587D94FF srgba(88,125,148,1)
+         2: ( 88,125,149,255) #587D95FF srgba(88,125,149,1)
+         7: ( 89,126,148,255) #597E94FF srgba(89,126,148,1)
+         6: ( 90,127,147,255) #5A7F93FF srgba(90,127,147,1)
+         9: ( 92,128,147,255) #5C8093FF srgba(92,128,147,1)
+         2: ( 93,128,146,255) #5D8092FF srgba(93,128,146,1)
+         4: ( 94,129,146,255) #5E8192FF srgba(94,129,146,1)
+         3: ( 96,130,145,255) #608291FF srgba(96,130,145,1)
+         1: ( 97,131,145,255) #618391FF srgba(97,131,145,1)
+         4: ( 98,132,144,255) #628490FF srgba(98,132,144,1)
+        11: ( 99,132,144,255) #638490FF srgba(99,132,144,1)
+         3: (100,133,143,255) #64858FFF srgba(100,133,143,1)
+         8: (100,133,144,255) #648590FF srgba(100,133,144,1)
+         5: (101,134,142,255) #65868EFF srgba(101,134,142,1)
+         3: (102,134,143,255) #66868FFF srgba(102,134,143,1)
+         5: (103,134,142,255) #67868EFF srgba(103,134,142,1)
+         9: (104,135,142,255) #68878EFF srgba(104,135,142,1)
+         4: (105,136,141,255) #69888DFF srgba(105,136,141,1)
+         7: (106,137,141,255) #6A898DFF srgba(106,137,141,1)
+         5: (107,137,141,255) #6B898DFF srgba(107,137,141,1)
+        46: (108,138,140,255) #6C8A8CFF srgba(108,138,140,1)
+         5: (109,139,140,255) #6D8B8CFF srgba(109,139,140,1)
+         4: (110,140,139,255) #6E8C8BFF srgba(110,140,139,1)
+         2: (111,139,139,255) #6F8B8BFF srgba(111,139,139,1)
+         9: (112,140,139,255) #708C8BFF srgba(112,140,139,1)
+         1: (112,141,138,255) #708D8AFF srgba(112,141,138,1)
+        10: (115,142,138,255) #738E8AFF srgba(115,142,138,1)
+         7: (115,143,137,255) #738F89FF srgba(115,143,137,1)
+         2: (116,144,136,255) #749088FF srgba(116,144,136,1)
+         4: (117,144,137,255) #759089FF srgba(117,144,137,1)
+        17: (118,145,136,255) #769188FF srgba(118,145,136,1)
+         1: (119,145,135,255) #779187FF srgba(119,145,135,1)
+         2: (119,146,136,255) #779288FF srgba(119,146,136,1)
+         3: (120,146,135,255) #789287FF srgba(120,146,135,1)
+        39: (121,146,134,255) #799286FF srgba(121,146,134,1)
+         3: (122,147,135,255) #7A9387FF srgba(122,147,135,1)
+         1: (123,147,134,255) #7B9386FF srgba(123,147,134,1)
+         6: (123,148,133,255) #7B9485FF srgba(123,148,133,1)
+         7: (124,149,133,255) #7C9585FF srgba(124,149,133,1)
+         4: (126,150,133,255) #7E9685FF srgba(126,150,133,1)
+         8: (127,150,132,255) #7F9684FF srgba(127,150,132,1)
+        25: (127,151,132,255) #7F9784FF srgba(127,151,132,1)
+         5: (128,152,132,255) #809884FF srgba(128,152,132,1)
+         5: (129,152,131,255) #819883FF srgba(129,152,131,1)
+         7: (130,152,131,255) #829883FF srgba(130,152,131,1)
+        28: (131,152,131,255) #839883FF srgba(131,152,131,1)
+         6: (132,154,130,255) #849A82FF srgba(132,154,130,1)
+         5: (133,154,130,255) #859A82FF srgba(133,154,130,1)
+        33: (134,155,129,255) #869B81FF srgba(134,155,129,1)
+         1: (135,155,128,255) #879B80FF srgba(135,155,128,1)
+         1: (135,156,129,255) #879C81FF srgba(135,156,129,1)
+        11: (136,157,128,255) #889D80FF srgba(136,157,128,1)
+         4: (137,157,128,255) #899D80FF srgba(137,157,128,1)
+         4: (138,158,128,255) #8A9E80FF srgba(138,158,128,1)
+         3: (139,157,127,255) #8B9D7FFF srgba(139,157,127,1)
+         2: (139,158,127,255) #8B9E7FFF srgba(139,158,127,1)
+         6: (140,159,127,255) #8C9F7FFF srgba(140,159,127,1)
+         3: (142,160,126,255) #8EA07EFF srgba(142,160,126,1)
+         2: (143,160,126,255) #8FA07EFF srgba(143,160,126,1)
+        15: (143,161,125,255) #8FA17DFF srgba(143,161,125,1)
+         1: (144,162,125,255) #90A27DFF srgba(144,162,125,1)
+         5: (146,163,124,255) #92A37CFF srgba(146,163,124,1)
+         1: (147,163,124,255) #93A37CFF srgba(147,163,124,1)
+         1: (147,164,123,255) #93A47BFF srgba(147,164,123,1)
+         2: (149,164,123,255) #95A47BFF srgba(149,164,123,1)
+         7: (150,165,122,255) #96A57AFF srgba(150,165,122,1)
+         2: (151,165,123,255) #97A57BFF srgba(151,165,123,1)
+         8: (151,166,122,255) #97A67AFF srgba(151,166,122,1)
+        20: (152,167,122,255) #98A77AFF srgba(152,167,122,1)
+         2: (153,168,121,255) #99A879FF srgba(153,168,121,1)
+         1: (153,169,120,255) #99A978FF srgba(153,169,120,1)
+         4: (154,169,121,255) #9AA979FF srgba(154,169,121,1)
+         2: (155,170,120,255) #9BAA78FF srgba(155,170,120,1)
+         1: (156,170,119,255) #9CAA77FF srgba(156,170,119,1)
+         7: (158,171,119,255) #9EAB77FF srgba(158,171,119,1)
+         6: (159,172,118,255) #9FAC76FF srgba(159,172,118,1)
+         2: (160,172,118,255) #A0AC76FF srgba(160,172,118,1)
+         2: (161,173,118,255) #A1AD76FF srgba(161,173,118,1)
+         2: (162,174,117,255) #A2AE75FF srgba(162,174,117,1)
+         2: (164,175,116,255) #A4AF74FF srgba(164,175,116,1)
+         6: (165,176,116,255) #A5B074FF srgba(165,176,116,1)
+         1: (166,176,115,255) #A6B073FF srgba(166,176,115,1)
+         4: (167,177,115,255) #A7B173FF srgba(167,177,115,1)
+         1: (168,177,115,255) #A8B173FF srgba(168,177,115,1)
+         4: (169,179,114,255) #A9B372FF srgba(169,179,114,1)
+         3: (170,179,114,255) #AAB372FF srgba(170,179,114,1)
+         4: (172,180,113,255) #ACB471FF srgba(172,180,113,1)
+         5: (174,182,112,255) #AEB670FF srgba(174,182,112,1)
+         2: (175,182,112,255) #AFB670FF srgba(175,182,112,1)
+         8: (176,182,111,255) #B0B66FFF srgba(176,182,111,1)
+         1: (177,183,111,255) #B1B76FFF srgba(177,183,111,1)
+         4: (177,184,111,255) #B1B86FFF srgba(177,184,111,1)
+        12: (178,184,110,255) #B2B86EFF srgba(178,184,110,1)
+         2: (179,185,110,255) #B3B96EFF srgba(179,185,110,1)
+         8: (180,185,109,255) #B4B96DFF srgba(180,185,109,1)
+         9: (181,186,110,255) #B5BA6EFF srgba(181,186,110,1)
+         1: (181,187,109,255) #B5BB6DFF srgba(181,187,109,1)
+         2: (182,187,108,255) #B6BB6CFF srgba(182,187,108,1)
+        17: (184,187,108,255) #B8BB6CFF srgba(184,187,108,1)
+         5: (185,188,107,255) #B9BC6BFF srgba(185,188,107,1)
+         1: (185,189,108,255) #B9BD6CFF srgba(185,189,108,1)
+         2: (187,190,106,255) #BBBE6AFF srgba(187,190,106,1)
+         2: (188,190,107,255) #BCBE6BFF srgba(188,190,107,1)
+         2: (189,191,106,255) #BDBF6AFF srgba(189,191,106,1)
+         2: (189,192,105,255) #BDC069FF srgba(189,192,105,1)
+         6: (190,192,105,255) #BEC069FF srgba(190,192,105,1)
+        11: (192,194,104,255) #C0C268FF srgba(192,194,104,1)
+         2: (193,194,104,255) #C1C268FF srgba(193,194,104,1)
+         4: (195,195,103,255) #C3C367FF srgba(195,195,103,1)
+        49: (196,196,103,255) #C4C467FF srgba(196,196,103,1)
+         3: (197,197,102,255) #C5C566FF srgba(197,197,102,1)
+         4: (198,197,102,255) #C6C566FF srgba(198,197,102,1)
+         3: (199,198,102,255) #C7C666FF srgba(199,198,102,1)
+        68: (200,199,101,255) #C8C765FF srgba(200,199,101,1)
+         2: (201,200,101,255) #C9C865FF srgba(201,200,101,1)
+         5: (202,200,100,255) #CAC864FF srgba(202,200,100,1)
+         3: (203,200,100,255) #CBC864FF srgba(203,200,100,1)
+         4: (204,201, 99,255) #CCC963FF srgba(204,201,99,1)
+         1: (204,201,100,255) #CCC964FF srgba(204,201,100,1)
+        63: (206,202, 99,255) #CECA63FF srgba(206,202,99,1)
+         5: (207,203, 98,255) #CFCB62FF srgba(207,203,98,1)
+        13: (208,204, 98,255) #D0CC62FF srgba(208,204,98,1)
+         2: (208,212,204,255) #D0D4CCFF srgba(208,212,204,1)
+         2: (209,205, 97,255) #D1CD61FF srgba(209,205,97,1)
+         1: (209,209,207,255) #D1D1CFFF srgba(209,209,207,1)
+        13: (210,205, 97,255) #D2CD61FF srgba(210,205,97,1)
+         3: (210,214,206,255) #D2D6CEFF srgba(210,214,206,1)
+         4: (211,206, 97,255) #D3CE61FF srgba(211,206,97,1)
+       859: (211,215,207,255) #D3D7CFFF srgba(211,215,207,1)
+         7: (212,206, 96,255) #D4CE60FF srgba(212,206,96,1)
+         4: (213,207, 96,255) #D5CF60FF srgba(213,207,96,1)
+         8: (214,207, 96,255) #D6CF60FF srgba(214,207,96,1)
+        10: (215,208, 95,255) #D7D05FFF srgba(215,208,95,1)
+        25: (216,209, 94,255) #D8D15EFF srgba(216,209,94,1)
+         9: (216,209, 95,255) #D8D15FFF srgba(216,209,95,1)
+         4: (216,210, 94,255) #D8D25EFF srgba(216,210,94,1)
+         6: (217,210, 93,255) #D9D25DFF srgba(217,210,93,1)
+        15: (218,211, 94,255) #DAD35EFF srgba(218,211,94,1)
+         6: (219,211, 92,255) #DBD35CFF srgba(219,211,92,1)
+         1: (219,212, 93,255) #DBD45DFF srgba(219,212,93,1)
+         2: (220,212, 93,255) #DCD45DFF srgba(220,212,93,1)
+        19: (221,212, 92,255) #DDD45CFF srgba(221,212,92,1)
+         4: (222,213, 91,255) #DED55BFF srgba(222,213,91,1)
+         3: (223,214, 91,255) #DFD65BFF srgba(223,214,91,1)
+        53: (224,215, 91,255) #E0D75BFF srgba(224,215,91,1)
+         4: (225,215, 90,255) #E1D75AFF srgba(225,215,90,1)
+         2: (226,216, 90,255) #E2D85AFF srgba(226,216,90,1)
+        17: (227,217, 89,255) #E3D959FF srgba(227,217,89,1)
+        11: (228,218, 89,255) #E4DA59FF srgba(228,218,89,1)
+         1: (229,217, 89,255) #E5D959FF srgba(229,217,89,1)
+         4: (230,218, 88,255) #E6DA58FF srgba(230,218,88,1)
+        14: (231,219, 88,255) #E7DB58FF srgba(231,219,88,1)
+         2: (232,220, 87,255) #E8DC57FF srgba(232,220,87,1)
+     69119: (232,232,231,255) #E8E8E7FF srgba(232,232,231,1)
+         4: (233,221, 87,255) #E9DD57FF srgba(233,221,87,1)
+        42: (234,221, 87,255) #EADD57FF srgba(234,221,87,1)
+        15: (234,222, 86,255) #EADE56FF srgba(234,222,86,1)
+         8: (235,222, 86,255) #EBDE56FF srgba(235,222,86,1)
+        13: (236,223, 86,255) #ECDF56FF srgba(236,223,86,1)
+         3: (237,224, 85,255) #EDE055FF srgba(237,224,85,1)
+        22: (238,224, 85,255) #EEE055FF srgba(238,224,85,1)
+         8: (239,224, 84,255) #EFE054FF srgba(239,224,84,1)
+        17: (240,225, 84,255) #F0E154FF srgba(240,225,84,1)
+         7: (241,226, 84,255) #F1E254FF srgba(241,226,84,1)
+        14: (242,226, 83,255) #F2E253FF srgba(242,226,83,1)
+         4: (242,227, 83,255) #F2E353FF srgba(242,227,83,1)
+        10: (243,227, 83,255) #F3E353FF srgba(243,227,83,1)
+        25: (244,228, 82,255) #F4E452FF srgba(244,228,82,1)
+         3: (245,229, 82,255) #F5E552FF srgba(245,229,82,1)
+        13: (246,229, 82,255) #F6E552FF srgba(246,229,82,1)
+        25: (246,230, 82,255) #F6E652FF srgba(246,230,82,1)
+        11: (247,229, 81,255) #F7E551FF srgba(247,229,81,1)
+        14: (248,230, 80,255) #F8E650FF srgba(248,230,80,1)
+         3: (249,231, 81,255) #F9E751FF srgba(249,231,81,1)
+        12: (250,231, 80,255) #FAE750FF srgba(250,231,80,1)
+         5: (250,232, 79,255) #FAE84FFF srgba(250,232,79,1)
+        19: (251,232, 80,255) #FBE850FF srgba(251,232,80,1)
+       882: (252,233, 79,255) #FCE94FFF srgba(252,233,79,1)
+  Rendering intent: Perceptual
+  Gamma: 0.454545
+  Chromaticity:
+    red primary: (0.64,0.33)
+    green primary: (0.3,0.6)
+    blue primary: (0.15,0.06)
+    white point: (0.3127,0.329)
+  Background color: white
+  Border color: srgba(223,223,223,1)
+  Matte color: grey74
+  Transparent color: none
+  Interlace: None
+  Intensity: Undefined
+  Compose: Over
+  Page geometry: 1920x1080+0+0
+  Dispose: Undefined
+  Iterations: 0
+  Compression: Zip
+  Orientation: Undefined
+  Properties:
+    date:create: 2016-08-21T15:18:57+01:00
+    date:modify: 2016-08-21T15:18:57+01:00
+    png:bKGD: chunk was found (see Background color, above)
+    png:IHDR.bit-depth-orig: 8
+    png:IHDR.bit_depth: 8
+    png:IHDR.color-type-orig: 6
+    png:IHDR.color_type: 6 (RGBA)
+    png:IHDR.interlace_method: 0 (Not interlaced)
+    png:IHDR.width,height: 1920, 1080
+    png:pHYs: x_res=2835, y_res=2835, units=1
+    png:sRGB: intent=0 (Perceptual Intent)
+    png:tIME: 2016-08-08T21:04:28Z
+    signature: 1d6beb4912b57dccdbe07d81279a116d866fdd29bc955f5e79215ac148b0ae75
+  Artifacts:
+    filename: /tmp/wi5Fnv_attachmentView.png
+    verbose: true
+  Tainted: False
+  Filesize: 57.5KB
+  Number pixels: 2.074M
+  Pixels per second: 414.72GB
+  User time: 0.000u
+  Elapsed time: 0:01.000
+  Version: ImageMagick 6.9.3-0 Q16 x86_64 2016-02-03 http://www.imagemagick.org
diff --git a/contrib/keybase/images/pagerMode.png b/contrib/keybase/images/pagerMode.png
new file mode 100644
index 0000000..52d5989
--- /dev/null
+++ b/contrib/keybase/images/pagerMode.png
@@ -0,0 +1,854 @@
+Image: /tmp/cctdBe_pagerMode.png
+  Format: PNG (Portable Network Graphics)
+  Mime type: image/png
+  Class: DirectClass
+  Geometry: 1920x1080+0+0
+  Resolution: 28.35x28.35
+  Print size: 67.7249x38.0952
+  Units: PixelsPerCentimeter
+  Type: TrueColorAlpha
+  Endianess: Undefined
+  Colorspace: sRGB
+  Depth: 8-bit
+  Channel depth:
+    red: 8-bit
+    green: 8-bit
+    blue: 8-bit
+    alpha: 1-bit
+  Channel statistics:
+    Pixels: 2073600
+    Red:
+      min: 0 (0)
+      max: 252 (0.988235)
+      mean: 11.7944 (0.0462526)
+      standard deviation: 44.941 (0.176239)
+      kurtosis: 18.4131
+      skewness: 4.39526
+      entropy: 0.105298
+    Green:
+      min: 0 (0)
+      max: 233 (0.913725)
+      mean: 16.1722 (0.0634204)
+      standard deviation: 50.6401 (0.198589)
+      kurtosis: 10.1704
+      skewness: 3.31685
+      entropy: 0.107892
+    Blue:
+      min: 0 (0)
+      max: 231 (0.905882)
+      mean: 18.5708 (0.0728267)
+      standard deviation: 55.6317 (0.218164)
+      kurtosis: 6.86178
+      skewness: 2.88999
+      entropy: 0.11074
+    Alpha:
+      min: 255 (1)
+      max: 255 (1)
+      mean: 255 (1)
+      standard deviation: 0 (0)
+      kurtosis: 0
+      skewness: 0
+      entropy: 0
+  Image statistics:
+    Overall:
+      min: 0 (0)
+      max: 252 (0.988235)
+      mean: 11.6344 (0.0456249)
+      standard deviation: 43.815 (0.171823)
+      kurtosis: 16.7758
+      skewness: 4.23948
+      entropy: 0.0809827
+  Colors: 749
+  Histogram:
+   1827461: (  0,  0,  0,255) #000000FF black
+       195: (  0,  0,  1,255) #000001FF srgba(0,0,1,1)
+        33: (  0,  0,  2,255) #000002FF srgba(0,0,2,1)
+         3: (  0,  0,  3,255) #000003FF srgba(0,0,3,1)
+         7: (  0,  1,  0,255) #000100FF srgba(0,1,0,1)
+       114: (  0,  1,  1,255) #000101FF srgba(0,1,1,1)
+         8: (  0,  1,  2,255) #000102FF srgba(0,1,2,1)
+         7: (  0,  1,  3,255) #000103FF srgba(0,1,3,1)
+         9: (  0,  1,  4,255) #000104FF srgba(0,1,4,1)
+        64: (  0,  2,  2,255) #000202FF srgba(0,2,2,1)
+         1: (  0,  2,  3,255) #000203FF srgba(0,2,3,1)
+         9: (  0,  2,  5,255) #000205FF srgba(0,2,5,1)
+         3: (  0,  2,  6,255) #000206FF srgba(0,2,6,1)
+        21: (  0,  3,  3,255) #000303FF srgba(0,3,3,1)
+        95: (  0,  4,  4,255) #000404FF srgba(0,4,4,1)
+        62: (  0,  5,  5,255) #000505FF srgba(0,5,5,1)
+        42: (  0,  6,  6,255) #000606FF srgba(0,6,6,1)
+        56: (  0,  7,  7,255) #000707FF srgba(0,7,7,1)
+        36: (  0,  8,  8,255) #000808FF srgba(0,8,8,1)
+        12: (  0,  9,  9,255) #000909FF srgba(0,9,9,1)
+        44: (  0, 10, 10,255) #000A0AFF srgba(0,10,10,1)
+        54: (  0, 11, 11,255) #000B0BFF srgba(0,11,11,1)
+        29: (  0, 12, 12,255) #000C0CFF srgba(0,12,12,1)
+         7: (  0, 13, 13,255) #000D0DFF srgba(0,13,13,1)
+         3: (  1,  0,  0,255) #010000FF srgba(1,0,0,1)
+         4: (  1,  0,  1,255) #010001FF srgba(1,0,1,1)
+         1: (  1,  1,  0,255) #010100FF srgba(1,1,0,1)
+       156: (  1,  1,  1,255) #010101FF srgba(1,1,1,1)
+        17: (  1,  1,  2,255) #010102FF srgba(1,1,2,1)
+         2: (  1,  1,  4,255) #010104FF srgba(1,1,4,1)
+         4: (  1,  2,  2,255) #010202FF srgba(1,2,2,1)
+         2: (  1,  2,  4,255) #010204FF srgba(1,2,4,1)
+         1: (  1,  2,  5,255) #010205FF srgba(1,2,5,1)
+         2: (  1,  3,  6,255) #010306FF srgba(1,3,6,1)
+        15: (  1, 13, 13,255) #010D0DFF srgba(1,13,13,1)
+        22: (  1, 14, 14,255) #010E0EFF srgba(1,14,14,1)
+         9: (  1, 15, 15,255) #010F0FFF srgba(1,15,15,1)
+         8: (  1, 15, 16,255) #010F10FF srgba(1,15,16,1)
+        22: (  1, 16, 16,255) #011010FF srgba(1,16,16,1)
+         4: (  1, 17, 17,255) #011111FF srgba(1,17,17,1)
+         5: (  1, 17, 18,255) #011112FF srgba(1,17,18,1)
+        11: (  1, 18, 18,255) #011212FF srgba(1,18,18,1)
+         3: (  1, 18, 19,255) #011213FF srgba(1,18,19,1)
+        21: (  1, 19, 19,255) #011313FF srgba(1,19,19,1)
+         6: (  1, 20, 20,255) #011414FF srgba(1,20,20,1)
+        15: (  1, 20, 21,255) #011415FF srgba(1,20,21,1)
+        51: (  1, 21, 21,255) #011515FF srgba(1,21,21,1)
+         9: (  1, 21, 22,255) #011516FF srgba(1,21,22,1)
+        14: (  1, 22, 22,255) #011616FF srgba(1,22,22,1)
+         8: (  1, 23, 23,255) #011717FF srgba(1,23,23,1)
+        51: (  1, 23, 24,255) #011718FF srgba(1,23,24,1)
+         9: (  1, 24, 24,255) #011818FF srgba(1,24,24,1)
+        23: (  1, 24, 25,255) #011819FF srgba(1,24,25,1)
+        10: (  1, 25, 25,255) #011919FF srgba(1,25,25,1)
+        18: (  1, 26, 26,255) #011A1AFF srgba(1,26,26,1)
+        17: (  1, 26, 27,255) #011A1BFF srgba(1,26,27,1)
+        20: (  1, 27, 27,255) #011B1BFF srgba(1,27,27,1)
+        12: (  1, 27, 28,255) #011B1CFF srgba(1,27,28,1)
+        35: (  1, 28, 28,255) #011C1CFF srgba(1,28,28,1)
+        14: (  1, 29, 29,255) #011D1DFF srgba(1,29,29,1)
+         9: (  1, 29, 30,255) #011D1EFF srgba(1,29,30,1)
+         8: (  1, 30, 30,255) #011E1EFF srgba(1,30,30,1)
+        17: (  1, 30, 31,255) #011E1FFF srgba(1,30,31,1)
+         9: (  1, 31, 31,255) #011F1FFF srgba(1,31,31,1)
+        10: (  1, 32, 32,255) #012020FF srgba(1,32,32,1)
+        12: (  1, 32, 33,255) #012021FF srgba(1,32,33,1)
+        54: (  1, 33, 33,255) #012121FF srgba(1,33,33,1)
+        14: (  1, 33, 34,255) #012122FF srgba(1,33,34,1)
+         7: (  1, 34, 34,255) #012222FF srgba(1,34,34,1)
+         5: (  1, 35, 35,255) #012323FF srgba(1,35,35,1)
+        26: (  1, 35, 36,255) #012324FF srgba(1,35,36,1)
+         8: (  1, 36, 36,255) #012424FF srgba(1,36,36,1)
+        13: (  1, 36, 37,255) #012425FF srgba(1,36,37,1)
+         5: (  1, 37, 37,255) #012525FF srgba(1,37,37,1)
+       113: (  1, 38, 38,255) #012626FF srgba(1,38,38,1)
+         1: (  2,  1,  2,255) #020102FF srgba(2,1,2,1)
+        71: (  2,  2,  2,255) #020202FF srgba(2,2,2,1)
+         1: (  2,  2,  3,255) #020203FF srgba(2,2,3,1)
+         1: (  2,  3,  6,255) #020306FF srgba(2,3,6,1)
+         1: (  2,  4,  7,255) #020407FF srgba(2,4,7,1)
+         2: (  2, 38, 39,255) #022627FF srgba(2,38,39,1)
+         8: (  2, 39, 39,255) #022727FF srgba(2,39,39,1)
+        12: (  2, 39, 40,255) #022728FF srgba(2,39,40,1)
+        33: (  2, 40, 40,255) #022828FF srgba(2,40,40,1)
+         2: (  2, 41, 41,255) #022929FF srgba(2,41,41,1)
+         9: (  2, 41, 42,255) #02292AFF srgba(2,41,42,1)
+         1: (  2, 42, 42,255) #022A2AFF srgba(2,42,42,1)
+        67: (  2, 42, 43,255) #022A2BFF srgba(2,42,43,1)
+        10: (  2, 43, 43,255) #022B2BFF srgba(2,43,43,1)
+        10: (  2, 44, 44,255) #022C2CFF srgba(2,44,44,1)
+        15: (  2, 44, 45,255) #022C2DFF srgba(2,44,45,1)
+        71: (  2, 45, 45,255) #022D2DFF srgba(2,45,45,1)
+        17: (  2, 45, 46,255) #022D2EFF srgba(2,45,46,1)
+        24: (  2, 46, 47,255) #022E2FFF srgba(2,46,47,1)
+        19: (  2, 47, 48,255) #022F30FF srgba(2,47,48,1)
+         5: (  2, 48, 48,255) #023030FF srgba(2,48,48,1)
+         9: (  2, 48, 49,255) #023031FF srgba(2,48,49,1)
+        57: (  2, 49, 50,255) #023132FF srgba(2,49,50,1)
+         9: (  2, 50, 51,255) #023233FF srgba(2,50,51,1)
+         9: (  2, 51, 51,255) #023333FF srgba(2,51,51,1)
+        13: (  2, 51, 52,255) #023334FF srgba(2,51,52,1)
+        52: (  2, 52, 53,255) #023435FF srgba(2,52,53,1)
+        25: (  2, 53, 54,255) #023536FF srgba(2,53,54,1)
+         9: (  2, 54, 54,255) #023636FF srgba(2,54,54,1)
+        29: (  2, 54, 55,255) #023637FF srgba(2,54,55,1)
+         6: (  2, 55, 56,255) #023738FF srgba(2,55,56,1)
+         7: (  2, 56, 57,255) #023839FF srgba(2,56,57,1)
+         7: (  2, 57, 57,255) #023939FF srgba(2,57,57,1)
+        20: (  2, 57, 58,255) #02393AFF srgba(2,57,58,1)
+        24: (  2, 58, 59,255) #023A3BFF srgba(2,58,59,1)
+        76: (  2, 59, 60,255) #023B3CFF srgba(2,59,60,1)
+         5: (  2, 60, 60,255) #023C3CFF srgba(2,60,60,1)
+         7: (  2, 60, 61,255) #023C3DFF srgba(2,60,61,1)
+        38: (  2, 61, 62,255) #023D3EFF srgba(2,61,62,1)
+         4: (  2, 62, 63,255) #023E3FFF srgba(2,62,63,1)
+         5: (  2, 63, 63,255) #023F3FFF srgba(2,63,63,1)
+         5: (  2, 63, 64,255) #023F40FF srgba(2,63,64,1)
+         1: (  3,  3,  2,255) #030302FF srgba(3,3,2,1)
+       135: (  3,  3,  3,255) #030303FF grey1
+         1: (  3,  3,  4,255) #030304FF srgba(3,3,4,1)
+         1: (  3,  4,  4,255) #030404FF srgba(3,4,4,1)
+       117: (  3, 64, 65,255) #034041FF srgba(3,64,65,1)
+        14: (  3, 65, 66,255) #034142FF srgba(3,65,66,1)
+        10: (  3, 66, 66,255) #034242FF srgba(3,66,66,1)
+        32: (  3, 66, 67,255) #034243FF srgba(3,66,67,1)
+        18: (  3, 67, 68,255) #034344FF srgba(3,67,68,1)
+         7: (  3, 68, 69,255) #034445FF srgba(3,68,69,1)
+        12: (  3, 69, 69,255) #034545FF srgba(3,69,69,1)
+         2: (  3, 69, 70,255) #034546FF srgba(3,69,70,1)
+        27: (  3, 70, 71,255) #034647FF srgba(3,70,71,1)
+         9: (  3, 71, 72,255) #034748FF srgba(3,71,72,1)
+         8: (  3, 72, 72,255) #034848FF srgba(3,72,72,1)
+        21: (  3, 72, 73,255) #034849FF srgba(3,72,73,1)
+        24: (  3, 73, 74,255) #03494AFF srgba(3,73,74,1)
+         2: (  3, 74, 75,255) #034A4BFF srgba(3,74,75,1)
+        17: (  3, 75, 75,255) #034B4BFF srgba(3,75,75,1)
+         6: (  3, 75, 76,255) #034B4CFF srgba(3,75,76,1)
+        65: (  3, 76, 77,255) #034C4DFF srgba(3,76,77,1)
+         8: (  3, 77, 78,255) #034D4EFF srgba(3,77,78,1)
+        14: (  3, 77, 79,255) #034D4FFF srgba(3,77,79,1)
+        20: (  3, 78, 79,255) #034E4FFF srgba(3,78,79,1)
+        31: (  3, 79, 80,255) #034F50FF srgba(3,79,80,1)
+         3: (  3, 80, 81,255) #035051FF srgba(3,80,81,1)
+        16: (  3, 80, 82,255) #035052FF srgba(3,80,82,1)
+        14: (  3, 81, 82,255) #035152FF srgba(3,81,82,1)
+        20: (  3, 82, 83,255) #035253FF srgba(3,82,83,1)
+        18: (  3, 83, 84,255) #035354FF srgba(3,83,84,1)
+         8: (  3, 83, 85,255) #035355FF srgba(3,83,85,1)
+         1: (  3, 84, 85,255) #035455FF srgba(3,84,85,1)
+        13: (  3, 85, 86,255) #035556FF srgba(3,85,86,1)
+         3: (  3, 86, 87,255) #035657FF srgba(3,86,87,1)
+         5: (  3, 86, 88,255) #035658FF srgba(3,86,88,1)
+         8: (  3, 87, 88,255) #035758FF srgba(3,87,88,1)
+        26: (  3, 88, 89,255) #035859FF srgba(3,88,89,1)
+         5: (  4,  4,  3,255) #040403FF srgba(4,4,3,1)
+        49: (  4,  4,  4,255) #040404FF srgba(4,4,4,1)
+         2: (  4,  4,  5,255) #040405FF srgba(4,4,5,1)
+         1: (  4,  4,  6,255) #040406FF srgba(4,4,6,1)
+         6: (  4,  5,  4,255) #040504FF srgba(4,5,4,1)
+         1: (  4,  5,  5,255) #040505FF srgba(4,5,5,1)
+         7: (  4, 89, 90,255) #04595AFF srgba(4,89,90,1)
+        14: (  4, 89, 91,255) #04595BFF srgba(4,89,91,1)
+         2: (  4, 90, 91,255) #045A5BFF srgba(4,90,91,1)
+        19: (  4, 91, 92,255) #045B5CFF srgba(4,91,92,1)
+        10: (  4, 92, 93,255) #045C5DFF srgba(4,92,93,1)
+        16: (  4, 92, 94,255) #045C5EFF srgba(4,92,94,1)
+        12: (  4, 93, 94,255) #045D5EFF srgba(4,93,94,1)
+        17: (  4, 94, 95,255) #045E5FFF srgba(4,94,95,1)
+        11: (  4, 95, 96,255) #045F60FF srgba(4,95,96,1)
+        11: (  4, 95, 97,255) #045F61FF srgba(4,95,97,1)
+         9: (  4, 96, 97,255) #046061FF srgba(4,96,97,1)
+        13: (  4, 97, 98,255) #046162FF srgba(4,97,98,1)
+         4: (  4, 98, 99,255) #046263FF srgba(4,98,99,1)
+         5: (  4, 98,100,255) #046264FF srgba(4,98,100,1)
+         6: (  4, 99,100,255) #046364FF srgba(4,99,100,1)
+         9: (  4,100,101,255) #046465FF srgba(4,100,101,1)
+         8: (  4,101,102,255) #046566FF srgba(4,101,102,1)
+        17: (  4,101,103,255) #046567FF srgba(4,101,103,1)
+       117: (  4,102,103,255) #046667FF srgba(4,102,103,1)
+        18: (  4,103,104,255) #046768FF srgba(4,103,104,1)
+         9: (  4,104,105,255) #046869FF srgba(4,104,105,1)
+        17: (  4,104,106,255) #04686AFF srgba(4,104,106,1)
+        23: (  4,105,106,255) #04696AFF srgba(4,105,106,1)
+        46: (  4,106,107,255) #046A6BFF srgba(4,106,107,1)
+        13: (  4,107,108,255) #046B6CFF srgba(4,107,108,1)
+         4: (  4,107,109,255) #046B6DFF srgba(4,107,109,1)
+         3: (  4,108,109,255) #046C6DFF srgba(4,108,109,1)
+        15: (  4,108,110,255) #046C6EFF srgba(4,108,110,1)
+         3: (  4,109,111,255) #046D6FFF srgba(4,109,111,1)
+         7: (  4,110,111,255) #046E6FFF srgba(4,110,111,1)
+         8: (  4,110,112,255) #046E70FF srgba(4,110,112,1)
+        26: (  4,111,112,255) #046F70FF srgba(4,111,112,1)
+         7: (  4,111,113,255) #046F71FF srgba(4,111,113,1)
+         5: (  4,112,114,255) #047072FF srgba(4,112,114,1)
+        15: (  4,113,114,255) #047172FF srgba(4,113,114,1)
+        19: (  4,113,115,255) #047173FF srgba(4,113,115,1)
+        45: (  4,114,115,255) #047273FF srgba(4,114,115,1)
+        35: (  5,  5,  5,255) #050505FF grey2
+         1: (  5,  6,  6,255) #050606FF srgba(5,6,6,1)
+        17: (  5,114,116,255) #057274FF srgba(5,114,116,1)
+         1: (  5,115,117,255) #057375FF srgba(5,115,117,1)
+        14: (  5,116,117,255) #057475FF srgba(5,116,117,1)
+        66: (  5,116,118,255) #057476FF srgba(5,116,118,1)
+        11: (  5,117,118,255) #057576FF srgba(5,117,118,1)
+         6: (  5,118,120,255) #057678FF srgba(5,118,120,1)
+         7: (  5,119,120,255) #057778FF srgba(5,119,120,1)
+         2: (  5,119,121,255) #057779FF srgba(5,119,121,1)
+         6: (  5,120,122,255) #05787AFF srgba(5,120,122,1)
+        30: (  5,121,123,255) #05797BFF srgba(5,121,123,1)
+        12: (  5,123,124,255) #057B7CFF srgba(5,123,124,1)
+         8: (  5,123,125,255) #057B7DFF srgba(5,123,125,1)
+         7: (  5,124,126,255) #057C7EFF srgba(5,124,126,1)
+         1: (  5,125,126,255) #057D7EFF srgba(5,125,126,1)
+         8: (  5,125,127,255) #057D7FFF srgba(5,125,127,1)
+         4: (  5,126,127,255) #057E7FFF srgba(5,126,127,1)
+         5: (  5,126,128,255) #057E80FF srgba(5,126,128,1)
+         6: (  5,127,129,255) #057F81FF srgba(5,127,129,1)
+        13: (  5,128,129,255) #058081FF srgba(5,128,129,1)
+        55: (  5,128,130,255) #058082FF srgba(5,128,130,1)
+         2: (  5,129,130,255) #058182FF srgba(5,129,130,1)
+         3: (  5,129,131,255) #058183FF srgba(5,129,131,1)
+        26: (  5,130,132,255) #058284FF srgba(5,130,132,1)
+         5: (  5,131,132,255) #058384FF srgba(5,131,132,1)
+        20: (  5,131,133,255) #058385FF srgba(5,131,133,1)
+        15: (  5,132,133,255) #058485FF srgba(5,132,133,1)
+         3: (  5,132,134,255) #058486FF srgba(5,132,134,1)
+        73: (  5,133,135,255) #058587FF srgba(5,133,135,1)
+         6: (  5,134,135,255) #058687FF srgba(5,134,135,1)
+         2: (  5,134,136,255) #058688FF srgba(5,134,136,1)
+        10: (  5,135,136,255) #058788FF srgba(5,135,136,1)
+        14: (  5,135,137,255) #058789FF srgba(5,135,137,1)
+         8: (  5,136,138,255) #05888AFF srgba(5,136,138,1)
+        12: (  5,137,138,255) #05898AFF srgba(5,137,138,1)
+        12: (  5,137,139,255) #05898BFF srgba(5,137,139,1)
+        14: (  5,138,140,255) #058A8CFF srgba(5,138,140,1)
+        24: (  5,139,141,255) #058B8DFF srgba(5,139,141,1)
+         1: (  6,  6,  5,255) #060605FF srgba(6,6,5,1)
+        20: (  6,  6,  6,255) #060606FF srgba(6,6,6,1)
+         1: (  6,  7,  6,255) #060706FF srgba(6,7,6,1)
+         1: (  6,  7,  8,255) #060708FF srgba(6,7,8,1)
+         1: (  6,  8, 11,255) #06080BFF srgba(6,8,11,1)
+         6: (  6,139,141,255) #068B8DFF srgba(6,139,141,1)
+        10: (  6,140,142,255) #068C8EFF srgba(6,140,142,1)
+        42: (  6,141,143,255) #068D8FFF srgba(6,141,143,1)
+        40: (  6,142,144,255) #068E90FF srgba(6,142,144,1)
+        15: (  6,143,145,255) #068F91FF srgba(6,143,145,1)
+        20: (  6,144,146,255) #069092FF srgba(6,144,146,1)
+        40: (  6,145,147,255) #069193FF srgba(6,145,147,1)
+        31: (  6,146,148,255) #069294FF srgba(6,146,148,1)
+        28: (  6,147,149,255) #069395FF srgba(6,147,149,1)
+        39: (  6,148,150,255) #069496FF srgba(6,148,150,1)
+        23: (  6,149,151,255) #069597FF srgba(6,149,151,1)
+       132: (  6,150,152,255) #069698FF srgba(6,150,152,1)
+       109: (  6,151,153,255) #069799FF srgba(6,151,153,1)
+     29532: (  6,152,154,255) #06989AFF srgba(6,152,154,1)
+        21: (  7,  7,  6,255) #070706FF srgba(7,7,6,1)
+        84: (  7,  7,  7,255) #070707FF srgba(7,7,7,1)
+        22: (  7,  8,  7,255) #070807FF srgba(7,8,7,1)
+         1: (  7,  8,  9,255) #070809FF srgba(7,8,9,1)
+         1: (  7,  9, 12,255) #07090CFF srgba(7,9,12,1)
+         1: (  8,  8,  7,255) #080807FF srgba(8,8,7,1)
+        11: (  8,  8,  8,255) #080808FF grey3
+         1: (  8,  9,  8,255) #080908FF srgba(8,9,8,1)
+         3: (  8,  9,  9,255) #080909FF srgba(8,9,9,1)
+         1: (  9,  9,  8,255) #090908FF srgba(9,9,8,1)
+        24: (  9,  9,  9,255) #090909FF srgba(9,9,9,1)
+         1: (  9, 10,  9,255) #090A09FF srgba(9,10,9,1)
+        27: ( 10, 10, 10,255) #0A0A0AFF grey4
+         6: ( 11, 11, 11,255) #0B0B0BFF srgba(11,11,11,1)
+         5: ( 12, 12, 11,255) #0C0C0BFF srgba(12,12,11,1)
+         1: ( 12, 12, 12,255) #0C0C0CFF srgba(12,12,12,1)
+         9: ( 12, 13, 12,255) #0C0D0CFF srgba(12,13,12,1)
+         1: ( 13, 13, 12,255) #0D0D0CFF srgba(13,13,12,1)
+        41: ( 13, 13, 13,255) #0D0D0DFF grey5
+        10: ( 14, 14, 14,255) #0E0E0EFF srgba(14,14,14,1)
+        24: ( 15, 15, 15,255) #0F0F0FFF grey6
+         2: ( 15, 16, 15,255) #0F100FFF srgba(15,16,15,1)
+        14: ( 16, 16, 15,255) #10100FFF srgba(16,16,15,1)
+         6: ( 16, 16, 16,255) #101010FF srgba(16,16,16,1)
+        23: ( 16, 17, 16,255) #101110FF srgba(16,17,16,1)
+         1: ( 17, 17, 17,255) #111111FF srgba(17,17,17,1)
+         1: ( 17, 17, 18,255) #111112FF srgba(17,17,18,1)
+         6: ( 17, 18, 17,255) #111211FF srgba(17,18,17,1)
+        28: ( 18, 18, 18,255) #121212FF grey7
+         1: ( 18, 19, 20,255) #121314FF srgba(18,19,20,1)
+         1: ( 19, 19, 18,255) #131312FF srgba(19,19,18,1)
+         3: ( 19, 19, 19,255) #131313FF srgba(19,19,19,1)
+         2: ( 19, 20, 20,255) #131414FF srgba(19,20,20,1)
+        13: ( 20, 20, 19,255) #141413FF srgba(20,20,19,1)
+        11: ( 21, 21, 20,255) #151514FF srgba(21,21,20,1)
+         3: ( 21, 21, 21,255) #151515FF srgba(21,21,21,1)
+        12: ( 21, 22, 21,255) #151615FF srgba(21,22,21,1)
+        18: ( 22, 23, 22,255) #161716FF srgba(22,23,22,1)
+        24: ( 23, 24, 23,255) #171817FF srgba(23,24,23,1)
+        19: ( 24, 24, 24,255) #181818FF srgba(24,24,24,1)
+         4: ( 25, 25, 24,255) #191918FF srgba(25,25,24,1)
+        16: ( 25, 26, 25,255) #191A19FF srgba(25,26,25,1)
+         8: ( 26, 26, 25,255) #1A1A19FF srgba(26,26,25,1)
+        90: ( 26, 26, 26,255) #1A1A1AFF grey10
+       935: ( 26, 27, 26,255) #1A1B1AFF srgba(26,27,26,1)
+         1: ( 26, 27, 28,255) #1A1B1CFF srgba(26,27,28,1)
+        73: ( 27, 27, 27,255) #1B1B1BFF srgba(27,27,27,1)
+        19: ( 27, 28, 27,255) #1B1C1BFF srgba(27,28,27,1)
+      3160: ( 28, 28, 28,255) #1C1C1CFF grey11
+         8: ( 28, 29, 28,255) #1C1D1CFF srgba(28,29,28,1)
+        19: ( 29, 30, 28,255) #1D1E1CFF srgba(29,30,28,1)
+       867: ( 30, 30, 29,255) #1E1E1DFF srgba(30,30,29,1)
+     32137: ( 30, 30, 30,255) #1E1E1EFF srgba(30,30,30,1)
+         3: ( 31, 31, 30,255) #1F1F1EFF srgba(31,31,30,1)
+         2: ( 31, 32, 31,255) #1F201FFF srgba(31,32,31,1)
+        12: ( 32, 33, 32,255) #202120FF srgba(32,33,32,1)
+       132: ( 33, 34, 32,255) #212220FF srgba(33,34,32,1)
+        17: ( 34, 35, 33,255) #222321FF srgba(34,35,33,1)
+        21: ( 35, 35, 34,255) #232322FF srgba(35,35,34,1)
+        10: ( 36, 36, 35,255) #242423FF srgba(36,36,35,1)
+         2: ( 36, 37, 36,255) #242524FF srgba(36,37,36,1)
+         2: ( 37, 38, 36,255) #252624FF srgba(37,38,36,1)
+         8: ( 38, 39, 37,255) #262725FF srgba(38,39,37,1)
+        20: ( 39, 40, 38,255) #272826FF srgba(39,40,38,1)
+        17: ( 40, 40, 39,255) #282827FF srgba(40,40,39,1)
+        17: ( 41, 41, 40,255) #292928FF srgba(41,41,40,1)
+         5: ( 41, 42, 41,255) #292A29FF srgba(41,42,41,1)
+        47: ( 43, 44, 42,255) #2B2C2AFF srgba(43,44,42,1)
+         1: ( 44, 45, 43,255) #2C2D2BFF srgba(44,45,43,1)
+         2: ( 45, 46, 44,255) #2D2E2CFF srgba(45,46,44,1)
+         9: ( 46, 46, 45,255) #2E2E2DFF srgba(46,46,45,1)
+        41: ( 46, 47, 45,255) #2E2F2DFF srgba(46,47,45,1)
+         8: ( 47, 48, 46,255) #2F302EFF srgba(47,48,46,1)
+         2: ( 48, 49, 47,255) #30312FFF srgba(48,49,47,1)
+         5: ( 49, 50, 48,255) #313230FF srgba(49,50,48,1)
+        35: ( 50, 51, 49,255) #323331FF srgba(50,51,49,1)
+        11: ( 51, 52, 50,255) #333432FF srgba(51,52,50,1)
+        24: ( 52, 53, 51,255) #343533FF srgba(52,53,51,1)
+     90468: ( 52,101,164,255) #3465A4FF srgba(52,101,164,1)
+        54: ( 53, 54, 52,255) #353634FF srgba(53,54,52,1)
+        28: ( 53,102,163,255) #3566A3FF srgba(53,102,163,1)
+        22: ( 54, 55, 53,255) #363735FF srgba(54,55,53,1)
+        34: ( 54,102,164,255) #3666A4FF srgba(54,102,164,1)
+        29: ( 54,103,163,255) #3667A3FF srgba(54,103,163,1)
+        28: ( 55, 56, 54,255) #373836FF srgba(55,56,54,1)
+        37: ( 55,103,162,255) #3767A2FF srgba(55,103,162,1)
+        20: ( 56, 57, 55,255) #383937FF srgba(56,57,55,1)
+        32: ( 56,104,162,255) #3868A2FF srgba(56,104,162,1)
+        12: ( 57, 58, 56,255) #393A38FF srgba(57,58,56,1)
+        27: ( 57,104,162,255) #3968A2FF srgba(57,104,162,1)
+        19: ( 58, 59, 57,255) #3A3B39FF srgba(58,59,57,1)
+        15: ( 58,104,161,255) #3A68A1FF srgba(58,104,161,1)
+        34: ( 58,105,161,255) #3A69A1FF srgba(58,105,161,1)
+         9: ( 59, 60, 58,255) #3B3C3AFF srgba(59,60,58,1)
+        17: ( 59,105,161,255) #3B69A1FF srgba(59,105,161,1)
+        11: ( 60, 61, 58,255) #3C3D3AFF srgba(60,61,58,1)
+         5: ( 60, 62, 59,255) #3C3E3BFF srgba(60,62,59,1)
+        23: ( 60,106,161,255) #3C6AA1FF srgba(60,106,161,1)
+         7: ( 61, 62, 60,255) #3D3E3CFF srgba(61,62,60,1)
+        10: ( 61,107,160,255) #3D6BA0FF srgba(61,107,160,1)
+        16: ( 62, 63, 61,255) #3E3F3DFF srgba(62,63,61,1)
+        99: ( 62,107,160,255) #3E6BA0FF srgba(62,107,160,1)
+        15: ( 62,108,160,255) #3E6CA0FF srgba(62,108,160,1)
+        65: ( 63, 64, 62,255) #3F403EFF srgba(63,64,62,1)
+         3: ( 63,108,159,255) #3F6C9FFF srgba(63,108,159,1)
+        20: ( 64, 65, 63,255) #40413FFF srgba(64,65,63,1)
+        42: ( 64, 66, 63,255) #40423FFF srgba(64,66,63,1)
+         1: ( 64,109,159,255) #406D9FFF srgba(64,109,159,1)
+         5: ( 65, 67, 64,255) #414340FF srgba(65,67,64,1)
+        24: ( 65,110,159,255) #416E9FFF srgba(65,110,159,1)
+        33: ( 66, 67, 65,255) #424341FF srgba(66,67,65,1)
+         9: ( 66,110,158,255) #426E9EFF srgba(66,110,158,1)
+         1: ( 67, 68, 66,255) #434442FF srgba(67,68,66,1)
+        22: ( 67,110,158,255) #436E9EFF srgba(67,110,158,1)
+        30: ( 68, 69, 67,255) #444543FF srgba(68,69,67,1)
+        16: ( 68,111,157,255) #446F9DFF srgba(68,111,157,1)
+        13: ( 69, 70, 67,255) #454643FF srgba(69,70,67,1)
+        78: ( 69, 71, 68,255) #454744FF srgba(69,71,68,1)
+        14: ( 69,112,156,255) #45709CFF srgba(69,112,156,1)
+        26: ( 70, 72, 69,255) #464845FF srgba(70,72,69,1)
+         2: ( 70,112,157,255) #46709DFF srgba(70,112,157,1)
+        11: ( 70,113,156,255) #46719CFF srgba(70,113,156,1)
+        17: ( 71, 72, 70,255) #474846FF srgba(71,72,70,1)
+        75: ( 71,113,156,255) #47719CFF srgba(71,113,156,1)
+        15: ( 72, 73, 71,255) #484947FF srgba(72,73,71,1)
+         4: ( 72,114,156,255) #48729CFF srgba(72,114,156,1)
+        28: ( 73, 74, 71,255) #494A47FF srgba(73,74,71,1)
+        20: ( 73,115,155,255) #49739BFF srgba(73,115,155,1)
+        15: ( 74, 75, 72,255) #4A4B48FF srgba(74,75,72,1)
+         3: ( 74, 76, 73,255) #4A4C49FF srgba(74,76,73,1)
+        38: ( 74,116,155,255) #4A749BFF srgba(74,116,155,1)
+         5: ( 75, 77, 74,255) #4B4D4AFF srgba(75,77,74,1)
+         4: ( 75,116,154,255) #4B749AFF srgba(75,116,154,1)
+        23: ( 76, 78, 75,255) #4C4E4BFF srgba(76,78,75,1)
+        13: ( 76,116,154,255) #4C749AFF srgba(76,116,154,1)
+        12: ( 77, 78, 75,255) #4D4E4BFF srgba(77,78,75,1)
+         2: ( 77,117,153,255) #4D7599FF srgba(77,117,153,1)
+        10: ( 77,117,154,255) #4D759AFF srgba(77,117,154,1)
+         5: ( 78, 79, 76,255) #4E4F4CFF srgba(78,79,76,1)
+        13: ( 78,118,153,255) #4E7699FF srgba(78,118,153,1)
+        21: ( 79, 80, 77,255) #4F504DFF srgba(79,80,77,1)
+        54: ( 79, 81, 78,255) #4F514EFF srgba(79,81,78,1)
+         3: ( 79,119,153,255) #4F7799FF srgba(79,119,153,1)
+         6: ( 80, 82, 79,255) #50524FFF srgba(80,82,79,1)
+         8: ( 80,119,152,255) #507798FF srgba(80,119,152,1)
+        17: ( 81, 83, 80,255) #515350FF srgba(81,83,80,1)
+         8: ( 81,120,151,255) #517897FF srgba(81,120,151,1)
+        36: ( 81,120,152,255) #517898FF srgba(81,120,152,1)
+         9: ( 82, 83, 80,255) #525350FF srgba(82,83,80,1)
+        10: ( 82,121,152,255) #527998FF srgba(82,121,152,1)
+        25: ( 83, 84, 81,255) #535451FF srgba(83,84,81,1)
+         8: ( 83,122,150,255) #537A96FF srgba(83,122,150,1)
+         7: ( 83,122,151,255) #537A97FF srgba(83,122,151,1)
+        10: ( 84, 85, 82,255) #545552FF srgba(84,85,82,1)
+         6: ( 84, 86, 83,255) #545653FF srgba(84,86,83,1)
+         3: ( 84,122,150,255) #547A96FF srgba(84,122,150,1)
+         2: ( 84,122,151,255) #547A97FF srgba(84,122,151,1)
+        14: ( 85, 87, 84,255) #555754FF srgba(85,87,84,1)
+         7: ( 85,123,149,255) #557B95FF srgba(85,123,149,1)
+        30: ( 86,124,150,255) #567C96FF srgba(86,124,150,1)
+        11: ( 87, 89, 85,255) #575955FF srgba(87,89,85,1)
+        20: ( 87,124,149,255) #577C95FF srgba(87,124,149,1)
+         4: ( 88, 89, 86,255) #585956FF srgba(88,89,86,1)
+         5: ( 88,125,148,255) #587D94FF srgba(88,125,148,1)
+        11: ( 88,125,149,255) #587D95FF srgba(88,125,149,1)
+        12: ( 89, 90, 87,255) #595A57FF srgba(89,90,87,1)
+       111: ( 89, 91, 88,255) #595B58FF srgba(89,91,88,1)
+        12: ( 89,126,148,255) #597E94FF srgba(89,126,148,1)
+        12: ( 90, 92, 88,255) #5A5C58FF srgba(90,92,88,1)
+        11: ( 90,127,147,255) #5A7F93FF srgba(90,127,147,1)
+        22: ( 91, 93, 89,255) #5B5D59FF srgba(91,93,89,1)
+        14: ( 91,127,147,255) #5B7F93FF srgba(91,127,147,1)
+         2: ( 92, 94, 90,255) #5C5E5AFF srgba(92,94,90,1)
+        33: ( 92,128,147,255) #5C8093FF srgba(92,128,147,1)
+        16: ( 93, 95, 92,255) #5D5F5CFF srgba(93,95,92,1)
+         9: ( 93,128,146,255) #5D8092FF srgba(93,128,146,1)
+         5: ( 94,129,146,255) #5E8192FF srgba(94,129,146,1)
+        31: ( 95, 97, 93,255) #5F615DFF srgba(95,97,93,1)
+         1: ( 95,129,146,255) #5F8192FF srgba(95,129,146,1)
+        24: ( 96, 98, 94,255) #60625EFF srgba(96,98,94,1)
+       156: ( 96,130,145,255) #608291FF srgba(96,130,145,1)
+        30: ( 97, 99, 95,255) #61635FFF srgba(97,99,95,1)
+         7: ( 97,131,145,255) #618391FF srgba(97,131,145,1)
+         2: ( 98, 99, 96,255) #626360FF srgba(98,99,96,1)
+        29: ( 98,100, 97,255) #626461FF srgba(98,100,97,1)
+       134: ( 98,132,144,255) #628490FF srgba(98,132,144,1)
+        20: ( 99,101, 97,255) #636561FF srgba(99,101,97,1)
+        27: ( 99,132,144,255) #638490FF srgba(99,132,144,1)
+         5: (100,102, 98,255) #646662FF srgba(100,102,98,1)
+         7: (100,133,143,255) #64858FFF srgba(100,133,143,1)
+        21: (100,133,144,255) #648590FF srgba(100,133,144,1)
+         5: (101,103, 99,255) #656763FF srgba(101,103,99,1)
+         8: (101,134,142,255) #65868EFF srgba(101,134,142,1)
+         5: (102,104,100,255) #666864FF srgba(102,104,100,1)
+         8: (102,134,143,255) #66868FFF srgba(102,134,143,1)
+        34: (103,105,101,255) #676965FF srgba(103,105,101,1)
+        18: (103,134,142,255) #67868EFF srgba(103,134,142,1)
+        20: (104,106,102,255) #686A66FF srgba(104,106,102,1)
+        19: (104,135,142,255) #68878EFF srgba(104,135,142,1)
+         5: (105,107,103,255) #696B67FF srgba(105,107,103,1)
+        17: (105,136,141,255) #69888DFF srgba(105,136,141,1)
+       110: (106,108,104,255) #6A6C68FF srgba(106,108,104,1)
+        13: (106,137,141,255) #6A898DFF srgba(106,137,141,1)
+         8: (107,109,105,255) #6B6D69FF srgba(107,109,105,1)
+        11: (107,137,141,255) #6B898DFF srgba(107,137,141,1)
+        12: (108,110,106,255) #6C6E6AFF srgba(108,110,106,1)
+       456: (108,138,140,255) #6C8A8CFF srgba(108,138,140,1)
+        24: (109,111,107,255) #6D6F6BFF srgba(109,111,107,1)
+        11: (109,139,140,255) #6D8B8CFF srgba(109,139,140,1)
+        21: (110,112,108,255) #6E706CFF srgba(110,112,108,1)
+         6: (110,140,139,255) #6E8C8BFF srgba(110,140,139,1)
+        14: (111,113,109,255) #6F716DFF srgba(111,113,109,1)
+        12: (111,139,139,255) #6F8B8BFF srgba(111,139,139,1)
+        16: (112,114,110,255) #70726EFF srgba(112,114,110,1)
+        10: (112,115,110,255) #70736EFF srgba(112,115,110,1)
+        27: (112,140,139,255) #708C8BFF srgba(112,140,139,1)
+         1: (112,141,138,255) #708D8AFF srgba(112,141,138,1)
+        15: (113,115,111,255) #71736FFF srgba(113,115,111,1)
+         6: (114,116,112,255) #727470FF srgba(114,116,112,1)
+         5: (114,142,137,255) #728E89FF srgba(114,142,137,1)
+         9: (115,117,113,255) #737571FF srgba(115,117,113,1)
+        24: (115,142,138,255) #738E8AFF srgba(115,142,138,1)
+         7: (115,143,137,255) #738F89FF srgba(115,143,137,1)
+        21: (116,118,114,255) #747672FF srgba(116,118,114,1)
+         4: (116,144,136,255) #749088FF srgba(116,144,136,1)
+         5: (117,119,114,255) #757772FF srgba(117,119,114,1)
+        11: (117,120,115,255) #757873FF srgba(117,120,115,1)
+        13: (117,144,137,255) #759089FF srgba(117,144,137,1)
+         2: (118,121,116,255) #767974FF srgba(118,121,116,1)
+         1: (118,145,136,255) #769188FF srgba(118,145,136,1)
+        62: (119,121,117,255) #777975FF srgba(119,121,117,1)
+         6: (119,145,135,255) #779187FF srgba(119,145,135,1)
+         4: (119,146,136,255) #779288FF srgba(119,146,136,1)
+        14: (120,122,118,255) #787A76FF srgba(120,122,118,1)
+         5: (120,146,135,255) #789287FF srgba(120,146,135,1)
+        15: (121,123,118,255) #797B76FF srgba(121,123,118,1)
+        24: (121,146,134,255) #799286FF srgba(121,146,134,1)
+        30: (122,124,119,255) #7A7C77FF srgba(122,124,119,1)
+       164: (122,125,120,255) #7A7D78FF srgba(122,125,120,1)
+         5: (122,147,135,255) #7A9387FF srgba(122,147,135,1)
+        20: (123,126,121,255) #7B7E79FF srgba(123,126,121,1)
+        12: (123,147,134,255) #7B9386FF srgba(123,147,134,1)
+        12: (123,148,133,255) #7B9485FF srgba(123,148,133,1)
+         2: (124,126,122,255) #7C7E7AFF srgba(124,126,122,1)
+        18: (124,149,133,255) #7C9585FF srgba(124,149,133,1)
+         6: (125,127,123,255) #7D7F7BFF srgba(125,127,123,1)
+        31: (126,128,123,255) #7E807BFF srgba(126,128,123,1)
+        10: (126,150,133,255) #7E9685FF srgba(126,150,133,1)
+        17: (127,129,124,255) #7F817CFF srgba(127,129,124,1)
+        12: (127,130,125,255) #7F827DFF srgba(127,130,125,1)
+        17: (127,150,132,255) #7F9684FF srgba(127,150,132,1)
+        37: (127,151,132,255) #7F9784FF srgba(127,151,132,1)
+         2: (128,131,126,255) #80837EFF srgba(128,131,126,1)
+         5: (128,152,132,255) #809884FF srgba(128,152,132,1)
+        26: (129,131,127,255) #81837FFF srgba(129,131,127,1)
+        11: (129,152,131,255) #819883FF srgba(129,152,131,1)
+        34: (130,132,127,255) #82847FFF srgba(130,132,127,1)
+        14: (130,152,131,255) #829883FF srgba(130,152,131,1)
+        13: (131,133,128,255) #838580FF srgba(131,133,128,1)
+        50: (131,152,131,255) #839883FF srgba(131,152,131,1)
+        21: (132,134,129,255) #848681FF srgba(132,134,129,1)
+        32: (132,135,130,255) #848782FF srgba(132,135,130,1)
+        17: (132,154,130,255) #849A82FF srgba(132,154,130,1)
+         3: (133,136,131,255) #858883FF srgba(133,136,131,1)
+        20: (133,154,130,255) #859A82FF srgba(133,154,130,1)
+         1: (134,137,131,255) #868983FF srgba(134,137,131,1)
+        66: (134,155,129,255) #869B81FF srgba(134,155,129,1)
+        14: (135,137,132,255) #878984FF srgba(135,137,132,1)
+        13: (135,155,128,255) #879B80FF srgba(135,155,128,1)
+         5: (135,156,129,255) #879C81FF srgba(135,156,129,1)
+         9: (136,138,133,255) #888A85FF srgba(136,138,133,1)
+        19: (136,157,128,255) #889D80FF srgba(136,157,128,1)
+         8: (137,139,134,255) #898B86FF srgba(137,139,134,1)
+         8: (137,140,135,255) #898C87FF srgba(137,140,135,1)
+        15: (137,157,128,255) #899D80FF srgba(137,157,128,1)
+         2: (138,141,136,255) #8A8D88FF srgba(138,141,136,1)
+        13: (138,158,128,255) #8A9E80FF srgba(138,158,128,1)
+       100: (139,142,136,255) #8B8E88FF srgba(139,142,136,1)
+        24: (139,157,127,255) #8B9D7FFF srgba(139,157,127,1)
+        11: (139,158,127,255) #8B9E7FFF srgba(139,158,127,1)
+         9: (140,142,137,255) #8C8E89FF srgba(140,142,137,1)
+        20: (140,159,127,255) #8C9F7FFF srgba(140,159,127,1)
+        27: (141,143,138,255) #8D8F8AFF srgba(141,143,138,1)
+        27: (141,144,139,255) #8D908BFF srgba(141,144,139,1)
+         1: (141,159,126,255) #8D9F7EFF srgba(141,159,126,1)
+        20: (142,145,140,255) #8E918CFF srgba(142,145,140,1)
+         9: (142,160,126,255) #8EA07EFF srgba(142,160,126,1)
+        34: (143,146,140,255) #8F928CFF srgba(143,146,140,1)
+         4: (143,160,126,255) #8FA07EFF srgba(143,160,126,1)
+        32: (143,161,125,255) #8FA17DFF srgba(143,161,125,1)
+         9: (144,147,141,255) #90938DFF srgba(144,147,141,1)
+         3: (144,162,125,255) #90A27DFF srgba(144,162,125,1)
+        22: (145,148,142,255) #91948EFF srgba(145,148,142,1)
+        10: (145,162,125,255) #91A27DFF srgba(145,162,125,1)
+        33: (146,148,143,255) #92948FFF srgba(146,148,143,1)
+         3: (146,149,144,255) #929590FF srgba(146,149,144,1)
+         8: (146,163,124,255) #92A37CFF srgba(146,163,124,1)
+        18: (147,150,144,255) #939690FF srgba(147,150,144,1)
+         4: (147,163,124,255) #93A37CFF srgba(147,163,124,1)
+         5: (147,164,123,255) #93A47BFF srgba(147,164,123,1)
+        28: (148,151,145,255) #949791FF srgba(148,151,145,1)
+       104: (149,152,146,255) #959892FF srgba(149,152,146,1)
+         3: (149,164,123,255) #95A47BFF srgba(149,164,123,1)
+        14: (150,153,147,255) #969993FF srgba(150,153,147,1)
+        10: (150,165,122,255) #96A57AFF srgba(150,165,122,1)
+        12: (151,153,148,255) #979994FF srgba(151,153,148,1)
+         9: (151,154,149,255) #979A95FF srgba(151,154,149,1)
+        10: (151,165,123,255) #97A57BFF srgba(151,165,123,1)
+        17: (151,166,122,255) #97A67AFF srgba(151,166,122,1)
+         6: (152,155,149,255) #989B95FF srgba(152,155,149,1)
+        45: (152,167,122,255) #98A77AFF srgba(152,167,122,1)
+         8: (153,156,150,255) #999C96FF srgba(153,156,150,1)
+         5: (153,168,121,255) #99A879FF srgba(153,168,121,1)
+         4: (153,169,120,255) #99A978FF srgba(153,169,120,1)
+         2: (154,157,151,255) #9A9D97FF srgba(154,157,151,1)
+        10: (154,169,121,255) #9AA979FF srgba(154,169,121,1)
+        15: (155,158,152,255) #9B9E98FF srgba(155,158,152,1)
+         6: (155,170,120,255) #9BAA78FF srgba(155,170,120,1)
+        33: (156,159,153,255) #9C9F99FF srgba(156,159,153,1)
+         2: (156,170,119,255) #9CAA77FF srgba(156,170,119,1)
+         8: (157,160,154,255) #9DA09AFF srgba(157,160,154,1)
+         3: (158,161,155,255) #9EA19BFF srgba(158,161,155,1)
+         8: (158,171,119,255) #9EAB77FF srgba(158,171,119,1)
+        61: (159,162,156,255) #9FA29CFF srgba(159,162,156,1)
+         8: (159,172,118,255) #9FAC76FF srgba(159,172,118,1)
+         8: (160,163,157,255) #A0A39DFF srgba(160,163,157,1)
+        50: (160,164,157,255) #A0A49DFF srgba(160,164,157,1)
+         8: (160,172,118,255) #A0AC76FF srgba(160,172,118,1)
+        23: (161,164,158,255) #A1A49EFF srgba(161,164,158,1)
+         1: (161,173,118,255) #A1AD76FF srgba(161,173,118,1)
+         2: (161,174,117,255) #A1AE75FF srgba(161,174,117,1)
+        23: (162,165,159,255) #A2A59FFF srgba(162,165,159,1)
+         7: (162,174,117,255) #A2AE75FF srgba(162,174,117,1)
+         4: (163,166,160,255) #A3A6A0FF srgba(163,166,160,1)
+         7: (164,167,161,255) #A4A7A1FF srgba(164,167,161,1)
+         5: (164,175,116,255) #A4AF74FF srgba(164,175,116,1)
+        10: (165,168,161,255) #A5A8A1FF srgba(165,168,161,1)
+       134: (165,169,162,255) #A5A9A2FF srgba(165,169,162,1)
+        30: (165,176,116,255) #A5B074FF srgba(165,176,116,1)
+        22: (166,169,163,255) #A6A9A3FF srgba(166,169,163,1)
+         5: (166,176,115,255) #A6B073FF srgba(166,176,115,1)
+        26: (167,170,164,255) #A7AAA4FF srgba(167,170,164,1)
+        10: (167,177,115,255) #A7B173FF srgba(167,177,115,1)
+         7: (168,171,165,255) #A8ABA5FF srgba(168,171,165,1)
+         2: (168,177,115,255) #A8B173FF srgba(168,177,115,1)
+        21: (169,172,166,255) #A9ACA6FF srgba(169,172,166,1)
+         1: (169,178,114,255) #A9B272FF srgba(169,178,114,1)
+        11: (169,179,114,255) #A9B372FF srgba(169,179,114,1)
+        13: (170,173,166,255) #AAADA6FF srgba(170,173,166,1)
+         4: (170,179,114,255) #AAB372FF srgba(170,179,114,1)
+         7: (171,175,168,255) #ABAFA8FF srgba(171,175,168,1)
+         9: (171,180,113,255) #ABB471FF srgba(171,180,113,1)
+         8: (172,175,169,255) #ACAFA9FF srgba(172,175,169,1)
+        11: (172,180,113,255) #ACB471FF srgba(172,180,113,1)
+         9: (173,176,170,255) #ADB0AAFF srgba(173,176,170,1)
+         6: (173,181,113,255) #ADB571FF srgba(173,181,113,1)
+        28: (174,177,170,255) #AEB1AAFF srgba(174,177,170,1)
+         7: (174,182,112,255) #AEB670FF srgba(174,182,112,1)
+        16: (175,178,171,255) #AFB2ABFF srgba(175,178,171,1)
+        20: (175,179,172,255) #AFB3ACFF srgba(175,179,172,1)
+         4: (175,182,112,255) #AFB670FF srgba(175,182,112,1)
+        23: (176,180,173,255) #B0B4ADFF srgba(176,180,173,1)
+        14: (176,182,111,255) #B0B66FFF srgba(176,182,111,1)
+        21: (177,180,174,255) #B1B4AEFF srgba(177,180,174,1)
+         4: (177,183,111,255) #B1B76FFF srgba(177,183,111,1)
+        14: (177,184,111,255) #B1B86FFF srgba(177,184,111,1)
+         9: (178,181,175,255) #B2B5AFFF srgba(178,181,175,1)
+        25: (178,184,110,255) #B2B86EFF srgba(178,184,110,1)
+        82: (179,182,175,255) #B3B6AFFF srgba(179,182,175,1)
+         6: (179,185,110,255) #B3B96EFF srgba(179,185,110,1)
+         7: (180,183,176,255) #B4B7B0FF srgba(180,183,176,1)
+        13: (180,184,177,255) #B4B8B1FF srgba(180,184,177,1)
+        13: (180,185,109,255) #B4B96DFF srgba(180,185,109,1)
+        12: (181,185,178,255) #B5B9B2FF srgba(181,185,178,1)
+        21: (181,186,110,255) #B5BA6EFF srgba(181,186,110,1)
+         6: (181,187,109,255) #B5BB6DFF srgba(181,187,109,1)
+        14: (182,185,179,255) #B6B9B3FF srgba(182,185,179,1)
+         7: (182,187,108,255) #B6BB6CFF srgba(182,187,108,1)
+        24: (183,186,179,255) #B7BAB3FF srgba(183,186,179,1)
+         2: (183,188,109,255) #B7BC6DFF srgba(183,188,109,1)
+        31: (184,187,108,255) #B8BB6CFF srgba(184,187,108,1)
+         6: (184,187,180,255) #B8BBB4FF srgba(184,187,180,1)
+        31: (184,188,181,255) #B8BCB5FF srgba(184,188,181,1)
+        16: (185,188,107,255) #B9BC6BFF srgba(185,188,107,1)
+         2: (185,189,108,255) #B9BD6CFF srgba(185,189,108,1)
+         6: (185,189,182,255) #B9BDB6FF srgba(185,189,182,1)
+         2: (186,189,107,255) #BABD6BFF srgba(186,189,107,1)
+        25: (186,190,183,255) #BABEB7FF srgba(186,190,183,1)
+         8: (187,190,106,255) #BBBE6AFF srgba(187,190,106,1)
+        16: (187,191,183,255) #BBBFB7FF srgba(187,191,183,1)
+        10: (188,190,107,255) #BCBE6BFF srgba(188,190,107,1)
+         8: (188,191,184,255) #BCBFB8FF srgba(188,191,184,1)
+         7: (189,191,106,255) #BDBF6AFF srgba(189,191,106,1)
+        10: (189,192,105,255) #BDC069FF srgba(189,192,105,1)
+         8: (189,192,185,255) #BDC0B9FF srgba(189,192,185,1)
+        32: (189,193,186,255) #BDC1BAFF srgba(189,193,186,1)
+        11: (190,192,105,255) #BEC069FF srgba(190,192,105,1)
+        10: (190,194,187,255) #BEC2BBFF srgba(190,194,187,1)
+         5: (191,193,105,255) #BFC169FF srgba(191,193,105,1)
+         3: (191,195,188,255) #BFC3BCFF srgba(191,195,188,1)
+         1: (192,193,105,255) #C0C169FF srgba(192,193,105,1)
+        29: (192,194,104,255) #C0C268FF srgba(192,194,104,1)
+        24: (192,196,188,255) #C0C4BCFF srgba(192,196,188,1)
+         3: (193,194,104,255) #C1C268FF srgba(193,194,104,1)
+         4: (193,196,189,255) #C1C4BDFF srgba(193,196,189,1)
+        18: (194,197,190,255) #C2C5BEFF srgba(194,197,190,1)
+        12: (194,198,191,255) #C2C6BFFF srgba(194,198,191,1)
+        14: (195,195,103,255) #C3C367FF srgba(195,195,103,1)
+        47: (195,199,192,255) #C3C7C0FF srgba(195,199,192,1)
+       105: (196,196,103,255) #C4C467FF srgba(196,196,103,1)
+        18: (196,200,192,255) #C4C8C0FF srgba(196,200,192,1)
+         6: (197,197,102,255) #C5C566FF srgba(197,197,102,1)
+        41: (197,201,193,255) #C5C9C1FF srgba(197,201,193,1)
+        11: (198,197,102,255) #C6C566FF srgba(198,197,102,1)
+         4: (198,201,194,255) #C6C9C2FF srgba(198,201,194,1)
+         9: (199,198,102,255) #C7C666FF srgba(199,198,102,1)
+        36: (199,202,195,255) #C7CAC3FF srgba(199,202,195,1)
+        12: (199,203,196,255) #C7CBC4FF srgba(199,203,196,1)
+       124: (200,199,101,255) #C8C765FF srgba(200,199,101,1)
+        46: (200,204,196,255) #C8CCC4FF srgba(200,204,196,1)
+         7: (201,200,101,255) #C9C865FF srgba(201,200,101,1)
+        23: (201,205,197,255) #C9CDC5FF srgba(201,205,197,1)
+        11: (202,200,100,255) #CAC864FF srgba(202,200,100,1)
+        23: (202,206,198,255) #CACEC6FF srgba(202,206,198,1)
+         9: (203,200,100,255) #CBC864FF srgba(203,200,100,1)
+        37: (203,207,199,255) #CBCFC7FF srgba(203,207,199,1)
+         8: (204,201, 99,255) #CCC963FF srgba(204,201,99,1)
+         2: (204,201,100,255) #CCC964FF srgba(204,201,100,1)
+        60: (204,207,200,255) #CCCFC8FF srgba(204,207,200,1)
+        31: (204,208,200,255) #CCD0C8FF srgba(204,208,200,1)
+        77: (205,209,201,255) #CDD1C9FF srgba(205,209,201,1)
+        93: (206,202, 99,255) #CECA63FF srgba(206,202,99,1)
+        53: (206,210,202,255) #CED2CAFF srgba(206,210,202,1)
+        11: (207,203, 98,255) #CFCB62FF srgba(207,203,98,1)
+        50: (207,211,203,255) #CFD3CBFF srgba(207,211,203,1)
+        22: (208,204, 98,255) #D0CC62FF srgba(208,204,98,1)
+        63: (208,212,204,255) #D0D4CCFF srgba(208,212,204,1)
+        64: (208,212,205,255) #D0D4CDFF srgba(208,212,205,1)
+         5: (209,205, 97,255) #D1CD61FF srgba(209,205,97,1)
+        26: (209,213,205,255) #D1D5CDFF srgba(209,213,205,1)
+        35: (210,205, 97,255) #D2CD61FF srgba(210,205,97,1)
+        61: (210,214,206,255) #D2D6CEFF srgba(210,214,206,1)
+         7: (211,206, 97,255) #D3CE61FF srgba(211,206,97,1)
+      1473: (211,215,207,255) #D3D7CFFF srgba(211,215,207,1)
+       276: (212,206, 96,255) #D4CE60FF srgba(212,206,96,1)
+         8: (213,207, 96,255) #D5CF60FF srgba(213,207,96,1)
+        22: (214,207, 96,255) #D6CF60FF srgba(214,207,96,1)
+        24: (215,208, 95,255) #D7D05FFF srgba(215,208,95,1)
+         4: (216,209, 94,255) #D8D15EFF srgba(216,209,94,1)
+        18: (216,209, 95,255) #D8D15FFF srgba(216,209,95,1)
+         3: (216,210, 94,255) #D8D25EFF srgba(216,210,94,1)
+        11: (217,210, 93,255) #D9D25DFF srgba(217,210,93,1)
+       283: (218,211, 94,255) #DAD35EFF srgba(218,211,94,1)
+        16: (219,211, 92,255) #DBD35CFF srgba(219,211,92,1)
+         5: (219,212, 93,255) #DBD45DFF srgba(219,212,93,1)
+         3: (220,212, 93,255) #DCD45DFF srgba(220,212,93,1)
+        30: (221,212, 92,255) #DDD45CFF srgba(221,212,92,1)
+        12: (222,213, 91,255) #DED55BFF srgba(222,213,91,1)
+        26: (223,214, 91,255) #DFD65BFF srgba(223,214,91,1)
+        76: (224,215, 91,255) #E0D75BFF srgba(224,215,91,1)
+        10: (225,215, 90,255) #E1D75AFF srgba(225,215,90,1)
+        10: (226,216, 90,255) #E2D85AFF srgba(226,216,90,1)
+        44: (227,217, 89,255) #E3D959FF srgba(227,217,89,1)
+         1: (227,217, 90,255) #E3D95AFF srgba(227,217,90,1)
+        22: (228,218, 89,255) #E4DA59FF srgba(228,218,89,1)
+        10: (229,217, 89,255) #E5D959FF srgba(229,217,89,1)
+         7: (230,218, 88,255) #E6DA58FF srgba(230,218,88,1)
+        62: (231,219, 88,255) #E7DB58FF srgba(231,219,88,1)
+         5: (232,220, 87,255) #E8DC57FF srgba(232,220,87,1)
+     69120: (232,232,231,255) #E8E8E7FF srgba(232,232,231,1)
+        11: (233,221, 87,255) #E9DD57FF srgba(233,221,87,1)
+       114: (234,221, 87,255) #EADD57FF srgba(234,221,87,1)
+        35: (234,222, 86,255) #EADE56FF srgba(234,222,86,1)
+        23: (235,222, 86,255) #EBDE56FF srgba(235,222,86,1)
+        24: (236,223, 86,255) #ECDF56FF srgba(236,223,86,1)
+        24: (237,224, 85,255) #EDE055FF srgba(237,224,85,1)
+        69: (238,224, 85,255) #EEE055FF srgba(238,224,85,1)
+        26: (239,224, 84,255) #EFE054FF srgba(239,224,84,1)
+        76: (240,225, 84,255) #F0E154FF srgba(240,225,84,1)
+        39: (241,226, 84,255) #F1E254FF srgba(241,226,84,1)
+        29: (242,226, 83,255) #F2E253FF srgba(242,226,83,1)
+         8: (242,227, 83,255) #F2E353FF srgba(242,227,83,1)
+        24: (243,227, 83,255) #F3E353FF srgba(243,227,83,1)
+        40: (244,228, 82,255) #F4E452FF srgba(244,228,82,1)
+        22: (245,229, 82,255) #F5E552FF srgba(245,229,82,1)
+        31: (246,229, 82,255) #F6E552FF srgba(246,229,82,1)
+        48: (246,230, 82,255) #F6E652FF srgba(246,230,82,1)
+        31: (247,229, 81,255) #F7E551FF srgba(247,229,81,1)
+        36: (248,230, 80,255) #F8E650FF srgba(248,230,80,1)
+        16: (249,231, 81,255) #F9E751FF srgba(249,231,81,1)
+        23: (250,231, 80,255) #FAE750FF srgba(250,231,80,1)
+        11: (250,232, 79,255) #FAE84FFF srgba(250,232,79,1)
+        46: (251,232, 80,255) #FBE850FF srgba(251,232,80,1)
+      2629: (252,233, 79,255) #FCE94FFF srgba(252,233,79,1)
+  Rendering intent: Perceptual
+  Gamma: 0.454545
+  Chromaticity:
+    red primary: (0.64,0.33)
+    green primary: (0.3,0.6)
+    blue primary: (0.15,0.06)
+    white point: (0.3127,0.329)
+  Background color: white
+  Border color: srgba(223,223,223,1)
+  Matte color: grey74
+  Transparent color: none
+  Interlace: None
+  Intensity: Undefined
+  Compose: Over
+  Page geometry: 1920x1080+0+0
+  Dispose: Undefined
+  Iterations: 0
+  Compression: Zip
+  Orientation: Undefined
+  Properties:
+    date:create: 2016-08-21T15:18:57+01:00
+    date:modify: 2016-08-21T15:18:57+01:00
+    png:bKGD: chunk was found (see Background color, above)
+    png:IHDR.bit-depth-orig: 8
+    png:IHDR.bit_depth: 8
+    png:IHDR.color-type-orig: 6
+    png:IHDR.color_type: 6 (RGBA)
+    png:IHDR.interlace_method: 0 (Not interlaced)
+    png:IHDR.width,height: 1920, 1080
+    png:pHYs: x_res=2835, y_res=2835, units=1
+    png:sRGB: intent=0 (Perceptual Intent)
+    png:tIME: 2016-08-08T21:05:17Z
+    signature: 1cb6d25c9949160285c5bb8d7dc13f0a3cc97c568b7cdc54eacb598b00e0de6f
+  Artifacts:
+    filename: /tmp/cctdBe_pagerMode.png
+    verbose: true
+  Tainted: False
+  Filesize: 54.4KB
+  Number pixels: 2.074M
+  Pixels per second: 414.72GB
+  User time: 0.000u
+  Elapsed time: 0:01.000
+  Version: ImageMagick 6.9.3-0 Q16 x86_64 2016-02-03 http://www.imagemagick.org
diff --git a/contrib/keybase/install.sh b/contrib/keybase/install.sh
new file mode 100644
index 0000000..5466d04
--- /dev/null
+++ b/contrib/keybase/install.sh
@@ -0,0 +1,59 @@
+#!/bin/sh
+
+# If no directory exists, make it exist.
+if [ -d "$HOME/.mutt/keybaseMutt" ]; then
+
+	# If someone already has a backup, complain.
+	if [ -d "$HOME/.mutt/keybaseMuttBACKUP" ]; then
+		#echo "$HOME/.mutt/keybaseMuttBACKUP exists"
+		echo "You are going to overwrite your backup. Are you sure you want to do this? [y|n]"
+		read -r overwrite
+
+		# If they want to delete their backup.
+		if [ "$overwrite" = 'y' ]; then
+			cp -R "$HOME/.mutt/keybaseMutt" "$HOME/.mutt/keybaseMuttBACKUP"
+			rm -r "$HOME/.mutt/keybaseMutt"
+			mkdir -p "$HOME/.mutt/keybaseMutt/scripts"
+
+		# Otherwise, abort mission.
+		else
+			echo "ABORT! ABORT! ABORT!"
+			exit 1
+		fi
+
+	elif [ ! -d "$HOME/.mutt/keybaseMuttBACKUP" ]; then
+		echo "Backing up previous install."
+		cp -R "$HOME/.mutt/keybaseMutt" "$HOME/.mutt/keybaseMuttBACKUP"
+		rm -r "$HOME/.mutt/keybaseMutt"
+		mkdir -p "$HOME/.mutt/keybaseMutt/scripts"
+	fi
+# Otherwise, make a backup
+elif [ ! -d "$HOME/.mutt/keybaseMutt" ]; then
+	echo "Installing your program..."
+	mkdir -p "$HOME/.mutt/keybaseMutt/scripts"
+
+fi
+
+# Copy my directory to your directory.
+cp ./keybase.py  "$HOME/.mutt/keybaseMutt"
+cp ./pgpdecrypt.sh "$HOME/.mutt/keybaseMutt/scripts"
+cp ./decrypt.sh "$HOME/.mutt/keybaseMutt/scripts"
+cp ./verify.sh "$HOME/.mutt/keybaseMutt/scripts"
+cp ./pgpverify.sh "$HOME/.mutt/keybaseMutt/scripts"
+
+# Yay! Stuff's installed!
+echo "You'll need to include a path to '~/.mutt/keybaseMutt/scripts' in your shell's rc file. If you've done this previously on your computer, press 'n'."
+echo "Do you use [b]ash, [k]sh, or [z]sh? [n]"
+echo "(You use $SHELL)"
+read -r shellInput
+if [ "$shellInput" = 'b' ]; then
+	echo 'export PATH="$PATH:~/.mutt/keybaseMutt/scripts"' >> "$HOME/.bashrc"
+elif [ "$shellInput" = 'k' ]; then
+	echo 'export PATH="$PATH:~/.mutt/keybaseMutt/scripts"' >> "$HOME/.kshrc"
+elif [ "$shellInput" = 'z' ]; then
+	echo 'export PATH="$PATH:~/.mutt/keybaseMutt/scripts"' >> "$HOME/.zshrc"
+else 
+	echo "If you use something another shell, you'll need to add the path manually."
+fi
+
+echo "Please restart your shell to be able to use the scripts (closing and reopening the terminal is easiest)."
diff --git a/contrib/keybase/keybase.py b/contrib/keybase/keybase.py
new file mode 100644
index 0000000..33a6e1d
--- /dev/null
+++ b/contrib/keybase/keybase.py
@@ -0,0 +1,60 @@
+#! /usr/bin/env python
+# Written by Joshua Jordi
+
+import os
+
+def helpfunc():
+    print("Run keybase commands here as if you were using keybase. WARNING: this program is not capable of MIME formatting. Only inline.")
+    print("To encrypt, use keybase syntax. (ie. 'keybase encrypt jakkinstewart' or 'keybase pgp encrypt jakkinstewart') Do not include a '-i' or '-o'. This script uses them in the background. Including either flag will mess with the script. (Unless that's what you want to do.)")
+    print("Don't worry about finding or attaching the file, the macro will take care of that.")
+    print("To sign, give it the style ('sign' or 'pgp sign'. It will automatically include the signature in the file.")
+    print("This program will not be able to decrypt or verify messages. I've created separate scripts for that.")
+    print('Type "quit" to quit.')
+
+def encryptSign(parameters):
+    os.system('echo $HOME > .file')
+    directory = open('.file', 'r')
+    pwd = directory.read().strip('\n')
+    directory.close()
+    tmp = open("%s/.mutt/keybaseMutt/.tmp" % pwd, "r")
+    tmp = tmp.read().strip("\n")
+    print("Working....")
+    os.system('%s -i %s -o %s' % (parameters, tmp, tmp))
+    print("Done!")
+
+#def sign(parameters):
+#    os.system('pwd > .file')
+#    directory = open('.file', 'r')
+#    pwd = directory.read().strip('\n')
+#    directory.close()
+#    tmp = open('%s/.mutt/keybaseMutt/.tmp' % pwd, 'r')
+#    tmp = tmp.read().strip('\n')
+#    print("Working...")
+#    os.system('%s -i %s -o %s' % (parameters, tmp, tmp))
+#    print("Done!")
+
+exitVar = ''
+
+print("Type help to learn how to use me.")
+
+while exitVar.lower() != 'quit':
+    inputStuffs = input('mutt#: ')
+    if (inputStuffs.lower() == 'help'):
+        helpfunc()
+
+    elif ('encrypt' in inputStuffs):
+        encryptSign(inputStuffs)
+
+    #elif ('decrypt' in inputStuffs):
+    #    decrypt(inputStuffs)
+
+    elif ('sign' in inputStuffs):
+        encryptSign(inputStuffs)
+
+    elif ('quit' in inputStuffs or 'exit' in inputStuffs):
+        exitVar = 'quit'
+
+    else:
+        print("You didn't use a known keybase command.")
+
+os.system('rm .file')
diff --git a/contrib/keybase/muttrc b/contrib/keybase/muttrc
new file mode 100644
index 0000000..ff65db9
--- /dev/null
+++ b/contrib/keybase/muttrc
@@ -0,0 +1,2 @@
+set editor = 'echo %s > ~/.mutt/keybaseMutt/.tmp; vim %s'
+macro compose K "<enter-command>unset wait_key<enter><shell-escape>python ~/.mutt/keybaseMutt/keybase.py<enter><enter-command>set wait_key<enter>
diff --git a/contrib/keybase/pgpdecrypt.sh b/contrib/keybase/pgpdecrypt.sh
new file mode 100755
index 0000000..2a88dff
--- /dev/null
+++ b/contrib/keybase/pgpdecrypt.sh
@@ -0,0 +1,2 @@
+#!/bin/sh
+sed -n '/BEGIN/,$p' | keybase pgp decrypt
diff --git a/contrib/keybase/pgpverify.sh b/contrib/keybase/pgpverify.sh
new file mode 100755
index 0000000..180bdea
--- /dev/null
+++ b/contrib/keybase/pgpverify.sh
@@ -0,0 +1,2 @@
+#!/bin/sh
+gawk '/BEGIN/{y=1}y' | keybase pgp verify
diff --git a/contrib/keybase/verify.sh b/contrib/keybase/verify.sh
new file mode 100755
index 0000000..10e7f01
--- /dev/null
+++ b/contrib/keybase/verify.sh
@@ -0,0 +1,2 @@
+#!/bin/sh
+sed -n 's/^.*BEGIN KEYBASE/BEGIN KEYBASE/p' | keybase verify
diff --git a/contrib/vim-keybindings/README.md b/contrib/vim-keybindings/README.md
new file mode 100644
index 0000000..2beeb08
--- /dev/null
+++ b/contrib/vim-keybindings/README.md
@@ -0,0 +1,13 @@
+# Vim Keybindings
+
+This Mutt config file sets up some keyboard mappings that make Mutt more
+friendly for Vim users.  For example:
+
+- gg  Move to top of Index
+- G   Move to bottom of Index
+- dd  Delete email from Index
+
+## Credits
+
+- Ivan Tham <pickfire@riseup.net>
+
diff --git a/contrib/vim-keybindings/vim-keybindings.rc b/contrib/vim-keybindings/vim-keybindings.rc
new file mode 100644
index 0000000..cb64889
--- /dev/null
+++ b/contrib/vim-keybindings/vim-keybindings.rc
@@ -0,0 +1,35 @@
+#------------------------------------------------------------
+# Vi Key Bindings
+#------------------------------------------------------------
+
+# Moving around
+bind attach,browser,index       gg  first-entry
+bind attach,browser,index       G   last-entry
+bind pager                      gg  top
+bind pager                      G   bottom
+bind pager                      k   previous-line
+bind pager                      j   next-line
+
+# Scrolling
+bind attach,browser,pager,index \CF next-page
+bind attach,browser,pager,index \CB previous-page
+bind attach,browser,pager,index \Cu half-up
+bind attach,browser,pager,index \Cd half-down
+bind browser,pager              \Ce next-line
+bind browser,pager              \Cy previous-line
+bind index                      \Ce next-line
+bind index                      \Cy previous-line
+
+bind pager,index                dd  delete-message
+
+# Mail & Reply
+bind index                      \Cm list-reply # Doesn't work currently
+
+# Threads
+bind browser,pager,index        N   search-opposite
+bind pager,index                dT  delete-thread
+bind pager,index                dt  delete-subthread
+bind pager,index                gt  next-thread
+bind pager,index                gT  previous-thread
+bind index                      za  collapse-thread
+bind index                      zA  collapse-all # Missing :folddisable/foldenable
diff --git a/copy.c b/copy.c
index 1ef441f..bfcd3a5 100644
--- a/copy.c
+++ b/copy.c
@@ -30,6 +30,10 @@
 #include "mutt_idna.h"
 #include "mutt_curses.h"
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include <string.h>
 #include <stdlib.h>
 #include <ctype.h>
@@ -111,6 +115,15 @@ mutt_copy_hdr (FILE *in, FILE *out, LOFF_T off_start, LOFF_T off_end, int flags,
 	ignore = 0;
       }
 
+      if (flags & CH_UPDATE_LABEL)
+      {
+	if ((mutt_strncasecmp ("X-Label:", buf, 8) == 0) ||
+	    (mutt_strncasecmp ("X-Keywords:", buf, 11) == 0) ||
+	    (mutt_strncasecmp ("X-Mozilla-Keys:", buf, 15) == 0) ||
+	    (mutt_strncasecmp ("Keywords:", buf, 9) == 0))
+	  continue;
+      }
+
       if (!ignore && fputs (buf, out) == EOF)
 	return (-1);
     }
@@ -335,6 +348,7 @@ mutt_copy_hdr (FILE *in, FILE *out, LOFF_T off_start, LOFF_T off_end, int flags,
 	CH_NOQFROM      ignore ">From " line
 	CH_UPDATE_IRT	update the In-Reply-To: header
 	CH_UPDATE_REFS	update the References: header
+	CH_VIRTUAL      write virtual header lines too
 
    prefix
    	string to use if CH_PREFIX is set
@@ -348,7 +362,7 @@ mutt_copy_header (FILE *in, HEADER *h, FILE *out, int flags, const char *prefix)
   if (h->env)
     flags |= (h->env->irt_changed ? CH_UPDATE_IRT : 0)
       | (h->env->refs_changed ? CH_UPDATE_REFS : 0);
-  
+
   if (mutt_copy_hdr (in, out, h->offset, h->content->offset, flags, prefix) == -1)
     return -1;
 
@@ -414,6 +428,70 @@ mutt_copy_header (FILE *in, HEADER *h, FILE *out, int flags, const char *prefix)
       fprintf (out, "Lines: %d\n", h->lines);
   }
 
+#ifdef USE_NOTMUCH
+  if ((flags & CH_VIRTUAL) && nm_header_get_tags(h))
+  {
+    fputs ("Tags: ", out);
+    fputs (nm_header_get_tags(h), out);
+    fputc ('\n', out);
+  }
+#endif
+
+  if (flags & CH_UPDATE_LABEL && h->label_changed)
+  {
+    h->label_changed = 0;
+    if (h->env->labels != NULL)
+    {
+      char buf[HUGE_STRING];
+      char *tmp = NULL;
+      int fail = 0;
+
+      if (fail == 0 &&
+          ((h->env->kwtypes & MUTT_X_LABEL) || (h->env->kwtypes == 0)) &&
+          (option(OPTKEYWORDSLEGACY) || option(OPTKEYWORDSSTANDARD) == 0))
+      {
+        mutt_labels(buf, sizeof(buf), h->env, XlabelDelim);
+        tmp = safe_strdup(buf);
+        rfc2047_encode_string(&tmp);
+        fail = fprintf(out, "X-Label: %s\n", tmp) != 10 + strlen(tmp);
+        FREE(&tmp);
+      }
+
+      if (fail == 0 && (h->env->kwtypes & MUTT_X_KEYWORDS) &&
+          (option(OPTKEYWORDSLEGACY) || option(OPTKEYWORDSSTANDARD) == 0))
+      {
+        mutt_labels(buf, sizeof(buf), h->env, " ");
+        tmp = safe_strdup(buf);
+        rfc2047_encode_string(&tmp);
+        fail = fprintf(out, "X-Keywords: %s\n", tmp) != 13 + strlen(tmp);
+        FREE(&tmp);
+      }
+
+      if (fail == 0 && (h->env->kwtypes & MUTT_X_MOZILLA_KEYS) &&
+          (option(OPTKEYWORDSLEGACY) || option(OPTKEYWORDSSTANDARD) == 0))
+      {
+        mutt_labels(buf, sizeof(buf), h->env, " ");
+        tmp = safe_strdup(buf);
+        rfc2047_encode_string(&tmp);
+        fail = fprintf(out, "X-Mozilla-Keys: %s\n", tmp) != 17 + strlen(tmp);
+        FREE(&tmp);
+      }
+
+      if (fail == 0 && ((h->env->kwtypes & MUTT_KEYWORDS) ||
+                        option(OPTKEYWORDSSTANDARD)))
+      {
+        mutt_labels(buf, sizeof(buf), h->env, NULL);
+        tmp = safe_strdup(buf);
+        rfc2047_encode_string(&tmp);
+        fail = fprintf(out, "Keywords: %s\n", tmp) != 11 + strlen(tmp);
+        FREE(&tmp);
+      }
+
+      if (fail)
+        return -1;
+    }
+  }
+
   if ((flags & CH_NONEWLINE) == 0)
   {
     if (flags & CH_PREFIX)
@@ -494,6 +572,9 @@ _mutt_copy_message (FILE *fpout, FILE *fpin, HEADER *hdr, BODY *body,
       _mutt_make_string (prefix, sizeof (prefix), NONULL (Prefix), Context, hdr, 0);
   }
 
+  if (hdr->label_changed)
+    chflags |= CH_UPDATE_LABEL;
+
   if ((flags & MUTT_CM_NOHEADER) == 0)
   {
     if (flags & MUTT_CM_PREFIX)
@@ -683,7 +764,7 @@ mutt_copy_message (FILE *fpout, CONTEXT *src, HEADER *hdr, int flags,
 {
   MESSAGE *msg;
   int r;
-  
+
   if ((msg = mx_open_message (src, hdr->msgno)) == NULL)
     return -1;
   if ((r = _mutt_copy_message (fpout, msg->fp, hdr, hdr->content, flags, chflags)) == 0 
@@ -718,7 +799,7 @@ _mutt_append_message (CONTEXT *dest, FILE *fpin, CONTEXT *src, HEADER *hdr,
   fseeko (fpin, hdr->offset, 0);
   if (fgets (buf, sizeof (buf), fpin) == NULL)
     return -1;
-  
+
   if ((msg = mx_open_new_message (dest, hdr, is_from (buf, NULL, 0, NULL) ? 0 : MUTT_ADD_FROM)) == NULL)
     return -1;
   if (dest->magic == MUTT_MBOX || dest->magic == MUTT_MMDF)
@@ -728,6 +809,11 @@ _mutt_append_message (CONTEXT *dest, FILE *fpin, CONTEXT *src, HEADER *hdr,
   if (mx_commit_message (msg, dest) != 0)
     r = -1;
 
+#ifdef USE_NOTMUCH
+  if (hdr && msg->commited_path && dest->magic == MUTT_MAILDIR && src->magic == MUTT_NOTMUCH)
+	  nm_update_filename(src, NULL, msg->commited_path, hdr);
+#endif
+
   mx_close_message (dest, &msg);
   return r;
 }
diff --git a/copy.h b/copy.h
index 4d6fc54..b47c7fb 100644
--- a/copy.h
+++ b/copy.h
@@ -53,6 +53,8 @@
 #define CH_UPDATE_IRT     (1<<16) /* update In-Reply-To: */
 #define CH_UPDATE_REFS    (1<<17) /* update References: */
 #define CH_DISPLAY        (1<<18) /* display result to user */
+#define CH_UPDATE_LABEL   (1<<19) /* update X-Label: from hdr->env->x_label? */
+#define CH_VIRTUAL	  (1<<20) /* write virtual header lines too */
 
 
 int mutt_copy_hdr (FILE *, FILE *, LOFF_T, LOFF_T, int, const char *);
diff --git a/crypt.c b/crypt.c
index 7659fdc..5aa8266 100644
--- a/crypt.c
+++ b/crypt.c
@@ -231,8 +231,21 @@ int mutt_protect (HEADER *msg, char *keylist)
     if ((WithCrypto & APPLICATION_SMIME)
         && (msg->security & APPLICATION_SMIME))
     {
-      if (!(tmp_pbody = crypt_smime_build_smime_entity (tmp_smime_pbody,
-                                                        keylist)))
+      char *new_keylist = keylist;
+
+      if (SmimeDefaultKey && query_quadoption(OPT_SMIMEENCRYPTSELF, _("Encrypt message to S/MIME Default Key also?")) == MUTT_YES)
+      {
+        /* +1 for NULL, +1 for \n */
+        int size = mutt_strlen(keylist) + mutt_strlen(SmimeDefaultKey) + 2;
+        new_keylist = safe_malloc(size);
+        snprintf(new_keylist, size, "%s%s\n", keylist, SmimeDefaultKey);
+      }
+
+      tmp_pbody = crypt_smime_build_smime_entity (tmp_smime_pbody, new_keylist);
+      if (new_keylist != keylist)
+        FREE(&new_keylist);
+
+      if (!tmp_pbody)
       {
 	/* signed ? free it! */
 	return (-1);
diff --git a/curs_lib.c b/curs_lib.c
index 8b21c43..d09278f 100644
--- a/curs_lib.c
+++ b/curs_lib.c
@@ -44,6 +44,10 @@
 #include <langinfo.h>
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 /* not possible to unget more than one char under some curses libs, and it
  * is impossible to unget function keys in SLang, so roll our own input
  * buffering routines.
@@ -419,6 +423,67 @@ void mutt_progress_init (progress_t* progress, const char *msg,
   mutt_progress_update (progress, 0, 0);
 }
 
+/**
+ * message_bar - Draw a colourful progress bar
+ * @percent: %age complete
+ * @fmt:     printf(1)-like formatting string
+ * @...:     Arguments to formatting string
+ */
+static void
+message_bar (int percent, const char *fmt, ...)
+{
+  va_list ap;
+  char buf[STRING], buf2[STRING];
+  int w = percent * COLS / 100;
+  size_t l;
+
+  va_start (ap, fmt);
+  vsnprintf (buf, sizeof (buf), fmt, ap);
+  l = mutt_strwidth (buf);
+  va_end (ap);
+
+  mutt_format_string (buf2, sizeof (buf2), 0, COLS-2, FMT_LEFT, 0, buf, sizeof (buf), 0);
+
+  move (LINES - 1, 0);
+
+  if (ColorDefs[MT_COLOR_PROGRESS] == 0)
+  {
+    addstr (buf2);
+  }
+  else
+  {
+    if (l < w)
+    {
+      /* The string fits within the colour bar */
+      SETCOLOR(MT_COLOR_PROGRESS);
+      addstr (buf2);
+      w -= l;
+      while (w--)
+      {
+        addch (' ');
+      }
+      SETCOLOR(MT_COLOR_NORMAL);
+    }
+    else
+    {
+      /* The string is too long for the colour bar */
+      char ch;
+      int off = mutt_wstr_trunc (buf2, sizeof (buf2), w, NULL);
+
+      ch = buf2[off];
+      buf2[off] = 0;
+      SETCOLOR(MT_COLOR_PROGRESS);
+      addstr (buf2);
+      buf2[off] = ch;
+      SETCOLOR(MT_COLOR_NORMAL);
+      addstr (&buf2[off]);
+    }
+  }
+
+  clrtoeol();
+  mutt_refresh();
+}
+
 void mutt_progress_update (progress_t* progress, long pos, int percent)
 {
   char posstr[SHORT_STRING];
@@ -469,16 +534,16 @@ void mutt_progress_update (progress_t* progress, long pos, int percent)
 
     if (progress->size > 0)
     {
-      mutt_message ("%s %s/%s (%d%%)", progress->msg, posstr, progress->sizestr,
-		    percent > 0 ? percent :
-		   	(int) (100.0 * (double) progress->pos / progress->size));
+      message_bar ((percent > 0) ? percent : (int) (100.0 * (double) progress->pos / progress->size),
+        "%s %s/%s (%d%%)", progress->msg, posstr, progress->sizestr,
+        (percent > 0) ? percent : (int) (100.0 * (double) progress->pos / progress->size));
     }
     else
     {
       if (percent > 0)
-	mutt_message ("%s %s (%d%%)", progress->msg, posstr, percent);
+        message_bar (percent, "%s %s (%d%%)", progress->msg, posstr, percent);
       else
-	mutt_message ("%s %s", progress->msg, posstr);
+        mutt_message ("%s %s", progress->msg, posstr);
     }
   }
 
@@ -541,9 +606,13 @@ void mutt_reflow_windows (void)
   {
     memcpy (MuttSidebarWindow, MuttIndexWindow, sizeof (mutt_window_t));
     MuttSidebarWindow->cols = SidebarWidth;
-
     MuttIndexWindow->cols -= SidebarWidth;
-    MuttIndexWindow->col_offset += SidebarWidth;
+
+    if (option (OPTSIDEBARONRIGHT)) {
+      MuttSidebarWindow->col_offset = COLS - SidebarWidth;
+    } else {
+      MuttIndexWindow->col_offset += SidebarWidth;
+    }
   }
 #endif
 }
@@ -731,7 +800,9 @@ int mutt_do_pager (const char *banner,
   return rc;
 }
 
-int _mutt_enter_fname (const char *prompt, char *buf, size_t blen, int *redraw, int buffy, int multiple, char ***files, int *numfiles)
+int _mutt_enter_fname (const char *prompt, char *buf, size_t blen,
+		int *redraw, int buffy, int multiple,
+		char ***files, int *numfiles, int flags)
 {
   event_t ch;
 
@@ -754,8 +825,10 @@ int _mutt_enter_fname (const char *prompt, char *buf, size_t blen, int *redraw,
   {
     mutt_refresh ();
     buf[0] = 0;
-    _mutt_select_file (buf, blen, MUTT_SEL_FOLDER | (multiple ? MUTT_SEL_MULTI : 0), 
-		       files, numfiles);
+    if (!flags)
+      flags = MUTT_SEL_FOLDER | (multiple ? MUTT_SEL_MULTI : 0);
+
+    _mutt_select_file (buf, blen, flags, files, numfiles);
     *redraw = REDRAW_FULL;
   }
   else
@@ -769,6 +842,10 @@ int _mutt_enter_fname (const char *prompt, char *buf, size_t blen, int *redraw,
       buf[0] = 0;
     MAYBE_REDRAW (*redraw);
     FREE (&pc);
+#ifdef USE_NOTMUCH
+    if ((flags & MUTT_SEL_VFOLDER) && buf[0] && strncmp(buf, "notmuch://", 10) != 0)
+      nm_description_to_path(buf, buf, blen);
+#endif
   }
 
   return 0;
@@ -933,6 +1010,7 @@ void mutt_format_string (char *dest, size_t destlen,
   size_t k, k2;
   char scratch[MB_LEN_MAX];
   mbstate_t mbstate1, mbstate2;
+  int escaped = 0;
 
   memset(&mbstate1, 0, sizeof (mbstate1));
   memset(&mbstate2, 0, sizeof (mbstate2));
@@ -948,8 +1026,15 @@ void mutt_format_string (char *dest, size_t destlen,
       k = (k == (size_t)(-1)) ? 1 : n;
       wc = replacement_char ();
     }
-    if (arboreal && wc < MUTT_TREE_MAX)
+    if (escaped) {
+      escaped = 0;
+      w = 0;
+    } else if (arboreal && wc == MUTT_SPECIAL_INDEX) {
+      escaped = 1;
+      w = 0;
+    } else if (arboreal && wc < MUTT_TREE_MAX) {
       w = 1; /* hack */
+    }
     else
     {
 #ifdef HAVE_ISWBLANK
@@ -1128,7 +1213,12 @@ size_t mutt_wstr_trunc (const char *src, size_t maxlen, size_t maxwid, size_t *w
     cw = wcwidth (wc);
     /* hack because MUTT_TREE symbols aren't turned into characters
      * until rendered by print_enriched_string (#3364) */
-    if (cw < 0 && cl == 1 && src[0] && src[0] < MUTT_TREE_MAX)
+    if ((cw < 0) && (src[0] == MUTT_SPECIAL_INDEX))
+    {
+      cl = 2; /* skip the index coloring sequence */
+      cw = 0;
+    }
+    else if (cw < 0 && cl == 1 && src[0] && src[0] < MUTT_TREE_MAX)
       cw = 1;
     else if (cw < 0)
       cw = 0;			/* unprintable wchar */
@@ -1186,6 +1276,12 @@ int mutt_strwidth (const char *s)
   memset (&mbstate, 0, sizeof (mbstate));
   for (w=0; n && (k = mbrtowc (&wc, s, n, &mbstate)); s += k, n -= k)
   {
+    if (*s == MUTT_SPECIAL_INDEX) {
+      s += 2; /* skip the index coloring sequence */
+      k = 0;
+      continue;
+    }
+
     if (k == (size_t)(-1) || k == (size_t)(-2))
     {
       if (k == (size_t)(-1))
diff --git a/curs_main.c b/curs_main.c
index 8e0f52a..7604b2c 100644
--- a/curs_main.c
+++ b/curs_main.c
@@ -22,6 +22,7 @@
 
 #include "mutt.h"
 #include "mutt_curses.h"
+#include "mx.h"
 #include "mutt_menu.h"
 #include "mailbox.h"
 #include "mapping.h"
@@ -41,8 +42,16 @@
 #include "imap_private.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include "mutt_crypt.h"
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
+
 
 #include <ctype.h>
 #include <stdlib.h>
@@ -123,7 +132,9 @@ short mutt_ts_capability(void)
 {
   char *term = getenv("TERM");
   char *tcaps;
+#ifdef HAVE_USE_EXTENDED_NAMES
   int tcapi;
+#endif
   char **termp;
   char *known[] = {
     "color-xterm",
@@ -482,6 +493,223 @@ static void resort_index (MUTTMENU *menu)
   menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
 }
 
+/**
+ * mutt_draw_statusline - Draw a highlighted status bar
+ * @cols:  Maximum number of screen columns
+ * @buf:   Message to be displayed
+ *
+ * Users configure the highlighting of the status bar, e.g.
+ *     color status red default "[0-9][0-9]:[0-9][0-9]"
+ *
+ * Where regexes overlap, the one nearest the start will be used.
+ * If two regexes start at the same place, the longer match will be used.
+ */
+void
+mutt_draw_statusline (int cols, const char *buf, int buflen)
+{
+  int i      = 0;
+  int offset = 0;
+  int found  = 0;
+  int chunks = 0;
+  int len    = 0;
+
+  struct syntax_t
+  {
+    int color;
+    int first;
+    int last;
+  } *syntax = NULL;
+
+  if (!buf)
+    return;
+
+  do
+  {
+    COLOR_LINE *cl;
+    found = 0;
+
+    if (!buf[offset])
+      break;
+
+    /* loop through each "color status regex" */
+    for (cl = ColorStatusList; cl; cl = cl->next)
+    {
+      regmatch_t pmatch[cl->match + 1];
+
+      if (regexec (&cl->rx, buf + offset, cl->match + 1, pmatch, 0) != 0)
+        continue; /* regex doesn't match the status bar */
+
+      int first = pmatch[cl->match].rm_so + offset;
+      int last  = pmatch[cl->match].rm_eo + offset;
+
+      if (first == last)
+        continue; /* ignore an empty regex */
+
+      if (!found)
+      {
+        chunks++;
+        safe_realloc (&syntax, chunks * sizeof (struct syntax_t));
+      }
+
+      i = chunks - 1;
+      if (!found || (first < syntax[i].first) || ((first == syntax[i].first) && (last > syntax[i].last)))
+      {
+        syntax[i].color = cl->pair;
+        syntax[i].first = first;
+        syntax[i].last  = last;
+      }
+      found = 1;
+    }
+
+    if (syntax)
+    {
+      offset = syntax[i].last;
+    }
+  } while (found);
+
+  /* Only 'len' bytes will fit into 'cols' screen columns */
+  len = mutt_wstr_trunc (buf, buflen, cols, NULL);
+
+  offset = 0;
+
+  if ((chunks > 0) && (syntax[0].first > 0))
+  {
+    /* Text before the first highlight */
+    addnstr (buf, MIN(len, syntax[0].first));
+    attrset (ColorDefs[MT_COLOR_STATUS]);
+    if (len <= syntax[0].first)
+      goto dsl_finish;  /* no more room */
+
+    offset = syntax[0].first;
+  }
+
+  for (i = 0; i < chunks; i++)
+  {
+    /* Highlighted text */
+    attrset (syntax[i].color);
+    addnstr (buf + offset, MIN(len, syntax[i].last) - offset);
+    if (len <= syntax[i].last)
+      goto dsl_finish;  /* no more room */
+
+    int next;
+    if ((i + 1) == chunks)
+    {
+      next = len;
+    }
+    else
+    {
+      next = MIN (len, syntax[i+1].first);
+    }
+
+    attrset (ColorDefs[MT_COLOR_STATUS]);
+    offset = syntax[i].last;
+    addnstr (buf + offset, next - offset);
+
+    offset = next;
+    if (offset >= len)
+      goto dsl_finish;  /* no more room */
+  }
+
+  attrset (ColorDefs[MT_COLOR_STATUS]);
+  if (offset < len)
+  {
+    /* Text after the last highlight */
+    addnstr (buf + offset, len - offset);
+  }
+
+  int width = mutt_strwidth (buf);
+  if (width < cols)
+  {
+    /* Pad the rest of the line with whitespace */
+    mutt_paddstr (cols - width, "");
+  }
+dsl_finish:
+  FREE(&syntax);
+}
+
+static int main_change_folder(MUTTMENU *menu, int op, char *buf, size_t bufsz,
+			  int *oldcount, int *index_hint, int flags)
+{
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    unset_option (OPTNEWS);
+    nntp_expand_path (buf, bufsz, &CurrentNewsSrv->conn->account);
+  }
+  else
+#endif
+  mutt_expand_path (buf, bufsz);
+  if (mx_get_magic (buf) <= 0)
+  {
+    mutt_error (_("%s is not a mailbox."), buf);
+    return -1;
+  }
+  mutt_str_replace (&CurrentFolder, buf);
+
+  /* keepalive failure in mutt_enter_fname may kill connection. #3028 */
+  if (Context && !Context->path)
+    FREE (&Context);
+
+  if (Context)
+  {
+    int check;
+
+#ifdef USE_COMPRESSED
+	  if (Context->compress_info && Context->realpath)
+	    mutt_str_replace (&LastFolder, Context->realpath);
+	  else
+#endif
+    mutt_str_replace (&LastFolder, Context->path);
+    *oldcount = Context ? Context->msgcount : 0;
+
+    if ((check = mx_close_mailbox (Context, index_hint)) != 0)
+    {
+      if (check == MUTT_NEW_MAIL || check == MUTT_REOPENED)
+        update_index (menu, Context, check, *oldcount, *index_hint);
+
+      set_option (OPTSEARCHINVALID);
+      menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
+      return 0;
+    }
+    FREE (&Context);
+  }
+
+  if (Labels)
+    hash_destroy(&Labels, NULL);
+
+  mutt_sleep (0);
+
+  /* Set CurrentMenu to MENU_MAIN before executing any folder
+   * hooks so that all the index menu functions are available to
+   * the exec command.
+   */
+
+  CurrentMenu = MENU_MAIN;
+  mutt_folder_hook (buf);
+
+  if ((Context = mx_open_mailbox (buf,
+		(option (OPTREADONLY) || op == OP_MAIN_CHANGE_FOLDER_READONLY) ?
+		MUTT_READONLY : 0, NULL)) != NULL)
+  {
+    Labels = hash_create(131, 0);
+    mutt_scan_labels(Context);
+    menu->current = ci_first_message ();
+  }
+  else
+    menu->current = 0;
+
+#ifdef USE_SIDEBAR
+        mutt_sb_set_open_buffy ();
+#endif
+
+  mutt_clear_error ();
+  mutt_buffy_check(1); /* force the buffy check after we have changed the folder */
+  menu->redraw = REDRAW_FULL;
+  set_option (OPTSEARCHINVALID);
+
+  return 0;
+}
+
 static const struct mapping_t IndexHelp[] = {
   { N_("Quit"),  OP_QUIT },
   { N_("Del"),   OP_DELETE },
@@ -494,12 +722,27 @@ static const struct mapping_t IndexHelp[] = {
   { NULL,	 0 }
 };
 
+#ifdef USE_NNTP
+struct mapping_t IndexNewsHelp[] = {
+  { N_("Quit"),     OP_QUIT },
+  { N_("Del"),      OP_DELETE },
+  { N_("Undel"),    OP_UNDELETE },
+  { N_("Save"),     OP_SAVE },
+  { N_("Post"),     OP_POST },
+  { N_("Followup"), OP_FOLLOWUP },
+  { N_("Catchup"),  OP_CATCHUP },
+  { N_("Help"),     OP_HELP },
+  { NULL,           0 }
+};
+#endif
+
 /* This function handles the message index window as well as commands returned
  * from the pager (MENU_PAGER).
  */
 int mutt_index_menu (void)
 {
   char buf[LONG_STRING], helpstr[LONG_STRING];
+  int flags;
   int op = OP_NULL;
   int done = 0;                /* controls when to exit the "event" loop */
   int i = 0, j;
@@ -518,7 +761,11 @@ int mutt_index_menu (void)
   menu->make_entry = index_make_entry;
   menu->color = index_color;
   menu->current = ci_first_message ();
-  menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_MAIN, IndexHelp);
+  menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_MAIN,
+#ifdef USE_NNTP
+	(Context && (Context->magic == MUTT_NNTP)) ? IndexNewsHelp :
+#endif
+	IndexHelp);
 
   if (!attach_msg)
     mutt_buffy_check(1); /* force the buffy check after we enter the folder */
@@ -577,6 +824,12 @@ int mutt_index_menu (void)
 	  mutt_message _("New mail in this mailbox.");
 	  if (option (OPTBEEPNEW))
 	    beep ();
+	  if (NewMailCmd)
+	  {
+	    char cmd[LONG_STRING];
+	    menu_status_line(cmd, sizeof(cmd), menu, NONULL(NewMailCmd));
+	    mutt_system(cmd);
+	  }
 	} else if (check == MUTT_FLAGS)
 	  mutt_message _("Mailbox was externally modified.");
 
@@ -603,6 +856,12 @@ int mutt_index_menu (void)
          menu->redraw |= REDRAW_STATUS;
          if (option (OPTBEEPNEW))
            beep();
+         if (NewMailCmd)
+         {
+           char cmd[LONG_STRING];
+           menu_status_line(cmd, sizeof(cmd), menu, NONULL(NewMailCmd));
+           mutt_system(cmd);
+         }
        }
      }
      else
@@ -647,7 +906,7 @@ int mutt_index_menu (void)
 	menu_status_line (buf, sizeof (buf), menu, NONULL (Status));
         mutt_window_move (MuttStatusWindow, 0, 0);
 	SETCOLOR (MT_COLOR_STATUS);
-	mutt_paddstr (MuttStatusWindow->cols, buf);
+	mutt_draw_statusline (MuttStatusWindow->cols, buf, sizeof (buf));
 	NORMAL_COLOR;
 	menu->redraw &= ~REDRAW_STATUS;
 	if (option(OPTTSENABLED) && TSSupported)
@@ -696,8 +955,10 @@ int mutt_index_menu (void)
 
       dprint(4, (debugfile, "mutt_index_menu[%d]: Got op %d\n", __LINE__, op));
 
-      if (op == -1)
+      if (op == -1) {
+        mutt_timeout_hook();
 	continue; /* either user abort or timeout */
+      }
 
       mutt_curs_set (1);
 
@@ -773,6 +1034,15 @@ int mutt_index_menu (void)
       mutt_curs_set (1);	/* fallback from the pager */
     }
 
+#ifdef USE_NNTP
+    unset_option (OPTNEWS);	/* for any case */
+#endif
+
+#ifdef USE_NOTMUCH
+    if (Context)
+      nm_debug_check(Context);
+#endif
+
     switch (op)
     {
 
@@ -823,6 +1093,161 @@ int mutt_index_menu (void)
 	menu_current_bottom (menu);
 	break;
 
+#ifdef USE_NNTP
+      case OP_GET_PARENT:
+	CHECK_MSGCOUNT;
+	CHECK_VISIBLE;
+
+      case OP_GET_MESSAGE:
+	CHECK_IN_MAILBOX;
+	CHECK_READONLY;
+	CHECK_ATTACH;
+	if (Context->magic == MUTT_NNTP)
+	{
+	  HEADER *hdr;
+
+	  if (op == OP_GET_MESSAGE)
+	  {
+	    buf[0] = 0;
+	    if (mutt_get_field (_("Enter Message-Id: "),
+		buf, sizeof (buf), 0) != 0 || !buf[0])
+	      break;
+	  }
+	  else
+	  {
+	    LIST *ref = CURHDR->env->references;
+	    if (!ref)
+	    {
+	      mutt_error _("Article has no parent reference.");
+	      break;
+	    }
+	    strfcpy (buf, ref->data, sizeof (buf));
+	  }
+	  if (!Context->id_hash)
+	    Context->id_hash = mutt_make_id_hash (Context);
+	  hdr = hash_find (Context->id_hash, buf);
+	  if (hdr)
+	  {
+	    if (hdr->virtual != -1)
+	    {
+	      menu->current = hdr->virtual;
+	      menu->redraw = REDRAW_MOTION_RESYNCH;
+	    }
+	    else if (hdr->collapsed)
+	    {
+	      mutt_uncollapse_thread (Context, hdr);
+	      mutt_set_virtual (Context);
+	      menu->current = hdr->virtual;
+	      menu->redraw = REDRAW_MOTION_RESYNCH;
+	    }
+	    else
+	      mutt_error _("Message is not visible in limited view.");
+	  }
+	  else
+	  {
+	    int rc;
+
+	    mutt_message (_("Fetching %s from server..."), buf);
+	    rc = nntp_check_msgid (Context, buf);
+	    if (rc == 0)
+	    {
+	      hdr = Context->hdrs[Context->msgcount - 1];
+	      mutt_sort_headers (Context, 0);
+	      menu->current = hdr->virtual;
+	      menu->redraw = REDRAW_FULL;
+	    }
+	    else if (rc > 0)
+	      mutt_error (_("Article %s not found on the server."), buf);
+	  }
+	}
+	break;
+
+      case OP_GET_CHILDREN:
+      case OP_RECONSTRUCT_THREAD:
+	CHECK_MSGCOUNT;
+	CHECK_VISIBLE;
+	CHECK_READONLY;
+	CHECK_ATTACH;
+	if (Context->magic == MUTT_NNTP)
+	{
+	  int oldmsgcount = Context->msgcount;
+	  int oldindex = CURHDR->index;
+	  int rc = 0;
+
+	  if (!CURHDR->env->message_id)
+	  {
+	    mutt_error _("No Message-Id. Unable to perform operation.");
+	    break;
+	  }
+
+	  mutt_message _("Fetching message headers...");
+	  if (!Context->id_hash)
+	    Context->id_hash = mutt_make_id_hash (Context);
+	  strfcpy (buf, CURHDR->env->message_id, sizeof (buf));
+
+	  /* trying to find msgid of the root message */
+	  if (op == OP_RECONSTRUCT_THREAD)
+	  {
+	    LIST *ref = CURHDR->env->references;
+	    while (ref)
+	    {
+	      if (hash_find (Context->id_hash, ref->data) == NULL)
+	      {
+		rc = nntp_check_msgid (Context, ref->data);
+		if (rc < 0)
+		  break;
+	      }
+
+	      /* the last msgid in References is the root message */
+	      if (!ref->next)
+		strfcpy (buf, ref->data, sizeof (buf));
+	      ref = ref->next;
+	    }
+	  }
+
+	  /* fetching all child messages */
+	  if (rc >= 0)
+	    rc = nntp_check_children (Context, buf);
+
+	  /* at least one message has been loaded */
+	  if (Context->msgcount > oldmsgcount)
+	  {
+	    HEADER *hdr;
+	    int i, quiet = Context->quiet;
+
+	    if (rc < 0)
+	      Context->quiet = 1;
+	    mutt_sort_headers (Context, (op == OP_RECONSTRUCT_THREAD));
+	    Context->quiet = quiet;
+
+	    /* if the root message was retrieved, move to it */
+	    hdr = hash_find (Context->id_hash, buf);
+	    if (hdr)
+	      menu->current = hdr->virtual;
+
+	    /* try to restore old position */
+	    else
+	    {
+	      for (i = 0; i < Context->msgcount; i++)
+	      {
+		if (Context->hdrs[i]->index == oldindex)
+		{
+		  menu->current = Context->hdrs[i]->virtual;
+		  /* as an added courtesy, recenter the menu
+		   * with the current entry at the middle of the screen */
+		  menu_check_recenter (menu);
+		  menu_current_middle (menu);
+		}
+	      }
+	    }
+	    menu->redraw = REDRAW_FULL;
+	  }
+	  else if (rc >= 0)
+	    mutt_error _("No deleted messages found in the thread.");
+	}
+	break;
+#endif
+
       case OP_JUMP:
 
 	CHECK_MSGCOUNT;
@@ -919,12 +1344,35 @@ int mutt_index_menu (void)
 	}
         break;
 
+      case OP_LIMIT_CURRENT_THREAD:
       case OP_MAIN_LIMIT:
+      case OP_TOGGLE_READ:
 
 	CHECK_IN_MAILBOX;
 	menu->oldcurrent = (Context->vcount && menu->current >= 0 && menu->current < Context->vcount) ?
 		CURHDR->index : -1;
-	if (mutt_pattern_func (MUTT_LIMIT, _("Limit to messages matching: ")) == 0)
+	if (op == OP_TOGGLE_READ)
+	{
+	  char buf[LONG_STRING];
+
+	  if (!Context->pattern || strncmp (Context->pattern, "!~R!~D~s", 8) != 0)
+	  {
+	    snprintf (buf, sizeof (buf), "!~R!~D~s%s",
+		      Context->pattern ? Context->pattern : ".*");
+	    set_option (OPTHIDEREAD);
+	  }
+	  else
+	  {
+	    strfcpy (buf, Context->pattern + 8, sizeof(buf));
+	    if (!*buf || strncmp (buf, ".*", 2) == 0)
+	      snprintf (buf, sizeof(buf), "~A");
+	    unset_option (OPTHIDEREAD);
+	  }
+	  FREE (&Context->pattern);
+	  Context->pattern = safe_strdup (buf);
+	}
+	if ((op == OP_TOGGLE_READ && mutt_pattern_func (MUTT_LIMIT, NULL) == 0) ||
+	    mutt_pattern_func (MUTT_LIMIT, _("Limit to messages matching: ")) == 0)
 	{
 	  if (menu->oldcurrent >= 0)
 	  {
@@ -1165,22 +1613,173 @@ int mutt_index_menu (void)
 	  menu->redraw = REDRAW_FULL;
 	break;
 
+      case OP_MAIN_QUASI_DELETE:
+	if (tag) {
+	  for (j = 0; j < Context->vcount; j++) {
+	    if (Context->hdrs[Context->v2r[j]]->tagged) {
+	      Context->hdrs[Context->v2r[j]]->quasi_deleted = TRUE;
+	      Context->changed = TRUE;
+	    }
+	  }
+	} else {
+	  CURHDR->quasi_deleted = TRUE;
+	  Context->changed = 1;
+	}
+	break;
+
+#ifdef USE_NOTMUCH
+      case OP_MAIN_ENTIRE_THREAD:
+      {
+	int oldcount  = Context->msgcount;
+	if (Context->magic != MUTT_NOTMUCH) {
+	  mutt_message _("No virtual folder, aborting.");
+	  break;
+	}
+	CHECK_MSGCOUNT;
+        CHECK_VISIBLE;
+	if (nm_read_entire_thread(Context, CURHDR) < 0) {
+	   mutt_message _("Failed to read thread, aborting.");
+	   break;
+	}
+	if (oldcount < Context->msgcount) {
+		HEADER *oldcur = CURHDR;
+
+		if ((Sort & SORT_MASK) == SORT_THREADS)
+			mutt_sort_headers (Context, 0);
+		menu->current = oldcur->virtual;
+		menu->redraw = REDRAW_STATUS | REDRAW_INDEX;
+
+		if (oldcur->collapsed || Context->collapsed) {
+			menu->current = mutt_uncollapse_thread(Context, CURHDR);
+			mutt_set_virtual(Context);
+		}
+	}
+	if (menu->menu == MENU_PAGER)
+	{
+	  op = OP_DISPLAY_MESSAGE;
+	  continue;
+	}
+	break;
+      }
+
+      case OP_MAIN_MODIFY_LABELS:
+      case OP_MAIN_MODIFY_LABELS_THEN_HIDE:
+      {
+	if (Context->magic != MUTT_NOTMUCH) {
+	  mutt_message _("No virtual folder, aborting.");
+	  break;
+	}
+	CHECK_MSGCOUNT;
+        CHECK_VISIBLE;
+	*buf = '\0';
+	if (mutt_get_field ("Add/remove labels: ", buf, sizeof (buf), MUTT_NM_TAG) || !*buf)
+	{
+          mutt_message _("No label specified, aborting.");
+          break;
+        }
+	if (tag)
+	{
+	  char msgbuf[STRING];
+	  progress_t progress;
+	  int px;
+
+	  if (!Context->quiet) {
+	    snprintf(msgbuf, sizeof (msgbuf), _("Update labels..."));
+	    mutt_progress_init(&progress, msgbuf, MUTT_PROGRESS_MSG,
+				   1, Context->tagged);
+	  }
+	  nm_longrun_init(Context, TRUE);
+	  for (px = 0, j = 0; j < Context->vcount; j++) {
+	    if (Context->hdrs[Context->v2r[j]]->tagged) {
+	      if (!Context->quiet)
+		mutt_progress_update(&progress, ++px, -1);
+	      nm_modify_message_tags(Context, Context->hdrs[Context->v2r[j]], buf);
+	      if (op == OP_MAIN_MODIFY_LABELS_THEN_HIDE)
+	      {
+		Context->hdrs[Context->v2r[j]]->quasi_deleted = TRUE;
+	        Context->changed = TRUE;
+	      }
+	    }
+	  }
+	  nm_longrun_done(Context);
+	  menu->redraw = REDRAW_STATUS | REDRAW_INDEX;
+	}
+	else
+	{
+	  if (nm_modify_message_tags(Context, CURHDR, buf)) {
+	    mutt_message _("Failed to modify labels, aborting.");
+	    break;
+	  }
+	  if (op == OP_MAIN_MODIFY_LABELS_THEN_HIDE)
+	  {
+	    CURHDR->quasi_deleted = TRUE;
+	    Context->changed = TRUE;
+	  }
+	  if (menu->menu == MENU_PAGER)
+	  {
+	    op = OP_DISPLAY_MESSAGE;
+	    continue;
+	  }
+	  if (option (OPTRESOLVE))
+	  {
+	    if ((menu->current = ci_next_undeleted (menu->current)) == -1)
+	    {
+	      menu->current = menu->oldcurrent;
+	      menu->redraw = REDRAW_CURRENT;
+	    }
+	    else
+	      menu->redraw = REDRAW_MOTION_RESYNCH;
+	  }
+	  else
+	    menu->redraw = REDRAW_CURRENT;
+	}
+	menu->redraw |= REDRAW_STATUS;
+	break;
+      }
+
+      case OP_MAIN_VFOLDER_FROM_QUERY:
+	buf[0] = '\0';
+        if (mutt_get_field ("Query: ", buf, sizeof (buf), MUTT_NM_QUERY) != 0 || !buf[0])
+        {
+          mutt_message _("No query, aborting.");
+          break;
+        }
+	if (!nm_uri_from_query(Context, buf, sizeof (buf)))
+	  mutt_message _("Failed to create query, aborting.");
+	else
+	  main_change_folder(menu, op, buf, sizeof (buf), &oldcount, &index_hint, 0);
+	break;
+
+      case OP_MAIN_CHANGE_VFOLDER:
+#endif
+
 #ifdef USE_SIDEBAR
       case OP_SIDEBAR_OPEN:
 #endif
       case OP_MAIN_CHANGE_FOLDER:
       case OP_MAIN_NEXT_UNREAD_MAILBOX:
-
-	if (attach_msg)
-	  op = OP_MAIN_CHANGE_FOLDER_READONLY;
-
-	/* fallback to the readonly case */
-
       case OP_MAIN_CHANGE_FOLDER_READONLY:
+#ifdef USE_NNTP
+      case OP_MAIN_CHANGE_GROUP:
+      case OP_MAIN_CHANGE_GROUP_READONLY:
+	unset_option (OPTNEWS);
+#endif
+	if (attach_msg || option (OPTREADONLY) ||
+#ifdef USE_NNTP
+	    op == OP_MAIN_CHANGE_GROUP_READONLY ||
+#endif
+	    op == OP_MAIN_CHANGE_FOLDER_READONLY)
+	  flags = MUTT_READONLY;
+	else
+	  flags = 0;
 
-        if ((op == OP_MAIN_CHANGE_FOLDER_READONLY) || option (OPTREADONLY))
+	if (flags)
           cp = _("Open mailbox in read-only mode");
-        else
+#ifdef USE_NOTMUCH
+        else if (op == OP_MAIN_CHANGE_VFOLDER)
+	  cp = _("Open virtual folder");
+#endif
+	else
           cp = _("Open mailbox");
 
 	buf[0] = '\0';
@@ -1204,8 +1803,38 @@ int mutt_index_menu (void)
           strncpy (buf, path, sizeof (buf));
         }
 #endif
+#ifdef USE_NOTMUCH
+	else if (op == OP_MAIN_CHANGE_VFOLDER) {
+	  if (Context->magic == MUTT_NOTMUCH) {
+		  strfcpy(buf, Context->path, sizeof (buf));
+		  mutt_buffy_vfolder (buf, sizeof (buf));
+	  }
+	  mutt_enter_vfolder (cp, buf, sizeof (buf), &menu->redraw, 1);
+	  if (!buf[0])
+	  {
+            mutt_window_clearline (MuttMessageWindow, 0);
+	    break;
+	  }
+	}
+#endif
 	else
 	{
+#ifdef USE_NNTP
+	  if (op == OP_MAIN_CHANGE_GROUP ||
+	      op == OP_MAIN_CHANGE_GROUP_READONLY)
+	  {
+	    set_option (OPTNEWS);
+	    CurrentNewsSrv = nntp_select_server (NewsServer, 0);
+	    if (!CurrentNewsSrv)
+	      break;
+	    if (flags)
+	      cp = _("Open newsgroup in read-only mode");
+	    else
+	      cp = _("Open newsgroup");
+	    nntp_buffy (buf, sizeof (buf));
+	  }
+	  else
+#endif
 	  mutt_buffy (buf, sizeof (buf));
 
           if (mutt_enter_fname (cp, buf, sizeof (buf), &menu->redraw, 1) == -1)
@@ -1225,65 +1854,16 @@ int mutt_index_menu (void)
 	  }
 	}
 
+	main_change_folder(menu, op, buf, sizeof (buf), &oldcount, &index_hint, flags);
+#ifdef USE_NNTP
+	/* mutt_buffy_check() must be done with mail-reader mode! */
+	menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_MAIN,
+	  (Context && (Context->magic == MUTT_NNTP)) ? IndexNewsHelp : IndexHelp);
+#endif
 	mutt_expand_path (buf, sizeof (buf));
-	if (mx_get_magic (buf) <= 0)
-	{
-	  mutt_error (_("%s is not a mailbox."), buf);
-	  break;
-	}
-	mutt_str_replace (&CurrentFolder, buf);
-
-	/* keepalive failure in mutt_enter_fname may kill connection. #3028 */
-	if (Context && !Context->path)
-	  FREE (&Context);
-
-        if (Context)
-        {
-	  int check;
-
-	  mutt_str_replace (&LastFolder, Context->path);
-	  oldcount = Context ? Context->msgcount : 0;
-
-	  if ((check = mx_close_mailbox (Context, &index_hint)) != 0)
-	  {
-	    if (check == MUTT_NEW_MAIL || check == MUTT_REOPENED)
-	      update_index (menu, Context, check, oldcount, index_hint);
-
-	    set_option (OPTSEARCHINVALID);
-	    menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
-	    break;
-	  }
-	  FREE (&Context);
-	}
-
-        mutt_sleep (0);
-
-	/* Set CurrentMenu to MENU_MAIN before executing any folder
-	 * hooks so that all the index menu functions are available to
-	 * the exec command.
-	 */
-
-	CurrentMenu = MENU_MAIN;
-	mutt_folder_hook (buf);
-
-	if ((Context = mx_open_mailbox (buf,
-					(option (OPTREADONLY) || op == OP_MAIN_CHANGE_FOLDER_READONLY) ?
-					MUTT_READONLY : 0, NULL)) != NULL)
-	{
-	  menu->current = ci_first_message ();
-	}
-	else
-	  menu->current = 0;
-
 #ifdef USE_SIDEBAR
-        mutt_sb_set_open_buffy ();
+        mutt_sb_set_open_buffy();
 #endif
-
-	mutt_clear_error ();
-	mutt_buffy_check(1); /* force the buffy check after we have changed
-			      the folder */
-	menu->redraw = REDRAW_FULL;
-	set_option (OPTSEARCHINVALID);
 	break;
 
       case OP_DISPLAY_MESSAGE:
@@ -1331,7 +1911,7 @@ int mutt_index_menu (void)
 
 	if ((menu->menu == MENU_MAIN)
 	    && (query_quadoption (OPT_QUIT,
-				  _("Exit Mutt without saving?")) == MUTT_YES))
+				  _("Exit NeoMutt without saving?")) == MUTT_YES))
 	{
 	  if (Context)
 	  {
@@ -1347,6 +1927,7 @@ int mutt_index_menu (void)
 	CHECK_MSGCOUNT;
         CHECK_VISIBLE;
 	CHECK_READONLY;
+	CHECK_ACL(MUTT_ACL_WRITE, _("Cannot break thread"));
 
         if ((Sort & SORT_MASK) != SORT_THREADS)
 	  mutt_error _("Threading is not enabled.");
@@ -1382,7 +1963,7 @@ int mutt_index_menu (void)
         CHECK_VISIBLE;
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(MUTT_ACL_DELETE, _("Cannot link threads"));
+	CHECK_ACL(MUTT_ACL_WRITE, _("Cannot link threads"));
 
         if ((Sort & SORT_MASK) != SORT_THREADS)
 	  mutt_error _("Threading is not enabled.");
@@ -2018,6 +2599,20 @@ int mutt_index_menu (void)
 	}
 	break;
 
+#ifdef USE_NNTP
+      case OP_CATCHUP:
+	CHECK_MSGCOUNT;
+	CHECK_READONLY;
+	CHECK_ATTACH
+	if (Context && Context->magic == MUTT_NNTP)
+	{
+	  NNTP_DATA *nntp_data = Context->data;
+	  if (mutt_newsgroup_catchup (nntp_data->nserv, nntp_data->group))
+	    menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
+	}
+	break;
+#endif
+
       case OP_DISPLAY_ADDRESS:
 
 	CHECK_MSGCOUNT;
@@ -2079,6 +2674,21 @@ int mutt_index_menu (void)
 	menu->redraw = REDRAW_FULL;
 	break;
 
+      case OP_EDIT_LABEL:
+
+	CHECK_MSGCOUNT;
+	CHECK_READONLY;
+	rc = mutt_label_message(tag ? NULL : CURHDR);
+	if (rc > 0) {
+	  Context->changed = 1;
+	  menu->redraw = REDRAW_FULL;
+	  mutt_message ("%d label%s changed.", rc, rc == 1 ? "" : "s");
+	}
+	else {
+	  mutt_message _("No labels changed.");
+	}
+	break;
+
       case OP_LIST_REPLY:
 
 	CHECK_ATTACH;
@@ -2224,6 +2834,39 @@ int mutt_index_menu (void)
         menu->redraw = REDRAW_FULL;
         break;
 
+#ifdef USE_NNTP
+      case OP_FOLLOWUP:
+      case OP_FORWARD_TO_GROUP:
+
+	CHECK_MSGCOUNT;
+	CHECK_VISIBLE;
+
+      case OP_POST:
+
+	CHECK_ATTACH;
+	if (op != OP_FOLLOWUP || !CURHDR->env->followup_to ||
+	    mutt_strcasecmp (CURHDR->env->followup_to, "poster") ||
+	    query_quadoption (OPT_FOLLOWUPTOPOSTER,
+	    _("Reply by mail as poster prefers?")) != MUTT_YES)
+	{
+	  if (Context && Context->magic == MUTT_NNTP &&
+	      !((NNTP_DATA *)Context->data)->allowed &&
+	      query_quadoption (OPT_TOMODERATED,
+	      _("Posting to this group not allowed, may be moderated. Continue?")) != MUTT_YES)
+	    break;
+	  if (op == OP_POST)
+	    ci_send_message (SENDNEWS, NULL, NULL, Context, NULL);
+	  else
+	  {
+	    CHECK_MSGCOUNT;
+	    ci_send_message ((op == OP_FOLLOWUP ? SENDREPLY : SENDFORWARD) |
+			SENDNEWS, NULL, NULL, Context, tag ? NULL : CURHDR);
+	  }
+	  menu->redraw = REDRAW_FULL;
+	  break;
+	}
+#endif
+
       case OP_REPLY:
 
 	CHECK_ATTACH;
@@ -2363,12 +3006,21 @@ int mutt_index_menu (void)
         mutt_reflow_windows();
 	menu->redraw = REDRAW_FULL;
 	break;
+
+      case OP_SIDEBAR_TOGGLE_VIRTUAL:
+	mutt_sb_toggle_virtual();
+	break;
 #endif
       default:
 	if (menu->menu == MENU_MAIN)
 	  km_error_key (MENU_MAIN);
     }
 
+#ifdef USE_NOTMUCH
+    if (Context)
+      nm_debug_check(Context);
+#endif
+
     if (menu->menu == MENU_PAGER)
     {
       mutt_clear_pager_position ();
diff --git a/doc/Makefile.am b/doc/Makefile.am
index bc8f856..2c2d7e4 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -14,7 +14,6 @@ noinst_PROGRAMS = makedoc
 
 EXTRA_DIST = dotlock.man		\
         smime_keys.man                  \
-	muttbug.man			\
 	mutt.man			\
 	pgpewrap.man			\
 	pgpring.man			\
@@ -46,8 +45,8 @@ BUILT_DISTFILES = stamp-doc-xml stamp-doc-chunked manual.txt $(HTML_DOCFILES)
 srcdir_DOCFILES = PGP-Notes.txt applying-patches.txt	\
 	devel-notes.txt patch-notes.txt smime-notes.txt
 
-topsrcdir_DOCFILES = COPYRIGHT GPL INSTALL ChangeLog	\
-	README NEWS TODO README.SECURITY README.SSL 
+topsrcdir_DOCFILES = COPYRIGHT GPL INSTALL ChangeLog ChangeLog.neomutt	\
+	README NEWS TODO README.SECURITY README.SSL README.neomutt README.notmuch
 
 all: makedoc-all
 
@@ -61,8 +60,6 @@ install-data-local: makedoc-all instdoc
 	./instdoc smime_keys.1 $(DESTDIR)$(mandir)/man1/smime_keys.1
 	./instdoc pgpewrap.1 $(DESTDIR)$(mandir)/man1/pgpewrap.1
 	./instdoc pgpring.1 $(DESTDIR)$(mandir)/man1/pgpring.1
-	./instdoc $(srcdir)/muttbug.man $(DESTDIR)$(mandir)/man1/flea.1
-	./instdoc $(srcdir)/muttbug.man $(DESTDIR)$(mandir)/man1/muttbug.1
 	test x$(DOTLOCK_TARGET) = x || ./instdoc $(srcdir)/dotlock.man \
 		$(DESTDIR)$(mandir)/man1/mutt_dotlock.1
 	./instdoc muttrc.man $(DESTDIR)$(mandir)/man5/muttrc.5
@@ -89,7 +86,7 @@ install-data-local: makedoc-all instdoc
 	fi
 
 uninstall-local:
-	for f in mutt.1 mutt_dotlock.1 flea.1 muttbug.1 smime_keys.1 pgpewrap.1 pgpring.1; do \
+	for f in mutt.1 mutt_dotlock.1 smime_keys.1 pgpewrap.1 pgpring.1; do \
 		rm -f $(DESTDIR)$(mandir)/man1/$$f ; \
 	done
 	for f in muttrc.5 mbox.5 mmdf.5 ; do \
@@ -189,9 +186,9 @@ smime_keys.1: $(srcdir)/smime_keys.man
 
 stamp-doc-xml: makedoc$(EXEEXT) $(top_srcdir)/init.h \
                manual.xml.head $(top_srcdir)/functions.h $(top_srcdir)/OPS* manual.xml.tail \
-               $(srcdir)/gen-map-doc $(top_srcdir)/VERSION $(top_srcdir)/ChangeLog
-	( date=`head -n 1 $(top_srcdir)/ChangeLog | LC_ALL=C cut -d ' ' -f 1` && \
-	  sed -e "s/@VERSION\@/`cat $(top_srcdir)/VERSION` ($$date)/" $(srcdir)/manual.xml.head && \
+               $(srcdir)/gen-map-doc
+	( date=`head -n 1 $(top_srcdir)/ChangeLog.neomutt | LC_ALL=C cut -b 1-10` && \
+	  sed -e "s/@VERSION\@/$(PACKAGE_VERSION) ($$date)/" $(srcdir)/manual.xml.head && \
 	  $(MAKEDOC_CPP) $(top_srcdir)/init.h | ./makedoc$(EXEEXT) -s && \
 	  $(MAKEDOC_CPP) $(top_srcdir)/functions.h | \
 	    perl $(srcdir)/gen-map-doc $(srcdir)/manual.xml.tail $(top_srcdir)/OPS* \
diff --git a/doc/Muttrc.head b/doc/Muttrc.head
index 1f7012e..69e27ca 100644
--- a/doc/Muttrc.head
+++ b/doc/Muttrc.head
@@ -29,6 +29,11 @@ macro generic,pager <F1> "<shell-escape> less @docdir@/manual.txt<Enter>" "show
 macro index,pager y "<change-folder>?<toggle-mailboxes>" "show incoming mailboxes list"
 bind browser y exit
 
+# Use folders which match on \\.gz$ as gzipped folders:
+# open-hook \\.gz$ "gzip -cd %f > %t"
+# close-hook \\.gz$ "gzip -c %t > %f"
+# append-hook \\.gz$ "gzip -c %t >> %f"
+
 # If Mutt is unable to determine your site's domain name correctly, you can
 # set the default here.
 #
diff --git a/doc/gen-map-doc b/doc/gen-map-doc
index e2fadac..416ae9e 100644
--- a/doc/gen-map-doc
+++ b/doc/gen-map-doc
@@ -34,7 +34,8 @@ while (<STDIN>) {
     $binding =~ s/^\\(0\d+)$/'^'.chr(64+oct($1))/e;
     $binding =~ s/^\\(0\d+)(.)/'^'.chr(64+oct($1)) ." $2"/e;
     $binding =~ s/\\t/&lt;Tab&gt;/;
-    $binding =~ s/M_ENTER_S/&lt;Return&gt;/;
+    $binding =~ s/\\r/&lt;Return&gt;/;
+    $binding =~ s/\\n/&lt;Enter&gt;/;
     $binding =~ s/NULL//;
     die "unknown key $binding" if $binding =~ /\\[^\\]|<|>/;
     die "unknown OP $op" unless $OPS{$op};
diff --git a/doc/manual.xml.head b/doc/manual.xml.head
index ac22afa..9807cbd 100644
--- a/doc/manual.xml.head
+++ b/doc/manual.xml.head
@@ -412,6 +412,593 @@ <sect2 id="intro-sidebar">
     turned on and off, it can be themed and the list style can be
     configured.
   </para>
+  <para>
+    This part of the manual is suitable for beginners.
+    If you already know Mutt you could skip ahead to the main
+    <link linkend="sidebar">Sidebar guide</link>.
+    If you just want to get started, you could use the sample
+    <link linkend="sidebar-muttrc">Sidebar muttrc</link>.
+  </para>
+  <para>
+    To check if Mutt supports <quote>Sidebar</quote>, look for the string
+    <literal>+USE_SIDEBAR</literal> in the mutt version.
+  </para>
+<screen>
+mutt -v
+</screen>
+  <para>
+    <emphasis role="bold">Let's turn on the Sidebar:</emphasis>
+  </para>
+<screen>
+set sidebar_visible
+set sidebar_format = "%B%?F? [%F]?%* %?N?%N/?%S"
+set mail_check_stats
+</screen>
+  <para>
+    You will see something like this.
+    A list of mailboxes on the left.
+    A list of emails, from the selected mailbox, on the right.
+  </para>
+<screen>
+<emphasis role="indicator">Fruit [1]     3/8</emphasis>|  1    + Jan 24  Rhys Lee         (192)  Yew
+Animals [1]   2/6|  2    + Feb 11  Grace Hall       (167)  Ilama
+Cars            4|  3      Feb 23  Aimee Scott      (450)  Nectarine
+Seas          1/7|  4    ! Feb 28  Summer Jackson   (264)  Lemon
+                 |  5      Mar 07  Callum Harrison  (464)  Raspberry
+                 |<emphasis role="indicator">  6 N  + Mar 24  Samuel Harris    (353)  Tangerine          </emphasis>
+                 |  7 N  + Sep 05  Sofia Graham     (335)  Cherry
+                 |  8 N    Sep 16  Ewan Brown       (105)  Ugli
+                 |
+                 |
+</screen>
+<para>
+  This user has four mailboxes: <quote>Fruit</quote>,
+  <quote>Cars</quote>, <quote>Animals</quote> and
+  <quote>Seas</quote>.
+</para>
+<para>
+  The current, open, mailbox is <quote>Fruit</quote>.  We can
+  also see information about the other mailboxes.  For example:
+  The <quote>Animals</quote> mailbox contains, 1 flagged email, 2
+  new emails out of a total of 6 emails.
+</para>
+  <sect3 id="intro-sidebar-navigation">
+    <title>Navigation</title>
+    <para>
+      The Sidebar adds some new <link linkend="sidebar-functions">functions</link>
+      to Mutt.
+    </para>
+    <para>
+      The user pressed the <quote>c</quote> key to
+      <literal>&lt;change-folder&gt;</literal> to the
+      <quote>Animals</quote> mailbox.  The Sidebar automatically
+      updated the indicator to match.
+    </para>
+<screen>
+Fruit [1]     3/8|  1      Jan 03  Tia Gibson       (362)  Caiman
+<emphasis role="indicator">Animals [1]   2/6</emphasis>|  2    + Jan 22  Rhys Lee         ( 48)  Dolphin
+Cars            4|  3    ! Aug 16  Ewan Brown       (333)  Hummingbird
+Seas          1/7|  4      Sep 25  Grace Hall       ( 27)  Capybara
+                 |<emphasis role="indicator">  5 N  + Nov 12  Evelyn Rogers    (453)  Tapir              </emphasis>
+                 |  6 N  + Nov 16  Callum Harrison  (498)  Hedgehog
+                 |
+                 |
+                 |
+                 |
+</screen>
+    <para>
+      Let's map some functions:
+    </para>
+<screen>
+bind index,pager \CP sidebar-prev       <emphasis role="comment"># Ctrl-Shift-P - Previous Mailbox</emphasis>
+bind index,pager \CN sidebar-next       <emphasis role="comment"># Ctrl-Shift-N - Next Mailbox</emphasis>
+bind index,pager \CO sidebar-open       <emphasis role="comment"># Ctrl-Shift-O - Open Highlighted Mailbox</emphasis>
+</screen>
+    <para>
+      Press <quote>Ctrl-Shift-N</quote> (Next mailbox) twice will
+      move the Sidebar <emphasis role="bold">highlight</emphasis> to
+      down to the <quote>Seas</quote> mailbox.
+    </para>
+<screen>
+Fruit [1]     3/8|  1      Jan 03  Tia Gibson       (362)  Caiman
+<emphasis role="indicator">Animals [1]   2/6</emphasis>|  2    + Jan 22  Rhys Lee         ( 48)  Dolphin
+Cars            4|  3    ! Aug 16  Ewan Brown       (333)  Hummingbird
+<emphasis role="highlight">Seas          1/7</emphasis>|  4      Sep 25  Grace Hall       ( 27)  Capybara
+                 |<emphasis role="indicator">  5 N  + Nov 12  Evelyn Rogers    (453)  Tapir              </emphasis>
+                 |  6 N  + Nov 16  Callum Harrison  (498)  Hedgehog
+                 |
+                 |
+                 |
+                 |
+</screen>
+    <note>
+      <para>
+        Functions <literal>&lt;sidebar-next&gt;</literal> and
+        <literal>&lt;sidebar-prev&gt;</literal> move the Sidebar
+        <emphasis role="bold">highlight</emphasis>.
+        They <emphasis role="bold">do not</emphasis> change the open
+        mailbox.
+      </para>
+    </note>
+    <para>
+      Press <quote>Ctrl-Shift-O</quote>
+      (<literal>&lt;sidebar-open&gt;</literal>)
+      to open the highlighted mailbox.
+    </para>
+<screen>
+Fruit [1]     3/8|  1    ! Mar 07  Finley Jones     (139)  Molucca Sea
+Animals [1]   2/6|  2    + Mar 24  Summer Jackson   ( 25)  Arafura Sea
+Cars            4|  3    + Feb 28  Imogen Baker     (193)  Pechora Sea
+<emphasis role="indicator">Seas          1/7</emphasis>|<emphasis role="indicator">  4 N  + Feb 23  Isla Hussain     (348)  Balearic Sea       </emphasis>
+                 |
+                 |
+                 |
+                 |
+                 |
+                 |
+</screen>
+  </sect3>
+  <sect3 id="intro-sidebar-features">
+    <title>Features</title>
+    <para>
+      The Sidebar shows a list of mailboxes in a panel.
+    </para>
+    <para>
+      Everything about the Sidebar can be configured.
+    </para>
+    <itemizedlist>
+    <title><link linkend="intro-sidebar-basics">State of the Sidebar</link></title>
+      <listitem><para>Visibility</para></listitem>
+      <listitem><para>Width</para></listitem>
+    </itemizedlist>
+    <itemizedlist>
+    <title><link linkend="intro-sidebar-limit">Which mailboxes are displayed</link></title>
+      <listitem><para>Display all</para></listitem>
+      <listitem><para>Limit to mailboxes with new mail</para></listitem>
+      <listitem><para>Whitelist mailboxes to display always</para></listitem>
+    </itemizedlist>
+    <itemizedlist>
+    <title><link linkend="sidebar-sort">The order in which mailboxes are displayed</link></title>
+      <listitem><para>Unsorted (order of mailboxes commands)</para></listitem>
+      <listitem><para>Sorted alphabetically</para></listitem>
+      <listitem><para>Sorted by number of new mails</para></listitem>
+    </itemizedlist>
+    <itemizedlist>
+    <title><link linkend="intro-sidebar-colors">Color</link></title>
+      <listitem><para>Sidebar indicators and divider</para></listitem>
+      <listitem><para>Mailboxes depending on their type</para></listitem>
+      <listitem><para>Mailboxes depending on their contents</para></listitem>
+    </itemizedlist>
+    <itemizedlist>
+    <title><link linkend="sidebar-functions">Key bindings</link></title>
+      <listitem><para>Hide/Unhide the Sidebar</para></listitem>
+      <listitem><para>Select previous/next mailbox</para></listitem>
+      <listitem><para>Select previous/next mailbox with new mail</para></listitem>
+      <listitem><para>Page up/down through a list of mailboxes</para></listitem>
+    </itemizedlist>
+    <itemizedlist>
+    <title>Misc</title>
+      <listitem><para><link linkend="intro-sidebar-format">Formatting string for mailbox</link></para></listitem>
+      <listitem><para><link linkend="sidebar-next-new-wrap">Wraparound searching</link></para></listitem>
+      <listitem><para><link linkend="intro-sidebar-abbrev">Flexible mailbox abbreviations</link></para></listitem>
+      <listitem><para>Support for Unicode mailbox names (utf-8)</para></listitem>
+    </itemizedlist>
+  </sect3>
+  <sect3 id="intro-sidebar-display">
+    <title>Display</title>
+    <para>
+      Everything about the Sidebar can be configured.
+    </para>
+    <itemizedlist>
+      <title>For a quick reference:</title>
+      <listitem><para><link linkend="sidebar-variables">Sidebar variables to set</link> </para></listitem>
+      <listitem><para><link linkend="sidebar-colors">Sidebar colors to apply</link></para></listitem>
+      <listitem><para><link linkend="sidebar-sort">Sidebar sort methods</link></para></listitem>
+    </itemizedlist>
+    <sect4 id="intro-sidebar-basics">
+      <title>Sidebar Basics</title>
+      <para>
+        The most important variable is <literal>$sidebar_visible</literal>.
+        You can set this in your <quote>muttrc</quote>, or bind a key to the
+        function <literal>&lt;sidebar-toggle-visible&gt;</literal>.
+      </para>
+<screen>
+set sidebar_visible                         <emphasis role="comment"># Make the Sidebar visible by default</emphasis>
+bind index,pager B sidebar-toggle-visible   <emphasis role="comment"># Use 'B' to switch the Sidebar on and off</emphasis>
+</screen>
+      <para>
+        Next, decide how wide you want the Sidebar to be.  25
+        characters might be enough for the mailbox name and some numbers.
+    Remember, you can hide/show the Sidebar at the press of button.
+    </para>
+    <para>
+    Finally, you might want to change the divider character.
+    By default, Sidebar draws an ASCII line between it and the Index panel
+        If your terminal supports it, you can use a Unicode line-drawing character.
+      </para>
+<screen>
+set sidebar_width = 25                  <emphasis role="comment"># Plenty of space</emphasis>
+set sidebar_divider_char = '│'          <emphasis role="comment"># Pretty line-drawing character</emphasis>
+</screen>
+    </sect4>
+    <sect4 id="intro-sidebar-format">
+      <title>Sidebar Format String</title>
+      <para>
+        <literal>$sidebar_format</literal> allows you to customize the Sidebar display.
+        For an introduction, read <link linkend="index-format">format strings</link>
+        including the section about <link linkend="formatstrings-conditionals">conditionals</link>.
+      </para>
+      <para>
+        The default value is <literal>%B%*  %n</literal>
+        The default value is <literal>%B%?F? [%F]?%* %?N?%N/?%S</literal>
+      </para>
+      <itemizedlist>
+        <title>Which breaks down as:</title>
+        <listitem><para><literal>%B</literal> - Mailbox name</para></listitem>
+        <listitem><para><literal>%?F? [%F]?</literal> - If flagged emails <literal>[%F]</literal>, otherwise nothing</para></listitem>
+        <listitem><para><literal>%* </literal> - Pad with spaces</para></listitem>
+        <listitem><para><literal>%?N?%N/?</literal> - If new emails <literal>%N/</literal>, otherwise nothing</para></listitem>
+        <listitem><para><literal>%S</literal> - Total number of emails</para></listitem>
+      </itemizedlist>
+      <table>
+        <title>sidebar_format</title>
+        <tgroup cols="3">
+          <thead>
+            <row>
+              <entry>Format</entry>
+              <entry>Notes</entry>
+              <entry>Description</entry>
+            </row>
+          </thead>
+          <tbody>
+            <row>
+              <entry>%B</entry>
+              <entry></entry>
+              <entry>Name of the mailbox</entry>
+            </row>
+            <row>
+              <entry>%S</entry>
+              <entry>* †</entry>
+              <entry>Size of mailbox (total number of messages)</entry>
+            </row>
+            <row>
+              <entry>%F</entry>
+              <entry>* †</entry>
+              <entry>Number of Flagged messages in the mailbox</entry>
+            </row>
+            <row>
+              <entry>%N</entry>
+              <entry>* †</entry>
+              <entry>Number of New messages in the mailbox</entry>
+            </row>
+            <row>
+              <entry>%n</entry>
+              <entry>*</entry>
+              <entry>If there's new mail, display <quote>N</quote>, otherwise nothing</entry>
+            </row>
+            <row>
+              <entry>%!</entry>
+              <entry></entry>
+              <entry>
+                <quote>!</quote>: one flagged message;
+                <quote>!!</quote>: two flagged messages;
+                <quote>n!</quote>: n flagged messages (for n &gt; 2).
+                Otherwise prints nothing.
+              </entry>
+            </row>
+            <row>
+              <entry>%d</entry>
+              <entry>* ‡</entry>
+              <entry>Number of deleted messages</entry>
+            </row>
+            <row>
+              <entry>%L</entry>
+              <entry>* ‡</entry>
+              <entry>Number of messages after limiting</entry>
+            </row>
+            <row>
+              <entry>%t</entry>
+              <entry>* ‡</entry>
+              <entry>Number of tagged messages</entry>
+            </row>
+            <row>
+              <entry>%&gt;X</entry>
+              <entry></entry>
+              <entry>Right justify the rest of the string and pad with <quote>X</quote></entry>
+            </row>
+            <row>
+              <entry>%|X</entry>
+              <entry></entry>
+              <entry>Pad to the end of the line with
+              <quote>X</quote></entry>
+            </row>
+            <row>
+              <entry>%*X</entry>
+              <entry></entry>
+              <entry>Soft-fill with character <quote>X</quote>as pad</entry>
+            </row>
+          </tbody>
+        </tgroup>
+      </table>
+      <para>
+      * = Can be optionally printed if nonzero
+      </para>
+      <para>
+      † = To use this expandos, you must first: <screen>set mail_check_stats</screen>
+      </para>
+      <para>
+      ‡ = Only applicable to the current folder
+      </para>
+      <para>
+        Here are some examples.
+        They show the number of (F)lagged, (N)ew and (S)ize.
+      </para>
+      <table>
+        <title>sidebar_format</title>
+        <tgroup cols="2">
+          <thead>
+            <row>
+              <entry>Format</entry>
+              <entry>Example</entry>
+            </row>
+          </thead>
+          <tbody>
+            <row>
+              <entry><literal>%B%?F? [%F]?%* %?N?%N/?%S</literal></entry>
+              <entry><screen>mailbox [F]            N/S</screen></entry>
+            </row>
+            <row>
+              <entry><literal>%B%* %F:%N:%S</literal></entry>
+              <entry><screen>mailbox              F:N:S</screen></entry>
+            </row>
+            <row>
+              <entry><literal>%B %?N?(%N)?%* %S</literal></entry>
+              <entry><screen>mailbox (N)              S</screen></entry>
+            </row>
+            <row>
+              <entry><literal>%B%* ?F?%F/?%N</literal></entry>
+              <entry><screen>mailbox                F/S</screen></entry>
+            </row>
+          </tbody>
+        </tgroup>
+      </table>
+    </sect4>
+    <sect4 id="intro-sidebar-abbrev">
+      <title>Abbreviating Mailbox Names</title>
+      <para>
+        <literal>$sidebar_delim_chars</literal> tells Sidebar
+        how to split up mailbox paths.  For local directories
+        use <quote>/</quote>; for IMAP folders use <quote>.</quote>
+      </para>
+      <sect5 id="intro-sidebar-abbrev-ex1">
+        <title>Example 1</title>
+        <para>
+          This example works well if your mailboxes have unique names
+          after the last separator.
+        </para>
+        <para>
+          Add some mailboxes of diffent depths.
+        </para>
+<screen>
+set folder="~/mail"
+mailboxes =fruit/apple          =fruit/banana          =fruit/cherry
+mailboxes =water/sea/sicily     =water/sea/archipelago =water/sea/sibuyan
+mailboxes =water/ocean/atlantic =water/ocean/pacific   =water/ocean/arctic
+</screen>
+        <para>
+          Shorten the names:
+        </para>
+<screen>
+set sidebar_short_path                  <emphasis role="comment"># Shorten mailbox names</emphasis>
+set sidebar_delim_chars="/"             <emphasis role="comment"># Delete everything up to the last / character</emphasis>
+</screen>
+        <para>
+          The screenshot below shows what the Sidebar would look like
+          before and after shortening.
+        </para>
+<screen>
+|fruit/apple                            |apple
+|fruit/banana                           |banana
+|fruit/cherry                           |cherry
+|water/sea/sicily                       |sicily
+|water/sea/archipelago                  |archipelago
+|water/sea/sibuyan                      |sibuyan
+|water/ocean/atlantic                   |atlantic
+|water/ocean/pacific                    |pacific
+|water/ocean/arctic                     |arctic
+</screen>
+      </sect5>
+      <sect5 id="intro-sidebar-abbrev-ex2">
+        <title>Example 2</title>
+        <para>
+          This example works well if you have lots of mailboxes which are arranged
+          in a tree.
+        </para>
+        <para>
+          Add some mailboxes of diffent depths.
+        </para>
+<screen>
+set folder="~/mail"
+mailboxes =fruit
+mailboxes =fruit/apple =fruit/banana =fruit/cherry
+mailboxes =water
+mailboxes =water/sea
+mailboxes =water/sea/sicily =water/sea/archipelago =water/sea/sibuyan
+mailboxes =water/ocean
+mailboxes =water/ocean/atlantic =water/ocean/pacific =water/ocean/arctic
+</screen>
+        <para>
+          Shorten the names:
+        </para>
+<screen>
+set sidebar_short_path                  <emphasis role="comment"># Shorten mailbox names</emphasis>
+set sidebar_delim_chars="/"             <emphasis role="comment"># Delete everything up to the last / character</emphasis>
+set sidebar_folder_indent               <emphasis role="comment"># Indent folders whose names we've shortened</emphasis>
+set sidebar_indent_string="  "          <emphasis role="comment"># Indent with two spaces</emphasis>
+</screen>
+        <para>
+          The screenshot below shows what the Sidebar would look like
+          before and after shortening.
+        </para>
+<screen>
+|fruit                                  |fruit
+|fruit/apple                            |  apple
+|fruit/banana                           |  banana
+|fruit/cherry                           |  cherry
+|water                                  |water
+|water/sea                              |  sea
+|water/sea/sicily                       |    sicily
+|water/sea/archipelago                  |    archipelago
+|water/sea/sibuyan                      |    sibuyan
+|water/ocean                            |  ocean
+|water/ocean/atlantic                   |    atlantic
+|water/ocean/pacific                    |    pacific
+|water/ocean/arctic                     |    arctic
+</screen>
+        <para>
+          Sometimes, it will be necessary to add mailboxes, that you
+          don't use, to fill in part of the tree.  This will trade
+          vertical space for horizonal space (but it looks good).
+        </para>
+      </sect5>
+    </sect4>
+    <sect4 id="intro-sidebar-limit">
+      <title>Limiting the Number of Mailboxes</title>
+      <para>
+        If you have a lot of mailboxes, sometimes it can be useful to hide
+        the ones you aren't using.  <literal>$sidebar_new_mail_only</literal>
+        tells Sidebar to only show mailboxes that contain new, or flagged, email.
+      </para>
+      <para>
+        If you want some mailboxes to be always visible, then use the
+        <literal>sidebar_whitelist</literal> command.  It takes a list of
+        mailboxes as parameters.
+      </para>
+<screen>
+set sidebar_new_mail_only               <emphasis role="comment"># Only mailboxes with new/flagged email</emphasis>
+sidebar_whitelist fruit fruit/apple     <emphasis role="comment"># Always display these two mailboxes</emphasis>
+</screen>
+    </sect4>
+  </sect3>
+  <sect3 id="intro-sidebar-colors">
+    <title>Colors</title>
+    <para>
+      Here is a sample color scheme:
+    </para>
+<screen>
+color sidebar_indicator default color17         <emphasis role="comment"># Dark blue background</emphasis>
+color sidebar_highlight white   color238        <emphasis role="comment"># Grey background</emphasis>
+color sidebar_spoolfile yellow  default         <emphasis role="comment"># Yellow</emphasis>
+color sidebar_new       green   default         <emphasis role="comment"># Green</emphasis>
+color sidebar_flagged   red     default         <emphasis role="comment"># Red</emphasis>
+color sidebar_divider   color8  default         <emphasis role="comment"># Dark grey</emphasis>
+</screen>
+    <para>
+      There is a priority order when coloring Sidebar mailboxes.
+      e.g.  If a mailbox has new mail it will have the
+      <literal>sidebar_new</literal> color, even if it also contains
+      flagged mails.
+    </para>
+    <table id="table-intro-sidebar-colors">
+      <title>Sidebar Color Priority</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Priority</entry>
+            <entry>Color</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>Highest</entry>
+            <entry><literal>sidebar_indicator</literal></entry>
+            <entry>Mailbox is open</entry>
+          </row>
+          <row>
+            <entry></entry>
+            <entry><literal>sidebar_highlight</literal></entry>
+            <entry>Mailbox is highlighed</entry>
+          </row>
+          <row>
+            <entry></entry>
+            <entry><literal>sidebar_spoolfile</literal></entry>
+            <entry>Mailbox is the spoolfile (receives incoming mail)</entry>
+          </row>
+          <row>
+            <entry></entry>
+            <entry><literal>sidebar_new</literal></entry>
+            <entry>Mailbox contains new mail</entry>
+          </row>
+          <row>
+            <entry></entry>
+            <entry><literal>sidebar_flagged</literal></entry>
+            <entry>Mailbox contains flagged mail</entry>
+          </row>
+          <row>
+            <entry>Lowest</entry>
+            <entry>(None)</entry>
+            <entry>Mailbox does not match above</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect3>
+  <sect3 id="intro-sidebar-config-changes">
+    <title>Config Changes</title>
+    <para>
+      If you haven't used Sidebar before, you can ignore this section.
+    </para>
+    <para>
+      Some of the Sidebar config has been changed to make its meaning clearer.
+      These changes have been made since the previous Sidebar release: 2015-11-11.
+    </para>
+    <table id="table-intro-sidebar-config-changes">
+      <title>Config Changes</title>
+      <tgroup cols="2">
+        <thead>
+          <row>
+            <entry>Old Name</entry>
+            <entry>New Name</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>$sidebar_delim</literal></entry>
+            <entry><literal>$sidebar_divider_char</literal></entry>
+          </row>
+          <row>
+            <entry><literal>$sidebar_folderindent</literal></entry>
+            <entry><literal>$sidebar_folder_indent</literal></entry>
+          </row>
+          <row>
+            <entry><literal>$sidebar_indentstr</literal></entry>
+            <entry><literal>$sidebar_indent_string</literal></entry>
+          </row>
+          <row>
+            <entry><literal>$sidebar_newmail_only</literal></entry>
+            <entry><literal>$sidebar_new_mail_only</literal></entry>
+          </row>
+          <row>
+            <entry><literal>$sidebar_shortpath</literal></entry>
+            <entry><literal>$sidebar_short_path</literal></entry>
+          </row>
+          <row>
+            <entry><literal>$sidebar_sort</literal></entry>
+            <entry><literal>$sidebar_sort_method</literal></entry>
+          </row>
+          <row>
+            <entry><literal>&lt;sidebar-scroll-down&gt;</literal></entry>
+            <entry><literal>&lt;sidebar-page-down&gt;</literal></entry>
+          </row>
+          <row>
+            <entry><literal>&lt;sidebar-scroll-up&gt;</literal></entry>
+            <entry><literal>&lt;sidebar-page-up&gt;</literal></entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect3>
 </sect2>
 
 <sect2 id="intro-help">
@@ -548,7 +1135,7 @@ <table id="tab-keys-editor">
 <row><entry>^E or &lt;End&gt;</entry><entry><literal>&lt;eol&gt;</literal></entry><entry>move to the end of the line</entry></row>
 <row><entry>^F or &lt;Right&gt;</entry><entry><literal>&lt;forward-char&gt;</literal></entry><entry>move forward one char</entry></row>
 <row><entry>Esc F</entry><entry><literal>&lt;forward-word&gt;</literal></entry><entry>move forward one word</entry></row>
-<row><entry>&lt;Tab&gt;</entry><entry><literal>&lt;complete&gt;</literal></entry><entry>complete filename or alias</entry></row>
+<row><entry>&lt;Tab&gt;</entry><entry><literal>&lt;complete&gt;</literal></entry><entry>complete filename, alias, or label</entry></row>
 <row><entry>^T</entry><entry><literal>&lt;complete-query&gt;</literal></entry><entry>complete address with query</entry></row>
 <row><entry>^K</entry><entry><literal>&lt;kill-eol&gt;</literal></entry><entry>delete to the end of the line</entry></row>
 <row><entry>Esc d</entry><entry><literal>&lt;kill-eow&gt;</literal></entry><entry>delete to the end of the word</entry></row>
@@ -1752,38 +2339,73 @@ <sect1 id="configuration-files">
 <title>Location of Initialization Files</title>
 
 <para>
-While the default configuration (or <quote>preferences</quote>) make
-Mutt usable right out of the box, it is often desirable to tailor Mutt
-to suit your own tastes. When Mutt is first invoked, it will attempt to
-read the <quote>system</quote> configuration file (defaults set by your
-local system administrator), unless the <quote>-n</quote> <link
-linkend="commandline">command line</link> option is specified.  This
-file is typically <literal>/usr/local/share/mutt/Muttrc</literal> or
-<literal>/etc/Muttrc</literal>. Mutt will next look for a file named
-<literal>.muttrc</literal> in your home directory.  If this file does
-not exist and your home directory has a subdirectory named
-<literal>.mutt</literal>, Mutt tries to load a file named
-<literal>.mutt/muttrc</literal>.
+  When Mutt starts up it looks for two configuration files -- a
+  <quote>system</quote> file and a <quote>user</quote> file.
+</para>
+
+<para>
+  Mutt will search for a system config file in several places.  The filenames
+  may depend on the version number of Mutt.  Mutt will read just one file, the
+  first file it finds, from the list below.
+</para>
+
+<para>
+  The system config file will not be read if the <quote>-n</quote>
+  option is used on the <link linkend="commandline">command line</link>.
+</para>
+
+<table id="system-muttrc">
+  <title>Mutt system config file locations</title>
+  <tgroup cols="1">
+    <thead>
+      <row><entry>File Location</entry></row>
+    </thead>
+    <tbody>
+      <row><entry>$XDG_CONFIG_DIRS/neomutt/config</entry></row>
+      <row><entry>/etc/NeoMuttrc</entry></row>
+      <row><entry>/etc/Muttrc-1.7.0-neo</entry></row>
+      <row><entry>/etc/Muttrc</entry></row>
+      <row><entry>/share/mutt/Muttrc-1.7.0-neo</entry></row>
+      <row><entry>/share/mutt/Muttrc</entry></row>
+    </tbody>
+  </tgroup>
+</table>
+
+<para>
+  <emphasis>($XDG_CONFIG_DIRS defaults to "/etc/xdg".)</emphasis>
+</para>
+
+<para>
+  Mutt will search for a user config file in several places in your home
+  directory.  The filenames may depend on the version number of Mutt.  Mutt
+  will read just one file, the first file it finds, from the list below.
 </para>
 
 <para>
-<literal>.muttrc</literal> is the file where you will usually place your
-<link linkend="commands">commands</link> to configure Mutt.
+  You may specify your own location for the user config file using the 
+  <quote>-F</quote> option on the <link linkend="commandline">command line</link>.
 </para>
 
+<table id="user-muttrc">
+  <title>Mutt user config file locations</title>
+  <tgroup cols="1">
+    <thead>
+      <row><entry>File Location</entry></row>
+    </thead>
+    <tbody>
+      <row><entry>$XDG_CONFIG_HOME/neomutt/config</entry></row>
+      <row><entry>~/.neomuttrc</entry></row>
+      <row><entry>~/.mutt/neomuttrc</entry></row>
+      <row><entry>~/.muttrc-1.7.0-neo</entry></row>
+      <row><entry>~/.muttrc</entry></row>
+      <row><entry>~/.mutt/muttrc-1.7.0-neo</entry></row>
+      <row><entry>~/.mutt/muttrc</entry></row>
+    </tbody>
+  </tgroup>
+</table>
+
 <para>
-In addition, Mutt supports version specific configuration files that are
-parsed instead of the default files as explained above.  For instance,
-if your system has a <literal>Muttrc-0.88</literal> file in the system
-configuration directory, and you are running version 0.88 of Mutt, this
-file will be sourced instead of the <literal>Muttrc</literal> file.  The
-same is true of the user configuration file, if you have a file
-<literal>.muttrc-0.88.6</literal> in your home directory, when you run
-Mutt version 0.88.6, it will source this file instead of the default
-<literal>.muttrc</literal> file.  The version number is the same which
-is visible using the <quote>-v</quote> <link
-linkend="commandline">command line</link> switch or using the
-<literal>show-version</literal> key (default: V) from the index menu.
+  <emphasis>($XDG_CONFIG_HOME defaults to "$HOME/.config".)</emphasis>
 </para>
 
 </sect1>
@@ -2651,7 +3273,7 @@ <sect1 id="color">
 
 <command>color</command>
 <arg choice="plain">
-<option>index</option>
+<option>index-object</option>
 </arg>
 <arg choice="plain">
 <replaceable class="parameter">foreground</replaceable>
@@ -2666,7 +3288,7 @@ <sect1 id="color">
 <command>uncolor</command>
 <group choice="req">
 <arg choice="plain">
-<option>index</option>
+<option>index-object</option>
 </arg>
 <arg choice="plain">
 <option>header</option>
@@ -2696,8 +3318,8 @@ <sect1 id="color">
 <para>
 <emphasis>header</emphasis> and <emphasis>body</emphasis> match
 <emphasis>regexp</emphasis> in the header/body of a message,
-<emphasis>index</emphasis> matches <emphasis>pattern</emphasis> (see
-<xref linkend="patterns"/>) in the message index.  Note that IMAP
+<emphasis>index-object</emphasis> can match <emphasis>pattern</emphasis>
+(see <xref linkend="patterns"/>) in the message index. Note that IMAP
 server-side searches (=b, =B, =h) are not supported for color index
 patterns.
 </para>
@@ -2711,10 +3333,19 @@ <sect1 id="color">
 <listitem><para>bold (highlighting bold patterns in the body of messages)</para></listitem>
 <listitem><para>error (error messages printed by Mutt)</para></listitem>
 <listitem><para>hdrdefault (default color of the message header in the pager)</para></listitem>
+<listitem><para>index_author (color of the author name in the index, uses <emphasis>pattern</emphasis>)</para></listitem>
+<listitem><para>index_collapsed (the number of messages in a collapsed thread in the index)</para></listitem>
+<listitem><para>index_date (color of the date field in the index)</para></listitem>
+<listitem><para>index_flags (color of the message flags in the index)</para></listitem>
+<listitem><para>index_label (color of the message label in the index)</para></listitem>
+<listitem><para>index_number (color of the message number in the index)</para></listitem>
+<listitem><para>index_size (color of the message size and line number in the index)</para></listitem>
+<listitem><para>index_subject (color of the subject in the index, uses <emphasis>pattern</emphasis>)</para></listitem>
 <listitem><para>indicator (arrow or bar used to indicate the current item in a menu)</para></listitem>
 <listitem><para>markers (the <quote>+</quote> markers at the beginning of wrapped lines in the pager)</para></listitem>
 <listitem><para>message (informational messages)</para></listitem>
 <listitem><para>normal</para></listitem>
+<listitem><para><link linkend="progress">progress</link> (visual progress bar)</para></listitem>
 <listitem><para>prompt</para></listitem>
 <listitem><para>quoted (text matching <link linkend="quote-regexp">$quote_regexp</link> in the body of a message)</para></listitem>
 <listitem><para>quoted1, quoted2, ..., quoted<emphasis>N</emphasis> (higher levels of quoting)</para></listitem>
@@ -2726,6 +3357,24 @@ <sect1 id="color">
 </itemizedlist>
 
 <para>
+<emphasis>index-object</emphasis> can be one of the following:
+</para>
+
+<itemizedlist>
+<listitem><para>index (default highlighting of the entire index line, uses <emphasis>pattern</emphasis>)</para></listitem>
+<listitem><para>index_date (the date field)</para></listitem>
+<listitem><para>index_flags (the message flags, %S %Z, uses <emphasis>pattern</emphasis>)</para></listitem>
+<listitem><para>index_number (the message number, %C)</para></listitem>
+<listitem><para>index_collapsed (the number of messages in a collapsed thread, %M)</para></listitem>
+<listitem><para>index_author (the author name, %A %a %F %L %n, uses <emphasis>pattern</emphasis>)</para></listitem>
+<listitem><para>index_subject (the subject, %s, uses <emphasis>pattern</emphasis>)</para></listitem>
+<listitem><para>index_size (the message size, %c %l)</para></listitem>
+<listitem><para>index_label (the message label, %y %Y)</para></listitem>
+<listitem><para>index_tags (the transformed message tags, %g)</para></listitem>
+<listitem><para>index_tag (an individual message tag, %G, uses <emphasis>pattern / tag name</emphasis>)</para></listitem>
+</itemizedlist>
+
+<para>
 <emphasis>foreground</emphasis> and <emphasis>background</emphasis> can
 be one of the following:
 </para>
@@ -2842,7 +3491,7 @@ <sect1 id="color">
 <command>unmono</command>
 <group choice="req">
 <arg choice="plain">
-<option>index</option>
+<option>index-object</option>
 </arg>
 <arg choice="plain">
 <option>header</option>
@@ -4541,8 +5190,8 @@ <sect2 id="formatstrings-basics">
 symbol (<literal>=</literal>) as a numeric prefix (like the minus
 above), it will force the string to be centered within its minimum space
 range. For example, <literal>%=14y</literal> will reserve 14 characters
-for the %y expansion &mdash; that's the X-Label: header, in <link
-linkend="index-format">$index_format</link>. If the expansion results in
+for the %y expansion &mdash; that's the set of message keywords (formerly
+X-Label).  If the expansion results in
 a string less than 14 characters, it will be centered in a 14-character
 space.  If the X-Label for a message were <quote>test</quote>, that
 expansion would look like
@@ -4604,6 +5253,18 @@ <sect2 id="formatstrings-conditionals">
 <emphasis>else_string</emphasis> will be expanded.
 </para>
 
+<para>
+The conditional sequences can also be nested by using the %&lt; and &gt;
+operators. The %? notation can still be used but requires quoting. For example:
+</para>
+
+<screen>
+%&lt;x?true&amp;false&gt;
+%&lt;x?%&lt;y?%&lt;z?xyz&amp;xy&gt;&amp;x&gt;&amp;none&gt;
+</screen>
+
+<para>For more examples, see <xref linkend="nested-if"/></para>
+
 </sect2>
 
 <sect2 id="formatstrings-filters">
@@ -4710,6 +5371,27 @@ <sect2 id="formatstrings-padding">
 
 </sect2>
 
+<sect2 id="formatstrings-conditional-dates">
+<title>Conditional Dates</title>
+<para>
+This patch allows the format of dates in the index to vary based on how recent
+the message is. This is especially useful in combination with David Champion's
+patch to allow if-else sequences to be nested.
+</para>
+
+<para>
+For example, using
+<literal>%&lt;[y?%&lt;[d?%[%H:%M]&amp;%[%m/%d]&gt;&amp;%[%y.%m]&gt;</literal>
+for the date in the <literal>$index_format</literal> will produce a display like:
+</para>
+
+<screen>
+   1   + 14.12 Grace Hall      (   13) Gulliver's Travels
+   2   + 10/02 Callum Harrison (   48) Huckleberry Finn
+   3     12:17 Rhys Lee        (   42) The Lord Of The Rings
+</screen>
+</sect2>
+
 </sect1>
 
 <sect1 id="mailto-allow">
@@ -5135,7 +5817,7 @@ <table id="tab-patterns">
 <row><entry>~V</entry><entry>cryptographically verified messages</entry></row>
 <row><entry>~x <emphasis>EXPR</emphasis></entry><entry>messages which contain <emphasis>EXPR</emphasis> in the <quote>References</quote> or <quote>In-Reply-To</quote> field</entry></row>
 <row><entry>~X [<emphasis>MIN</emphasis>]-[<emphasis>MAX</emphasis>]</entry><entry>messages with <emphasis>MIN</emphasis> to <emphasis>MAX</emphasis> attachments *)</entry></row>
-<row><entry>~y <emphasis>EXPR</emphasis></entry><entry>messages which contain <emphasis>EXPR</emphasis> in the <quote>X-Label</quote> field</entry></row>
+<row><entry>~y <emphasis>EXPR</emphasis></entry><entry>messages which contain <emphasis>EXPR</emphasis> in their keywords</entry></row>
 <row><entry>~z [<emphasis>MIN</emphasis>]-[<emphasis>MAX</emphasis>]</entry><entry>messages with a size in the range <emphasis>MIN</emphasis> to <emphasis>MAX</emphasis> *) **)</entry></row>
 <row><entry>~=</entry><entry>duplicated messages (see <link linkend="duplicate-threads">$duplicate_threads</link>)</entry></row>
 <row><entry>~$</entry><entry>unreferenced messages (requires threaded view)</entry></row>
@@ -5530,12 +6212,24 @@ <sect1 id="hooks">
 
 <listitem>
 <para>
+<link linkend="append-hook"><command>append-hook</command></link>
+</para>
+</listitem>
+
+<listitem>
+<para>
 <link linkend="charset-hook"><command>charset-hook</command></link>
 </para>
 </listitem>
 
 <listitem>
 <para>
+<link linkend="close-hook"><command>close-hook</command></link>
+</para>
+</listitem>
+
+<listitem>
+<para>
 <link linkend="crypt-hook"><command>crypt-hook</command></link>
 </para>
 </listitem>
@@ -5578,6 +6272,12 @@ <sect1 id="hooks">
 
 <listitem>
 <para>
+<link linkend="open-hook"><command>open-hook</command></link>
+</para>
+</listitem>
+
+<listitem>
+<para>
 <link linkend="reply-hook"><command>reply-hook</command></link>
 </para>
 </listitem>
@@ -5987,18 +6687,6 @@ <sect1 id="using-lists">
 </para>
 
 <para>
-The <quote>X-Label:</quote> header field can be used to further identify
-mailing lists or list subject matter (or just to annotate messages
-individually).  The <link linkend="index-format">$index_format</link>
-variable's <quote>%y</quote> and <quote>%Y</quote> expandos can be used
-to expand <quote>X-Label:</quote> fields in the index, and Mutt's
-pattern-matcher can match regular expressions to <quote>X-Label:</quote>
-fields with the <quote>~y</quote> selector.  <quote>X-Label:</quote> is
-not a standard message header field, but it can easily be inserted by
-procmail and other mail filtering agents.
-</para>
-
-<para>
 Lastly, Mutt has the ability to <link linkend="sort">sort</link> the
 mailbox into <link linkend="threads">threads</link>.  A thread is a
 group of messages which all relate to the same subject.  This is usually
@@ -6011,6 +6699,121 @@ <sect1 id="using-lists">
 
 </sect1>
 
+<sect1 id="using-keywords">
+<title>Keyword Management</title>
+
+<para>
+Mutt has supported textual labels (usually known as X-Labels after
+the header that we use to store them) for many years.  Since we
+initially added support for X-Lanels, however, the larger community
+has evolved more common ways of using and managing such labels, often
+known as <quote>keywords</quote> or <quote>tags</quote>.
+</para>
+
+<para>
+If you are new to Mutt or to using keywords in Mutt, you only need
+to know that the &lt;edit-label&gt; binding (<literal>y</literal> by
+default) will edit keywords, and that you can search for keywords
+using the <literal>~y</literal> pattern, and use the <literal>%y</literal>
+expando to display it in your <literal>$index_format</literal>.  You also
+can sort by keyword.  Keywords that you set will be stored to the
+<literal>X-Label:</literal> header by default.
+</para>
+
+<para>
+If you've been using X-Labels for a while, things have grown slightly.
+Mutt still supports X-Labels much as it has since 2000, but the scope
+of this support has expanded to support three additional header-based
+techniques for storing keyword metadata on messages:
+</para>
+
+<variablelist>
+
+<varlistentry>
+<term>X-Keywords</term>
+<listitem>
+<para>
+Informal design; space-delimited keywords
+</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>X-Mozilla-Keys</term>
+<listitem>
+<para>
+Informal design used by Mozilla-based agents; space-delimited keywords
+</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>Keywords</term>
+<listitem>
+<para>
+Standardized in RFC2822 (2001); comma-space-delimited keywords
+</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>X-Label</term>
+<listitem>
+<para>
+Mutt-specific design; freeform text (but see <link linkend="xlabel-delimiter">$xlabel_delimiter</link>)
+</para>
+</listitem>
+</varlistentry>
+
+</variablelist>
+
+<para>
+With X-Label, mutt's only notion of a message keyword was the literal
+string value of the X-Label header.  Under the new, integrated support,
+each message may have a list of distinct message keywords.  When reading
+keywords from one of the headers in the list above, the header value is
+split on the indicated delimiter (space or comma-space) for X-Keywords:,
+X-Mozilla-Keys:, and Keywords:.  By default, X-Label: is parsed as a
+single keyword.  By setting $xlabel_delimiter, you can force splitting
+of X-Label: as well.
+</para>
+
+<para>
+Two boolean variables control how keywords are saved when writing
+messages to a mailbox.  The default settings preserve backward
+compatibility within mutt completely, but by changing these
+values you can transition to more standard keyword storage. <link
+linkend="keywords-legacy">$keywords_legacy</link>, if set, will tell
+mutt to use only "legacy" headers -- i.e., <literal>X-Keywords:</literal>,
+<literal>X-Mozilla-Keys</literal>, <literal>Keywords</literal>, or
+<literal>X-Label:</literal>.  Keywords will be saved to whichever
+header was in use by the message the keyword was read from.  If
+<link linkend="keywords-standard">$keywords_standard</link> is
+set, keywords will be saved without exception to the standard
+<literal>Keywords:</literal> header.  (If both are set, both will be used;
+if both are unset, legacy headers are used.)  Additionally, <link
+linkend="xlabel-delimiter">$xlabel_delimiter</link> is used to format
+the X-Label: header on saves.
+</para>
+
+<para>
+To migrate completely to the new standard,
+unset <literal>$keywords_legacy</literal> and set
+<literal>$keywords_standard</literal>, and set
+<literal>$xlabel_delimiter</literal> either to what you currently use to
+delimit keywords in X-Labels, or to <quote>,&nbsp;</quote> (comma
+space).
+</para>
+
+<para>
+Note that it is common practice to insert <literal>X-Label:</literal> or
+other keyword headers from proxmail or other mail filters.  This is
+a useful trick for categorizing messages en masse as they are delivered
+to your inbox, and it is fully compatible with the new keywords code.
+</para>
+
+</sect1>
+
 <sect1 id="new-mail">
 <title>New Mail Detection</title>
 
@@ -6056,7 +6859,10 @@ <sect2 id="new-mail-formats">
 <link linkend="maildir-trash">$maildir_trash</link>). For MH folders, a
 mailbox is considered having new mail if there's at least one message in
 the <quote>unseen</quote> sequence as specified by <link
-linkend="mh-seq-unseen">$mh_seq_unseen</link>.
+linkend="mh-seq-unseen">$mh_seq_unseen</link>. Optionally, <link
+linkend="new-mail-command">$new_mail_command</link> can be configured to
+execute an external program every time new mail is detected in the current
+inbox.
 </para>
 
 <para>
@@ -7515,6 +8321,16 @@ <sect2 id="compile-time-features">
 
 </sect2>
 
+<sect2 id="mutt-patches">
+<title>Mutt Patches</title>
+<para>
+Mutt may also be <quote>patched</quote> to support smaller features.
+These patches should add a free-form string to the end Mutt's version string.
+Running <literal>mutt -v</literal> might show:
+<screen>patch-1.7.0.sidebar.20160709</screen>
+</para>
+</sect2>
+
 <sect2 id="url-syntax">
 <title>URL Syntax</title>
 
@@ -8129,286 +8945,4217 @@ <sect1 id="sending-mixmaster">
 
 </sect1>
 
-<sect1 id="sidebar">
-  <title>Sidebar</title>
-  <subtitle>Overview of mailboxes</subtitle>
+<sect1 id="compress">
+  <title>Compressed Folders Patch</title>
+  <subtitle>Read from/write to compressed mailboxes</subtitle>
 
-  <sect2 id="sidebar-intro">
-    <title>Introduction</title>
+  <sect2 id="compress-patch">
+    <title>Patch</title>
 
     <para>
-      The Sidebar shows a list of all your mailboxes.  The list can be
-      turned on and off, it can be themed and the list style can be
-      configured.
+      To check if Mutt supports <quote>Compress Folders</quote>, look for
+      <quote>+USE_COMPRESSED</quote> in the mutt version.
+      See: <xref linkend="compile-time-features"/>.
     </para>
-  </sect2>
 
-  <sect2 id="sidebar-variables">
-    <title>Variables</title>
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
 
-    <table id="table-sidebar-variables">
-      <title>Sidebar Variables</title>
-      <tgroup cols="3">
-	<thead>
-	  <row>
-	    <entry>Name</entry>
-	    <entry>Type</entry>
-	    <entry>Default</entry>
-	  </row>
-	</thead>
-	<tbody>
-	  <row>
-	    <entry><literal>sidebar_delim_chars</literal></entry>
-	    <entry>string</entry>
-	    <entry><literal>/.</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_divider_char</literal></entry>
-	    <entry>string</entry>
-	    <entry><literal>|</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_folder_indent</literal></entry>
-	    <entry>boolean</entry>
-	    <entry><literal>no</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_format</literal></entry>
-	    <entry>string</entry>
-	    <entry><literal>%B%*  %n</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_indent_string</literal></entry>
-	    <entry>string</entry>
-	    <entry><literal>&nbsp;&nbsp;</literal> (two spaces)</entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_new_mail_only</literal></entry>
-	    <entry>boolean</entry>
-	    <entry><literal>no</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_next_new_wrap</literal></entry>
-	    <entry>boolean</entry>
-	    <entry><literal>no</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_short_path</literal></entry>
-	    <entry>boolean</entry>
-	    <entry><literal>no</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_sort_method</literal></entry>
-	    <entry>enum</entry>
-	    <entry><literal>unsorted</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_visible</literal></entry>
-	    <entry>boolean</entry>
-	    <entry><literal>no</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_whitelist</literal></entry>
-	    <entry>list</entry>
-	    <entry>(empty)</entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_width</literal></entry>
-	    <entry>number</entry>
-	    <entry><literal>20</literal></entry>
-	  </row>
-	</tbody>
-      </tgroup>
-    </table>
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
   </sect2>
 
-  <sect2 id="sidebar-functions">
-    <title>Functions</title>
+  <sect2 id="compress-intro">
+    <title>Introduction</title>
 
     <para>
-      Sidebar adds the following functions to Mutt.
-      By default, none of them are bound to keys.
+      The Compressed Folder patch allows Mutt to read mailbox files that are
+      compressed.  But it isn't limited to compressed files.  It works well
+      with encrypted files, too.  In fact, if you can create a program/script
+      to convert to and from your format, then Mutt can read it.
+    </para>
+
+    <para>
+      The patch adds three hooks to Mutt: <literal>open-hook</literal>,
+      <literal>close-hook</literal> and <literal>append-hook</literal>.  They
+      define commands to: uncompress a file; compress a file; append
+      messages to an already compressed file.
+    </para>
+
+    <para>
+      There are some examples of both compressed and encrypted files,
+      later.  For now, the documentation will just concentrate on
+      compressed files.
     </para>
 
-    <table id="table-sidebar-functions">
-      <title>Sidebar Functions</title>
-      <tgroup cols="3">
-	<thead>
-	  <row>
-	    <entry>Menus</entry>
-	    <entry>Function</entry>
-	    <entry>Description</entry>
-	  </row>
-	</thead>
-	<tbody>
-	  <row>
-	    <entry>index,pager</entry>
-	    <entry><literal>&lt;sidebar-next&gt;</literal></entry>
-	    <entry>Move the highlight to next mailbox</entry>
-	  </row>
-	  <row>
-	    <entry>index,pager</entry>
-	    <entry><literal>&lt;sidebar-next-new&gt;</literal></entry>
-	    <entry>Move the highlight to next mailbox with new mail</entry>
-	  </row>
-	  <row>
-	    <entry>index,pager</entry>
-	    <entry><literal>&lt;sidebar-open&gt;</literal></entry>
-	    <entry>Open highlighted mailbox</entry>
-	  </row>
-	  <row>
-	    <entry>index,pager</entry>
-	    <entry><literal>&lt;sidebar-page-down&gt;</literal></entry>
-	    <entry>Scroll the Sidebar down 1 page</entry>
-	  </row>
-	  <row>
-	    <entry>index,pager</entry>
-	    <entry><literal>&lt;sidebar-page-up&gt;</literal></entry>
-	    <entry>Scroll the Sidebar up 1 page</entry>
-	  </row>
-	  <row>
-	    <entry>index,pager</entry>
-	    <entry><literal>&lt;sidebar-prev&gt;</literal></entry>
-	    <entry>Move the highlight to previous mailbox</entry>
-	  </row>
-	  <row>
-	    <entry>index,pager</entry>
-	    <entry><literal>&lt;sidebar-prev-new&gt;</literal></entry>
-	    <entry>Move the highlight to previous mailbox with new mail</entry>
-	  </row>
-	  <row>
-	    <entry>index,pager</entry>
-	    <entry><literal>&lt;sidebar-toggle-visible&gt;</literal></entry>
-	    <entry>Make the Sidebar (in)visible</entry>
-	  </row>
-	</tbody>
-      </tgroup>
-    </table>
   </sect2>
 
-  <sect2 id="sidebar-commands">
+  <sect2 id="compress-commands">
     <title>Commands</title>
     <cmdsynopsis>
-      <command>sidebar_whitelist<anchor id="sidebar-whitelist"/></command>
+      <command>open-hook</command>
       <arg choice="plain">
-	<replaceable class="parameter">mailbox</replaceable>
+        <replaceable class="parameter">pattern</replaceable>
       </arg>
-      <arg choice="opt" rep="repeat">
-	<replaceable class="parameter">mailbox</replaceable>
+      <arg choice="plain">
+        <replaceable class="parameter">shell-command</replaceable>
       </arg>
-    </cmdsynopsis>
-  </sect2>
-
-  <sect2 id="sidebar-colors">
+      <command>close-hook</command>
+      <arg choice="plain">
+        <replaceable class="parameter">pattern</replaceable>
+      </arg>
+      <arg choice="plain">
+        <replaceable class="parameter">shell-command</replaceable>
+      </arg>
+      <command>append-hook</command>
+      <arg choice="plain">
+        <replaceable class="parameter">pattern</replaceable>
+      </arg>
+      <arg choice="plain">
+        <replaceable class="parameter">shell-command</replaceable>
+      </arg>
+    </cmdsynopsis>
+
+    <para>
+      The shell-command must contain two placeholders for filenames:
+      <literal>%f</literal> and <literal>%t</literal>.  These represent
+      <quote>from</quote> and <quote>to</quote> filenames.  It's a good idea to
+      put quotes around these placeholders.
+    </para>
+
+    <para>
+      If you need the exact string <quote>%f</quote> or <quote>%t</quote> in your
+      command, simply double up the <quote>%</quote> character, e.g.
+      <quote>%%f</quote> or <quote>%%t</quote>.
+    </para>
+
+    <table id="table-compress-optional">
+      <title>Not all Hooks are Required</title>
+      <tgroup cols="5">
+        <thead>
+          <row>
+            <entry>Open</entry>
+            <entry>Close</entry>
+            <entry>Append</entry>
+            <entry>Effect</entry>
+            <entry>Useful if</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>Open</entry>
+            <entry>-</entry>
+            <entry>-</entry>
+            <entry>Folder is readonly</entry>
+            <entry>The folder is just a backup</entry>
+          </row>
+          <row>
+            <entry>Open</entry>
+            <entry>Close</entry>
+            <entry>-</entry>
+            <entry>Folder is read/write, but the entire folder must be
+              written if anything is changed</entry>
+            <entry>Your compression format doesn't support appending</entry>
+          </row>
+          <row>
+            <entry>Open</entry>
+            <entry>Close</entry>
+            <entry>Append</entry>
+            <entry>Folder is read/write and emails can be efficiently added
+              to the end</entry>
+            <entry>Your compression format supports appending</entry>
+          </row>
+          <row>
+            <entry>Open</entry>
+            <entry>-</entry>
+            <entry>Append</entry>
+            <entry>Folder is readonly, but can be appended to</entry>
+            <entry>You want to store emails, but never change them</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+
+    <note>
+      <para>The command:</para>
+      <itemizedlist>
+        <listitem><para>should return a non-zero exit status on failure</para></listitem>
+        <listitem><para>should not delete any files</para></listitem>
+      </itemizedlist>
+    </note>
+
+    <sect3 id="open-hook">
+      <title>Read from compressed mailbox</title>
+
+      <screen>open-hook regexp shell-command</screen>
+
+      <para>
+        If Mutt is unable to open a file, it then looks for
+        <literal>open-hook</literal> that matches the filename.
+      </para>
+
+      <para>
+        If your compression program doesn't have a well-defined extension,
+        then you can use <literal>.</literal> as the regexp.
+      </para>
+
+      <sect4 id="compress-open-hook-example">
+        <title>Example of open-hook</title>
+
+        <screen>open-hook '\.gz$' &quot;gzip -cd '%f' &gt; '%t'&quot;</screen>
+
+        <itemizedlist>
+          <listitem><para>Mutt finds a file, <quote>example.gz</quote>,
+              that it can't read</para></listitem>
+          <listitem><para>Mutt has an <literal>open-hook</literal>
+              whose regexp matches the filename:
+              <literal>\.gz$</literal></para></listitem>
+          <listitem><para>Mutt uses the command <literal>gzip -cd</literal>
+              to create a temporary file that it <emphasis>can</emphasis>
+              read</para></listitem>
+        </itemizedlist>
+      </sect4>
+    </sect3>
+
+    <sect3 id="close-hook">
+      <title>Write to a compressed mailbox</title>
+
+      <screen>close-hook regexp shell-command</screen>
+
+      <para>
+        When Mutt has finished with a compressed mail folder, it will look
+        for a matching <literal>close-hook</literal> to recompress the file.
+        This hook is <link linkend="table-compress-optional">optional</link>.
+      </para>
+
+      <note>
+        <para>
+          If the folder has not been modifed, the
+          <literal>close-hook</literal> will not be called.
+        </para>
+      </note>
+
+      <sect4 id="compress-close-hook-example">
+        <title>Example of close-hook</title>
+
+        <screen>close-hook '\.gz$' &quot;gzip -c '%t' &gt; '%f'&quot;</screen>
+
+        <itemizedlist>
+          <listitem><para>Mutt has finished with a folder, <quote>example.gz</quote>,
+              that it opened with <literal>open-hook</literal></para></listitem>
+          <listitem><para>The folder has been modified</para></listitem>
+          <listitem><para>Mutt has a <literal>close-hook</literal> whose regexp
+              matches the filename: <literal>\.gz$</literal></para></listitem>
+          <listitem><para>Mutt uses the command <literal>gzip -c</literal>
+              to create a new compressed file</para></listitem>
+        </itemizedlist>
+      </sect4>
+    </sect3>
+
+    <sect3 id="append-hook">
+      <title>Append to a compressed mailbox</title>
+
+      <screen>append-hook regexp shell-command</screen>
+
+      <para>
+        When Mutt wants to append an email to a compressed mail folder, it
+        will look for a matching <literal>append-hook</literal>.
+        This hook is <link linkend="table-compress-optional">optional</link>.
+      </para>
+
+      <para>
+        Using the <literal>append-hook</literal> will save time, but
+        Mutt won't be able to determine the type of the mail folder
+        inside the compressed file.
+      </para>
+
+      <para>
+        Mutt will <emphasis>assume</emphasis> the type to be that of
+        the <literal>$mbox_type</literal> variable.  Mutt also uses
+        this type for temporary files.
+      </para>
+
+      <para>
+        Mutt will only use the <literal>append-hook</literal> for existing files.
+        The <literal>close-hook</literal> will be used for empty, or missing files.
+      </para>
+
+      <note>
+        <para>
+          If your command writes to stdout, it is vital that you use
+          <literal>&gt;&gt;</literal> in the <quote>append-hook</quote>.
+          If not, data will be lost.
+        </para>
+      </note>
+
+      <sect4 id="compress-append-hook-example">
+        <title>Example of append-hook</title>
+
+        <screen>append-hook '\.gz$' &quot;gzip -c '%t' &gt;&gt; '%f'&quot;</screen>
+
+        <itemizedlist>
+          <listitem><para>Mutt wants to append an email to a folder, <quote>example.gz</quote>,
+              that it opened with <literal>open-hook</literal></para></listitem>
+          <listitem><para>Mutt has an <literal>append-hook</literal> whose regexp matches
+              the filename: <literal>\.gz$</literal></para></listitem>
+          <listitem><para>Mutt knows the mailbox type from the <literal>$mbox</literal>
+              variable</para></listitem>
+          <listitem><para>Mutt uses the command <literal>gzip -c</literal>
+              to append to an existing compressed file</para></listitem>
+        </itemizedlist>
+      </sect4>
+
+    </sect3>
+
+    <sect3 id="compress-empty">
+      <title>Empty Files</title>
+
+      <para>
+        Mutt assumes that an empty file is not compressed.  In this
+        situation, unset <link linkend="save-empty">$save_empty</link>, so
+        that the compressed file will be removed if you delete all of the
+        messages.
+      </para>
+    </sect3>
+
+    <sect3 id="compress-security">
+      <title>Security</title>
+
+      <para>
+        Encrypted files are decrypted into temporary files which are
+        stored in the <link linkend="tmpdir">$tmpdir</link> directory.
+        This could be a security risk.
+      </para>
+    </sect3>
+  </sect2>
+
+  <sect2 id="compress-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example Mutt config file for the 'compressed folders' feature.
+ 
+# This feature adds three hooks to Mutt which allow it to
+# work with compressed, or encrypted, mailboxes.
+ 
+# The hooks are of the form:
+#       open-hook   regexp &quot;shell-command&quot;
+#       close-hook  regexp &quot;shell-command&quot;
+#       append-hook regexp &quot;shell-command&quot;
+ 
+# The 'append-hook' is optional.
+ 
+# Hander for gzip compressed mailboxes</emphasis>
+open-hook   '\.gz$'  &quot;gzip -cd  '%f' &gt;  '%t'&quot;
+close-hook  '\.gz$'  &quot;gzip -c   '%t' &gt;  '%f'&quot;
+append-hook '\.gz$'  &quot;gzip -c   '%t' &gt;&gt; '%f'&quot;
+ 
+<emphasis role="comment"># Hander for bzip2 compressed mailboxes</emphasis>
+open-hook   '\.bz2$' &quot;bzip2 -cd '%f' &gt;  '%t'&quot;
+close-hook  '\.bz2$' &quot;bzip2 -c  '%t' &gt;  '%f'&quot;
+append-hook '\.bz2$' &quot;bzip2 -c  '%t' &gt;&gt; '%f'&quot;
+ 
+<emphasis role="comment"># Hander for xz compressed mailboxes</emphasis>
+open-hook   '\.xz$'  &quot;xz    -cd '%f' &gt;  '%t'&quot;
+close-hook  '\.xz$'  &quot;xz    -c  '%t' &gt;  '%f'&quot;
+append-hook '\.xz$'  &quot;xz    -c  '%t' &gt;&gt; '%f'&quot;
+ 
+<emphasis role="comment"># Hander for pgp encrypted mailboxes
+# PGP does not support appending to an encrypted file</emphasis>
+open-hook   '\.pgp$' &quot;pgp -f &lt; '%f' &gt; '%t'&quot;
+close-hook  '\.pgp$' &quot;pgp -fe YourPgpUserIdOrKeyId &lt; '%t' &gt; '%f'&quot;
+ 
+<emphasis role="comment"># Hander for gpg encrypted mailboxes
+# gpg does not support appending to an encrypted file</emphasis>
+open-hook   '\.gpg$' &quot;gpg --decrypt &lt; '%f' &gt; '%t'&quot;
+close-hook  '\.gpg$' &quot;gpg --encrypt --recipient YourGpgUserIdOrKeyId &lt; '%t' &gt; '%f'&quot;
+ 
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="compress-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="compile-time-features">Compile-Time Features</link></para></listitem>
+      <listitem><para><link linkend="regexp">Regular Expressions</link></para></listitem>
+      <listitem><para><link linkend="tmpdir">$tmpdir</link></para></listitem>
+      <listitem><para><link linkend="mbox-type">$mbox_type</link></para></listitem>
+      <listitem><para><link linkend="save-empty">$save_empty</link></para></listitem>
+      <listitem><para><link linkend="folder-hook">folder-hook</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="compress-known-bugs">
+    <title>Known Bugs</title>
+
+    <itemizedlist>
+      <listitem><para>The Compressed Folder hooks cannot deal with filenames that contains quotes/apostrophes.</para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="compress-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Roland Rosenfeld <email>roland@spinnaker.de</email></para></listitem>
+    <listitem><para>Alain Penders <email>Alain@Finale-Dev.com</email></para></listitem>
+    <listitem><para>Christoph <quote>Myon</quote> Berg <email>myon@debian.org</email></para></listitem>
+    <listitem><para>Evgeni Golov <email>evgeni@debian.org</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="cond-date">
+  <title>Conditional Dates Patch</title>
+  <subtitle>Use rules to choose date format</subtitle>
+
+  <sect2 id="cond-date-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>Conditional Dates</quote>, look for
+      <quote>patch-cond-date</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+      <listitem><para><link linkend="nested-if">nested-if patch</link></para></listitem>
+    </itemizedlist>
+
+    <para>
+      This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.
+    </para>
+  </sect2>
+
+  <sect2 id="cond-date-intro">
+    <title>Introduction</title>
+
+    <para>
+    The <quote>cond-date</quote> patch allows you to construct
+    <link linkend="index-format">$index_format</link> expressions based on the age of the email.
+    </para>
+
+    <para>
+    Mutt's default <literal>$index_format</literal> displays email dates in the
+    form: abbreviated-month day-of-month &mdash; <quote>Jan 14</quote>.
+    </para>
+
+    <para>
+    The format is configurable but only per-mailbox.  This patch allows you
+    to configure the display depending on the age of the email.
+    </para>
+
+    <table id="table-cond-date-scheme">
+      <title>Potential Formatting Scheme</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Email Sent</entry>
+            <entry>Format</entry>
+            <entry>Example</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>Today</entry>
+            <entry><literal>%H:%M</literal></entry>
+            <entry>13:23</entry>
+          </row>
+          <row>
+            <entry>This Month</entry>
+            <entry><literal>%a %d</literal></entry>
+            <entry>Thu 17</entry>
+          </row>
+          <row>
+            <entry>This Year</entry>
+            <entry><literal>%b %d</literal></entry>
+            <entry>Dec 10</entry>
+          </row>
+          <row>
+            <entry>Older than 1 Year</entry>
+            <entry><literal>%m/%y</literal></entry>
+            <entry>06/14</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+
+    <para>
+        For an explanation of the date formatting strings, see
+        <literal>strftime(3).</literal>
+    </para>
+
+    <para>
+        By carefully picking your formats, the dates can remain
+        unambiguous and compact.
+    </para>
+
+    <para>
+    Mutt's conditional format strings have the form:
+    (whitespace introduced for clarity)
+    </para>
+
+    <screen>%? TEST ? TRUE &amp; FALSE ?</screen>
+
+    <para>
+    The examples below use the test <quote>%[</quote> &mdash; the date
+    of the message in the local timezone.  They will also work with
+    <quote>%(</quote> &mdash; the local time that the message arrived.
+    </para>
+
+    <para>
+    The date tests are of the form:
+    </para>
+
+    <screen>%[nX? TRUE &amp; FALSE ?</screen>
+
+    <itemizedlist>
+    <listitem><para><quote>n</quote> is an optional count (defaults to 1 if missing)</para></listitem>
+    <listitem><para><quote>X</quote> is the time period</para></listitem>
+    </itemizedlist>
+
+    <table id="table-cond-date-format-codes">
+      <title>Date Formatting Codes</title>
+      <tgroup cols="2">
+        <thead>
+          <row>
+            <entry>Letter</entry>
+            <entry>Time Period</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>y</entry>
+            <entry>Years</entry>
+          </row>
+          <row>
+            <entry>m</entry>
+            <entry>Months</entry>
+          </row>
+          <row>
+            <entry>w</entry>
+            <entry>Weeks</entry>
+          </row>
+          <row>
+            <entry>d</entry>
+            <entry>Days</entry>
+          </row>
+          <row>
+            <entry>H</entry>
+            <entry>Hours</entry>
+          </row>
+          <row>
+            <entry>M</entry>
+            <entry>Minutes</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+
+    <table id="table-cond-date-example-tests">
+      <title>Example Date Tests</title>
+      <tgroup cols="2">
+        <thead>
+          <row>
+            <entry>Test</entry>
+            <entry>Meaning</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>%[y</literal></entry>
+            <entry>This year</entry>
+          </row>
+          <row>
+            <entry><literal>%[1y</literal></entry>
+            <entry>This year</entry>
+          </row>
+          <row>
+            <entry><literal>%[6m</literal></entry>
+            <entry>In the last 6 months</entry>
+          </row>
+          <row>
+            <entry><literal>%[w</literal></entry>
+            <entry>This week</entry>
+          </row>
+          <row>
+            <entry><literal>%[d</literal></entry>
+            <entry>Today</entry>
+          </row>
+          <row>
+            <entry><literal>%[4H</literal></entry>
+            <entry>In the last 4 hours</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+
+    <sect3 id="cond-date-example1">
+      <title>Example 1</title>
+
+      <para>We start with a one-condition test.</para>
+
+      <table id="table-cond-date-example1">
+        <title>Example 1</title>
+        <tgroup cols="4">
+          <thead>
+            <row>
+              <entry>Test</entry>
+              <entry>Date Range</entry>
+              <entry>Format String</entry>
+              <entry>Example</entry>
+            </row>
+          </thead>
+          <tbody>
+            <row>
+              <entry><literal>%[1m</literal></entry>
+              <entry>This month</entry>
+              <entry><literal>%[%b %d]</literal></entry>
+              <entry>Dec 10</entry>
+            </row>
+            <row>
+              <entry></entry>
+              <entry>Older</entry>
+              <entry><literal>%[%Y-%m-%d]</literal></entry>
+              <entry>2015-04-23</entry>
+            </row>
+          </tbody>
+        </tgroup>
+      </table>
+
+      <para>The $index_format string would contain:</para>
+<screen>
+%?[1m?%[%b %d]&amp;%[%Y-%m-%d]?
+</screen>
+ 
+      <para>
+        Reparsed a little, for clarity, you can see the
+        test condition and the two format strings.
+      </para>
+
+<screen>
+%?[1m?        &amp;           ?
+      %[%b %d] %[%Y-%m-%d]
+</screen>
+
+    </sect3>
+
+    <sect3 id="cond-date-example2">
+      <title>Example 2</title>
+
+      <para>
+      This example contains three test conditions and four date formats.
+      </para>
+
+      <table id="table-cond-date-example2">
+        <title>Example 2</title>
+        <tgroup cols="4">
+          <thead>
+            <row>
+              <entry>Test</entry>
+              <entry>Date Range</entry>
+              <entry>Format String</entry>
+              <entry>Example</entry>
+            </row>
+          </thead>
+          <tbody>
+            <row>
+              <entry><literal>%[d</literal></entry>
+              <entry>Today</entry>
+              <entry><literal>%[%H:%M ] </literal></entry>
+              <entry>12:34</entry>
+            </row>
+            <row>
+              <entry><literal>%[m</literal></entry>
+              <entry>This month</entry>
+              <entry><literal>%[%a %d]</literal></entry>
+              <entry>Thu 12</entry>
+            </row>
+            <row>
+              <entry><literal>%[y</literal></entry>
+              <entry>This year</entry>
+              <entry><literal>%[%b %d]</literal></entry>
+              <entry>Dec 10</entry>
+            </row>
+            <row>
+              <entry></entry>
+              <entry>Older</entry>
+              <entry><literal>%[%m/%y ]</literal></entry>
+              <entry>06/15</entry>
+            </row>
+          </tbody>
+        </tgroup>
+      </table>
+
+      <para>The $index_format string would contain:</para>
+ 
+<screen>
+%&lt;[y?%&lt;[m?%&lt;[d?%[%H:%M ]&amp;%[%a %d]&gt;&amp;%[%b %d]&gt;&amp;%[%m/%y ]&gt;
+</screen>
+
+      <para>
+        Reparsed a little, for clarity, you can see the
+        test conditions and the four format strings.
+      </para>
+
+<screen>
+%&lt;[y?                                       &amp;%[%m/%y ]&gt;  Older
+     %&lt;[m?                        &amp;%[%b %d]&gt;             This year
+          %&lt;[d?         &amp;%[%a %d]&gt;                       This month
+               %[%H:%M ]                                 Today
+</screen>
+
+      <para>
+      This a another view of the same example, with some whitespace
+      for clarity.
+      </para>
+
+<screen>
+%&lt;[y? %&lt;[m? %&lt;[d? AAA &amp; BBB &gt; &amp; CCC &gt; &amp; DDD &gt;
+</screen>
+
+      <literallayout>
+AAA = %[%H:%M ]
+BBB = %[%a %d]
+CCC = %[%b %d]
+DDD = %[%m/%y ]
+      </literallayout>
+    </sect3>
+  </sect2>
+
+  <sect2 id="cond-date-variables">
+    <title>Variables</title>
+
+        <para>
+    The <quote>cond-date</quote> patch doesn't have any config of its own.
+    It modifies the behavior of the format strings.
+        </para>
+  </sect2>
+
+  <sect2 id="cond-date-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example Mutt config file for the 'cond-date' feature.
+#
+# The default index_format is:
+#       '%4C %Z %{%b %d} %-15.15L (%?l?%4l&amp;%4c?) %s'
+#
+# We replace the date field '%{%b %d}', giving:</emphasis>
+set index_format='%4C %Z %&lt;[y?%&lt;[m?%&lt;[d?%[%H:%M ]&amp;%[%a %d]&gt;&amp;%[%b %d]&gt;&amp;%[%m/%y ]&gt; %-15.15L (%?l?%4l&amp;%4c?) %s'
+ 
+<emphasis role="comment"># Test  Date Range  Format String  Example
+# --------------------------------------------
+# %[d   Today       %[%H:%M ]      12:34
+# %[m   This month  %[%a %d]       Thu 12
+# %[y   This year   %[%b %d]       Dec 10
+# -     Older       %[%m/%y ]      06/15
+ 
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="cond-date-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="index-format">$index_format</link></para></listitem>
+      <listitem><para><link linkend="nested-if">nested-if patch</link></para></listitem>
+      <listitem><para><literal>strftime(3)</literal></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="cond-date-known-bugs">
+    <title>Known Bugs</title>
+
+    <para>
+      Date parsing doesn't quite do what you expect.
+      <quote>1w</quote> doesn't mean the <quote>in the last 7 days</quote>, but
+      <quote><emphasis>this</emphasis> week</quote>.  This doesn't match
+      the normal Mutt behaviour: for example <literal>~d>1w</literal>
+      means emails dated in the last 7 days.
+    </para>
+
+  </sect2>
+
+  <sect2 id="cond-date-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Aaron Schrab <email>aaron@schrab.com</email></para></listitem>
+    <listitem><para>Eric Davis <email>edavis@insanum.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="fmemopen">
+  <title>Fmemopen Patch</title>
+  <subtitle>Replace some temporary files with memory buffers</subtitle>
+
+  <sect2 id="fmemopen-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>fmemopen</quote>, look for
+      <quote>patch-fmemopen</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+      <listitem><para><literal>open_memstream()</literal>, <literal>fmemopen()</literal> from glibc</para></listitem>
+    </itemizedlist>
+
+    <para>
+      This patch can be disabled by running <literal>configure</literal> with
+      the option <literal>--disable-fmemopen</literal>
+    </para>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="fmemopen-intro">
+    <title>Introduction</title>
+
+        <para>
+    The <quote>fmemopen</quote> patch speeds up some searches.
+        </para>
+
+        <para>
+    This patch changes a few places where Mutt creates temporary files.
+    It replaces them with in-memory buffers.  This should improve the
+    performance when searching the header or body using the
+    <link linkend="thorough-search">$thorough_search</link> option.
+        </para>
+
+        <para>
+    There are no user-configurable parts.
+        </para>
+
+        <para>
+    This patch depends on <literal>open_memstream()</literal> and
+    <literal>fmemopen()</literal>.  They are provided by glibc.  Without
+    them, Mutt will simply create temporary files.
+        </para>
+  </sect2>
+
+  <sect2 id="fmemopen-muttrc">
+    <title>Muttrc</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="fmemopen-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="compile-time-features">Compile-Time Features</link></para></listitem>
+      <listitem><para><literal>fmemopen(3)</literal></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="fmemopen-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="fmemopen-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Julius Plenz <email>plenz@cis.fu-berlin.de</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="ifdef">
+  <title>Ifdef Patch</title>
+  <subtitle>Conditional config options</subtitle>
+
+  <sect2 id="ifdef-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>ifdef</quote>, look for
+      <quote>patch-ifdef</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="ifdef-intro">
+    <title>Introduction</title>
+
+    <para>
+      The <quote>ifdef</quote> patch introduces three new commands to
+      Mutt and allow you to share one config file between versions of Mutt
+      that may have different features compiled in.
+    </para>
+
+<screen>
+ifdef  symbol config-command [args...]  <emphasis role="comment"># If a symbol is defined</emphasis>
+ifndef symbol config-command [args...]  <emphasis role="comment"># If a symbol is not defined</emphasis>
+finish                                  <emphasis role="comment"># Finish reading the current file</emphasis>
+</screen>
+
+    <para>
+      Here a symbol can be a <link linkend="variables">$variable</link>,
+      <link linkend="functions">&lt;function&gt;</link>,
+      <link linkend="commands">command</link> or compile-time symbol, such
+      as <quote>USE_IMAP</quote>.
+    </para>
+
+        <para>
+            <literal>finish</literal> is particularly useful when combined with
+            <literal>ifndef</literal>. e.g.
+        </para>
+
+<screen>
+<emphasis role="comment"># Sidebar config file</emphasis>
+ifndef USE_SIDEBAR finish
+</screen>
+
+  </sect2>
+
+  <sect2 id="ifdef-commands">
+    <title>Commands</title>
+    <cmdsynopsis>
+      <command>ifdef</command>
+      <arg choice="plain">
+        <replaceable class="parameter">symbol</replaceable>
+      </arg>
+      <arg choice="plain">
+        <replaceable class="parameter">"config-command [args]"</replaceable>
+      </arg>
+      <command>ifndef</command>
+      <arg choice="plain">
+        <replaceable class="parameter">symbol</replaceable>
+      </arg>
+      <arg choice="plain">
+        <replaceable class="parameter">"config-command [args]"</replaceable>
+      </arg>
+      <command>finish</command>
+    </cmdsynopsis>
+  </sect2>
+
+  <sect2 id="ifdef-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example Mutt config file for the 'ifdef' feature.
+ 
+# This feature introduces three useful commands which allow you to share
+# one config file between versions of Mutt that may have different
+# features compiled in.
+ 
+#     ifdef  symbol config-command [args...]
+#     ifndef symbol config-command [args...]
+#     finish
+ 
+# The 'ifdef' command tests whether Mutt understands the name of
+# a variable, function, command or compile-time symbol.
+# If it does, then it executes a config command.
+ 
+# The 'ifndef' command tests whether a symbol does NOT exist.
+ 
+# The 'finish' command tells Mutt to stop reading current config file.
+ 
+# If the 'trash' variable exists, set it.</emphasis>
+ifdef trash 'set trash=~/Mail/trash'
+ 
+<emphasis role="comment"># If the 'tag-pattern' function exists, bind a key to it.</emphasis>
+ifdef tag-pattern 'bind index &lt;F6&gt; tag-pattern'
+ 
+<emphasis role="comment"># If the 'imap-fetch-mail' command exists, read my IMAP config.</emphasis>
+ifdef imap-fetch-mail 'source ~/.mutt/imap.rc'
+ 
+<emphasis role="comment"># If the compile-time symbol 'USE_SIDEBAR' does not exist, then
+# stop reading the current config file.</emphasis>
+ifndef USE_SIDEBAR finish
+ 
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="ifdef-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="ifdef-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="ifdef-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Cedric Duval <email>cedricduval@free.fr</email></para></listitem>
+    <listitem><para>Matteo F. Vescovi <email>mfvescovi@gmail.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="index-color">
+  <title>Index Color Patch</title>
+  <subtitle>Custom rules for theming the email index</subtitle>
+
+  <sect2 id="index-color-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>Index Color</quote>, look for
+      <quote>patch-index-color</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+      <listitem><para><link linkend="status-color">status-color patch</link></para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="index-color-intro">
+    <title>Introduction</title>
+
+        <para>
+    The <quote>index-color</quote> patch allows you to specify colors for
+    individual parts of the email index. e.g. Subject, Author, Flags.
+        </para>
+
+        <para>
+    First choose which part of the index you'd like to color.
+    Then, if needed, pick a pattern to match.
+        </para>
+
+    <para>
+    Note: The pattern does not have to refer to the object you wish to
+    color.  e.g.
+    </para>
+
+<screen>
+color index_author red default &quot;~smutt&quot;
+</screen>
+
+        <para>
+    The author appears red when the subject (~s) contains <quote>mutt</quote>.
+        </para>
+  </sect2>
+
+  <sect2 id="index-color-colors">
+    <title>Colors</title>
+
+        <para>
+    All the colors default to <literal>default</literal>, i.e. unset.
+        </para>
+
+        <para>
+    The index objects can be themed using the <literal>color</literal> command.
+    Some objects require a pattern.
+        </para>
+
+<screen>
+color index-object foreground background
+color index-object foreground background pattern
+</screen>
+
+    <table id="table-index-color-colors">
+      <title>Index Colors</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Object</entry>
+            <entry>Pattern</entry>
+            <entry>Highlights</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>index</literal></entry>
+            <entry>yes</entry>
+            <entry>Entire index line</entry>
+          </row>
+          <row>
+            <entry><literal>index_author</literal></entry>
+            <entry>yes</entry>
+            <entry>Author name, %A %a %F %L %n</entry>
+          </row>
+          <row>
+            <entry><literal>index_collapsed</literal></entry>
+            <entry>no</entry>
+            <entry>Number of messages in a collapsed thread, %M</entry>
+          </row>
+          <row>
+            <entry><literal>index_date</literal></entry>
+            <entry>no</entry>
+            <entry>Date field</entry>
+          </row>
+          <row>
+            <entry><literal>index_flags</literal></entry>
+            <entry>yes</entry>
+            <entry>Message flags, %S %Z</entry>
+          </row>
+          <row>
+            <entry><literal>index_label</literal></entry>
+            <entry>no</entry>
+            <entry>Message label, %y %Y</entry>
+          </row>
+          <row>
+            <entry><literal>index_number</literal></entry>
+            <entry>no</entry>
+            <entry>Message number, %C</entry>
+          </row>
+          <row>
+            <entry><literal>index_size</literal></entry>
+            <entry>no</entry>
+            <entry>Message size, %c %l</entry>
+          </row>
+          <row>
+            <entry><literal>index_subject</literal></entry>
+            <entry>yes</entry>
+            <entry>Subject, %s</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="index-color-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example Mutt config file for the 'index-color' feature.
+ 
+# Entire index line</emphasis>
+color index white black '.*'
+ 
+<emphasis role="comment"># Author name, %A %a %F %L %n
+ 
+# Give the author column a dark grey background</emphasis>
+color index_author default color234 '.*'
+ 
+<emphasis role="comment"># Highlight a particular from (~f)</emphasis>
+color index_author brightyellow color234 '~fRay Charles'
+ 
+<emphasis role="comment"># Message flags, %S %Z
+# Highlight the flags for flagged (~F) emails</emphasis>
+color index_flags default red '~F'
+ 
+<emphasis role="comment"># Subject, %s
+# Look for a particular subject (~s)</emphasis>
+color index_subject brightcyan default '~s\(closes #[0-9]+\)'
+ 
+<emphasis role="comment"># Number of messages in a collapsed thread, %M</emphasis>
+color index_collapsed default brightblue
+ 
+<emphasis role="comment"># Date field</emphasis>
+color index_date green default
+ 
+<emphasis role="comment"># Message label, %y %Y</emphasis>
+color index_label default brightgreen
+ 
+<emphasis role="comment"># Message number, %C</emphasis>
+color index_number red default
+ 
+<emphasis role="comment"># Message size, %c %l</emphasis>
+color index_size cyan default
+ 
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="index-color-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="regexp">Regular Expressions</link></para></listitem>
+      <listitem><para><link linkend="patterns">Patterns</link></para></listitem>
+      <listitem><para><link linkend="index-format">$index_format</link></para></listitem>
+      <listitem><para><link linkend="color">Color command</link></para></listitem>
+      <listitem><para><link linkend="status-color">Status-Color patch</link></para></listitem>
+      <listitem><para><link linkend="keywords">Keywords patch</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="index-color-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="index-color-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Christian Aichinger <email>Greek0@gmx.net</email></para></listitem>
+    <listitem><para>Christoph <quote>Myon</quote> Berg <email>myon@debian.org</email></para></listitem>
+    <listitem><para>Elimar Riesebieter <email>riesebie@lxtec.de</email></para></listitem>
+    <listitem><para>Eric Davis <email>edavis@insanum.com</email></para></listitem>
+    <listitem><para>Vladimir Marek <email>Vladimir.Marek@oracle.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="initials">
+  <title>Initials Expando Patch</title>
+  <subtitle>Expando for author's initials</subtitle>
+
+  <sect2 id="initials-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>Initials</quote>, look for
+      <quote>patch-initials</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="initials-intro">
+    <title>Introduction</title>
+
+        <para>
+    The <quote>initials</quote> patch adds an expando (%I) for an author's
+    initials.
+        </para>
+
+    <para>
+    The index panel displays a list of emails.  Its layout is controlled by
+    the <link linkend="index-format">$index_format</link> variable.  Using
+    this expando saves space in the index panel.  This can be useful if you
+    are regularly working with a small set of people.
+    </para>
+  </sect2>
+
+  <sect2 id="initials-variables">
+    <title>Variables</title>
+
+        <para>
+        This patch has no config of its own.  It adds an expando which can be
+    used in the <link linkend="index-format">$index_format</link> variable.
+        </para>
+  </sect2>
+
+  <sect2 id="initials-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example Mutt config file for the 'initials' patch.
+ 
+# The 'initials' patch has no config of its own.
+# It adds an expando for an author's initials,
+# which can be used in the 'index_format' variable.
+ 
+# The default 'index_format' is:</emphasis>
+set index_format='%4C %Z %{%b %d} %-15.15L (%?l?%4l&amp;%4c?) %s'
+ 
+<emphasis role="comment"># Where %L represents the author/recipient
+ 
+# This might look like:
+#       1   + Nov 17 David Bowie   Changesbowie    ( 689)
+#       2   ! Nov 17 Stevie Nicks  Rumours         ( 555)
+#       3   + Nov 16 Jimi Hendrix  Voodoo Child    ( 263)
+#       4   + Nov 16 Debbie Harry  Parallel Lines  ( 540)
+ 
+# Using the %I expando:</emphasis>
+set index_format='%4C %Z %{%b %d} %I (%?l?%4l&amp;%4c?) %s'
+ 
+<emphasis role="comment"># This might look like:
+#       1   + Nov 17 DB Changesbowie    ( 689)
+#       2   ! Nov 17 SN Rumours         ( 555)
+#       3   + Nov 16 JH Voodoo Child    ( 263)
+#       4   + Nov 16 DH Parallel Lines  ( 540)
+ 
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="initials-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="index-format">$index_format</link></para></listitem>
+      <listitem><para><link linkend="index-color">index-color patch</link></para></listitem>
+      <listitem><para><link linkend="folder-hook">folder-hook</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="initials-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="initials-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Vsevolod Volkov <email>vvv@mutt.org.ua</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="keywords">
+  <title>Keywords Patch</title>
+  <subtitle>Labels/Tagging for emails</subtitle>
+
+  <sect2 id="keywords-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>Keywords</quote>, look for
+      <quote>patch-keywords</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="keywords-intro">
+    <title>Introduction</title>
+
+    <para>
+    Unify label/keyword handling.
+    </para>
+
+    <para>
+    Since x-labels were added to mutt in 2000, a number of other approaches
+    to what we now call <quote>tagging</quote> have also emerged.
+    One of them was even made standard in RFC 2822.
+    This update unifies the handling of all these strategies.
+    </para>
+
+    <para>
+    We start by changing mutt's internal keyword storage from a single
+    string which may contain whitespace to a list of discrete keywords.
+    This has advantages for keyword completion as well as for portabilty
+    among varying "standards" for keyword storage.  This may represent
+    a significant change for existing mutt users who have set x-labels
+    containing spaces, and should be regarded with suspicion.  The
+    advantages are significant, though.
+    </para>
+
+    <para>
+    Next we allow mutt to parse keywords into this internal list from
+    any of the following headers: X-Label (freeform), X-Keywords
+    (space-delimited), X-Mozilla-Keys (space-delimited), and Keywords (RFC
+    2822, comma-space-delimited).  Mutt remembers which headers it sourced
+    keywords from, and can rewrite those headers when saving messages for
+    compatibility with the mailer of origin.
+    </para>
+
+    <para>
+    (X-Label was specified as freeform text by mutt, its only known
+    implementation.  X-Labels have been used both as a
+    <quote>tagging</quote> device, probably with space delimiting, and as a
+    <quote>memo</quote> field, where space-delimited parsing would ruin the
+    semantics of the memo.  By default mutt will not split X-Labels at all.
+    Set $xlabel_delimiter if your needs vary.)
+    </para>
+
+    <para>
+    Finally we add two booleans: $keywords_legacy=true and
+    $keywords_standard=FALSE.  When $keywords_legacy is true, mutt will
+    always save keyword to whatever original header it came from.  When
+    $keywords_standard=true, mutt will save to the Keywords: header.  If
+    both are true mutt saves to both; if neither is true, mutt saves only
+    to legacy headers to avoid complete loss of keywords.
+    </para>
+
+    <para>
+    Overall this represents convergence path for all competing
+    labelling/tagging/keywording systems toward one that is specified by
+    RFC.
+    </para>
+
+    <para>
+    You can change or delete the X-Label: field within
+    Mutt using the edit-label command.
+    This works for tagged messages, too.
+    </para>
+  </sect2>
+
+  <sect2 id="keywords-variables">
+    <title>Variables</title>
+
+    <table id="table-keywords-variables">
+      <title>Keywords Variables</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>keywords_legacy</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>yes</literal></entry>
+          </row>
+          <row>
+            <entry><literal>keywords_standard</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>xlabel_delimiter</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="keywords-functions">
+    <title>Functions</title>
+
+    <para>
+      Keywords adds the following function to Mutt.
+      By default, it is not bound to a key.
+    </para>
+
+    <table id="table-keywords-funcions">
+      <title>Keyword Functions</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Menus</entry>
+            <entry>Function</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;edit-label&gt;</literal></entry>
+            <entry>add, change, or delete a message's label</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="keywords-sort">
+    <title>Sort</title>
+    <table id="table-keywords-sort">
+      <title>Keywords Sort</title>
+      <tgroup cols="2">
+        <thead>
+          <row>
+            <entry>Sort</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>label</literal></entry>
+            <entry>Sort by label</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="keywords-muttrc">
+    <title>Muttrc</title>
+
+<screen>
+<emphasis role="comment"># This is a complete list of keywords-related configuration.
+ 
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+ 
+# Should Mutt save the keywords to whatever keyword it came from?</emphasis>
+set keywords_legacy = yes
+ 
+<emphasis role="comment"># Should Mutt use the "Keywords:" header?</emphasis>
+set keywords_standard = no
+ 
+<emphasis role="comment"># How should the keywords be separated?</emphasis>
+set xlabel_delimiter = ""
+ 
+<emphasis role="comment"># --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+ 
+# Bind 'y' to edit labels/keywords</emphasis>
+bind index,pager y edit-label
+ 
+<emphasis role="comment"># --------------------------------------------------------------------------
+ 
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="keywords-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="index-format">$index_format</link></para></listitem>
+      <listitem><para><link linkend="index-color">index-color patch</link></para></listitem>
+      <listitem><para><link linkend="folder-hook">folder-hook</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="keywords-known-bugs">
+    <title>Known Bugs</title>
+    <para>
+      None
+    </para>
+  </sect2>
+
+  <sect2 id="keywords-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>David Champion <email>dgc@uchicago.edu</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="limit-current-thread">
+  <title>Limit-Current-Thread Patch</title>
+  <subtitle>Focus on one Email Thread</subtitle>
+
+  <sect2 id="limit-current-thread-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>limit-current-thread</quote>, look for
+      <quote>patch-limit-current-thread</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="limit-current-thread-intro">
+    <title>Introduction</title>
+
+    <para>
+      This patch adds a new way of using the
+      <link linkend="tuning-search">Limit Command</link>.
+      The <literal>&lt;limit-current-thread&gt;</literal>
+      function restricts the view to just the current thread.
+      Setting the limit (the <literal>l</literal> key) to
+      <quote>all</quote> will restore the full email list.
+    </para>
+
+  </sect2>
+
+  <sect2 id="limit-current-thread-functions">
+    <title>Functions</title>
+
+    <para>
+      Limit-current-thread adds the following function to Mutt.
+      By default, it is not bound to a key.
+    </para>
+
+    <table id="table-limit-current-thread-functions">
+      <title>Limit-Current-Thread Functions</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Menus</entry>
+            <entry>Function</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>index</entry>
+            <entry><literal>&lt;limit-current-thread&gt;</literal></entry>
+            <entry>Limit view to current thread</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+
+  </sect2>
+
+  <sect2 id="limit-current-thread-muttrc">
+    <title>Muttrc</title>
+
+<screen>
+<emphasis role="comment"># Example Mutt config file for the 'limit-current-thread' patch.
+ 
+# Limit view to current thread</emphasis>
+bind index &lt;esc&gt;L limit-current-thread
+ 
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="limit-current-thread-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="limit-current-thread-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="limit-current-thread-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>David Sterba <email>dsterba@suse.cz</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="lmdb">
+  <title>LMDB Patch</title>
+  <subtitle>LMDB backend for the header cache</subtitle>
+
+  <sect2 id="lmdb-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>lmdb</quote>, look for
+      <quote>patch-lmdb</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="lmdb-intro">
+    <title>Introduction</title>
+
+    <para>
+      This patch adds support for using LMDB as a storage backend for
+      Mutt's header cache (hcache). It is enabled at configure time with
+      the <emphasis>--with-lmdb=&lt;path&gt;</emphasis> switch.
+    </para>
+
+    <note>
+      <para>
+        It is not recommended to store the lmdb database on a shared drive.
+      </para>
+    </note>
+  </sect2>
+
+  <sect2 id="lmdb-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="caching">Local Caching</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="lmdb-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="lmdb-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Pietro Cerutti <email>gahr@gahr.ch</email></para></listitem>
+    <listitem><para>Jan-Piet Mens <email>jp@mens.de</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="multiple-fcc">
+  <title>multiple-fcc Patch</title>
+  <subtitle>Save multiple copies of outgoing mail</subtitle>
+
+  <sect2 id="multiple-fcc-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>multiple-fcc</quote>, look for
+      <quote>patch-multiple-fcc</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="multiple-fcc-intro">
+    <title>Introduction</title>
+
+    <para>
+      This patch allows the user to save outgoing emails in multiple folders.
+    </para>
+
+    <para>
+      Folders should be listed separated by commas, <emphasis role="bold">but no spaces</emphasis>.
+    </para>
+
+    <para>
+      The <quote>fcc</quote> field of an email can be set in two ways:
+    </para>
+
+    <itemizedlist>
+      <listitem><para>The &lt;edit-fcc&gt; command in the compose menu (default key: <quote>f</quote>)</para></listitem>
+      <listitem><para>Creating a <literal>fcc-hook</literal> in your <literal>.muttrc</literal></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="multiple-fcc-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="record">$record</link></para></listitem>
+      <listitem><para><link linkend="fcc-hook">fcc-hook</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="multiple-fcc-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="multiple-fcc-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Omen Wild <email>omen@mandarb.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="nested-if">
+  <title>Nested If Patch</title>
+  <subtitle>Allow complex nested conditions in format strings</subtitle>
+
+  <sect2 id="nested-if-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>Nested If</quote>, look for
+      <quote>patch-nested-if</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="nested-if-intro">
+    <title>Introduction</title>
+
+    <para>
+      Mutt's format strings can contain embedded if-then-else conditions.
+      They are of the form:
+    </para>
+
+<screen>
+%?VAR?TRUE&amp;FALSE?
+</screen>
+
+    <para>
+      If the variable <quote>VAR</quote> has a value greater than zero,
+      print the <quote>TRUE</quote> string, otherwise print the
+      <quote>FALSE</quote> string.
+    </para>
+
+    <para>
+      e.g.  <literal>%?S?Size: %S&amp;Empty?</literal>
+    </para>
+
+    <para>Which can be read as:</para>
+
+    <literallayout>
+if (%S &gt; 0) {
+    print &quot;Size: %S&quot;
+} else {
+    print &quot;Empty&quot;
+}
+    </literallayout>
+
+    <para>
+      These conditions are useful, but in Mutt they cannot be nested
+      within one another.  This patch uses the notation
+      <literal>%&lt;VAR?TRUE&amp;FALSE&gt;</literal> and allows them to be nested.
+    </para>
+
+    <para>
+      The <literal>%&lt;...&gt;</literal> notation was used to format the
+      current local time.  but that's not really very useful since mutt
+      has no means of refreshing the screen periodically.
+    </para>
+
+    <para>
+      A simple nested condition might be:
+      (Some whitespace has been introduced for clarity)
+    </para>
+
+<screen>
+%&lt;x? %&lt;y? XY &amp; X &gt; &amp; %&lt;y? Y &amp; NONE &gt; &gt;  Conditions
+     %&lt;y? XY &amp; X &gt;                      x&gt;0
+          XY                            x&gt;0,y&gt;0
+               X                        x&gt;0,y=0
+</screen>
+
+<screen>
+%&lt;x? %&lt;y? XY &amp; X &gt; &amp; %&lt;y? Y &amp; NONE &gt; &gt;  Conditions
+                      %&lt;y? Y &amp; NONE &gt;    x=0
+                          Y             x=0,y&gt;0
+                              NONE      x=0,y=0
+</screen>
+
+    <para>Equivalent to:</para>
+
+    <literallayout>
+if (x &gt; 0) {
+    if (y &gt; 0) {
+        print 'XY'
+    } else {
+        print 'X'
+    }
+} else {
+    if (y &gt; 0) {
+        print 'Y'
+    } else {
+        print 'NONE'
+    }
+}
+    </literallayout>
+
+    <para>Examples:</para>
+
+<screen>
+set index_format='%4C %Z %{%b %d} %-25.25n %s%&gt; %&lt;M?%M Msgs &amp;%&lt;l?%l Lines&amp;%c Bytes&gt;&gt;'
+</screen>
+
+    <literallayout>
+if a thread is folded
+    display the number of messages (%M)
+else if we know how many lines in the message
+    display lines in message (%l)
+else
+    display the size of the message in bytes (%c)
+    </literallayout>
+
+<screen>
+set index_format='%4C %Z %{%b %d} %-25.25n %&lt;M?[%M] %s&amp;%s%* %&lt;l?%l&amp;%c&gt;&gt;'
+</screen>
+
+    <literallayout>
+if a thread is folded
+    display the number of messages (%M)
+    display the subject (%s)
+else if we know how many lines in the message
+    display lines in message (%l)
+else
+    display the size of the message in bytes (%c)
+    </literallayout>
+
+  </sect2>
+
+  <sect2 id="nested-if-variables">
+    <title>Variables</title>
+    <para>
+      The <quote>nested-if</quote> patch doesn't have any config of its own.
+      It modifies the behavior of the format strings.
+    </para>
+  </sect2>
+
+  <sect2 id="nested-if-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example Mutt config file for the 'nested-if' feature.
+ 
+# This patch uses the format: '%&lt;VAR?TRUE&amp;FALSE&gt;' for conditional
+# format strings that can be nested.
+ 
+# Example 1
+# if a thread is folded
+#       display the number of messages (%M)
+# else if we know how many lines in the message
+#       display lines in message (%l)
+# else display the size of the message in bytes (%c)</emphasis>
+set index_format='%4C %Z %{%b %d} %-25.25n %s%&gt; %&lt;M?%M Msgs &amp;%&lt;l?%l Lines&amp;%c Bytes&gt;&gt;'
+ 
+<emphasis role="comment"># Example 2
+# if a thread is folded
+#       display the number of messages (%M)
+#       display the subject (%s)
+# else if we know how many lines in the message
+#       display lines in message (%l)
+# else
+#       display the size of the message in bytes (%c)</emphasis>
+set index_format='%4C %Z %{%b %d} %-25.25n %&lt;M?[%M] %s&amp;%s%* %&lt;l?%l&amp;%c&gt;&gt;'
+ 
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="nested-if-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="cond-date">cond-date patch</link></para></listitem>
+      <listitem><para><link linkend="index-format">$index_format</link></para></listitem>
+      <listitem><para><link linkend="status-format">$status_format</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="nested-if-known-bugs">
+    <title>Known Bugs</title>
+    <para>
+      Patch overwrites $&lt;fmt&gt; handler in <literal>$index_format</literal>
+    </para>
+  </sect2>
+
+  <sect2 id="nested-if-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>David Champion <email>dgc@uchicago.edu</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="new-mail-hook">
+  <title>new-mail Patch</title>
+  <subtitle>Execute a command upon the receipt of new mail.</subtitle>
+
+  <sect2 id="new-mail-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>new-mail</quote>, look for
+      <quote>patch-new-mail</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="new-mail-intro">
+    <title>Introduction</title>
+
+    <para>
+      This patch enables the new_mail_command setting, which can be used to
+      execute a custom script (e.g., a notification handler) upon receiving a
+      new mail.
+    </para>
+
+    <para>
+      The command string can contain expandos, such as <literal>%f</literal>
+      for the folder name.  For a complete list, see:
+      <link linkend="status-format">$status_format</link>.
+    </para>
+
+    <para>
+      For example in Linux you can use (most distributions already provide notify-send):
+    </para>
+
+<screen>
+set new_mail_command="notify-send --icon='/home/santiago/Pictures/mutt.png' 'New Email in %f' '%n new messages, %u unread.' &amp;"
+</screen>
+
+    <para>
+      And in OS X you will need to install a command line interface for
+      Notification Center, for example
+      <ulink url="https://github.com/julienXX/terminal-notifier">terminal-notifier</ulink>:
+    </para>
+
+<screen>
+set new_mail_command="terminal-notifier -title '%v' -subtitle 'New Mail in %f' -message '%n new messages, %u unread.' -activate 'com.apple.Terminal'"
+</screen>
+
+  </sect2>
+
+  <sect2 id="new-mail-variables">
+    <title>Variables</title>
+
+    <table id="table-new-mail-variables">
+      <title>New Mail Command Variables</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>new_mail_command</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="new-mail-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example Mutt config file for the 'new-mail-command' patch.
+ 
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+ 
+# Set the command you want mutt to execute upon the receipt of a new email</emphasis>
+set new_mail_command = ""
+ 
+<emphasis role="comment"># Linux example:
+# set new_command="notify-send --icon='/home/santiago/Pictures/mutt.png' 'New Email in %f' '%n new messages, %u unread.' &amp;"
+ 
+# OS X example:
+# set new_mail_command="terminal-notifier -title '%v' -subtitle 'New Mail in %f' -message '%n new messages, %u unread.' -activate 'com.apple.Terminal'"
+
+# --------------------------------------------------------------------------
+
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="new-mail-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="folder-hook">folder-hook</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="new-mail-known-bugs">
+    <title>Known Bugs</title>
+    <itemizedlist>
+      <listitem>
+        <para>
+          Notifies about spurious <emphasis role="bold">new email</emphasis>
+          when an email is saved, see
+          <ulink url="https://github.com/neomutt/neomutt/issues/20">Issue #20</ulink>
+        </para>
+    </listitem>
+    <listitem>
+      <para>
+        Will not notify about new e-mail if the pager is open, see
+        <ulink url="https://github.com/neomutt/neomutt/issues/19">Issue #19</ulink>
+      </para>
+    </listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="new-mail-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Yoshiki Vazquez-Baeza <email>yoshiki@ucsd.edu</email></para></listitem>
+    <listitem><para>Santiago Torres-Arias <email>santiago@nyu.edu</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="nntp">
+  <title>NNTP Patch</title>
+  <subtitle>Talk to a Usenet news server</subtitle>
+
+  <sect2 id="nntp-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>NNTP</quote>, look for
+      <quote>+USE_NNTP</quote> in the mutt version.
+      See: <xref linkend="compile-time-features"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="nntp-intro">
+    <title>Introduction</title>
+
+    <para>Reading news via NNTP</para>
+    <para>
+    If compiled with <emphasis>--enable-nntp</emphasis> option, Mutt can
+    read news from news server via NNTP.  You can open a newsgroup with
+    function ``change-newsgroup'' (default: ``i'').  Default news server
+    can be obtained from <literal>$NNTPSERVER</literal> environment
+    variable or from <literal>/etc/nntpserver</literal> file.  Like other
+    news readers, info about subscribed newsgroups is saved in file by
+    <link linkend="newsrc">$newsrc</link> variable.  The variable <link
+    linkend="news-cache-dir">$news_cache_dir</link> can be used to point
+    to a directory.  Mutt will create a hierarchy of subdirectories named
+    like the account and newsgroup the cache is for.  Also the hierarchy
+    is used to store header cache if Mutt was compiled with <link
+    linkend="header-caching">header cache</link> support.
+    </para>
+  </sect2>
+
+  <sect2 id="nntp-variables">
+    <title>Variables</title>
+
+    <table id="table-nntp-variables">
+      <title>NNTP Variables</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>ask_follow_up</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>ask_x_comment_to</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>catchup_newsgroup</literal></entry>
+            <entry>quad</entry>
+            <entry><literal>ask-yes</literal></entry>
+          </row>
+          <row>
+            <entry><literal>followup_to_poster</literal></entry>
+            <entry>quad</entry>
+            <entry><literal>ask-yes</literal></entry>
+          </row>
+          <row>
+            <entry><literal>group_index_format</literal></entry>
+            <entry>string</entry>
+            <entry><literal>%4C %M%N %5s  %-45.45f %d</literal></entry>
+          </row>
+          <row>
+            <entry><literal>inews</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>mime_subject</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>yes</literal></entry>
+          </row>
+          <row>
+            <entry><literal>newsgroups_charset</literal></entry>
+            <entry>string</entry>
+            <entry><literal>utf-8</literal></entry>
+          </row>
+          <row>
+            <entry><literal>newsrc</literal></entry>
+            <entry>string</entry>
+            <entry><literal>~/.newsrc</literal></entry>
+          </row>
+          <row>
+            <entry><literal>news_cache_dir</literal></entry>
+            <entry>string</entry>
+            <entry><literal>~/.mutt</literal></entry>
+          </row>
+          <row>
+            <entry><literal>news_server</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>nntp_authenticators</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>nntp_context</literal></entry>
+            <entry>number</entry>
+            <entry><literal>1000</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nntp_listgroup</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>yes</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nntp_load_description</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>yes</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nntp_pass</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>nntp_poll</literal></entry>
+            <entry>number</entry>
+            <entry><literal>60</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nntp_user</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>post_moderated</literal></entry>
+            <entry>quad</entry>
+            <entry><literal>ask-yes</literal></entry>
+          </row>
+          <row>
+            <entry><literal>save_unsubscribed</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>show_new_news</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>yes</literal></entry>
+          </row>
+          <row>
+            <entry><literal>show_only_unread</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>x_comment_to</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="nntp-functions">
+    <title>Functions</title>
+
+    <para>
+      NNTP adds the following functions to Mutt.
+      By default, none of them are bound to keys.
+    </para>
+
+    <table id="table-nntp-functions">
+      <title>NNTP Functions</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Menus</entry>
+            <entry>Function</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>browser,index</entry>
+            <entry><literal>&lt;catchup&gt;</literal></entry>
+            <entry>mark all articles in newsgroup as read</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;change-newsgroup&gt;</literal></entry>
+            <entry>open a different newsgroup</entry>
+          </row>
+          <row>
+            <entry>compose</entry>
+            <entry><literal>&lt;edit-followup-to&gt;</literal></entry>
+            <entry>edit the Followup-To field</entry>
+          </row>
+          <row>
+            <entry>compose</entry>
+            <entry><literal>&lt;edit-newsgroups&gt;</literal></entry>
+            <entry>edit the newsgroups list</entry>
+          </row>
+          <row>
+            <entry>compose</entry>
+            <entry><literal>&lt;edit-x-comment-to&gt;</literal></entry>
+            <entry>edit the X-Comment-To field</entry>
+          </row>
+          <row>
+            <entry>attachment,index,pager</entry>
+            <entry><literal>&lt;followup-message&gt;</literal></entry>
+            <entry>followup to newsgroup</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;post-message&gt;</literal></entry>
+            <entry>post message to newsgroup</entry>
+          </row>
+          <row>
+            <entry>browser</entry>
+            <entry><literal>&lt;reload-active&gt;</literal></entry>
+            <entry>load list of all newsgroups from NNTP server</entry>
+          </row>
+          <row>
+            <entry>browser</entry>
+            <entry><literal>&lt;subscribe&gt;</literal></entry>
+            <entry>subscribe to current mbox (IMAP/NNTP only)</entry>
+          </row>
+          <row>
+            <entry>browser</entry>
+            <entry><literal>&lt;subscribe-pattern&gt;</literal></entry>
+            <entry>subscribe to newsgroups matching a pattern</entry>
+          </row>
+          <row>
+            <entry>browser</entry>
+            <entry><literal>&lt;uncatchup&gt;</literal></entry>
+            <entry>mark all articles in newsgroup as unread</entry>
+          </row>
+          <row>
+            <entry>browser</entry>
+            <entry><literal>&lt;unsubscribe&gt;</literal></entry>
+            <entry>unsubscribe from current mbox (IMAP/NNTP only)</entry>
+          </row>
+          <row>
+            <entry>browser</entry>
+            <entry><literal>&lt;unsubscribe-pattern&gt;</literal></entry>
+            <entry>unsubscribe from newsgroups matching a pattern</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;change-newsgroup-readonly&gt;</literal></entry>
+            <entry>open a different newsgroup in read only mode</entry>
+          </row>
+          <row>
+            <entry>attachment,index,pager</entry>
+            <entry><literal>&lt;forward-to-group&gt;</literal></entry>
+            <entry>forward to newsgroup</entry>
+          </row>
+          <row>
+            <entry>index</entry>
+            <entry><literal>&lt;get-children&gt;</literal></entry>
+            <entry>get all children of the current message</entry>
+          </row>
+          <row>
+            <entry>index</entry>
+            <entry><literal>&lt;get-parent&gt;</literal></entry>
+            <entry>get parent of the current message</entry>
+          </row>
+          <row>
+            <entry>index</entry>
+            <entry><literal>&lt;reconstruct-thread&gt;</literal></entry>
+            <entry>reconstruct thread containing current message</entry>
+          </row>
+          <row>
+            <entry>index</entry>
+            <entry><literal>&lt;get-message&gt;</literal></entry>
+            <entry>get message with Message-Id</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="nntp-muttrc">
+    <title>Muttrc</title>
+
+<screen>
+<emphasis role="comment"># This is a complete list of nntp configuration.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------</emphasis>
+
+set ask_follow_up = no
+set ask_x_comment_to = no
+set catchup_newsgroup = ask-yes
+set followup_to_poster = ask-yes
+set group_index_format = '%4C %M%N %5s  %-45.45f %d'
+set inews = ''
+set mime_subject = yes
+set newsgroups_charset = utf-8
+set newsrc = '~/.newsrc'
+set news_cache_dir = '~/.mutt'
+set news_server = ''
+set nntp_authenticators = ''
+set nntp_context = 1000
+set nntp_listgroup = yes
+set nntp_load_description = yes
+set nntp_pass = ''
+set nntp_poll = 60
+set nntp_user = ''
+set post_moderated = ask-yes
+set save_unsubscribed = no
+set show_new_news = yes
+set show_only_unread = no
+set x_comment_to = no
+
+<emphasis role="comment"># --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# mark all articles in newsgroup as read</emphasis>
+bind browser,index y catchup 
+
+<emphasis role="comment"># open a different newsgroup</emphasis>
+bind index,pager i change-newsgroup 
+
+<emphasis role="comment"># edit the Followup-To field</emphasis>
+bind compose o edit-followup-to 
+
+<emphasis role="comment"># edit the newsgroups list</emphasis>
+bind compose N edit-newsgroups 
+
+<emphasis role="comment"># edit the X-Comment-To field</emphasis>
+bind compose x edit-x-comment-to 
+
+<emphasis role="comment"># followup to newsgroup</emphasis>
+bind attachment,index,pager F followup-message 
+
+<emphasis role="comment"># post message to newsgroup</emphasis>
+bind index,pager P post-message 
+
+<emphasis role="comment"># load list of all newsgroups from NNTP server</emphasis>
+bind browser g reload-active 
+
+<emphasis role="comment"># subscribe to current mbox (IMAP/NNTP only)</emphasis>
+bind browser s subscribe 
+
+<emphasis role="comment"># subscribe to newsgroups matching a pattern</emphasis>
+bind browser S subscribe-pattern 
+
+<emphasis role="comment"># mark all articles in newsgroup as unread</emphasis>
+bind browser Y uncatchup 
+
+<emphasis role="comment"># unsubscribe from current mbox (IMAP/NNTP only)</emphasis>
+bind browser u unsubscribe 
+
+<emphasis role="comment"># unsubscribe from newsgroups matching a pattern</emphasis>
+bind browser U unsubscribe-pattern 
+
+<emphasis role="comment"># open a different newsgroup in read only mode</emphasis>
+bind index,pager \ei change-newsgroup-readonly 
+
+<emphasis role="comment"># forward to newsgroup</emphasis>
+bind attachment,index,pager \eF forward-to-group 
+
+<emphasis role="comment"># get all children of the current message</emphasis>
+# bind index ??? get-children 
+
+<emphasis role="comment"># get parent of the current message</emphasis>
+bind index \eG get-parent 
+
+# reconstruct thread containing current message
+# bind index ??? reconstruct-thread 
+
+<emphasis role="comment"># get message with Message-Id</emphasis>
+bind index \CG get-message 
+
+<emphasis role="comment"># --------------------------------------------------------------------------
+
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="nntp-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="compile-time-features">Compile-Time Features</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="nntp-known-bugs">
+    <title>Known Bugs</title>
+    <para>
+      None
+    </para>
+  </sect2>
+
+  <sect2 id="nntp-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Vsevolod Volkov <email>vvv@mutt.org.ua</email></para></listitem>
+    <listitem><para>Felix von Leitner <email>leitner@fefe.de</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="notmuch">
+  <title>Notmuch Patch</title>
+  <subtitle>Email search engine</subtitle>
+
+  <sect2 id="notmuch-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>Notmuch</quote>, look for
+      <quote>+USE_NOTMUCH</quote> in the mutt version.
+      See: <xref linkend="compile-time-features"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+      <listitem><para><link linkend="sidebar">sidebar patch</link></para></listitem>
+      <listitem><para><link linkend="quasi-delete">quasi-delete patch</link></para></listitem>
+      <listitem><para><link linkend="index-color">index-color patch</link></para></listitem>
+      <listitem><para>Notmuch libraries</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="notmuch-intro">
+    <title>Introduction</title>
+
+    <para>
+      Notmuch is an email fulltext indexing and tagging engine.
+    </para>
+
+    <itemizedlist>
+      <listitem><para>For more information, see: 
+      <ulink url="http://notmuchmail.org/">http://notmuchmail.org/</ulink>
+      </para></listitem>
+      <listitem><para>Home page (wiki) and git:
+      <ulink url="https://github.com/karelzak/mutt-kz">https://github.com/karelzak/mutt-kz</ulink>
+      </para></listitem>
+      <listitem><para>Mailing list:
+      <ulink url="https://admin.fedoraproject.org/mailman/listinfo/mutt-kz">https://admin.fedoraproject.org/mailman/listinfo/mutt-kz</ulink>
+      </para></listitem>
+
+      <listitem><para>More examples:
+      <ulink url="http://notmuchmail.org/mutttips/">http://notmuchmail.org/mutttips/</ulink>
+      </para></listitem>
+    </itemizedlist>
+
+  </sect2>
+
+  <sect2 id="notmuch-using">
+    <title>Using NotMuch</title>
+
+    <sect3 id="notmuch-folder-uri">
+      <title>Folders URI</title>
+
+      <para>
+        <emphasis role="bold">notmuch://[&lt;path&gt;][?&lt;item&gt;=&lt;name&gt;[&amp; ...]]</emphasis>
+      </para>
+
+      <para>
+        The &lt;path&gt; is an absolute path to the directory where the notmuch database
+        is found as returned by <quote>notmuch config get database.path</quote> command. Note that
+        the &lt;path&gt; should NOT include <literal>.notmuch</literal> directory name.
+      </para>
+
+      <para>
+        If the &quot;&lt;path&gt;&quot; is not defined then
+        <literal>$nm_default_uri</literal> or <literal>$folder</literal> is
+        used, for example:
+      </para>
+
+<screen>
+set nm_default_uri = "notmuch:///home/foo/maildir"
+virtual-mailboxes "My INBOX" "notmuch://?query=tag:inbox"
+</screen>
+    </sect3>
+
+    <sect3 id="notmuch-items">
+      <title>Items</title>
+
+      <para>
+        <emphasis role="bold">query=&lt;string&gt;</emphasis>
+      </para>
+
+      <para>
+        See SEARCH SYNTAX in notmuch man page. Don't forget to use
+        <quote>and</quote> and <quote>or</quote> operators in your queries.
+      </para>
+
+      <para>
+        Note that proper URI should not contain blank space and all
+        <quote>bad</quote> chars should be encoded, for example
+      </para>
+
+      <para>
+        <literal>tag:AAA and tag:BBB</literal> --encoding-&gt; <literal>tag:AAA%20and%20tag:BBB</literal>
+      </para>
+
+      <para>
+        but mutt config file parser is smart enough to accept space in quoted
+        strings. It means that you can use
+      </para>
+
+      <para>
+        <literal>notmuch:///foo?query=tag:AAA and tag:BBB</literal>
+      </para>
+
+      <para>
+        in your config files to keep things readable.
+      </para>
+
+      <para>
+        For more details about Xapian queries, see:
+        <ulink url="http://xapian.org/docs/queryparser.html">http://xapian.org/docs/queryparser.html</ulink>
+      </para>
+
+      <para>
+        <emphasis role="bold">limit=&lt;number&gt;</emphasis>
+      </para>
+
+      <para>
+         Restricts number of messages/threads in the result. The default limit
+         is nm_db_limit.
+      </para>
+
+      <para>
+        <emphasis role="bold">type=&lt;threads|messages&gt;</emphasis>
+      </para>
+
+      <para>
+         Reads all matching messages or whole-threads. The default is 'messages'
+         or nm_query_type.
+      </para>
+    </sect3>
+
+  </sect2>
+
+  <sect2 id="notmuch-variables">
+    <title>Variables</title>
+
+    <table id="table-notmuch-variables">
+      <title>Notmuch Variables</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>nm_db_limit</literal></entry>
+            <entry>number</entry>
+            <entry><literal>0</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nm_default_uri</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>nm_exclude_tags</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>nm_hidden_tags</literal></entry>
+            <entry>string</entry>
+            <entry><literal>unread,draft,flagged,passed,replied,attachment,signed,encrypted</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nm_open_timeout</literal></entry>
+            <entry>number</entry>
+            <entry><literal>5</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nm_query_type</literal></entry>
+            <entry>string</entry>
+            <entry><literal>messages</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nm_record</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nm_record_tags</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>nm_unread_tag</literal></entry>
+            <entry>string</entry>
+            <entry><literal>unread</literal></entry>
+          </row>
+          <row>
+            <entry><literal>vfolder_format</literal></entry>
+            <entry>string</entry>
+            <entry><literal>%6n(%6N) %f</literal></entry>
+          </row>
+          <row>
+            <entry><literal>virtual_spoolfile</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="notmuch-functions">
+    <title>Functions</title>
+
+    <para>
+      Notmuch adds the following functions to Mutt.
+      By default, none of them are bound to keys.
+    </para>
+
+    <table id="table-notmuch-functions">
+      <title>Notmuch Functions</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Menus</entry>
+            <entry>Function</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;change-vfolder&gt;</literal></entry>
+            <entry>open a different virtual folder</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;entire-thread&gt;</literal></entry>
+            <entry>read entire thread of the current message</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;modify-labels&gt;</literal></entry>
+            <entry>modify (notmuch) tags</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;modify-labels-then-hide&gt;</literal></entry>
+            <entry>modify labels and then hide message</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-toggle-virtual&gt;</literal></entry>
+            <entry>toggle between mailboxes and virtual mailboxes</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;vfolder-from-query&gt;</literal></entry>
+            <entry>generate virtual folder from query</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="notmuch-commands">
+    <title>Commands</title>
+    <cmdsynopsis>
+
+      <command>virtual-mailboxes</command>
+      <arg choice="plain">
+        <replaceable class="parameter">description</replaceable>
+        <arg choice="plain">
+          <replaceable class="parameter">notmuch-URI</replaceable>
+        </arg>
+      </arg>
+      <group choice="req" rep="repeat">
+        <arg choice="plain">
+          <replaceable class="parameter">description</replaceable>
+          <arg choice="plain">
+            <replaceable class="parameter">notmuch-URI</replaceable>
+          </arg>
+        </arg>
+      </group>
+
+      <command>tag-transforms</command>
+      <arg choice="plain">
+        <replaceable class="parameter">tag</replaceable>
+        <arg choice="plain">
+          <replaceable class="parameter">transformed-string</replaceable>
+        </arg>
+      </arg>
+      <group choice="req" rep="repeat">
+        <arg choice="plain">
+          <replaceable class="parameter">tag</replaceable>
+          <arg choice="plain">
+            <replaceable class="parameter">transformed-string</replaceable>
+          </arg>
+        </arg>
+      </group>
+
+      <command>tag-formats</command>
+      <arg choice="plain">
+        <replaceable class="parameter">tag</replaceable>
+        <arg choice="plain">
+          <replaceable class="parameter">format-string</replaceable>
+        </arg>
+      </arg>
+      <group choice="req" rep="repeat">
+        <arg choice="plain">
+          <replaceable class="parameter">tag</replaceable>
+          <arg choice="plain">
+            <replaceable class="parameter">format-string</replaceable>
+          </arg>
+        </arg>
+      </group>
+
+    </cmdsynopsis>
+  </sect2>
+
+  <sect2 id="notmuch-colors">
+    <title>Colors</title>
+
+    <para>Adds these to index-color patch:</para>
+
+    <table id="table-notmuch-colors">
+      <title>Index Colors</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Object</entry>
+            <entry>Pattern</entry>
+            <entry>Highlights</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>index_tag</literal></entry>
+            <entry>yes</entry>
+            <entry>an individual message tag, %G, uses tag name</entry>
+          </row>
+          <row>
+            <entry><literal>index_tags</literal></entry>
+            <entry>no</entry>
+            <entry>the transformed message tags, %g</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="notmuch-muttrc">
+    <title>Muttrc</title>
+
+<screen>
+<emphasis role="comment"># This is a complete list of notmuch-related configuration.
+ 
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+ 
+# This variable specifies notmuch query limit.</emphasis>
+set nm_db_limit = 0
+ 
+<emphasis role="comment"># This variable specifies the default Notmuch database in format:
+# notmuch://&lt;absolute path&gt;</emphasis>
+set nm_default_uri = ""
+ 
+<emphasis role="comment"># The messages tagged with these tags are excluded and not loaded
+# from notmuch DB to mutt unless specified explicitly.</emphasis>
+set nm_exclude_tags = ""
+ 
+<emphasis role="comment"># This variable specifies private notmuch tags which should not be printed
+# on screen (index, pager).</emphasis>
+set nm_hidden_tags = "unread,draft,flagged,passed,replied,attachment,signed,encrypted"
+ 
+<emphasis role="comment"># This option specifies timeout for Notmuch database. Default is 5 seconds.</emphasis>
+set nm_open_timeout = 5
+ 
+<emphasis role="comment"># This variable specifies notmuch query type, supported types: 'threads' and</emphasis>
+# 'messages'.
+set nm_query_type = messages
+ 
+<emphasis role="comment"># Add messages stored to the mutt record (see $record in the mutt docs)
+# also to notmuch DB.</emphasis>
+set nm_record = no
+ 
+<emphasis role="comment"># Tags that should be removed or added to the to the messages stored in the mutt record.</emphasis>
+set nm_record_tags = ""
+ 
+<emphasis role="comment"># This variable specifies notmuch tag which is used for unread messages.</emphasis>
+set nm_unread_tag = unread
+ 
+<emphasis role="comment"># This variable allows you to customize the file browser display for virtual
+# folders to your personal taste.</emphasis>
+set vfolder_format = "%6n(%6N) %f"
+ 
+<emphasis role="comment"># When set, mutt will use the first virtual mailbox (see virtual-mailboxes)
+# as a spoolfile.</emphasis>
+set virtual_spoolfile = no
+ 
+<emphasis role="comment"># --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+ 
+# open a different virtual folder</emphasis>
+bind index,pager X change-vfolder 
+ 
+<emphasis role="comment"># read entire thread of the current message</emphasis>
+bind index,pager + entire-thread 
+ 
+<emphasis role="comment"># modify (notmuch) tags</emphasis>
+bind index,pager \` modify-labels 
+ 
+<emphasis role="comment"># generate virtual folder from query</emphasis>
+bind index,pager \eX vfolder-from-query 
+ 
+<emphasis role="comment"># modify labels and then hide message
+# bind index,pager ??? modify-labels-then-hide 
+ 
+# toggle between mailboxes and virtual mailboxes
+# bind index,pager ??? sidebar-toggle-virtual 
+ 
+# --------------------------------------------------------------------------
+# COMMANDS - shown with an example
+# --------------------------------------------------------------------------
+ 
+# virtual-mailboxes description notmuch-URI { description notmuch-URI ...}
+# virtual-mailboxes "Climbing" "notmuch://?query=climbing"
+ 
+# Replace some tags with icons
+# tag-transforms tag transformed-string { tag transformed-string ...}
+# tag-transforms "inbox"   "i"   \
+#                "unread"  "u"   \
+#                "replied" "↻ "  \
+#                "sent"    "➥ "  \
+#                "todo"    "T"   \
+#                "deleted" "DEL" \
+#                "invites" "CAL"
+ 
+# See README.notmuch for an explanation
+# tag-formats tag format-string { tag format-string ...}
+# tag-formats "inbox"   "GI" \
+#              "unread"  "GU" \
+#              "replied" "GR" \
+#              "sent"    "GS" \
+#              "todo"    "Gt" \
+#              "deleted" "GD" \
+#              "invites" "Gi"
+ 
+# set index_format='4C %S %[%y.%m.%d] %-18.18n %?GU?%GU&amp; ? %?GR?%GR&amp; ? %?GI?%GI&amp; ? %s'
+ 
+# --------------------------------------------------------------------------
+# COLORS - some unpleasant examples are given
+# --------------------------------------------------------------------------
+ 
+# These symbols are added to the index-color patch:
+ 
+# an individual message tag, %G, uses tag name
+# this symbol uses a pattern</emphasis>
+color index_tag red white "inbox"
+ 
+<emphasis role="comment"># the transformed message tags, %g
+# this symbol does not use a pattern</emphasis>
+color index_tags green default
+ 
+<emphasis role="comment"># --------------------------------------------------------------------------
+ 
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="notmuch-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="compile-time-features">Compile-Time Features</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="notmuch-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="notmuch-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Karel Zak <email>kzak@redhat.com</email></para></listitem>
+    <listitem><para>Chris Mason <email>clm@fb.com</email></para></listitem>
+    <listitem><para>Christoph Rissner <email>cri@visotech.at</email></para></listitem>
+    <listitem><para>David Riebenbauer <email>davrieb@liegesta.at</email></para></listitem>
+    <listitem><para>David Sterba <email>dsterba@suse.cz</email></para></listitem>
+    <listitem><para>David Wilson <email>dw@botanicus.net</email></para></listitem>
+    <listitem><para>Don Zickus <email>dzickus@redhat.com</email></para></listitem>
+    <listitem><para>Eric Davis <email>edavis@insanum.com</email></para></listitem>
+    <listitem><para>Jan Synacek <email>jsynacek@redhat.com</email></para></listitem>
+    <listitem><para>Jeremiah C. Foster <email>jeremiah@jeremiahfoster.com</email></para></listitem>
+    <listitem><para>Josh Poimboeuf <email>jpoimboe@redhat.com</email></para></listitem>
+    <listitem><para>Kirill A. Shutemov <email>kirill@shutemov.name</email></para></listitem>
+    <listitem><para>Luke Macken <email>lmacken@redhat.com</email></para></listitem>
+    <listitem><para>Mantas Mikulėnas <email>grawity@gmail.com</email></para></listitem>
+    <listitem><para>Patrick Brisbin <email>pbrisbin@gmail.com</email></para></listitem>
+    <listitem><para>Philippe Le Brouster <email>plb@nebkha.net</email></para></listitem>
+    <listitem><para>Raghavendra D Prabhu <email>rprabhu@wnohang.net</email></para></listitem>
+    <listitem><para>Sami Farin <email>hvtaifwkbgefbaei@gmail.com</email></para></listitem>
+    <listitem><para>Stefan Assmann <email>sassmann@kpanic.de</email></para></listitem>
+    <listitem><para>Stefan Kuhn <email>p_regius@gmx.ch</email></para></listitem>
+    <listitem><para>Tim Stoakes <email>tim@stoakes.net</email></para></listitem>
+    <listitem><para>Vladimir Marek <email>Vladimir.Marek@oracle.com</email></para></listitem>
+    <listitem><para>Víctor Manuel Jáquez Leal <email>vjaquez@igalia.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="progress">
+  <title>Progress Bar Patch</title>
+  <subtitle>Show a visual progress bar on slow operations</subtitle>
+
+  <sect2 id="progress-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>Progress Bar</quote>, look for
+      <quote>patch-progress</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="progress-intro">
+    <title>Introduction</title>
+
+        <para>
+    The <quote>progress</quote> patch shows a visual progress bar on slow
+    tasks, such as indexing a large folder over the net.
+        </para>
+  </sect2>
+
+  <sect2 id="progress-colors">
+    <title>Colors</title>
+    <table id="table-progress-colors">
+      <title>Progress Colors</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Default Color</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>progress</literal></entry>
+            <entry>default</entry>
+            <entry>Visual progress bar</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="progress-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example Mutt config file for the 'progress' patch.
+ 
+# The 'progress' patch provides clear visual feedback for
+# slow tasks, such as indexing a large folder over the net.
+ 
+# Set the color of the progress bar
+# White text on a red background</emphasis>
+color progress white red
+ 
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="progress-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="color">Color command</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="progress-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="progress-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Rocco Rutte <email>pdmef@gmx.net</email></para></listitem>
+    <listitem><para>Vincent Lefevre <email>vincent@vinc17.org</email></para></listitem>
+    <listitem><para>Stefan Kuhn <email>wuodan@hispeed.ch</email></para></listitem>
+    <listitem><para>Karel Zak <email>kzak@redhat.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="quasi-delete">
+  <title>Quasi-Delete Patch</title>
+  <subtitle>Mark emails that should be hidden, but not deleted</subtitle>
+
+  <sect2 id="quasi-delete-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>Quasi-Delete</quote>, look for
+      <quote>patch-quasi-delete</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="quasi-delete-intro">
+    <title>Introduction</title>
+
+        <para>
+    The <quote>quasi-delete</quote> function marks an email that should be
+    hidden from the index, but NOT deleted.
+        </para>
+
+        <para>
+    On its own, this patch isn't very useful.  It forms a useful part of
+    the notmuch plugin.
+        </para>
+  </sect2>
+
+  <sect2 id="quasi-delete-functions">
+    <title>Functions</title>
+    <table id="table-quasi-delete-functions">
+      <title>Quasi-Delete Functions</title>
+      <tgroup cols="4">
+        <thead>
+          <row>
+            <entry>Menus</entry>
+            <entry>Default Key</entry>
+            <entry>Function</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>index,pager</entry>
+            <entry>(none)</entry>
+            <entry><literal>&lt;quasi-delete&gt;</literal></entry>
+            <entry>delete from mutt, don't touch on disk</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="quasi-delete-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example Mutt config file for the 'quasi-delete' feature.
+ 
+# The 'quasi-delete' function marks an email that should be hidden
+# from the index, but NOT deleted.</emphasis>
+bind index,pager Q quasi-delete
+ 
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="quasi-delete-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="notmuch">notmuch patch</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="quasi-delete-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="quasi-delete-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Karel Zak <email>kzak@redhat.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="sidebar">
+  <title>Sidebar Patch</title>
+  <subtitle>Overview of mailboxes</subtitle>
+
+  <sect2 id="sidebar-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>Sidebar</quote>, look for
+      <quote>+USE_SIDEBAR</quote> in the mutt version.
+      See: <xref linkend="compile-time-features"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="sidebar-intro">
+    <title>Introduction</title>
+
+    <para>
+      The Sidebar shows a list of all your mailboxes.  The list can be
+      turned on and off, it can be themed and the list style can be
+      configured.
+    </para>
+
+    <para>
+      This part of the manual is a reference guide.
+      If you want a simple introduction with examples see the
+      <link linkend="intro-sidebar">Sidebar Howto</link>.
+      If you just want to get started, you could use the sample
+      <link linkend="sidebar-muttrc">Sidebar muttrc</link>.
+    </para>
+  </sect2>
+
+  <sect2 id="sidebar-variables">
+    <title>Variables</title>
+
+    <table id="table-sidebar-variables">
+      <title>Sidebar Variables</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>sidebar_delim_chars</literal></entry>
+            <entry>string</entry>
+            <entry><literal>/.</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_divider_char</literal></entry>
+            <entry>string</entry>
+            <entry><literal>|</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_folder_indent</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_format</literal></entry>
+            <entry>string</entry>
+            <entry><literal>%B%*  %n</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_indent_string</literal></entry>
+            <entry>string</entry>
+            <entry><literal>&nbsp;&nbsp;</literal> (two spaces)</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_new_mail_only</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_next_new_wrap</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_on_right</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_short_path</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_sort_method</literal></entry>
+            <entry>enum</entry>
+            <entry><literal>unsorted</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_visible</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_whitelist</literal></entry>
+            <entry>list</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_width</literal></entry>
+            <entry>number</entry>
+            <entry><literal>20</literal></entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  <para>
+    For more details, and examples, about the <literal>$sidebar_format</literal>,
+    see the <link linkend="intro-sidebar-format">Sidebar Intro</link>.
+  </para>
+
+  </sect2>
+
+  <sect2 id="sidebar-functions">
+    <title>Functions</title>
+
+    <para>
+      Sidebar adds the following functions to Mutt.
+      By default, none of them are bound to keys.
+    </para>
+
+    <table id="table-sidebar-functions">
+      <title>Sidebar Functions</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Menus</entry>
+            <entry>Function</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-next&gt;</literal></entry>
+            <entry>Move the highlight to next mailbox</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-next-new&gt;</literal></entry>
+            <entry>Move the highlight to next mailbox with new mail</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-open&gt;</literal></entry>
+            <entry>Open highlighted mailbox</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-page-down&gt;</literal></entry>
+            <entry>Scroll the Sidebar down 1 page</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-page-up&gt;</literal></entry>
+            <entry>Scroll the Sidebar up 1 page</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-prev&gt;</literal></entry>
+            <entry>Move the highlight to previous mailbox</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-prev-new&gt;</literal></entry>
+            <entry>Move the highlight to previous mailbox with new mail</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-toggle-visible&gt;</literal></entry>
+            <entry>Make the Sidebar (in)visible</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="sidebar-commands">
+    <title>Commands</title>
+    <cmdsynopsis>
+      <command>sidebar_whitelist<anchor id="sidebar-whitelist"/></command>
+      <arg choice="plain">
+        <replaceable class="parameter">mailbox</replaceable>
+      </arg>
+      <arg choice="opt" rep="repeat">
+        <replaceable class="parameter">mailbox</replaceable>
+      </arg>
+    </cmdsynopsis>
+  </sect2>
+
+  <sect2 id="sidebar-colors">
     <title>Colors</title>
 
-    <table id="table-sidebar-colors">
-      <title>Sidebar Colors</title>
+    <table id="table-sidebar-colors">
+      <title>Sidebar Colors</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Default Color</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>sidebar_divider</literal></entry>
+            <entry>default</entry>
+            <entry>The dividing line between the Sidebar and the Index/Pager panels</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_flagged</literal></entry>
+            <entry>default</entry>
+            <entry>Mailboxes containing flagged mail</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_highlight</literal></entry>
+            <entry>underline</entry>
+            <entry>Cursor to select a mailbox</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_indicator</literal></entry>
+            <entry>mutt <literal>indicator</literal></entry>
+            <entry>The mailbox open in the Index panel</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_new</literal></entry>
+            <entry>default</entry>
+            <entry>Mailboxes containing new mail</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_spoolfile</literal></entry>
+            <entry>default</entry>
+            <entry>Mailbox that receives incoming mail</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+
+    <para>
+    If the <literal>sidebar_indicator</literal> color isn't set, then the default Mutt
+    indicator color will be used (the color used in the index panel).
+    </para>
+  </sect2>
+
+  <sect2 id="sidebar-sort">
+    <title>Sort</title>
+
+    <table id="table-sidebar-sort">
+      <title>Sidebar Sort</title>
+      <tgroup cols="2">
+        <thead>
+          <row>
+            <entry>Sort</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>alpha</literal></entry>
+            <entry>Alphabetically by path</entry>
+          </row>
+          <row>
+            <entry><literal>count</literal></entry>
+            <entry>Total number of messages</entry>
+          </row>
+          <row>
+            <entry><literal>flagged</literal></entry>
+            <entry>Number of flagged messages</entry>
+          </row>
+          <row>
+            <entry><literal>name</literal></entry>
+            <entry>Alphabetically by path</entry>
+          </row>
+          <row>
+            <entry><literal>new</literal></entry>
+            <entry>Number of new messages</entry>
+          </row>
+          <row>
+            <entry><literal>path</literal></entry>
+            <entry>Alphabetically by path</entry>
+          </row>
+          <row>
+            <entry><literal>unsorted</literal></entry>
+            <entry>Order of the <literal>mailboxes</literal> command</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="sidebar-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># This is a complete list of sidebar-related configuration.
+ 
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+ 
+# Should the Sidebar be shown?</emphasis>
+set sidebar_visible = no
+ 
+<emphasis role="comment"># How wide should the Sidebar be in screen columns?
+# Note: Some characters, e.g. Chinese, take up two columns each.</emphasis>
+set sidebar_width = 20
+ 
+<emphasis role="comment"># Should the mailbox paths be abbreviated?</emphasis>
+set sidebar_short_path = no
+ 
+<emphasis role="comment"># When abbreviating mailbox path names, use any of these characters as path
+# separators.  Only the part after the last separators will be shown.
+# For file folders '/' is good.  For IMAP folders, often '.' is useful.</emphasis>
+set sidebar_delim_chars = '/.'
+ 
+<emphasis role="comment"># If the mailbox path is abbreviated, should it be indented?</emphasis>
+set sidebar_folder_indent = no
+ 
+<emphasis role="comment"># Indent mailbox paths with this string.</emphasis>
+set sidebar_indent_string = '  '
+ 
+<emphasis role="comment"># Make the Sidebar only display mailboxes that contain new, or flagged,
+# mail.</emphasis>
+set sidebar_new_mail_only = no
+ 
+<emphasis role="comment"># Any mailboxes that are whitelisted will always be visible, even if the
+# sidebar_new_mail_only option is enabled.</emphasis>
+sidebar_whitelist '/home/user/mailbox1'
+sidebar_whitelist '/home/user/mailbox2'
+ 
+<emphasis role="comment"># When searching for mailboxes containing new mail, should the search wrap
+# around when it reaches the end of the list?</emphasis>
+set sidebar_next_new_wrap = no
+ 
+<emphasis role="comment"># Show the Sidebar on the right-hand side of the screen</emphasis>
+set sidebar_on_right = no
+ 
+<emphasis role="comment"># The character to use as the divider between the Sidebar and the other Mutt
+# panels.
+# Note: Only the first character of this string is used.</emphasis>
+set sidebar_divider_char = '|'
+ 
+<emphasis role="comment"># Display the Sidebar mailboxes using this format string.</emphasis>
+set sidebar_format = '%B%*  %n'
+ 
+<emphasis role="comment"># If you want to display more information, this is a useful format:</emphasis>
+set mail_check_stats
+set sidebar_format = '%B%?F? [%F]?%* %?N?%N/?%S'
+ 
+<emphasis role="comment"># Sort the mailboxes in the Sidebar using this method:
+#       count    - total number of messages
+#       flagged  - number of flagged messages
+#       new      - number of new messages
+#       path     - mailbox path
+#       unsorted - order of the mailboxes command</emphasis>
+set sidebar_sort_method = 'unsorted'
+ 
+<emphasis role="comment"># --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+ 
+# Move the highlight to the previous mailbox</emphasis>
+bind index,pager \Cp sidebar-prev
+ 
+<emphasis role="comment"># Move the highlight to the next mailbox</emphasis>
+bind index,pager \Cn sidebar-next
+ 
+<emphasis role="comment"># Open the highlighted mailbox</emphasis>
+bind index,pager \Co sidebar-open
+ 
+<emphasis role="comment"># Move the highlight to the previous page
+# This is useful if you have a LOT of mailboxes.</emphasis>
+bind index,pager &lt;F3&gt; sidebar-page-up
+ 
+<emphasis role="comment"># Move the highlight to the next page
+# This is useful if you have a LOT of mailboxes.</emphasis>
+bind index,pager &lt;F4&gt; sidebar-page-down
+ 
+<emphasis role="comment"># Move the highlight to the previous mailbox containing new, or flagged,
+# mail.</emphasis>
+bind index,pager &lt;F5&gt; sidebar-prev-new
+ 
+<emphasis role="comment"># Move the highlight to the next mailbox containing new, or flagged, mail.</emphasis>
+bind index,pager &lt;F6&gt; sidebar-next-new
+ 
+<emphasis role="comment"># Toggle the visibility of the Sidebar.</emphasis>
+bind index,pager B sidebar-toggle-visible
+ 
+<emphasis role="comment"># --------------------------------------------------------------------------
+# COLORS - some unpleasant examples are given
+# --------------------------------------------------------------------------
+# Note: All color operations are of the form:
+#       color OBJECT FOREGROUND BACKGROUND
+ 
+# Color of the current, open, mailbox
+# Note: This is a general Mutt option which colors all selected items.</emphasis>
+color indicator cyan black
+ 
+<emphasis role="comment"># Color of the highlighted, but not open, mailbox.</emphasis>
+color sidebar_highlight black color8
+ 
+<emphasis role="comment"># Color of the divider separating the Sidebar from Mutt panels</emphasis>
+color sidebar_divider color8 black
+ 
+<emphasis role="comment"># Color to give mailboxes containing flagged mail</emphasis>
+color sidebar_flagged red black
+ 
+<emphasis role="comment"># Color to give mailboxes containing new mail</emphasis>
+color sidebar_new green black
+ 
+<emphasis role="comment"># --------------------------------------------------------------------------
+ 
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="sidebar-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><link linkend="regexp">Regular Expressions</link></para></listitem>
+      <listitem><para><link linkend="patterns">Patterns</link></para></listitem>
+      <listitem><para><link linkend="color">Color command</link></para></listitem>
+      <listitem><para><link linkend="notmuch">notmuch patch</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="sidebar-known-bugs">
+    <title>Known Bugs</title>
+    <para>
+      None
+    </para>
+  </sect2>
+
+  <sect2 id="sidebar-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Justin Hibbits <email>jrh29@po.cwru.edu</email></para></listitem>
+    <listitem><para>Thomer M. Gil <email>mutt@thomer.com</email></para></listitem>
+    <listitem><para>David Sterba <email>dsterba@suse.cz</email></para></listitem>
+    <listitem><para>Evgeni Golov <email>evgeni@debian.org</email></para></listitem>
+    <listitem><para>Fabian Groffen <email>grobian@gentoo.org</email></para></listitem>
+    <listitem><para>Jason DeTiberus <email>jdetiber@redhat.com</email></para></listitem>
+    <listitem><para>Stefan Assmann <email>sassmann@kpanic.de</email></para></listitem>
+    <listitem><para>Steve Kemp <email>steve@steve.org.uk</email></para></listitem>
+    <listitem><para>Terry Chan <email>tchan@lunar-linux.org</email></para></listitem>
+    <listitem><para>Tyler Earnest <email>tylere@rne.st</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="skip-quoted-patch">
+  <title>Skip-Quoted Patch</title>
+  <subtitle>Leave some context visible</subtitle>
+
+  <sect2 id="skip-quoted-patch2">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>skip-quoted</quote>, look for
+      <quote>patch-skip-quoted</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="skip-quoted-intro">
+    <title>Introduction</title>
+
+    <para>
+      When viewing an email, the
+      <literal>&lt;skip-to-quoted&gt;</literal> function (by default the
+      <literal>S</literal> key) will scroll past any quoted text.
+      Sometimes, a little context is useful.
+    </para>
+
+    <para>
+      By setting the <literal>$skip_quoted_offset</literal> variable, you
+      can select how much of the quoted text is left visible.
+    </para>
+  </sect2>
+
+  <sect2 id="skip-quoted-variables">
+    <title>Variables</title>
+    <table id="table-skip-quoted-variables">
+      <title>Skip-Quoted Variables</title>
       <tgroup cols="3">
-	<thead>
-	  <row>
-	    <entry>Name</entry>
-	    <entry>Default Color</entry>
-	    <entry>Description</entry>
-	  </row>
-	</thead>
-	<tbody>
-	  <row>
-	    <entry><literal>sidebar_divider</literal></entry>
-	    <entry>default</entry>
-	    <entry>The dividing line between the Sidebar and the Index/Pager panels</entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_flagged</literal></entry>
-	    <entry>default</entry>
-	    <entry>Mailboxes containing flagged mail</entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_highlight</literal></entry>
-	    <entry>underline</entry>
-	    <entry>Cursor to select a mailbox</entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_indicator</literal></entry>
-	    <entry>mutt <literal>indicator</literal></entry>
-	    <entry>The mailbox open in the Index panel</entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_new</literal></entry>
-	    <entry>default</entry>
-	    <entry>Mailboxes containing new mail</entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_spoolfile</literal></entry>
-	    <entry>default</entry>
-	    <entry>Mailbox that receives incoming mail</entry>
-	  </row>
-	</tbody>
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>skip_quoted_offset</literal></entry>
+            <entry>number</entry>
+            <entry>0</entry>
+          </row>
+        </tbody>
       </tgroup>
     </table>
+  </sect2>
+
+  <sect2 id="skip-quoted-muttrc">
+    <title>Muttrc</title>
+
+<screen>
+<emphasis role="comment"># Example Mutt config file for the 'skip-quoted' patch.
+ 
+# The 'S' (skip-quoted) command scrolls the pager past the quoted text (usually
+# indented with '&gt; '.  Setting 'skip_quoted_offset' leaves some lines of quoted
+# text on screen for context.
+ 
+# Show three quoted lines before the reply</emphasis>
+set skip_quoted_offset = 3
+ 
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="skip-quoted-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="skip-quoted-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="skip-quoted-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>David Sterba <email>dsterba@suse.cz</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="smime-encrypt-self-patch">
+  <title>smime-encrypt-self Patch</title>
+  <subtitle>Save an self-encrypted copy of emails</subtitle>
+
+  <sect2 id="smime-encrypt-self-patch2">
+    <title>Patch</title>
 
     <para>
-    If the <literal>sidebar_indicator</literal> color isn't set, then the default Mutt
-    indicator color will be used (the color used in the index panel).
+      To check if Mutt supports <quote>smime-encrypt-self</quote>, look for
+      <quote>patch-smime-encrypt-self</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
     </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
   </sect2>
 
-  <sect2 id="sidebar-sort">
-    <title>Sort</title>
+  <sect2 id="smime-encrypt-self-intro">
+    <title>Introduction</title>
 
-    <table id="table-sidebar-sort">
-      <title>Sidebar Sort</title>
-      <tgroup cols="2">
-	<thead>
-	  <row>
-	    <entry>Sort</entry>
-	    <entry>Description</entry>
-	  </row>
-	</thead>
-	<tbody>
-	  <row>
-	    <entry><literal>alpha</literal></entry>
-	    <entry>Alphabetically by path</entry>
-	  </row>
-	  <row>
-	    <entry><literal>count</literal></entry>
-	    <entry>Total number of messages</entry>
-	  </row>
-	  <row>
-	    <entry><literal>flagged</literal></entry>
-	    <entry>Number of flagged messages</entry>
-	  </row>
-	  <row>
-	    <entry><literal>name</literal></entry>
-	    <entry>Alphabetically by path</entry>
-	  </row>
-	  <row>
-	    <entry><literal>new</literal></entry>
-	    <entry>Number of new messages</entry>
-	  </row>
-	  <row>
-	    <entry><literal>path</literal></entry>
-	    <entry>Alphabetically by path</entry>
-	  </row>
-	  <row>
-	    <entry><literal>unsorted</literal></entry>
-	    <entry>Do not resort the paths</entry>
-	  </row>
-	</tbody>
+    <para>
+      Once you encrypt an email to someone you cannot read it.  This is good
+      for security, but bad for record-keeping.  If you wanted to keep a copy
+      of an encrypted email you could set <link linkend="fcc-clear">$fcc_clear</link>.
+    </para>
+
+    <para>
+      A better option is to enable
+      <link linkend="smime-encrypt-self">$smime_encrypt_self</link>, then set
+      <link linkend="smime-default-key">$smime_default_key</link> to your
+      personal S/MIME key id.
+    </para>
+
+<screen>
+set smime_encrypt_self = yes
+set smime_default_key  = bb345e23.0
+</screen>
+
+  </sect2>
+
+  <sect2 id="smime-encrypt-self-variables">
+    <title>Variables</title>
+
+    <table id="table-smime-encrypt-self-variables">
+      <title>smime-encrypt-self Variables</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>smime_encrypt_self</literal></entry>
+            <entry>quad</entry>
+            <entry>No</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="smime-encrypt-self-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># This is a complete list of smime-encrypt-self-related configuration.
+ 
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+ 
+# Save a copy of outgoing email, encrypted to yourself</emphasis>
+set smime_encrypt_self = "no"
+ 
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="smime-encrypt-self-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="smime-encrypt-self-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="smime-encrypt-self-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Omen Wild <email>omen@mandarb.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="status-color">
+  <title>Status Color Patch</title>
+  <subtitle>Custom rules for theming the status bar</subtitle>
+
+  <sect2 id="status-color-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>Status Color</quote>, look for
+      <quote>patch-status-color</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="status-color-intro">
+    <title>Introduction</title>
+
+        <para>
+    The <quote>status-color</quote> patch allows you to theme different
+    parts of the status bar (also when it's used by the index).
+        </para>
+
+        <para>
+    Unlike normal color commands, <literal>color status</literal> can now
+    take up to 2 extra parameters (regex, num).
+        </para>
+  </sect2>
+
+  <sect2 id="status-color-commands">
+    <title>Commands</title>
+    <cmdsynopsis>
+      <command>color</command>
+      <arg choice="plain">
+        <option>status</option>
+      </arg>
+      <arg choice="plain">
+        <replaceable class="parameter">foreground</replaceable>
+      </arg>
+      <arg choice="plain">
+        <replaceable class="parameter">background</replaceable>
+      </arg>
+      <group choice="opt">
+        <arg choice="plain">
+          <replaceable class="parameter">regex</replaceable>
+        </arg>
+        <group choice="opt">
+          <arg choice="plain">
+            <replaceable class="parameter">num</replaceable>
+          </arg>
+        </group>
+      </group>
+    </cmdsynopsis>
+
+    <para>
+      With zero parameters, Mutt will set the default color for the entire
+      status bar.
+    </para>
+
+    <para>
+      With one parameter, Mutt will only color the parts matching the
+      regex.
+    </para>
+
+    <para>
+      With two parameters, Mutt will only color the num'th sub-match of
+      the regex.
+    </para>
+  </sect2>
+
+  <sect2 id="status-color-colors">
+    <title>Colors</title>
+
+    <table id="table-status-color-colors">
+      <title>Status Colors</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Default Color</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>status</entry>
+            <entry><literal>reverse</literal></entry>
+            <entry>Status bar</entry>
+          </row>
+        </tbody>
       </tgroup>
     </table>
   </sect2>
 
+  <sect2 id="status-color-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example Mutt config file for the 'status-color' patch.
+ 
+# The 'status-color' patch allows you to theme different parts of
+# the status bar (also when it's used by the index).
+ 
+# For the examples below, set some defaults</emphasis>
+set status_format='-%r-Mutt: %f [Msgs:%?M?%M/?%m%?n? New:%n?%?o? Old:%o?%?d? Del:%d?%?F? Flag:%F?%?t? Tag:%t?%?p? Post:%p?%?b? Inc:%b?%?l? %l?]---(%s/%S)-%&gt;-(%P)---'
+set index_format='%4C %Z %{%b %d} %-15.15L (%?l?%4l&amp;%4c?) %s'
+set sort=threads
+set sort_aux=last-date-received
+ 
+<emphasis role="comment"># 'status color' can take up to 2 extra parameters
+ 
+# color status foreground background [ regex [ num ]]
+ 
+# 0 extra parameters
+# Set the default color for the entire status line</emphasis>
+color status blue white
+ 
+<emphasis role="comment"># 1 extra parameter
+# Set the color for a matching pattern
+# color status foreground background regexp
+ 
+# Highlight New, Deleted, or Flagged emails</emphasis>
+color status brightred white '(New|Del|Flag):[0-9]+'
+ 
+<emphasis role="comment"># Highlight mailbox ordering if it's different from the default
+# First, highlight anything (*/*)</emphasis>
+color status brightred default '\([^)]+/[^)]+\)'
+ 
+<emphasis role="comment"># Then override the color for one specific case</emphasis>
+color status default   default '\(threads/last-date-received\)'
+ 
+<emphasis role="comment"># 2 extra parameters
+# Set the color for the nth submatch of a pattern
+# color status foreground background regexp num
+ 
+# Highlight the contents of the []s but not the [] themselves</emphasis>
+color status red default '\[([^]]+)\]' 1
+ 
+<emphasis role="comment"># The '1' refers to the first regex submatch, which is the inner
+# part in ()s
+ 
+# Highlight the mailbox</emphasis>
+color status brightwhite default 'Mutt: ([^ ]+)' 1
+ 
+<emphasis role="comment"># Search for 'Mutt: ' but only highlight what comes after it
+ 
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
 
-  <sect2 id="sidebar-see-also">
+  <sect2 id="status-color-see-also">
     <title>See Also</title>
 
     <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="compile-time-features">Compile-Time Features</link></para></listitem>
       <listitem><para><link linkend="regexp">Regular Expressions</link></para></listitem>
       <listitem><para><link linkend="patterns">Patterns</link></para></listitem>
+      <listitem><para><link linkend="index-color">index-color patch</link></para></listitem>
       <listitem><para><link linkend="color">Color command</link></para></listitem>
     </itemizedlist>
   </sect2>
+
+  <sect2 id="status-color-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="status-color-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>David Sterba <email>dsterba@suse.cz</email></para></listitem>
+    <listitem><para>Thomas Glanzmann <email>thomas@glanzmann.de</email></para></listitem>
+    <listitem><para>Kirill A. Shutemov <email>kirill@shutemov.name</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="timeout-hook">
+  <title>Timeout Patch</title>
+  <subtitle>Run a command periodically</subtitle>
+
+  <sect2 id="timeout-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>timeout</quote>, look for
+      <quote>patch-timeout</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="timeout-intro">
+    <title>Introduction</title>
+
+    <para>
+      This patch implements a new hook that is called periodically when Mutt
+      checks for new mail. This hook is called every <literal>$timeout</literal> seconds.
+    </para>
+  </sect2>
+
+  <sect2 id="timeout-commands">
+    <title>Commands</title>
+    <cmdsynopsis>
+      <command>timeout-hook</command>
+      <arg choice="plain">
+        <replaceable class="parameter">.</replaceable>
+      </arg>
+      <arg choice="plain">
+        <replaceable class="parameter">MUTT-COMMAND</replaceable>
+      </arg>
+    </cmdsynopsis>
+  </sect2>
+
+  <sect2 id="timeout-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># This is a complete list of timeout configuration.
+
+# --------------------------------------------------------------------------
+# COMMANDS - shown with an example arguments
+# --------------------------------------------------------------------------
+
+# After $timeout seconds of inactivity, run this mutt command</emphasis>
+timeout-hook . 'exec sync-mailbox'
+
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="timeout-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="timeout">$timeout</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="timeout-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="timeout-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Armin Wolfermann <email>armin@wolfermann.org</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="tls-sni">
+  <title>TLS-SNI Patch</title>
+  <subtitle>Negotiate with a server for a TSL/SSL certificate</subtitle>
+
+  <sect2 id="tls-sni-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>TLS-SNI</quote>, look for
+      <quote>patch-tls-sni</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+      <listitem><para>OpenSSL</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="tls-sni-intro">
+    <title>Introduction</title>
+
+    <para>
+    The <quote>TLS-SNI</quote> patch adds support for TLS virtual hosting.
+    If your mail server doesn't support this everything will still work
+    normally.
+    </para>
+
+    <para>
+    TLS supports sending the expected server hostname during the
+    handshake, via the SNI extension.  This can be used to select a
+    server certificate to issue to the client, permitting
+    virtual-hosting without requiring multiple IP addresses.
+    </para>
+
+    <para>
+    This has been tested against Exim 4.80, which optionally logs SNI
+    and can perform vhosting.
+    </para>
+
+        <para>
+    To verify TLS SNI support by a server, you can use:
+        </para>
+
+<screen>
+openssl s_client -host &lt;imap server&gt; -port &lt;port&gt; -tls1 -servername &lt;imap server&gt;
+</screen>
+  </sect2>
+
+  <sect2 id="tls-sni-muttrc">
+    <title>Muttrc</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="tls-sni-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="tls-sni-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="tls-sni-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Jeremy Katz <email>katzj@linuxpower.org</email></para></listitem>
+    <listitem><para>Phil Pennock <email>mutt-dev@spodhuis.demon.nl</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
 </sect1>
 
 </chapter>
@@ -8953,6 +13700,18 @@ <sect1 id="commands">
 
 <listitem>
 <cmdsynopsis>
+<command><link linkend="append-hook">append-hook</link></command>
+<arg choice="plain">
+<replaceable class="parameter">pattern</replaceable>
+</arg>
+<arg choice="plain">
+<replaceable class="parameter">shell-command</replaceable>
+</arg>
+</cmdsynopsis>
+</listitem>
+
+<listitem>
+<cmdsynopsis>
 <command><link linkend="auto-view">auto_view</link></command>
 <arg choice="plain">
 <replaceable>mimetype</replaceable>
@@ -9014,6 +13773,18 @@ <sect1 id="commands">
 
 <listitem>
 <cmdsynopsis>
+<command><link linkend="close-hook">close-hook</link></command>
+<arg choice="plain">
+<replaceable class="parameter">pattern</replaceable>
+</arg>
+<arg choice="plain">
+<replaceable class="parameter">shell-command</replaceable>
+</arg>
+</cmdsynopsis>
+</listitem>
+
+<listitem>
+<cmdsynopsis>
 <command><link linkend="color">color</link></command>
 <arg choice="plain">
 <replaceable class="parameter">object</replaceable>
@@ -9083,6 +13854,18 @@ <sect1 id="commands">
 
 <listitem>
 <cmdsynopsis>
+<command><link linkend="open-hook">open-hook</link></command>
+<arg choice="plain">
+<replaceable class="parameter">pattern</replaceable>
+</arg>
+<arg choice="plain">
+<replaceable class="parameter">shell-command</replaceable>
+</arg>
+</cmdsynopsis>
+</listitem>
+
+<listitem>
+<cmdsynopsis>
 <command><link linkend="crypt-hook">crypt-hook</link></command>
 <arg choice="plain">
 <replaceable class="parameter">regexp</replaceable>
@@ -9204,6 +13987,18 @@ <sect1 id="commands">
 
 <listitem>
 <cmdsynopsis>
+<command>ifdef</command>
+<arg choice="plain">
+<replaceable class="parameter">item</replaceable>
+</arg>
+<arg choice="plain">
+<replaceable class="parameter">"config-command [args]"</replaceable>
+</arg>
+</cmdsynopsis>
+</listitem>
+
+<listitem>
+<cmdsynopsis>
 <command><link linkend="ignore">ignore</link></command>
 <arg choice="plain">
 <replaceable class="parameter">pattern</replaceable>
diff --git a/doc/mutt.css b/doc/mutt.css
index 5a37b3c..d7ff017 100644
--- a/doc/mutt.css
+++ b/doc/mutt.css
@@ -9,17 +9,24 @@ div.table-contents table td, div.informaltable td, div.table-contents table th,
 div.table-contents table th, div.informaltable table th {
     font-family:sans-serif;
     background:#d0d0d0;
-    font-weight:normal;
+    font-weight:bold;
     vertical-align:top;
 }
-div.cmdsynopsis { border-left:1px solid #707070; padding-left:5px; }
+div.cmdsynopsis { border-left:1px solid #707070; padding-left: 1em; }
 li div.cmdsynopsis { border-left:none; padding-left:0px; }
-pre.screen, div.note { background:#f0f0f0; border:1px solid #c0c0c0; padding:5px; margin-left:2%; margin-right:2%; }
+li p { margin: 0; }
+pre.screen, div.note { border:1px solid #c0c0c0; margin-left:2%; margin-right:2%; }
+pre.screen { color: #ffffff; background:#000000; padding: 0.5em; }
+div.note { background:#ffff80; padding: 0.5em; }
 div.example p.title { margin-left:2%; }
 div.note h3 { font-size:small; font-style:italic; font-variant: small-caps; }
 div.note h3:after { content: ":" }
 div.note { margin-bottom: 5px; }
-.command { font-family: monospace; font-weight: normal; }
+div.literallayout, .command { font-family: monospace; font-weight: normal; }
 .command strong { font-weight: normal; }
 tr { vertical-align: top; }
-.comment { color:#707070; }
+.comment { color:#00c000; }
+code.literal { background: #f0f0f0; color: #000000; }
+span.indicator { background: #000060; color: #ffffff; }
+span.highlight { background: #404040; color: #ffffff; }
+span.reverse { background: #ffffff; color: #000000; }
diff --git a/doc/mutt.man b/doc/mutt.man
index d29294f..b5b7337 100644
--- a/doc/mutt.man
+++ b/doc/mutt.man
@@ -23,8 +23,8 @@ mutt \- The Mutt Mail User Agent
 .SH SYNOPSIS
 .PP
 .B mutt
-[\-nRyzZ]
-[\-e \fIcmd\fP] [\-F \fIfile\fP] [\-m \fItype\fP] [\-f \fIfile\fP]
+[\-GnRyzZ]
+[\-e \fIcmd\fP] [\-F \fIfile\fP] [\-g \fIserver\fP] [\-m \fItype\fP] [\-f \fIfile\fP]
 .PP
 .B mutt 
 [\-Enx] 
@@ -104,6 +104,10 @@ files.
 Specify which mailbox to load.
 .IP "-F \fImuttrc\fP"
 Specify an initialization file to read instead of ~/.muttrc
+.IP "-g \fIserver\fP"
+Start Mutt with a listing of subscribed newsgroups at specified news server.
+.IP "-G"
+Start Mutt with a listing of subscribed newsgroups.
 .IP "-h"
 Display help.
 .IP "-H \fIdraft\fP"
diff --git a/doc/muttbug.man b/doc/muttbug.man
deleted file mode 100644
index 6b71c99..0000000
--- a/doc/muttbug.man
+++ /dev/null
@@ -1,200 +0,0 @@
-.\" -*-nroff-*-
-.\"
-.\"
-.\"     Copyright (C) 1996-2000 Thomas Roessler <roessler@does-not-exist.org>
-.\" 
-.\"     This program is free software; you can redistribute it and/or modify
-.\"     it under the terms of the GNU General Public License as published by
-.\"     the Free Software Foundation; either version 2 of the License, or
-.\"     (at your option) any later version.
-.\" 
-.\"     This program is distributed in the hope that it will be useful,
-.\"     but WITHOUT ANY WARRANTY; without even the implied warranty of
-.\"     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-.\"     GNU General Public License for more details.
-.\" 
-.\"     You should have received a copy of the GNU General Public License
-.\"     along with this program; if not, write to the Free Software
-.\"     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
-.\"
-.TH flea 1 "July 2000" Unix "User Manuals"
-.SH NAME
-flea \- Report a bug (or rather a flea) in mutt.
-.SH SYNOPSIS
-.PP
-.B flea
-.SH DESCRIPTION
-.PP
-.B flea
-is a shell script which helps you to submit a bug report against the 
-.BR mutt (1)
-mail user agent.
-.PP
-If you invoke 
-.BR flea , 
-you'll first be prompted for a short
-description of the problem you experience.  This will be used as the
-bug report's subject line, so it should be concise, but informative.
-.PP
-You are then asked to assign an initial severity level to the
-problem you observe; 
-.B flea
-will give you a description which severity level is appropriate or
-not.
-.PP
-Then, you are asked for the location of a core dump (normally named
-.BR core )
-which may have been left over by a crash of your 
-.BR mutt (1).
-You can just type \(lqno\(rq here, or you can enter the path leading 
-to a core dump.
-.B flea
-will try to use either
-.BR sdb (1),
-.BR dbx (1),
-or
-.BR gdb (1)
-to extract some information from this core dump which may be helpful
-to developers in order to determine the reason for the crash.
-.PP
-Finally, you are asked whether or not you want to include personal
-and system 
-.BR mutt (1)
-configuration files with the bug report.  If at all possible, we
-urge you to answer these questions with \(lqyes\(rq, since a
-reference configuration makes it incredibly easier to track down a
-problem.
-.PP
-If you are using Debian GNU/Linux,
-.B flea
-will now check whether or not 
-.B mutt
-has been installed as a Debian
-package on your system, and suggest to file the bug against the
-.BR mutt (1)
-and Debian bug tracking systems.  This option was added since the 
-.BR mutt (1)
-project uses another instantiation of the Debian bug tracking
-system, so submitting bugs against both systems in one pass is
-simple.
-.PP
-You are then dropped into your favorite editor as determined by the 
-.B EDITOR
-and
-.B VISUAL
-environment variables.  
-.PP
-Please give us details about the problem in the empty space below
-the line reading \(lqPlease type your report below this line\(rq.
-We are most interested in precise information on what symptoms you
-observe and what steps may be used to reproduce the bug.  Chances
-are that problems which can easily be reproduced will be fixed
-quickly.  So please take some time when filling out this part of the
-template.
-.PP
-The remainder of the template contains various kinds of information
-gathered from your system, including output of the
-.BR uname (1)
-command, output from
-.BR mutt (1)
-itself, and your system's 
-.BR mutt (1)
-configuration files.  You may wish to browse through this part of
-the bug report form in order to avoid leaking confidential
-information to the public.
-.PP
-If you leave the editor, 
-.B flea
-will give you the option to review, re-edit, submit, or abandon your
-bug report.  If you decide to submit it, a mail message containing
-your report will be sent to <fleas@mutt.org>.  You'll receive a
-copy of this message.
-.PP
-While your bug report is being processed by the bug tracking system,
-you will receive various e-mail messages from the bug tracking
-system informing you about what's going on: Once your bug report has
-been entered into the bug tracking system, it will be assigned a
-unique serial number about which you are informed via e-mail.  If
-you wish to submit additional information about the bug, you can
-just send it to the address
-.BR fleas@mutt.org
-with #\fIserial\fP in the subject.
-.PP
-Later, you will most likely receive questions from the developers
-about the problem you observed, and you will eventually be informed
-that your bug report has been closed.  This means that the bug has
-been fixed at least in the
-.BR hg (1)
-repository.  If the answers you receive don't satisfy you, don't
-hesitate to contact the developers directly under
-.BR mutt-dev@mutt.org.
-.PP
-You can also browse your bug report and all additional information
-and replies connected to it using the bug tracking system's Web
-interface under the following URL:
-http://bugs.mutt.org/
-.SH
-ENVIRONMENT
-.PP
-.B flea
-will use the following environment variables:
-.IP "EMAIL"
-Your electronic mail address.  Will be used to set the bug report's
-From header, and to send you a copy of the report.
-.IP "LOGNAME"
-Your login name.  If the
-.B EMAIL
-environment variable isn't set, this will be used instead to send
-you a copy of the report.  Setting the sender will be left to 
-.BR sendmail (1)
-on your system.
-.IP "REPLYTO"
-If set, the bug report will contain a Reply-To header with the
-e-mail address contained in this environment variable.
-.IP "ORGANIZATION"
-If set, the bug report will contain an Organization header with the
-contents of this environment variable.
-.IP "PAGER"
-If set, this environment variable will be expected to contain the
-path to your favorite pager for viewing the bug report.  If unset, 
-.BR more (1)
-will be used.
-.IP "VISUAL"
-If set, this environment variable will be expected to contain the
-path to your favorite visual editor.
-.IP "EDITOR"
-If set, this environment variable will be expected to contain the
-path to your favorite editor.  This variable is examined if and only
-if the 
-.B VISUAL
-environment variable is unset.  If
-.B EDITOR
-is unset, 
-.BR vi (1)
-will be used to edit the bug report.
-.SH
-FILES
-.PP
-.IP "core"
-If present, this file may contain a post-mortem memory dump of mutt.
-It will be inspected using the debugger installed on your system.
-.SH 
-SEE ALSO
-.PP
-.BR dbx (1),
-.BR gdb (1),
-.BR lynx (1),
-.BR mutt (1),
-.BR muttrc (5),
-.BR sdb (1),
-.BR sendmail (1),
-.BR uname (1),
-.BR vi (1)
-.PP
-The mutt bug tracking system: http://bugs.mutt.org/
-.SH
-AUTHOR
-.PP
-.B flea
-and this manual page were written by Thomas Roessler
-<roessler@does-not-exist.org>.
diff --git a/doc/muttrc.compress b/doc/muttrc.compress
new file mode 100644
index 0000000..ab6fe3c
--- /dev/null
+++ b/doc/muttrc.compress
@@ -0,0 +1,38 @@
+# Example Mutt config file for the 'compressed folders' feature.
+
+# This feature adds three hooks to Mutt which allow it to
+# work with compressed, or encrypted, mailboxes.
+
+# The hooks are of the form:
+#       open-hook   regexp "shell-command"
+#       close-hook  regexp "shell-command"
+#       append-hook regexp "shell-command"
+
+# The 'append-hook' is optional.
+
+# Hander for gzip compressed mailboxes
+open-hook   '\.gz$'  "gzip -cd  '%f' >  '%t'"
+close-hook  '\.gz$'  "gzip -c   '%t' >  '%f'"
+append-hook '\.gz$'  "gzip -c   '%t' >> '%f'"
+
+# Hander for bzip2 compressed mailboxes
+open-hook   '\.bz2$' "bzip2 -cd '%f' >  '%t'"
+close-hook  '\.bz2$' "bzip2 -c  '%t' >  '%f'"
+append-hook '\.bz2$' "bzip2 -c  '%t' >> '%f'"
+
+# Hander for xz compressed mailboxes
+open-hook   '\.xz$'  "xz    -cd '%f' >  '%t'"
+close-hook  '\.xz$'  "xz    -c  '%t' >  '%f'"
+append-hook '\.xz$'  "xz    -c  '%t' >> '%f'"
+
+# Hander for pgp encrypted mailboxes
+# PGP does not support appending to an encrypted file
+open-hook   '\.pgp$' "pgp -f < '%f' > '%t'"
+close-hook  '\.pgp$' "pgp -fe YourPgpUserIdOrKeyId < '%t' > '%f'"
+
+# Hander for gpg encrypted mailboxes
+# gpg does not support appending to an encrypted file
+open-hook   '\.gpg$' "gpg --decrypt < '%f' > '%t'"
+close-hook  '\.gpg$' "gpg --encrypt --recipient YourGpgUserIdOrKeyId < '%t' > '%f'"
+
+# vim: syntax=muttrc
diff --git a/doc/muttrc.cond-date b/doc/muttrc.cond-date
new file mode 100644
index 0000000..30c28b9
--- /dev/null
+++ b/doc/muttrc.cond-date
@@ -0,0 +1,16 @@
+# Example Mutt config file for the 'cond-date' feature.
+#
+# The default index_format is:
+#       '%4C %Z %{%b %d} %-15.15L (%?l?%4l&%4c?) %s'
+#
+# We replace the date field '%{%b %d}', giving:
+set index_format='%4C %Z %<[y?%<[m?%<[d?%[%H:%M ]&%[%a %d]>&%[%b %d]>&%[%m/%y ]> %-15.15L (%?l?%4l&%4c?) %s'
+
+# Test  Date Range  Format String  Example
+# --------------------------------------------
+# %[d   Today       %[%H:%M ]      12:34
+# %[m   This month  %[%a %d]       Thu 12
+# %[y   This year   %[%b %d]       Dec 10
+# -     Older       %[%m/%y ]      06/15
+
+# vim: syntax=muttrc
diff --git a/doc/muttrc.ifdef b/doc/muttrc.ifdef
new file mode 100644
index 0000000..f618d5d
--- /dev/null
+++ b/doc/muttrc.ifdef
@@ -0,0 +1,32 @@
+# Example Mutt config file for the 'ifdef' feature.
+
+# This feature introduces three useful commands which allow you to share
+# one config file between versions of Mutt that may have different
+# features compiled in.
+
+#	ifdef  symbol config-command [args...]
+#	ifndef symbol config-command [args...]
+#	finish                                
+
+# The 'ifdef' command tests whether Mutt understands the name of
+# a variable, function, command or compile-time symbol.
+# If it does, then it executes a config command.
+
+# The 'ifndef' command tests whether a symbol does NOT exist.
+
+# The 'finish' command tells Mutt to stop reading current config file.
+
+# If the 'trash' variable exists, set it.
+ifdef trash 'set trash=~/Mail/trash'
+
+# If the 'tag-pattern' function exists, bind a key to it.
+ifdef tag-pattern 'bind index <F6> tag-pattern'
+
+# If the 'imap-fetch-mail' command exists, read my IMAP config.
+ifdef imap-fetch-mail 'source ~/.mutt/imap.rc'
+
+# If the compile-time symbol 'USE_SIDEBAR' does not exist, then
+# stop reading the current config file.
+ifndef USE_SIDEBAR finish
+
+# vim: syntax=muttrc
diff --git a/doc/muttrc.index-color b/doc/muttrc.index-color
new file mode 100644
index 0000000..3ec91f5
--- /dev/null
+++ b/doc/muttrc.index-color
@@ -0,0 +1,37 @@
+# Example Mutt config file for the 'index-color' feature.
+
+# Entire index line
+color index white black '.*'
+
+# Author name, %A %a %F %L %n
+
+# Give the author column a dark grey background
+color index_author default color234 '.*'
+
+# Highlight a particular from (~f)
+color index_author brightyellow color234 '~fRay Charles'
+
+# Message flags, %S %Z
+# Highlight the flags for flagged (~F) emails
+color index_flags default red '~F'
+
+# Subject, %s
+# Look for a particular subject (~s)
+color index_subject brightcyan default '~s\(closes #[0-9]+\)'
+
+# Number of messages in a collapsed thread, %M
+color index_collapsed default brightblue
+
+# Date field
+color index_date green default
+
+# Message label, %y %Y
+color index_label default brightgreen
+
+# Message number, %C
+color index_number red default
+
+# Message size, %c %l
+color index_size cyan default
+
+# vim: syntax=muttrc
diff --git a/doc/muttrc.initials b/doc/muttrc.initials
new file mode 100644
index 0000000..644c1b7
--- /dev/null
+++ b/doc/muttrc.initials
@@ -0,0 +1,27 @@
+# Example Mutt config file for the 'initials' patch.
+
+# The 'initials' patch has no config of its own.
+# It adds an expando for an author's initials,
+# which can be used in the 'index_format' variable.
+
+# The default 'index_format' is:
+set index_format='%4C %Z %{%b %d} %-15.15L (%?l?%4l&%4c?) %s'
+
+# Where %L represents the author/recipient
+
+# This might look like:
+#       1   + Nov 17 David Bowie   Changesbowie    ( 689)
+#       2   ! Nov 17 Stevie Nicks  Rumours         ( 555)
+#       3   + Nov 16 Jimi Hendrix  Voodoo Child    ( 263)
+#       4   + Nov 16 Debbie Harry  Parallel Lines  ( 540)
+
+# Using the %I expando:
+set index_format='%4C %Z %{%b %d} %I (%?l?%4l&%4c?) %s'
+
+# This might look like:
+#       1   + Nov 17 DB Changesbowie    ( 689)
+#       2   ! Nov 17 SN Rumours         ( 555)
+#       3   + Nov 16 JH Voodoo Child    ( 263)
+#       4   + Nov 16 DH Parallel Lines  ( 540)
+
+# vim: syntax=muttrc
diff --git a/doc/muttrc.keywords b/doc/muttrc.keywords
new file mode 100644
index 0000000..5b72d4b
--- /dev/null
+++ b/doc/muttrc.keywords
@@ -0,0 +1,23 @@
+# This is a complete list of keywords-related configuration.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# Should Mutt save the keywords to whatever keyword it came from?
+set keywords_legacy = yes
+
+# Should Mutt use the "Keywords:" header?
+set keywords_standard = no
+
+# How should the keywords be separated?
+set xlabel_delimiter = ""
+
+# --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# Bind 'y' to edit labels/keywords
+bind index,pager y edit-label
+
+# vim: syntax=muttrc
diff --git a/doc/muttrc.limit-current-thread b/doc/muttrc.limit-current-thread
new file mode 100644
index 0000000..5d32cf5
--- /dev/null
+++ b/doc/muttrc.limit-current-thread
@@ -0,0 +1,6 @@
+# Example Mutt config file for the 'limit-current-thread' patch.
+ 
+# Limit view to current thread
+bind index <esc>L limit-current-thread
+ 
+# vim: syntax=muttrc
diff --git a/doc/muttrc.man.head b/doc/muttrc.man.head
index b237c5a..6ab69a7 100644
--- a/doc/muttrc.man.head
+++ b/doc/muttrc.man.head
@@ -358,7 +358,24 @@ You may use multiple
 \fBcrypt-hook\fPs with the same \fIregexp\fP; multiple matching
 \fBcrypt-hook\fPs result in the use of multiple \fIkey-id\fPs for
 a recipient.
-
+.PP
+.nf
+\fBopen-hook\fP \fIregexp\fP "\fIcommand\fP"
+\fBclose-hook\fP \fIregexp\fP "\fIcommand\fP"
+\fBappend-hook\fP \fIregexp\fP "\fIcommand\fP"
+.fi
+.IP
+These commands provide a way to handle compressed folders. The given
+\fBregexp\fP specifies which folders are taken as compressed (e.g.
+"\fI\\\\.gz$\fP"). The commands tell Mutt how to uncompress a folder
+(\fBopen-hook\fP), compress a folder (\fBclose-hook\fP) or append a
+compressed mail to a compressed folder (\fBappend-hook\fP). The
+\fIcommand\fP string is the
+.BR printf (3)
+like format string, and it should accept two parameters: \fB%f\fP,
+which is replaced with the (compressed) folder name, and \fB%t\fP
+which is replaced with the name of the temporary folder to which to
+write.
 .TP
 \fBpush\fP \fIstring\fP
 This command adds the named \fIstring\fP to the keyboard buffer.
diff --git a/doc/muttrc.nested-if b/doc/muttrc.nested-if
new file mode 100644
index 0000000..aee76eb
--- /dev/null
+++ b/doc/muttrc.nested-if
@@ -0,0 +1,24 @@
+# Example Mutt config file for the 'nested-if' feature.
+
+# This patch uses the format: '%<VAR?TRUE&FALSE>' for conditional
+# format strings that can be nested.
+
+# Example 1
+# if a thread is folded
+#       display the number of messages (%M)
+# else if we know how many lines in the message
+#       display lines in message (%l)
+# else display the size of the message in bytes (%c)
+set index_format='%4C %Z %{%b %d} %-25.25n %s%> %<M?%M Msgs &%<l?%l Lines&%c Bytes>>'
+
+# Example 2
+# if a thread is folded
+#       display the number of messages (%M)
+#       display the subject (%s)
+# else if we know how many lines in the message
+#       display lines in message (%l)
+# else
+#       display the size of the message in bytes (%c)
+set index_format='%4C %Z %{%b %d} %-25.25n %<M?[%M] %s&%s%* %<l?%l&%c>>'
+
+# vim: syntax=muttrc
diff --git a/doc/muttrc.new-mail b/doc/muttrc.new-mail
new file mode 100644
index 0000000..3c3ce1f
--- /dev/null
+++ b/doc/muttrc.new-mail
@@ -0,0 +1,18 @@
+# Example Mutt config file for the 'new-mail-command' patch.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# Set the command you want mutt to execute upon the receipt of a new email
+set new_mail_command = ""
+
+# Linux example:
+# set new_command="notify-send --icon='/home/santiago/Pictures/mutt.png' 'New Email in %f' '%n new messages, %u unread.' &"
+
+# OS X example:
+# set new_mail_command="terminal-notifier -title '%v' -subtitle 'New Mail in %f' -message '%n new messages, %u unread.' -activate 'com.apple.Terminal'"
+
+# --------------------------------------------------------------------------
+
+# vim: syntax=muttrc
diff --git a/doc/muttrc.nntp b/doc/muttrc.nntp
new file mode 100644
index 0000000..74bd4e8
--- /dev/null
+++ b/doc/muttrc.nntp
@@ -0,0 +1,94 @@
+# This is a complete list of nntp configuration.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+set ask_follow_up = no
+set ask_x_comment_to = no
+set catchup_newsgroup = ask-yes
+set followup_to_poster = ask-yes
+set group_index_format = '%4C %M%N %5s  %-45.45f %d'
+set inews = ''
+set mime_subject = yes
+set newsgroups_charset = utf-8
+set newsrc = '~/.newsrc'
+set news_cache_dir = '~/.mutt'
+set news_server = ''
+set nntp_authenticators = ''
+set nntp_context = 1000
+set nntp_listgroup = yes
+set nntp_load_description = yes
+set nntp_pass = ''
+set nntp_poll = 60
+set nntp_user = ''
+set post_moderated = ask-yes
+set save_unsubscribed = no
+set show_new_news = yes
+set show_only_unread = no
+set x_comment_to = no
+
+# --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# mark all articles in newsgroup as read
+bind browser,index y catchup
+
+# open a different newsgroup
+bind index,pager i change-newsgroup
+
+# edit the Followup-To field
+bind compose o edit-followup-to
+
+# edit the newsgroups list
+bind compose N edit-newsgroups
+
+# edit the X-Comment-To field
+bind compose x edit-x-comment-to
+
+# followup to newsgroup
+bind attachment,index,pager F followup-message
+
+# post message to newsgroup
+bind index,pager P post-message
+
+# load list of all newsgroups from NNTP server
+bind browser g reload-active
+
+# subscribe to current mbox (IMAP/NNTP only)
+bind browser s subscribe
+
+# subscribe to newsgroups matching a pattern
+bind browser S subscribe-pattern
+
+# mark all articles in newsgroup as unread
+bind browser Y uncatchup
+
+# unsubscribe from current mbox (IMAP/NNTP only)
+bind browser u unsubscribe
+
+# unsubscribe from newsgroups matching a pattern
+bind browser U unsubscribe-pattern
+
+# open a different newsgroup in read only mode
+bind index,pager \ei change-newsgroup-readonly
+
+# forward to newsgroup
+bind attachment,index,pager \eF forward-to-group
+
+# get all children of the current message
+# bind index ??? get-children
+
+# get parent of the current message
+bind index \eG get-parent
+
+# reconstruct thread containing current message
+# bind index ??? reconstruct-thread
+
+# get message with Message-Id
+bind index \CG get-message
+
+# --------------------------------------------------------------------------
+
+# vim: syntax=muttrc
diff --git a/doc/muttrc.notmuch b/doc/muttrc.notmuch
new file mode 100644
index 0000000..07dd71b
--- /dev/null
+++ b/doc/muttrc.notmuch
@@ -0,0 +1,114 @@
+# This is a complete list of notmuch-related configuration.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# This variable specifies notmuch query limit.
+set nm_db_limit = 0
+
+# This variable specifies the default Notmuch database in format:
+# notmuch://<absolute path>
+set nm_default_uri = ""
+
+# The messages tagged with these tags are excluded and not loaded
+# from notmuch DB to mutt unless specified explicitly.
+set nm_exclude_tags = ""
+
+# This variable specifies private notmuch tags which should not be printed
+# on screen (index, pager).
+set nm_hidden_tags = "unread,draft,flagged,passed,replied,attachment,signed,encrypted"
+
+# This option specifies timeout for Notmuch database. Default is 5 seconds.
+set nm_open_timeout = 5
+
+# This variable specifies notmuch query type, supported types: 'threads' and
+# 'messages'.
+set nm_query_type = messages
+
+# Add messages stored to the mutt record (see $record in the mutt docs)
+# also to notmuch DB.
+set nm_record = no
+
+# Tags that should be removed or added to the to the messages stored in the mutt record.
+set nm_record_tags = ""
+
+# This variable specifies notmuch tag which is used for unread messages.
+set nm_unread_tag = unread
+
+# This variable allows you to customize the file browser display for virtual
+# folders to your personal taste.
+set vfolder_format = "%6n(%6N) %f"
+
+# When set, mutt will use the first virtual mailbox (see virtual-mailboxes)
+# as a spoolfile.
+set virtual_spoolfile = no
+
+# --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# open a different virtual folder
+bind index,pager X change-vfolder
+
+# read entire thread of the current message
+bind index,pager + entire-thread
+
+# modify (notmuch) tags
+bind index,pager \` modify-labels
+
+# generate virtual folder from query
+bind index,pager \eX vfolder-from-query
+
+# modify labels and then hide message
+# bind index,pager ??? modify-labels-then-hide
+
+# toggle between mailboxes and virtual mailboxes
+# bind index,pager ??? sidebar-toggle-virtual
+
+# --------------------------------------------------------------------------
+# COMMANDS - shown with an example
+# --------------------------------------------------------------------------
+
+# virtual-mailboxes description notmuch-URI { description notmuch-URI ...}
+# virtual-mailboxes "Climbing" "notmuch://?query=climbing"
+
+# Replace some tags with icons
+# tag-transforms tag transformed-string { tag transformed-string ...}
+# tag-transforms "inbox"   "i"   \
+#                "unread"  "u"   \
+#                "replied" "↻ "  \
+#                "sent"    "➥ "  \
+#                "todo"    "T"   \
+#                "deleted" "DEL" \
+#                "invites" "CAL"
+
+# See README.notmuch for an explanation
+# tag-formats tag format-string { tag format-string ...}
+# tag-formats "inbox"   "GI" \
+#              "unread"  "GU" \
+#              "replied" "GR" \
+#              "sent"    "GS" \
+#              "todo"    "Gt" \
+#              "deleted" "GD" \
+#              "invites" "Gi"
+
+# set index_format='4C %S %[%y.%m.%d] %-18.18n %?GU?%GU& ? %?GR?%GR& ? %?GI?%GI& ? %s'
+
+# --------------------------------------------------------------------------
+# COLORS - some unpleasant examples are given
+# --------------------------------------------------------------------------
+
+# These symbols are added to the index-color patch:
+
+# an individual message tag, %G, uses tag name
+# this symbol uses a pattern
+color index_tag red white "inbox"
+
+# the transformed message tags, %g
+# this symbol does not use a pattern
+color index_tags green default
+
+# --------------------------------------------------------------------------
+
+# vim: syntax=muttrc
diff --git a/doc/muttrc.progress b/doc/muttrc.progress
new file mode 100644
index 0000000..7efe45c
--- /dev/null
+++ b/doc/muttrc.progress
@@ -0,0 +1,10 @@
+# Example Mutt config file for the 'progress' patch.
+
+# The 'progress' patch provides clear visual feedback for
+# slow tasks, such as indexing a large folder over the net.
+
+# Set the color of the progress bar
+# White text on a red background
+color progress white red
+
+# vim: syntax=muttrc
diff --git a/doc/muttrc.quasi-delete b/doc/muttrc.quasi-delete
new file mode 100644
index 0000000..67031ff
--- /dev/null
+++ b/doc/muttrc.quasi-delete
@@ -0,0 +1,7 @@
+# Example Mutt config file for the 'quasi-delete' feature.
+
+# The 'quasi-delete' function marks an email that should be hidden
+# from the index, but NOT deleted.
+bind index,pager Q quasi-delete
+
+# vim: syntax=muttrc
diff --git a/doc/muttrc.sidebar b/doc/muttrc.sidebar
new file mode 100644
index 0000000..1f10ea9
--- /dev/null
+++ b/doc/muttrc.sidebar
@@ -0,0 +1,119 @@
+# This is a complete list of sidebar-related configuration.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# Should the Sidebar be shown?
+set sidebar_visible = no
+
+# How wide should the Sidebar be in screen columns?
+# Note: Some characters, e.g. Chinese, take up two columns each.
+set sidebar_width = 20
+
+# Should the mailbox paths be abbreviated?
+set sidebar_short_path = no
+
+# When abbreviating mailbox path names, use any of these characters as path
+# separators.  Only the part after the last separators will be shown.
+# For file folders '/' is good.  For IMAP folders, often '.' is useful.
+set sidebar_delim_chars = '/.'
+
+# If the mailbox path is abbreviated, should it be indented?
+set sidebar_folder_indent = no
+
+# Indent mailbox paths with this string.
+set sidebar_indent_string = '  '
+
+# Make the Sidebar only display mailboxes that contain new, or flagged,
+# mail.
+set sidebar_new_mail_only = no
+
+# Any mailboxes that are whitelisted will always be visible, even if the
+# sidebar_new_mail_only option is enabled.
+sidebar_whitelist '/home/user/mailbox1'
+sidebar_whitelist '/home/user/mailbox2'
+
+# When searching for mailboxes containing new mail, should the search wrap
+# around when it reaches the end of the list?
+set sidebar_next_new_wrap = no
+
+# Show the Sidebar on the right-hand side of the screen
+set sidebar_on_right = no
+
+# The character to use as the divider between the Sidebar and the other Mutt
+# panels.
+# Note: Only the first character of this string is used.
+set sidebar_divider_char = '|'
+
+# Enable extended buffy mode to calculate total, new, and flagged
+# message counts for each mailbox.
+set mail_check_stats
+
+# Display the Sidebar mailboxes using this format string.
+set sidebar_format = '%B%?F? [%F]?%* %?N?%N/?%S'
+
+# Sort the mailboxes in the Sidebar using this method:
+#       count    - total number of messages
+#       flagged  - number of flagged messages
+#       new      - number of new messages
+#       path     - mailbox path
+#       unsorted - do not sort the mailboxes
+set sidebar_sort_method = 'unsorted'
+
+# --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# Move the highlight to the previous mailbox
+bind index,pager \Cp sidebar-prev
+
+# Move the highlight to the next mailbox
+bind index,pager \Cn sidebar-next
+
+# Open the highlighted mailbox
+bind index,pager \Co sidebar-open
+
+# Move the highlight to the previous page
+# This is useful if you have a LOT of mailboxes.
+bind index,pager <F3> sidebar-page-up
+
+# Move the highlight to the next page
+# This is useful if you have a LOT of mailboxes.
+bind index,pager <F4> sidebar-page-down
+
+# Move the highlight to the previous mailbox containing new, or flagged,
+# mail.
+bind index,pager <F5> sidebar-prev-new
+
+# Move the highlight to the next mailbox containing new, or flagged, mail.
+bind index,pager <F6> sidebar-next-new
+
+# Toggle the visibility of the Sidebar.
+bind index,pager B sidebar-toggle-visible
+
+# --------------------------------------------------------------------------
+# COLORS - some unpleasant examples are given
+# --------------------------------------------------------------------------
+# Note: All color operations are of the form:
+#       color OBJECT FOREGROUND BACKGROUND
+
+# Color of the current, open, mailbox
+# Note: This is a general Mutt option which colors all selected items.
+color indicator cyan black
+
+# Color of the highlighted, but not open, mailbox.
+color sidebar_highlight black color8
+
+# Color of the divider separating the Sidebar from Mutt panels
+color sidebar_divider color8 black
+
+# Color to give mailboxes containing flagged mail
+color sidebar_flagged red black
+
+# Color to give mailboxes containing new mail
+color sidebar_new green black
+
+# --------------------------------------------------------------------------
+
+# vim: syntax=muttrc
diff --git a/doc/muttrc.skip-quoted b/doc/muttrc.skip-quoted
new file mode 100644
index 0000000..cd13ed4
--- /dev/null
+++ b/doc/muttrc.skip-quoted
@@ -0,0 +1,10 @@
+# Example Mutt config file for the 'skip-quoted' patch.
+ 
+# The 'S' (skip-quoted) command scrolls the pager past the quoted text (usually
+# indented with '> '.  Setting 'skip_quoted_offset' leaves some lines of quoted
+# text on screen for context.
+ 
+# Show three quoted lines before the reply
+set skip_quoted_offset = 3
+ 
+# vim: syntax=muttrc
diff --git a/doc/muttrc.smime-encrypt-self b/doc/muttrc.smime-encrypt-self
new file mode 100644
index 0000000..0ef7c48
--- /dev/null
+++ b/doc/muttrc.smime-encrypt-self
@@ -0,0 +1,10 @@
+# This is a complete list of smime-encrypt-self-related configuration.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# Save a copy of outgoing email, encrypted to yourself
+set smime_encrypt_self = "no"
+
+# vim: syntax=muttrc
diff --git a/doc/muttrc.status-color b/doc/muttrc.status-color
new file mode 100644
index 0000000..9a1350c
--- /dev/null
+++ b/doc/muttrc.status-color
@@ -0,0 +1,49 @@
+# Example Mutt config file for the 'status-color' patch.
+
+# The 'status-color' patch allows you to theme different parts of
+# the status bar (also when it's used by the index).
+
+# For the examples below, set some defaults
+set status_format='-%r-Mutt: %f [Msgs:%?M?%M/?%m%?n? New:%n?%?o? Old:%o?%?d? Del:%d?%?F? Flag:%F?%?t? Tag:%t?%?p? Post:%p?%?b? Inc:%b?%?l? %l?]---(%s/%S)-%>-(%P)---'
+set index_format='%4C %Z %{%b %d} %-15.15L (%?l?%4l&%4c?) %s'
+set sort=threads
+set sort_aux=last-date-received
+
+# 'status color' can take up to 2 extra parameters
+
+# color status foreground background [ regex [ num ]]
+
+# 0 extra parameters
+# Set the default color for the entire status line
+color status blue white
+
+# 1 extra parameter
+# Set the color for a matching pattern
+# color status foreground background regexp
+
+# Highlight New, Deleted, or Flagged emails
+color status brightred white '(New|Del|Flag):[0-9]+'
+
+# Highlight mailbox ordering if it's different from the default
+# First, highlight anything (*/*)
+color status brightred default '\([^)]+/[^)]+\)'
+
+# Then override the color for one specific case
+color status default   default '\(threads/last-date-received\)'
+
+# 2 extra parameters
+# Set the color for the nth submatch of a pattern
+# color status foreground background regexp num
+
+# Highlight the contents of the []s but not the [] themselves
+color status red default '\[([^]]+)\]' 1
+
+# The '1' refers to the first regex submatch, which is the inner
+# part in ()s
+
+# Highlight the mailbox
+color status brightwhite default 'Mutt: ([^ ]+)' 1
+
+# Search for 'Mutt: ' but only highlight what comes after it
+
+# vim: syntax=muttrc
diff --git a/doc/muttrc.timeout b/doc/muttrc.timeout
new file mode 100644
index 0000000..911d92a
--- /dev/null
+++ b/doc/muttrc.timeout
@@ -0,0 +1,10 @@
+# This is a complete list of timeout configuration.
+
+# --------------------------------------------------------------------------
+# COMMANDS - shown with an example arguments
+# --------------------------------------------------------------------------
+
+# After $timeout seconds of inactivity, run this mutt command
+timeout-hook . 'exec sync-mailbox'
+
+# vim: syntax=muttrc
diff --git a/doc/vimrc.compress b/doc/vimrc.compress
new file mode 100644
index 0000000..e84fad2
--- /dev/null
+++ b/doc/vimrc.compress
@@ -0,0 +1,7 @@
+" Vim syntax file for the mutt compress patch
+
+syntax keyword muttrcCommand    append-hook
+syntax keyword muttrcCommand    close-hook
+syntax keyword muttrcCommand    open-hook
+
+" vim: syntax=vim
diff --git a/doc/vimrc.ifdef b/doc/vimrc.ifdef
new file mode 100644
index 0000000..342c75e
--- /dev/null
+++ b/doc/vimrc.ifdef
@@ -0,0 +1,7 @@
+" Vim syntax file for the mutt ifdef patch
+
+syntax keyword muttrcCommand    ifdef
+syntax keyword muttrcCommand    ifndef
+syntax keyword muttrcCommand    finish
+
+" vim: syntax=vim
diff --git a/doc/vimrc.index-color b/doc/vimrc.index-color
new file mode 100644
index 0000000..8de9c67
--- /dev/null
+++ b/doc/vimrc.index-color
@@ -0,0 +1,13 @@
+" Vim syntax file for the mutt index-color patch
+
+syntax keyword muttrcColorField contained index
+syntax keyword muttrcColorField contained index_author
+syntax keyword muttrcColorField contained index_collapsed
+syntax keyword muttrcColorField contained index_date
+syntax keyword muttrcColorField contained index_flags
+syntax keyword muttrcColorField contained index_label
+syntax keyword muttrcColorField contained index_number
+syntax keyword muttrcColorField contained index_size
+syntax keyword muttrcColorField contained index_subject
+
+" vim: syntax=vim
diff --git a/doc/vimrc.keywords b/doc/vimrc.keywords
new file mode 100644
index 0000000..e217ed3
--- /dev/null
+++ b/doc/vimrc.keywords
@@ -0,0 +1,10 @@
+" Vim syntax file for the mutt keywords patch
+
+syntax keyword muttrcVarBool    contained skipwhite keywords_legacy       nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite keywords_standard     nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarStr     contained skipwhite xlabel_delimiter      nextgroup=muttrcVarEqualsIdxFmt
+
+syntax match muttrcFunction     contained "\<edit-label\>"
+
+" vim: syntax=vim
diff --git a/doc/vimrc.new-mail b/doc/vimrc.new-mail
new file mode 100644
index 0000000..0d58075
--- /dev/null
+++ b/doc/vimrc.new-mail
@@ -0,0 +1,5 @@
+" Vim syntax file for the mutt new-mail patch
+
+syntax keyword muttrcVarStr     contained skipwhite new_mail_command         nextgroup=muttrcVarEqualsIdxFmt
+
+" vim: syntax=vim
diff --git a/doc/vimrc.nntp b/doc/vimrc.nntp
new file mode 100644
index 0000000..58a5d38
--- /dev/null
+++ b/doc/vimrc.nntp
@@ -0,0 +1,50 @@
+" Vim syntax file for the mutt nntp patch
+
+syntax keyword muttrcVarBool    contained skipwhite ask_follow_up         nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite ask_x_comment_to      nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite mime_subject          nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite nntp_listgroup        nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite nntp_load_description nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite save_unsubscribed     nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite show_new_news         nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite show_only_unread      nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite x_comment_to          nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarNum     contained skipwhite nntp_context          nextgroup=muttrcSetNumAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarNum     contained skipwhite nntp_poll             nextgroup=muttrcSetNumAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syn keyword muttrcVarQuad	contained skipwhite catchup_newsgroup     nextgroup=muttrcSetQuadAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn keyword muttrcVarQuad	contained skipwhite followup_to_poster    nextgroup=muttrcSetQuadAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn keyword muttrcVarQuad	contained skipwhite post_moderated        nextgroup=muttrcSetQuadAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarStr     contained skipwhite group_index_format    nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite inews                 nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite newsgroups_charset    nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite newsrc                nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite news_cache_dir        nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite news_server           nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nntp_authenticators   nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nntp_pass             nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nntp_user             nextgroup=muttrcVarEqualsIdxFmt
+
+syntax match muttrcFunction     contained "\<attach-news-message>"
+syntax match muttrcFunction     contained "\<catchup>"
+syntax match muttrcFunction     contained "\<change-newsgroup-readonly>"
+syntax match muttrcFunction     contained "\<change-newsgroup>"
+syntax match muttrcFunction     contained "\<edit-followup-to>"
+syntax match muttrcFunction     contained "\<edit-newsgroups>"
+syntax match muttrcFunction     contained "\<edit-x-comment-to>"
+syntax match muttrcFunction     contained "\<followup-message>"
+syntax match muttrcFunction     contained "\<forward-to-group>"
+syntax match muttrcFunction     contained "\<get-children>"
+syntax match muttrcFunction     contained "\<get-message>"
+syntax match muttrcFunction     contained "\<get-parent>"
+syntax match muttrcFunction     contained "\<post-message>"
+syntax match muttrcFunction     contained "\<reconstruct-thread>"
+syntax match muttrcFunction     contained "\<reload-active>"
+syntax match muttrcFunction     contained "\<subscribe-pattern>"
+syntax match muttrcFunction     contained "\<toggle-read>"
+syntax match muttrcFunction     contained "\<uncatchup>"
+syntax match muttrcFunction     contained "\<unsubscribe-pattern>"
+
+" vim: syntax=vim
diff --git a/doc/vimrc.notmuch b/doc/vimrc.notmuch
new file mode 100644
index 0000000..918d23d
--- /dev/null
+++ b/doc/vimrc.notmuch
@@ -0,0 +1,28 @@
+" Vim syntax file for the mutt notmuch patch
+
+syntax keyword muttrcVarBool    contained skipwhite nm_record             nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite virtual_spoolfile     nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarNum     contained skipwhite nm_db_limit           nextgroup=muttrcSetNumAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarNum     contained skipwhite nm_open_timeout       nextgroup=muttrcSetNumAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarStr     contained skipwhite nm_default_uri        nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nm_exclude_tags       nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nm_hidden_tags        nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nm_query_type         nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nm_record_tags        nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nm_unread_tag         nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite vfolder_format        nextgroup=muttrcVarEqualsIdxFmt
+
+syntax keyword muttrcCommand    virtual-mailboxes
+syntax keyword muttrcCommand    tag-transforms
+syntax keyword muttrcCommand    tag-formats
+
+syntax match muttrcFunction     contained "<change-vfolder>"
+syntax match muttrcFunction     contained "<entire-thread>"
+syntax match muttrcFunction     contained "<modify-labels-then-hide>"
+syntax match muttrcFunction     contained "<modify-labels>"
+syntax match muttrcFunction     contained "<sidebar-toggle>"
+syntax match muttrcFunction     contained "<vfolder-from-query>"
+
+" vim: syntax=vim
diff --git a/doc/vimrc.progress b/doc/vimrc.progress
new file mode 100644
index 0000000..a632dc0
--- /dev/null
+++ b/doc/vimrc.progress
@@ -0,0 +1,5 @@
+" Vim syntax file for the mutt progress patch
+
+syntax keyword muttrcColorField contained progress
+
+" vim: syntax=vim
diff --git a/doc/vimrc.quasi-delete b/doc/vimrc.quasi-delete
new file mode 100644
index 0000000..f8a69e7
--- /dev/null
+++ b/doc/vimrc.quasi-delete
@@ -0,0 +1,5 @@
+" Vim syntax file for the mutt quasi-delete patch
+
+syntax match muttrcFunction     contained "\<quasi-delete\>"
+
+" vim: syntax=vim
diff --git a/doc/vimrc.sidebar b/doc/vimrc.sidebar
new file mode 100644
index 0000000..ac1efc4
--- /dev/null
+++ b/doc/vimrc.sidebar
@@ -0,0 +1,34 @@
+" Vim syntax file for the mutt sidebar patch
+
+syntax keyword muttrcVarBool    contained skipwhite sidebar_folder_indent nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite sidebar_new_mail_only nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite sidebar_next_new_wrap nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite sidebar_short_path    nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite sidebar_visible       nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarNum     contained skipwhite sidebar_width         nextgroup=muttrcSetNumAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarStr     contained skipwhite sidebar_divider_char  nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite sidebar_delim_chars   nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite sidebar_format        nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite sidebar_indent_string nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite sidebar_sort_method   nextgroup=muttrcVarEqualsIdxFmt
+
+syntax keyword muttrcCommand    sidebar_whitelist
+
+syntax match muttrcFunction     contained "\<sidebar-next\>"
+syntax match muttrcFunction     contained "\<sidebar-next-new\>"
+syntax match muttrcFunction     contained "\<sidebar-open\>"
+syntax match muttrcFunction     contained "\<sidebar-page-down\>"
+syntax match muttrcFunction     contained "\<sidebar-page-up\>"
+syntax match muttrcFunction     contained "\<sidebar-prev\>"
+syntax match muttrcFunction     contained "\<sidebar-prev-new\>"
+syntax match muttrcFunction     contained "\<sidebar-toggle-visible\>"
+
+syntax keyword muttrcColorField contained sidebar_divider
+syntax keyword muttrcColorField contained sidebar_flagged
+syntax keyword muttrcColorField contained sidebar_highlight
+syntax keyword muttrcColorField contained sidebar_indicator
+syntax keyword muttrcColorField contained sidebar_new
+
+" vim: syntax=vim
diff --git a/doc/vimrc.smime-encrypt-self b/doc/vimrc.smime-encrypt-self
new file mode 100644
index 0000000..7fe9357
--- /dev/null
+++ b/doc/vimrc.smime-encrypt-self
@@ -0,0 +1,5 @@
+" Vim syntax file for the mutt smime-encrypt-self patch
+
+syntax keyword muttrcVarQuad    contained skipwhite muttrcVarQuad
+
+" vim: syntax=vim
diff --git a/doc/vimrc.timeout b/doc/vimrc.timeout
new file mode 100644
index 0000000..d94c40a
--- /dev/null
+++ b/doc/vimrc.timeout
@@ -0,0 +1,5 @@
+" Vim syntax file for the mutt timeout patch
+
+syntax keyword muttrcCommand    timeout-hook
+
+" vim: syntax=vim
diff --git a/dotlock.c b/dotlock.c
index 5bf0348..dc14396 100644
--- a/dotlock.c
+++ b/dotlock.c
@@ -53,7 +53,7 @@
 #endif
 
 #ifdef DL_STANDALONE
-# include "reldate.h"
+# include "oldmutt_ver.h"
 #endif
 
 #define MAXLINKS 1024 /* maximum link depth */
@@ -339,7 +339,7 @@ END_PRIVILEGED (void)
 static void 
 usage (const char *av0)
 {
-  fprintf (stderr, "dotlock [Mutt %s (%s)]\n", MUTT_VERSION, ReleaseDate);
+  fprintf (stderr, "dotlock [NeoMutt %s (%s)]\n", PACKAGE_VERSION, OldMuttVer);
   fprintf (stderr, "usage: %s [-t|-f|-u|-d] [-p] [-r <retries>] file\n",
 	  av0);
 
diff --git a/enter.c b/enter.c
index 2f3ebdd..7a806dd 100644
--- a/enter.c
+++ b/enter.c
@@ -566,6 +566,49 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 	    }
 	    break;
 	  }
+	  else if (flags & MUTT_LABEL && ch == OP_EDITOR_COMPLETE)
+	  {
+	    for (i = state->curpos; i && state->wbuf[i-1] != ',' && 
+		 state->wbuf[i-1] != ':'; i--)
+	      ;
+	    for (; i < state->lastchar && state->wbuf[i] == ' '; i++)
+	      ;
+	    my_wcstombs (buf, buflen, state->wbuf + i, state->curpos - i);
+	    r = mutt_label_complete (buf, buflen, i, state->tabs);
+	    replace_part (state, i, buf);
+	    if (!r)
+	    {
+	      rv = 1;
+	      goto bye;
+	    }
+	    break;
+	  }
+	  else if (flags & MUTT_PATTERN && ch == OP_EDITOR_COMPLETE)
+	  {
+        char *p;
+	    for (i = state->curpos; i && state->wbuf[i-1] != ',' && 
+		 state->wbuf[i-1] != ':'; i--)
+	      ;
+	    for (; i < state->lastchar && state->wbuf[i] == ' '; i++)
+	      ;
+	    my_wcstombs (buf, buflen, state->wbuf + i, state->curpos - i);
+        p = &buf[i];
+        while (p > buf && *(p-1) != '~')
+          p--;
+        if (*p == '~' && *(p+1) == 'y')
+        {
+	      r = mutt_label_complete (buf, buflen, i, state->tabs);
+	      replace_part (state, i, buf);
+	      if (!r)
+	      {
+	        rv = 1;
+	        goto bye;
+	      }
+        }
+        else
+          goto self_insert;
+	    break;
+	  }
 	  else if (flags & MUTT_ALIAS && ch == OP_EDITOR_COMPLETE_QUERY)
 	  {
 	    /* invoke the query-menu to get more addresses */
@@ -631,6 +674,27 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 	      BEEP (); /* let the user know that nothing matched */
 	    replace_part (state, 0, buf);
 	  }
+#if USE_NOTMUCH
+	  else if (flags & MUTT_NM_QUERY)
+	  {
+	    my_wcstombs (buf, buflen, state->wbuf, state->curpos);
+	    i = strlen (buf);
+	    if (!mutt_nm_query_complete(buf, buflen, i, state->tabs))
+	      BEEP ();
+
+	    replace_part (state, 0, buf);
+	  }
+	  else if (flags & MUTT_NM_TAG)
+	  {
+	    my_wcstombs (buf, buflen, state->wbuf, state->curpos);
+	    i = strlen (buf);
+	    if (!mutt_nm_tag_complete(buf, buflen, i, state->tabs))
+	      BEEP ();
+
+	    replace_part (state, 0, buf);
+	  }
+
+#endif
 	  else
 	    goto self_insert;
 	  break;
@@ -678,12 +742,6 @@ self_insert:
       /* use the raw keypress */
       ch = LastKey;
 
-#ifdef KEY_ENTER
-      /* treat ENTER the same as RETURN */
-      if (ch == KEY_ENTER)
-	ch = '\r';
-#endif
-
       /* quietly ignore all other function keys */
       if (ch & ~0xff)
 	continue;
diff --git a/functions.h b/functions.h
index abc06ca..dad63b6 100644
--- a/functions.h
+++ b/functions.h
@@ -22,9 +22,6 @@
  *
  * Notes:
  *
- * - If you want to bind \n or \r, use MUTT_ENTER_S so that it will work
- * correctly under both ncurses and S-Lang
- *
  * - If you need to bind a control char, use the octal value because the \cX
  * construct does not work at this level.
  *
@@ -70,7 +67,8 @@ const struct binding_t OpGeneric[] = { /* map: generic */
   { "tag-prefix-cond",	OP_TAG_PREFIX_COND,	NULL },
   { "end-cond",		OP_END_COND,		NULL },
   { "shell-escape",	OP_SHELL_ESCAPE,	"!" },
-  { "select-entry",	OP_GENERIC_SELECT_ENTRY,MUTT_ENTER_S },
+  { "select-entry",	OP_GENERIC_SELECT_ENTRY,"\n" },
+  { "select-entry",	OP_GENERIC_SELECT_ENTRY,"\r" },
   { "search",		OP_SEARCH,		"/" },
   { "search-reverse",	OP_SEARCH_REVERSE,	"\033/" },
   { "search-opposite",	OP_SEARCH_OPPOSITE,	NULL },
@@ -88,6 +86,10 @@ const struct binding_t OpMain[] = { /* map: index */
   { "break-thread",		OP_MAIN_BREAK_THREAD,		"#" },
   { "change-folder",		OP_MAIN_CHANGE_FOLDER,		"c" },
   { "change-folder-readonly",	OP_MAIN_CHANGE_FOLDER_READONLY,	"\033c" },
+#ifdef USE_NNTP
+  { "change-newsgroup",		OP_MAIN_CHANGE_GROUP,		NULL },
+  { "change-newsgroup-readonly",OP_MAIN_CHANGE_GROUP_READONLY,	NULL },
+#endif
   { "next-unread-mailbox",	OP_MAIN_NEXT_UNREAD_MAILBOX,    NULL },
   { "collapse-thread",		OP_MAIN_COLLAPSE_THREAD,	"\033v" },
   { "collapse-all",		OP_MAIN_COLLAPSE_ALL,		"\033V" },
@@ -99,8 +101,17 @@ const struct binding_t OpMain[] = { /* map: index */
   { "delete-thread",		OP_DELETE_THREAD,		"\004" },
   { "delete-subthread",		OP_DELETE_SUBTHREAD,		"\033d" },
   { "edit",			OP_EDIT_MESSAGE,		"e" },
+  { "edit-label",		OP_EDIT_LABEL,			NULL },
   { "edit-type",		OP_EDIT_TYPE,			"\005" },
   { "forward-message",		OP_FORWARD_MESSAGE,		"f" },
+#ifdef USE_NNTP
+  { "forward-to-group",		OP_FORWARD_TO_GROUP,		NULL },
+  { "followup-message",		OP_FOLLOWUP,			NULL },
+  { "get-children",		OP_GET_CHILDREN,		NULL },
+  { "get-message",		OP_GET_MESSAGE,			NULL },
+  { "get-parent",		OP_GET_PARENT,			NULL },
+  { "reconstruct-thread",	OP_RECONSTRUCT_THREAD,		NULL },
+#endif
   { "flag-message",		OP_FLAG_MESSAGE,		"F" },
   { "group-reply",		OP_GROUP_REPLY,			"g" },
 #ifdef USE_POP
@@ -114,6 +125,7 @@ const struct binding_t OpMain[] = { /* map: index */
   { "next-undeleted",		OP_MAIN_NEXT_UNDELETED,		"j" },
   { "previous-undeleted",	OP_MAIN_PREV_UNDELETED,		"k" },
   { "limit",			OP_MAIN_LIMIT,			"l" },
+  { "limit-current-thread",	OP_LIMIT_CURRENT_THREAD,	NULL },
   { "link-threads",		OP_MAIN_LINK_THREADS,		"&" },
   { "list-reply",		OP_LIST_REPLY,			"L" },
   { "mail",			OP_MAIL,			"m" },
@@ -129,6 +141,9 @@ const struct binding_t OpMain[] = { /* map: index */
   { "sort-mailbox",		OP_SORT,			"o" },
   { "sort-reverse",		OP_SORT_REVERSE,		"O" },
   { "print-message",		OP_PRINT,			"p" },
+#ifdef USE_NNTP
+  { "post-message",		OP_POST,			NULL },
+#endif
   { "previous-thread",		OP_MAIN_PREV_THREAD,		"\020" },
   { "previous-subthread",	OP_MAIN_PREV_SUBTHREAD,		"\033p" },
   { "recall-message",		OP_RECALL_MESSAGE,		"R" },
@@ -148,7 +163,12 @@ const struct binding_t OpMain[] = { /* map: index */
   { "show-version",		OP_VERSION,			"V" },
   { "set-flag",			OP_MAIN_SET_FLAG,		"w" },
   { "clear-flag",		OP_MAIN_CLEAR_FLAG,		"W" },
-  { "display-message",		OP_DISPLAY_MESSAGE,		MUTT_ENTER_S },
+  { "toggle-read",		OP_TOGGLE_READ,			NULL },
+#ifdef USE_NNTP
+  { "catchup",			OP_CATCHUP,			NULL },
+#endif
+  { "display-message",		OP_DISPLAY_MESSAGE,		"\n" },
+  { "display-message",		OP_DISPLAY_MESSAGE,		"\r" },
   { "buffy-list",		OP_BUFFY_LIST,			"." },
   { "sync-mailbox",		OP_MAIN_SYNC_FOLDER,		"$" },
   { "display-address",		OP_DISPLAY_ADDRESS,		"@" },
@@ -168,6 +188,7 @@ const struct binding_t OpMain[] = { /* map: index */
   { "mail-key",			OP_MAIL_KEY,			"\033k" },
   { "decrypt-copy",		OP_DECRYPT_COPY,		NULL },
   { "decrypt-save",		OP_DECRYPT_SAVE,		NULL },
+  { "quasi-delete",		OP_MAIN_QUASI_DELETE,		NULL },
 
 #ifdef USE_SIDEBAR
   { "sidebar-next",		OP_SIDEBAR_NEXT,		NULL },
@@ -177,9 +198,17 @@ const struct binding_t OpMain[] = { /* map: index */
   { "sidebar-page-up",		OP_SIDEBAR_PAGE_UP,		NULL },
   { "sidebar-prev",		OP_SIDEBAR_PREV,		NULL },
   { "sidebar-prev-new",		OP_SIDEBAR_PREV_NEW,		NULL },
+  { "sidebar-toggle-virtual",	OP_SIDEBAR_TOGGLE_VIRTUAL,	NULL },
   { "sidebar-toggle-visible",	OP_SIDEBAR_TOGGLE_VISIBLE,	NULL },
 #endif
 
+#ifdef USE_NOTMUCH
+  { "change-vfolder",		OP_MAIN_CHANGE_VFOLDER,         NULL },
+  { "vfolder-from-query",	OP_MAIN_VFOLDER_FROM_QUERY,     NULL },
+  { "modify-labels",		OP_MAIN_MODIFY_LABELS,		NULL },
+  { "modify-labels-then-hide",	OP_MAIN_MODIFY_LABELS_THEN_HIDE, NULL },
+  { "entire-thread",		OP_MAIN_ENTIRE_THREAD,          NULL },
+#endif
   { NULL,			0,				NULL }
 };
 
@@ -189,6 +218,10 @@ const struct binding_t OpPager[] = { /* map: pager */
   { "bounce-message",	OP_BOUNCE_MESSAGE,		"b" },
   { "change-folder",	OP_MAIN_CHANGE_FOLDER,		"c" },
   { "change-folder-readonly",	OP_MAIN_CHANGE_FOLDER_READONLY,	"\033c" },
+#ifdef USE_NNTP
+  { "change-newsgroup",		OP_MAIN_CHANGE_GROUP,		NULL },
+  { "change-newsgroup-readonly",OP_MAIN_CHANGE_GROUP_READONLY,	NULL },
+#endif
   { "next-unread-mailbox",	OP_MAIN_NEXT_UNREAD_MAILBOX, NULL },
   { "copy-message",	OP_COPY_MESSAGE,		"C" },
   { "decode-copy",	OP_DECODE_COPY,			"\033C" },
@@ -198,7 +231,12 @@ const struct binding_t OpPager[] = { /* map: pager */
   { "set-flag",  	OP_MAIN_SET_FLAG,		"w" },
   { "clear-flag",       OP_MAIN_CLEAR_FLAG,		"W" },
   { "edit",		OP_EDIT_MESSAGE,		"e" },
+  { "edit-label",	OP_EDIT_LABEL,			NULL },
   { "edit-type",	OP_EDIT_TYPE,			"\005" },
+#ifdef USE_NNTP
+  { "followup-message",	OP_FOLLOWUP,			NULL },
+  { "forward-to-group",	OP_FORWARD_TO_GROUP,		NULL },
+#endif
   { "forward-message",	OP_FORWARD_MESSAGE,		"f" },
   { "flag-message",	OP_FLAG_MESSAGE,		"F" },
   { "group-reply",	OP_GROUP_REPLY,			"g" },
@@ -222,6 +260,9 @@ const struct binding_t OpPager[] = { /* map: pager */
   { "sort-mailbox",	OP_SORT,			"o" },
   { "sort-reverse",	OP_SORT_REVERSE,		"O" },
   { "print-message",	OP_PRINT,			"p" },
+#ifdef USE_NNTP
+  { "post-message",	OP_POST,			NULL },
+#endif
   { "previous-thread",	OP_MAIN_PREV_THREAD,		"\020" },
   { "previous-subthread",OP_MAIN_PREV_SUBTHREAD,	"\033p" },
   { "purge-message",	OP_PURGE_MESSAGE,		NULL },
@@ -259,7 +300,8 @@ const struct binding_t OpPager[] = { /* map: pager */
   { "search",		OP_SEARCH,			"/" },
   { "search-reverse",	OP_SEARCH_REVERSE,		"\033/" },
   { "search-opposite",	OP_SEARCH_OPPOSITE,		NULL },
-  { "next-line",	OP_NEXT_LINE,			MUTT_ENTER_S },
+  { "next-line",	OP_NEXT_LINE,			"\n" },
+  { "next-line",	OP_NEXT_LINE,			"\r" },
   { "jump",		OP_JUMP,			NULL },
   { "next-unread",	OP_MAIN_NEXT_UNREAD,		NULL },
   { "previous-new",	OP_MAIN_PREV_NEW,		NULL },
@@ -283,6 +325,7 @@ const struct binding_t OpPager[] = { /* map: pager */
   { "decrypt-save",    	OP_DECRYPT_SAVE,		NULL },
 
   { "what-key",		OP_WHAT_KEY,		NULL },
+  { "quasi-delete",	OP_MAIN_QUASI_DELETE,		NULL },
 
 #ifdef USE_SIDEBAR
   { "sidebar-next",		OP_SIDEBAR_NEXT,		NULL },
@@ -292,9 +335,18 @@ const struct binding_t OpPager[] = { /* map: pager */
   { "sidebar-page-up",		OP_SIDEBAR_PAGE_UP,		NULL },
   { "sidebar-prev",		OP_SIDEBAR_PREV,		NULL },
   { "sidebar-prev-new",		OP_SIDEBAR_PREV_NEW,		NULL },
+  { "sidebar-toggle-virtual",	OP_SIDEBAR_TOGGLE_VIRTUAL,	NULL },
   { "sidebar-toggle-visible",	OP_SIDEBAR_TOGGLE_VISIBLE,	NULL },
 #endif
 
+#ifdef USE_NOTMUCH
+  { "change-vfolder",		OP_MAIN_CHANGE_VFOLDER,		NULL },
+  { "vfolder-from-query",	OP_MAIN_VFOLDER_FROM_QUERY,	NULL },
+  { "modify-labels",		OP_MAIN_MODIFY_LABELS,		NULL },
+  { "modify-labels-then-hide",	OP_MAIN_MODIFY_LABELS_THEN_HIDE, NULL },
+  { "entire-thread",		OP_MAIN_ENTIRE_THREAD,          NULL },
+#endif
+
   { NULL,		0,				NULL }
 };
 
@@ -302,6 +354,10 @@ const struct binding_t OpAttach[] = { /* map: attachment */
   { "bounce-message",	OP_BOUNCE_MESSAGE,		"b" },
   { "display-toggle-weed",	OP_DISPLAY_HEADERS,	"h" },
   { "edit-type",	OP_EDIT_TYPE,			"\005" },
+#ifdef USE_NNTP
+  { "followup-message",	OP_FOLLOWUP,			NULL },
+  { "forward-to-group",	OP_FORWARD_TO_GROUP,		NULL },
+#endif
   { "print-entry",	OP_PRINT,			"p" },
   { "save-entry",	OP_SAVE,			"s" },
   { "pipe-entry",	OP_PIPE,			"|" },
@@ -312,7 +368,8 @@ const struct binding_t OpAttach[] = { /* map: attachment */
   { "list-reply",	OP_LIST_REPLY,			"L" },
   { "forward-message",	OP_FORWARD_MESSAGE,		"f" },
   { "view-text",	OP_ATTACH_VIEW_TEXT,		"T" },
-  { "view-attach",	OP_VIEW_ATTACH,			MUTT_ENTER_S },
+  { "view-attach",	OP_VIEW_ATTACH,			"\n" },
+  { "view-attach",	OP_VIEW_ATTACH,			"\r" },
   { "delete-entry",	OP_DELETE,			"d" },
   { "undelete-entry",	OP_UNDELETE,			"u" },
   { "collapse-parts",	OP_ATTACH_COLLAPSE,		"v" },
@@ -327,6 +384,7 @@ const struct binding_t OpAttach[] = { /* map: attachment */
 const struct binding_t OpCompose[] = { /* map: compose */
   { "attach-file",	OP_COMPOSE_ATTACH_FILE,		"a" },
   { "attach-message",	OP_COMPOSE_ATTACH_MESSAGE,	"A" },
+  { "attach-news-message",OP_COMPOSE_ATTACH_NEWS_MESSAGE,NULL },
   { "edit-bcc",		OP_COMPOSE_EDIT_BCC,		"b" },
   { "edit-cc",		OP_COMPOSE_EDIT_CC,		"c" },
   { "copy-file",	OP_SAVE,			"C" },
@@ -346,6 +404,11 @@ const struct binding_t OpCompose[] = { /* map: compose */
   { "print-entry",	OP_PRINT,			"l" },
   { "edit-mime",	OP_COMPOSE_EDIT_MIME,		"m" },
   { "new-mime",		OP_COMPOSE_NEW_MIME,		"n" },
+#ifdef USE_NNTP
+  { "edit-newsgroups",	OP_COMPOSE_EDIT_NEWSGROUPS,	NULL },
+  { "edit-followup-to",	OP_COMPOSE_EDIT_FOLLOWUP_TO,	NULL },
+  { "edit-x-comment-to",OP_COMPOSE_EDIT_X_COMMENT_TO,	NULL },
+#endif
   { "postpone-message",	OP_COMPOSE_POSTPONE_MESSAGE,	"P" },
   { "edit-reply-to",	OP_COMPOSE_EDIT_REPLY_TO,	"r" },
   { "rename-file",	OP_COMPOSE_RENAME_FILE,		"R" },
@@ -356,7 +419,8 @@ const struct binding_t OpCompose[] = { /* map: compose */
   { "toggle-unlink",	OP_COMPOSE_TOGGLE_UNLINK,	"u" },
   { "toggle-recode",    OP_COMPOSE_TOGGLE_RECODE,	NULL },
   { "update-encoding",	OP_COMPOSE_UPDATE_ENCODING,	"U" },
-  { "view-attach",	OP_VIEW_ATTACH,			MUTT_ENTER_S },
+  { "view-attach",	OP_VIEW_ATTACH,			"\n" },
+  { "view-attach",	OP_VIEW_ATTACH,			"\r" },
   { "send-message",	OP_COMPOSE_SEND_MESSAGE,	"y" },
   { "pipe-entry",	OP_PIPE,			"|" },
 
@@ -397,14 +461,25 @@ const struct binding_t OpBrowser[] = { /* map: browser */
   { "select-new",	OP_BROWSER_NEW_FILE,	"N" },
   { "check-new",	OP_CHECK_NEW,		NULL },
   { "toggle-mailboxes", OP_TOGGLE_MAILBOXES, 	"\t" },
+#ifdef USE_NNTP
+  { "reload-active",	OP_LOAD_ACTIVE,		NULL },
+  { "subscribe-pattern", OP_SUBSCRIBE_PATTERN,	NULL },
+  { "unsubscribe-pattern", OP_UNSUBSCRIBE_PATTERN, NULL },
+  { "catchup",		OP_CATCHUP,		NULL },
+  { "uncatchup",	OP_UNCATCHUP,		NULL },
+#endif
   { "view-file",	OP_BROWSER_VIEW_FILE,	" " },
   { "buffy-list",	OP_BUFFY_LIST,		"." },
 #ifdef USE_IMAP
   { "create-mailbox",   OP_CREATE_MAILBOX,      "C" },
   { "delete-mailbox",   OP_DELETE_MAILBOX,      "d" },
   { "rename-mailbox",   OP_RENAME_MAILBOX,      "r" },
+#endif
+#if defined USE_IMAP || defined USE_NNTP
   { "subscribe",	OP_BROWSER_SUBSCRIBE,	"s" },
   { "unsubscribe",	OP_BROWSER_UNSUBSCRIBE,	"u" },
+#endif
+#ifdef USE_IMAP
   { "toggle-subscribed", OP_BROWSER_TOGGLE_LSUB, "T" },
 #endif
   { NULL,		0,			NULL }
@@ -469,7 +544,8 @@ const struct binding_t OpSmime[] = { /* map: smime */
 
 #ifdef MIXMASTER
 const struct binding_t OpMix[] = { /* map: mixmaster */
-  { "accept",		OP_MIX_USE,	MUTT_ENTER_S },
+  { "accept",		OP_MIX_USE,	"\n" },
+  { "accept",		OP_MIX_USE,	"\r" },
   { "append",		OP_MIX_APPEND,	"a"       },
   { "insert",		OP_MIX_INSERT,	"i"       },
   { "delete",		OP_MIX_DELETE,  "d"	  },
diff --git a/git-version-gen b/git-version-gen
new file mode 100755
index 0000000..bd2c4b6
--- /dev/null
+++ b/git-version-gen
@@ -0,0 +1,226 @@
+#!/bin/sh
+# Print a version string.
+scriptversion=2016-05-08.18; # UTC
+
+# Copyright (C) 2007-2016 Free Software Foundation, Inc.
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# This script is derived from GIT-VERSION-GEN from GIT: http://git.or.cz/.
+# It may be run two ways:
+# - from a git repository in which the "git describe" command below
+#   produces useful output (thus requiring at least one signed tag)
+# - from a non-git-repo directory containing a .tarball-version file, which
+#   presumes this script is invoked like "./git-version-gen .tarball-version".
+
+# In order to use intra-version strings in your project, you will need two
+# separate generated version string files:
+#
+# .tarball-version - present only in a distribution tarball, and not in
+#   a checked-out repository.  Created with contents that were learned at
+#   the last time autoconf was run, and used by git-version-gen.  Must not
+#   be present in either $(srcdir) or $(builddir) for git-version-gen to
+#   give accurate answers during normal development with a checked out tree,
+#   but must be present in a tarball when there is no version control system.
+#   Therefore, it cannot be used in any dependencies.  GNUmakefile has
+#   hooks to force a reconfigure at distribution time to get the value
+#   correct, without penalizing normal development with extra reconfigures.
+#
+# .version - present in a checked-out repository and in a distribution
+#   tarball.  Usable in dependencies, particularly for files that don't
+#   want to depend on config.h but do want to track version changes.
+#   Delete this file prior to any autoconf run where you want to rebuild
+#   files to pick up a version string change; and leave it stale to
+#   minimize rebuild time after unrelated changes to configure sources.
+#
+# As with any generated file in a VC'd directory, you should add
+# /.version to .gitignore, so that you don't accidentally commit it.
+# .tarball-version is never generated in a VC'd directory, so needn't
+# be listed there.
+#
+# Use the following line in your configure.ac, so that $(VERSION) will
+# automatically be up-to-date each time configure is run (and note that
+# since configure.ac no longer includes a version string, Makefile rules
+# should not depend on configure.ac for version updates).
+#
+# AC_INIT([GNU project],
+#         m4_esyscmd([build-aux/git-version-gen .tarball-version]),
+#         [bug-project@example])
+#
+# Then use the following lines in your Makefile.am, so that .version
+# will be present for dependencies, and so that .version and
+# .tarball-version will exist in distribution tarballs.
+#
+# EXTRA_DIST = $(top_srcdir)/.version
+# BUILT_SOURCES = $(top_srcdir)/.version
+# $(top_srcdir)/.version:
+#	echo $(VERSION) > $@-t && mv $@-t $@
+# dist-hook:
+#	echo $(VERSION) > $(distdir)/.tarball-version
+
+
+me=$0
+
+version="git-version-gen $scriptversion
+
+Copyright 2011 Free Software Foundation, Inc.
+There is NO warranty.  You may redistribute this software
+under the terms of the GNU General Public License.
+For more information about these matters, see the files named COPYING."
+
+usage="\
+Usage: $me [OPTION]... \$srcdir/.tarball-version [TAG-NORMALIZATION-SED-SCRIPT]
+Print a version string.
+
+Options:
+
+   --prefix PREFIX    prefix of git tags (default 'v')
+   --fallback VERSION
+                      fallback version to use if \"git --version\" fails
+
+   --help             display this help and exit
+   --version          output version information and exit
+
+Running without arguments will suffice in most cases."
+
+prefix=v
+fallback=
+
+while test $# -gt 0; do
+  case $1 in
+    --help) echo "$usage"; exit 0;;
+    --version) echo "$version"; exit 0;;
+    --prefix) shift; prefix=${1?};;
+    --fallback) shift; fallback=${1?};;
+    -*)
+      echo "$0: Unknown option '$1'." >&2
+      echo "$0: Try '--help' for more information." >&2
+      exit 1;;
+    *)
+      if test "x$tarball_version_file" = x; then
+        tarball_version_file="$1"
+      elif test "x$tag_sed_script" = x; then
+        tag_sed_script="$1"
+      else
+        echo "$0: extra non-option argument '$1'." >&2
+        exit 1
+      fi;;
+  esac
+  shift
+done
+
+if test "x$tarball_version_file" = x; then
+    echo "$usage"
+    exit 1
+fi
+
+tag_sed_script="${tag_sed_script:-s/x/x/}"
+
+nl='
+'
+
+# Avoid meddling by environment variable of the same name.
+v=
+v_from_git=
+
+# First see if there is a tarball-only version file.
+# then try "git describe", then default.
+if test -f $tarball_version_file
+then
+    v=`cat $tarball_version_file` || v=
+    case $v in
+        *$nl*) v= ;; # reject multi-line output
+        [0-9]*) ;;
+        *) v= ;;
+    esac
+    test "x$v" = x \
+        && echo "$0: WARNING: $tarball_version_file is missing or damaged" 1>&2
+fi
+
+if test "x$v" != x
+then
+    : # use $v
+# Otherwise, if there is at least one git commit involving the working
+# directory, and "git describe" output looks sensible, use that to
+# derive a version string.
+elif test "`git log -1 --pretty=format:x . 2>&1`" = x \
+    && v=`git describe --abbrev=4 --match="$prefix*" HEAD 2>/dev/null \
+          || git describe --abbrev=4 HEAD 2>/dev/null` \
+    && v=`printf '%s\n' "$v" | sed "$tag_sed_script"` \
+    && case $v in
+         $prefix[0-9]*) ;;
+         *) (exit 1) ;;
+       esac
+then
+    # Is this a new git that lists number of commits since the last
+    # tag or the previous older version that did not?
+    #   Newer: v6.10-77-g0f8faeb
+    #   Older: v6.10-g0f8faeb
+    case $v in
+        *-*-*) : git describe is okay three part flavor ;;
+        *-*)
+            : git describe is older two part flavor
+            # Recreate the number of commits and rewrite such that the
+            # result is the same as if we were using the newer version
+            # of git describe.
+            vtag=`echo "$v" | sed 's/-.*//'`
+            commit_list=`git rev-list "$vtag"..HEAD 2>/dev/null` \
+                || { commit_list=failed;
+                     echo "$0: WARNING: git rev-list failed" 1>&2; }
+            numcommits=`echo "$commit_list" | wc -l`
+            v=`echo "$v" | sed "s/\(.*\)-\(.*\)/\1-$numcommits-\2/"`;
+            test "$commit_list" = failed && v=UNKNOWN
+            ;;
+    esac
+
+    # Change the first '-' to a '.', so version-comparing tools work properly.
+    # Remove the "g" in git describe's output string, to save a byte.
+    v=`echo "$v" | sed 's/-/./;s/\(.*\)-g/\1-/'`;
+    v_from_git=1
+elif test "x$fallback" = x || git --version >/dev/null 2>&1; then
+    v=UNKNOWN
+else
+    v=$fallback
+fi
+
+v=`echo "$v" |sed "s/^$prefix//"`
+
+# Test whether to append the "-dirty" suffix only if the version
+# string we're using came from git.  I.e., skip the test if it's "UNKNOWN"
+# or if it came from .tarball-version.
+if test "x$v_from_git" != x; then
+  # Don't declare a version "dirty" merely because a time stamp has changed.
+  git update-index --refresh > /dev/null 2>&1
+
+  dirty=`exec 2>/dev/null;git diff-index --name-only HEAD` || dirty=
+  case "$dirty" in
+      '') ;;
+      *) # Append the suffix only if there isn't one already.
+          case $v in
+            *-dirty) ;;
+            *) v="$v-dirty" ;;
+          esac ;;
+  esac
+fi
+
+# Omit the trailing newline, so that m4_esyscmd can use the result directly.
+printf %s "$v"
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-time-zone: "UTC0"
+# time-stamp-end: "; # UTC"
+# End:
diff --git a/globals.h b/globals.h
index 95a6869..bd4af94 100644
--- a/globals.h
+++ b/globals.h
@@ -66,10 +66,11 @@ WHERE char *ImapUser INITVAL (NULL);
 #endif
 WHERE char *Inbox;
 WHERE char *Ispell;
+WHERE char *KeywordsSave;
 WHERE char *Locale;
 WHERE char *MailcapPath;
 WHERE char *Maildir;
-#if defined(USE_IMAP) || defined(USE_POP)
+#if defined(USE_IMAP) || defined(USE_POP) || defined(USE_NNTP)
 WHERE char *MessageCachedir;
 #endif
 #if USE_HCACHE
@@ -95,6 +96,17 @@ WHERE char *MixEntryFormat;
 #endif
 
 WHERE char *Muttrc INITVAL (NULL);
+#ifdef USE_NNTP
+WHERE char *GroupFormat;
+WHERE char *Inews;
+WHERE char *NewsCacheDir;
+WHERE char *NewsServer;
+WHERE char *NewsgroupsCharset;
+WHERE char *NewsRc;
+WHERE char *NntpAuthenticators;
+WHERE char *NntpUser;
+WHERE char *NntpPass;
+#endif
 WHERE char *Outbox;
 WHERE char *Pager;
 WHERE char *PagerFmt;
@@ -111,6 +123,7 @@ WHERE char *Postponed;
 WHERE char *PostponeEncryptAs;
 WHERE char *Prefix;
 WHERE char *PrintCmd;
+WHERE char *NewMailCmd;
 WHERE char *QueryCmd;
 WHERE char *QueryFormat;
 WHERE char *Realname;
@@ -153,15 +166,21 @@ WHERE char *TSIconFormat;
 WHERE short TSSupported;
 WHERE char *Username;
 WHERE char *Visual;
+WHERE char *XlabelDelim;
 
 WHERE char *CurrentFolder;
 WHERE char *LastFolder;
 
 
-WHERE const char *ReleaseDate;
+WHERE const char *OldMuttVer;
 
 WHERE HASH *Groups;
+WHERE HASH *Labels;
 WHERE HASH *ReverseAlias;
+#ifdef USE_NOTMUCH
+WHERE HASH *TagTransforms;
+WHERE HASH *TagFormats;
+#endif
 
 WHERE LIST *AutoViewList INITVAL(0);
 WHERE LIST *AlternativeOrderList INITVAL(0);
@@ -201,6 +220,11 @@ extern unsigned char QuadOptions[];
 
 WHERE unsigned short Counter INITVAL (0);
 
+#ifdef USE_NNTP
+WHERE short NewsPollTimeout;
+WHERE short NntpContext;
+#endif
+
 WHERE short ConnectTimeout;
 WHERE short HistSize;
 WHERE short MenuContext;
@@ -211,6 +235,7 @@ WHERE short ReflowWrap;
 WHERE short SaveHist;
 WHERE short SendmailWait;
 WHERE short SleepTime INITVAL (1);
+WHERE short SkipQuotedOffset;
 WHERE short TimeInc;
 WHERE short Timeout;
 WHERE short Wrap;
@@ -222,7 +247,7 @@ WHERE short ScoreThresholdRead;
 WHERE short ScoreThresholdFlag;
 
 #ifdef USE_SIDEBAR
-WHERE short SidebarWidth;
+WHERE short SidebarWidth INITVAL(0);
 WHERE LIST *SidebarWhitelist INITVAL(0);
 WHERE int SidebarNeedsRedraw INITVAL (0);
 #endif
@@ -282,6 +307,17 @@ WHERE char *SmimeGetCertCommand;
 WHERE char *SmimeImportCertCommand;
 WHERE char *SmimeGetCertEmailCommand;
 
+#ifdef USE_NOTMUCH
+WHERE int NotmuchOpenTimeout;
+WHERE char *NotmuchDefaultUri;
+WHERE char *NotmuchExcludeTags;
+WHERE char *NotmuchUnreadTag;
+WHERE char *NotmuchHiddenTags;
+WHERE char *VirtFolderFormat;
+WHERE int NotmuchDBLimit;
+WHERE char *NotmuchQueryType;
+WHERE char *NotmuchRecordTags;
+#endif
 
 
 
@@ -303,5 +339,5 @@ extern const char * const Months[];
 #include "buffy.h"
 #include "sort.h"
 #include "mutt_crypt.h"
-#include "reldate.h"
+#include "oldmutt_ver.h"
 #endif /* MAIN_C */
diff --git a/handler.c b/handler.c
index 7ce53f9..014268f 100644
--- a/handler.c
+++ b/handler.c
@@ -1596,7 +1596,9 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
   int origType;
   char *savePrefix = NULL;
   FILE *fp = NULL;
+#ifndef USE_FMEMOPEN
   char tempfile[_POSIX_PATH_MAX];
+#endif
   size_t tmplength = 0;
   LOFF_T tmpoffset = 0;
   int decode = 0;
@@ -1604,6 +1606,11 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
 
   fseeko (s->fpin, b->offset, 0);
 
+#ifdef USE_FMEMOPEN
+  char *temp;
+  size_t tempsize;
+#endif
+
   /* see if we need to decode this part before processing it */
   if (b->encoding == ENCBASE64 || b->encoding == ENCQUOTEDPRINTABLE ||
       b->encoding == ENCUUENCODED || plaintext ||
@@ -1619,6 +1626,14 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
     {
       /* decode to a tempfile, saving the original destination */
       fp = s->fpout;
+#ifdef USE_FMEMOPEN
+     s->fpout = open_memstream (&temp, &tempsize);
+     if (!s->fpout) {
+       mutt_error _("Unable to open memory stream!");
+       dprint (1, (debugfile, "Can't open memory stream.\n"));
+       return -1;
+     }
+#else
       mutt_mktemp (tempfile, sizeof (tempfile));
       if ((s->fpout = safe_fopen (tempfile, "w")) == NULL)
       {
@@ -1626,6 +1641,7 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
         dprint (1, (debugfile, "Can't open %s.\n", tempfile));
         return -1;
       }
+#endif
       /* decoding the attachment changes the size and offset, so save a copy
         * of the "real" values now, and restore them after processing
         */
@@ -1654,9 +1670,20 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
       /* restore final destination and substitute the tempfile for input */
       s->fpout = fp;
       fp = s->fpin;
+#ifdef USE_FMEMOPEN
+      if (tempsize) {
+        s->fpin = fmemopen (temp, tempsize, "r");
+      } else { /* fmemopen cannot handle zero-length buffers */
+        s->fpin = safe_fopen ("/dev/null", "r");
+      }
+      if (!s->fpin) {
+        mutt_perror ("failed to re-open memstream!");
+        return -1;
+      }
+#else
       s->fpin = fopen (tempfile, "r");
       unlink (tempfile);
-
+#endif
       /* restore the prefix */
       s->prefix = savePrefix;
     }
@@ -1681,6 +1708,10 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
 
       /* restore the original source stream */
       safe_fclose (&s->fpin);
+#ifdef USE_FMEMOPEN
+      if (tempsize)
+        FREE(&temp);
+#endif
       s->fpin = fp;
     }
   }
diff --git a/hash.c b/hash.c
index 08f7171..34b96ef 100644
--- a/hash.c
+++ b/hash.c
@@ -57,6 +57,7 @@ HASH *hash_create (int nelem, int lower)
   if (nelem == 0)
     nelem = 2;
   table->nelem = nelem;
+  table->curnelem = 0;
   table->table = safe_calloc (nelem, sizeof (struct hash_elem *));
   if (lower)
   {
@@ -71,6 +72,29 @@ HASH *hash_create (int nelem, int lower)
   return table;
 }
 
+HASH *hash_resize (HASH *ptr, int nelem, int lower)
+{
+  HASH *table;
+  struct hash_elem *elem, *tmp;
+  int i;
+
+  table = hash_create (nelem, lower);
+
+  for (i = 0; i < ptr->nelem; i++)
+  {
+    for (elem = ptr->table[i]; elem; )
+    {
+      tmp = elem;
+      elem = elem->next;
+      hash_insert (table, tmp->key, tmp->data, 1);
+      FREE (&tmp);
+    }
+  }
+  FREE (&ptr->table);
+  FREE (&ptr);
+  return table;
+}
+
 /* table        hash table to update
  * key          key to hash on
  * data         data to associate with `key'
@@ -90,6 +114,7 @@ int hash_insert (HASH * table, const char *key, void *data, int allow_dup)
   {
     ptr->next = table->table[h];
     table->table[h] = ptr;
+    table->curnelem++;
   }
   else
   {
@@ -112,6 +137,7 @@ int hash_insert (HASH * table, const char *key, void *data, int allow_dup)
     else
       table->table[h] = ptr;
     ptr->next = tmp;
+    table->curnelem++;
   }
   return h;
 }
@@ -142,6 +168,7 @@ void hash_delete_hash (HASH * table, int hash, const char *key, const void *data
       if (destroy)
 	destroy (ptr->data);
       FREE (&ptr);
+      table->curnelem--;
       
       ptr = *last;
     }
@@ -176,3 +203,30 @@ void hash_destroy (HASH **ptr, void (*destroy) (void *))
   FREE (&pptr->table);
   FREE (ptr);		/* __FREE_CHECKED__ */
 }
+
+struct hash_elem *hash_walk(const HASH *table, struct hash_walk_state *state)
+{
+  if (state->last && state->last->next)
+  {
+    state->last = state->last->next;
+    return state->last;
+  }
+
+  if (state->last)
+    state->index++;
+
+  while (state->index < table->nelem)
+  {
+    if (table->table[state->index])
+    {
+      state->last = table->table[state->index];
+      return state->last;
+    }
+    state->index++;
+  } 
+
+  state->index = 0;
+  state->last = NULL;
+  return NULL;
+}
+
diff --git a/hash.h b/hash.h
index fb77d0c..c944660 100644
--- a/hash.h
+++ b/hash.h
@@ -28,7 +28,7 @@ struct hash_elem
 
 typedef struct
 {
-  int nelem;
+  int nelem, curnelem;
   struct hash_elem **table;
   unsigned int (*hash_string)(const unsigned char *, unsigned int);
   int (*cmp_string)(const char *, const char *);
@@ -41,9 +41,17 @@ HASH;
 
 HASH *hash_create (int nelem, int lower);
 int hash_insert (HASH * table, const char *key, void *data, int allow_dup);
+HASH *hash_resize (HASH * table, int nelem, int lower);
 void *hash_find_hash (const HASH * table, int hash, const char *key);
 void hash_delete_hash (HASH * table, int hash, const char *key, const void *data,
 		       void (*destroy) (void *));
 void hash_destroy (HASH ** hash, void (*destroy) (void *));
 
+struct hash_walk_state {
+  int index;
+  struct hash_elem *last;
+};
+
+struct hash_elem *hash_walk(const HASH *table, struct hash_walk_state *state);
+
 #endif
diff --git a/hcache.c b/hcache.c
index fb6a561..de278ce 100644
--- a/hcache.c
+++ b/hcache.c
@@ -32,6 +32,9 @@
 #include <gdbm.h>
 #elif HAVE_DB4
 #include <db.h>
+#elif HAVE_LMDB
+#define LMDB_DB_SIZE    (1024 * 1024 * 1024)
+#include <lmdb.h>
 #endif
 
 #include <errno.h>
@@ -83,6 +86,15 @@ struct header_cache
 
 static void mutt_hcache_dbt_init(DBT * dbt, void *data, size_t len);
 static void mutt_hcache_dbt_empty_init(DBT * dbt);
+#elif HAVE_LMDB
+struct header_cache
+{
+  MDB_env *env;
+  MDB_txn *txn;
+  MDB_dbi db;
+  char *folder;
+  unsigned int crc;
+};
 #endif
 
 typedef union
@@ -439,13 +451,19 @@ dump_envelope(ENVELOPE * e, unsigned char *d, int *off, int convert)
   d = dump_char(e->message_id, d, off, 0);
   d = dump_char(e->supersedes, d, off, 0);
   d = dump_char(e->date, d, off, 0);
-  d = dump_char(e->x_label, d, off, convert);
 
   d = dump_buffer(e->spam, d, off, convert);
 
   d = dump_list(e->references, d, off, 0);
   d = dump_list(e->in_reply_to, d, off, 0);
   d = dump_list(e->userhdrs, d, off, convert);
+  d = dump_list(e->labels, d, off, convert);
+
+#ifdef USE_NNTP
+  d = dump_char(e->xref, d, off, 0);
+  d = dump_char(e->followup_to, d, off, 0);
+  d = dump_char(e->x_comment_to, d, off, convert);
+#endif
 
   return d;
 }
@@ -476,13 +494,19 @@ restore_envelope(ENVELOPE * e, const unsigned char *d, int *off, int convert)
   restore_char(&e->message_id, d, off, 0);
   restore_char(&e->supersedes, d, off, 0);
   restore_char(&e->date, d, off, 0);
-  restore_char(&e->x_label, d, off, convert);
 
   restore_buffer(&e->spam, d, off, convert);
 
   restore_list(&e->references, d, off, 0);
   restore_list(&e->in_reply_to, d, off, 0);
   restore_list(&e->userhdrs, d, off, convert);
+  restore_list(&e->labels, d, off, convert);
+
+#ifdef USE_NNTP
+  restore_char(&e->xref, d, off, 0);
+  restore_char(&e->followup_to, d, off, 0);
+  restore_char(&e->x_comment_to, d, off, convert);
+#endif
 }
 
 static int
@@ -732,6 +756,11 @@ mutt_hcache_fetch_raw (header_cache_t *h, const char *filename,
 #elif HAVE_DB4
   DBT key;
   DBT data;
+#elif HAVE_LMDB
+  MDB_val key;
+  MDB_val data;
+  size_t folderlen;
+  int rc;
 #endif
   
   if (!h)
@@ -748,6 +777,43 @@ mutt_hcache_fetch_raw (header_cache_t *h, const char *filename,
   h->db->get(h->db, NULL, &key, &data, 0);
   
   return data.data;
+#elif HAVE_LMDB
+  strncpy(path, h->folder, sizeof (path));
+  safe_strcat(path, sizeof (path), filename);
+
+  folderlen = strlen(h->folder);
+  ksize = folderlen + keylen(path + folderlen);  
+  key.mv_data = (char *)path;
+  key.mv_size = ksize;
+  data.mv_data = NULL;
+  data.mv_size = 0;
+  rc = mdb_txn_renew(h->txn);
+  if (rc != MDB_SUCCESS)
+  {
+    h->txn = NULL;
+    fprintf(stderr, "txn_renew: %s\n", mdb_strerror(rc));
+    return NULL;
+  }
+  rc = mdb_get(h->txn, h->db, &key, &data);
+  if (rc == MDB_NOTFOUND)
+  {
+    mdb_txn_reset(h->txn);
+    return NULL;
+  }
+  if (rc != MDB_SUCCESS)
+  {
+    fprintf(stderr, "mdb_get: %s\n", mdb_strerror(rc));
+    mdb_txn_reset(h->txn);
+    return NULL;
+  }
+  /* Caller frees the data we return, so I MUST make a copy of it */
+
+  char *d = safe_malloc(data.mv_size);
+  memcpy(d, data.mv_data, data.mv_size);
+  mdb_txn_reset(h->txn);
+
+  return d;
+
 #else
   strncpy(path, h->folder, sizeof (path));
   safe_strcat(path, sizeof (path), filename);
@@ -813,6 +879,12 @@ mutt_hcache_store_raw (header_cache_t* h, const char* filename, void* data,
 #elif HAVE_DB4
   DBT key;
   DBT databuf;
+#elif HAVE_LMDB
+  MDB_val key;
+  MDB_val databuf;
+  MDB_txn *txn;
+  size_t folderlen;
+  int rc;
 #endif
   
   if (!h)
@@ -831,6 +903,31 @@ mutt_hcache_store_raw (header_cache_t* h, const char* filename, void* data,
   databuf.ulen = dlen;
   
   return h->db->put(h->db, NULL, &key, &databuf, 0);
+#elif HAVE_LMDB
+  folderlen = strlen(h->folder);
+  strncpy(path, h->folder, sizeof (path));
+  safe_strcat(path, sizeof (path), filename);
+  ksize = folderlen + keylen(path + folderlen);
+
+  key.mv_data = (char *)path;
+  key.mv_size = ksize;
+  databuf.mv_data = data;
+  databuf.mv_size = dlen;
+  rc = mdb_txn_begin(h->env, NULL, 0, &txn);
+  if (rc != MDB_SUCCESS)
+  {
+    fprintf(stderr, "txn_begin: %s\n", mdb_strerror(rc));
+    return rc;
+  }
+  rc = mdb_put(txn, h->db, &key, &databuf, 0);
+  if (rc != MDB_SUCCESS)
+  {
+    fprintf(stderr, "mdb_put: %s\n", mdb_strerror(rc));
+    mdb_txn_abort(txn);
+    return rc;
+  }
+  rc = mdb_txn_commit(txn);
+  return rc;
 #else
   strncpy(path, h->folder, sizeof (path));
   safe_strcat(path, sizeof (path), filename);
@@ -1134,6 +1231,104 @@ mutt_hcache_delete(header_cache_t *h, const char *filename,
   mutt_hcache_dbt_init(&key, (void *) filename, keylen(filename));
   return h->db->del(h->db, NULL, &key, 0);
 }
+#elif HAVE_LMDB
+
+static int
+hcache_open_lmdb (struct header_cache* h, const char* path)
+{
+  int rc;
+
+  h->txn = NULL;
+
+  rc = mdb_env_create(&h->env);
+  if (rc != MDB_SUCCESS)
+  {
+    fprintf(stderr, "hcache_open_lmdb: mdb_env_create: %s", mdb_strerror(rc));
+    return -1;
+  }
+
+  mdb_env_set_mapsize(h->env, LMDB_DB_SIZE);
+
+  rc = mdb_env_open(h->env, path, MDB_NOSUBDIR, 0644);
+  if (rc != MDB_SUCCESS)
+  {
+    fprintf(stderr, "hcache_open_lmdb: mdb_env_open: %s", mdb_strerror(rc));
+    goto fail_env;
+  }
+
+  rc = mdb_txn_begin(h->env, NULL, MDB_RDONLY, &h->txn);
+  if (rc != MDB_SUCCESS)
+  {
+      fprintf(stderr, "hcache_open_lmdb: mdb_txn_begin: %s", mdb_strerror(rc));
+      goto fail_env;
+  }
+
+  rc = mdb_dbi_open(h->txn, NULL, MDB_CREATE, &h->db);
+  if (rc != MDB_SUCCESS)
+  {
+    fprintf(stderr, "hcache_open_lmdb: mdb_dbi_open: %s", mdb_strerror(rc));
+    goto fail_dbi;
+  }
+
+  mdb_txn_reset(h->txn);
+  return 0;
+
+fail_dbi:
+  mdb_txn_abort(h->txn);
+  h->txn = NULL;
+
+fail_env:
+  mdb_env_close(h->env);
+  return -1;
+}
+
+void
+mutt_hcache_close(header_cache_t *h)
+{
+  if (!h)
+    return;
+
+  mdb_env_close(h->env);
+  FREE (&h->folder);
+  FREE (&h);
+}
+
+int
+mutt_hcache_delete(header_cache_t *h, const char *filename,
+                   size_t(*keylen) (const char *fn))
+{
+  MDB_val key;
+  MDB_txn *txn;
+  int rc;
+
+  if (!h)
+    return -1;
+
+  if (filename[0] == '/')
+    filename++;
+
+  key.mv_data = (char *)filename;
+  key.mv_size = strlen(filename);
+  rc = mdb_txn_begin(h->env, NULL, 0, &txn);
+  if (rc != MDB_SUCCESS)
+  {
+    fprintf(stderr, "txn_begin: %s\n", mdb_strerror(rc));
+    return rc;
+  }
+  rc = mdb_del(txn, h->db, &key, NULL);
+  if (rc != MDB_SUCCESS)
+  {
+    if (rc != MDB_NOTFOUND)
+    {
+      fprintf(stderr, "mdb_del: %s\n", mdb_strerror(rc));
+    }
+    mdb_txn_abort(txn);
+    return rc;
+  }
+
+  mdb_txn_commit(txn);
+  return rc;
+}
 #endif
 
 header_cache_t *
@@ -1151,6 +1346,8 @@ mutt_hcache_open(const char *path, const char *folder, hcache_namer_t namer)
   hcache_open = hcache_open_gdbm;
 #elif HAVE_DB4
   hcache_open = hcache_open_db4;
+#elif HAVE_LMDB
+  hcache_open = hcache_open_lmdb;
 #endif
 
   /* Calculate the current hcache version from dynamic configuration */
@@ -1188,7 +1385,11 @@ mutt_hcache_open(const char *path, const char *folder, hcache_namer_t namer)
     hcachever = digest.intval;
   }
 
+#if HAVE_LMDB
+  h->db = 0;
+#else
   h->db = NULL;
+#endif
   h->folder = get_foldername(folder);
   h->crc = hcachever;
 
@@ -1223,6 +1424,11 @@ const char *mutt_hcache_backend (void)
 {
   return DB_VERSION_STRING;
 }
+#elif HAVE_LMDB
+const char *mutt_hcache_backend (void)
+{
+  return "lmdb " MDB_VERSION_STRING;
+}
 #elif HAVE_GDBM
 const char *mutt_hcache_backend (void)
 {
diff --git a/hdrline.c b/hdrline.c
index eef19e6..c1447ff 100644
--- a/hdrline.c
+++ b/hdrline.c
@@ -36,6 +36,10 @@
 #include <alloca.h>
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 int mutt_is_mail_list (ADDRESS *addr)
 {
   if (!mutt_match_rx_list (addr->mailbox, UnMailLists))
@@ -103,6 +107,38 @@ static int first_mailing_list (char *buf, size_t buflen, ADDRESS *a)
   return 0;
 }
 
+/**
+ * add_index_color - XXX
+ *
+ * Takes the color to embed, the buffer to manipulate and the buffer length as
+ * arguments.
+ * Returns the number of chars written.
+ */
+static size_t
+add_index_color (char *buf, size_t buflen, format_flag flags, char color)
+{
+  int len;
+
+  /* only add color markers if we are operating on main index entries. */
+  if (!(flags & MUTT_FORMAT_INDEX))
+    return 0;
+
+  if (color == MT_COLOR_INDEX) { /* buf might be uninitialized other cases */
+    len = mutt_strlen (buf);
+    buf += len;
+    buflen -= len;
+  }
+
+  if (buflen < 2)
+    return 0;
+
+  buf[0] = MUTT_SPECIAL_INDEX;
+  buf[1] = color;
+  buf[2] = '\0';
+
+  return 2;
+}
+
 static void make_from (ENVELOPE *hdr, char *buf, size_t len, int do_lists)
 {
   int me;
@@ -211,7 +247,10 @@ int mutt_user_is_recipient (HEADER *h)
  * %E = number of messages in current thread
  * %f = entire from line
  * %F = like %n, unless from self
+ * %g = newsgroup name (if compiled with NNTP support)
+ * %g = message labels (e.g. notmuch tags)
  * %i = message-id
+ * %I = initials of author
  * %l = number of lines in the message
  * %L = like %F, except `lists' are displayed first
  * %m = number of messages in the mailbox
@@ -227,6 +266,8 @@ int mutt_user_is_recipient (HEADER *h)
  * %T = $to_chars
  * %u = user (login) name of author
  * %v = first name of author, unless from self
+ * %W = where user is (organization)
+ * %x = `x-comment-to:' field (if present and compiled with NNTP support)
  * %X = number of MIME attachments
  * %y = `x-label:' field (if present)
  * %Y = `x-label:' field (if present, tree unfolded, and != parent's x-label)
@@ -256,6 +297,7 @@ hdr_format_str (char *dest,
 #define THREAD_NEW (threads && hdr->collapsed && hdr->num_hidden > 1 && mutt_thread_contains_unread (ctx, hdr) == 1)
 #define THREAD_OLD (threads && hdr->collapsed && hdr->num_hidden > 1 && mutt_thread_contains_unread (ctx, hdr) == 2)
   size_t len;
+  size_t colorlen;
 
   hdr = hfi->hdr;
   ctx = hfi->ctx;
@@ -266,18 +308,20 @@ hdr_format_str (char *dest,
     case 'A':
       if(hdr->env->reply_to && hdr->env->reply_to->mailbox)
       {
-	mutt_format_s (dest, destlen, prefix, mutt_addr_for_display (hdr->env->reply_to));
+        colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_AUTHOR);
+        mutt_format_s (dest + colorlen, destlen - colorlen, prefix, mutt_addr_for_display (hdr->env->reply_to));
+        add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
 	break;
       }
       /* fall through if 'A' returns nothing */
 
     case 'a':
+      colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_AUTHOR);
       if(hdr->env->from && hdr->env->from->mailbox)
-      {
-	mutt_format_s (dest, destlen, prefix, mutt_addr_for_display (hdr->env->from));
-      }
+        mutt_format_s (dest + colorlen, destlen - colorlen, prefix, mutt_addr_for_display (hdr->env->from));
       else
-        dest[0] = '\0';
+        mutt_format_s (dest + colorlen, destlen - colorlen, prefix, "");
+      add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
       break;
 
     case 'B':
@@ -307,12 +351,16 @@ hdr_format_str (char *dest,
       break;
     
     case 'c':
+      colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_SIZE);
       mutt_pretty_size (buf2, sizeof (buf2), (long) hdr->content->length);
-      mutt_format_s (dest, destlen, prefix, buf2);
+      mutt_format_s (dest + colorlen, destlen - colorlen, prefix, buf2);
+      add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
       break;
 
     case 'C':
-      snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
+      colorlen = add_index_color (fmt, sizeof (fmt), flags, MT_COLOR_INDEX_NUMBER);
+      snprintf (fmt + colorlen, sizeof (fmt) - colorlen, "%%%sd", prefix);
+      add_index_color (fmt + colorlen, sizeof (fmt) - colorlen, flags, MT_COLOR_INDEX);
       snprintf (dest, destlen, fmt, hdr->msgno + 1);
       break;
 
@@ -328,6 +376,98 @@ hdr_format_str (char *dest,
 	const char *cp;
 	struct tm *tm; 
 	time_t T;
+	int i = 0, invert = 0;
+
+	if (optional && ((op == '[') || (op == '('))) {
+	  char *is;
+	  T = time (NULL);
+	  tm = localtime (&T);
+	  T -= (op == '(') ? hdr->received : hdr->date_sent;
+
+	  is = (char *) prefix;
+	  if (*is == '>') {
+	    invert = 1;
+	    is++;
+	  }
+
+	  while (*is && (*is != '?')) {
+	    int t = strtol (is, &is, 10);
+	    /* semi-broken (assuming 30 days in all months) */
+	    switch (*(is++)) {
+	      case 'y':
+		if (t > 1) {
+		  t--;
+		  t *= (60 * 60 * 24 * 365);
+		}
+		t += ((tm->tm_mon  * 60 * 60 * 24 * 30) +
+		      (tm->tm_mday * 60 * 60 * 24) +
+		      (tm->tm_hour * 60 * 60) +
+		      (tm->tm_min  * 60) +
+		       tm->tm_sec);
+		break;
+
+	      case 'm':
+		if (t > 1) {
+		  t--;
+		  t *= (60 * 60 * 24 * 30);
+		}
+		t += ((tm->tm_mday * 60 * 60 * 24) +
+		      (tm->tm_hour * 60 * 60) +
+		      (tm->tm_min  * 60) +
+		      tm->tm_sec);
+		break;
+
+	      case 'w':
+		if (t > 1) {
+		  t--;
+		  t *= (60 * 60 * 24 * 7);
+		}
+		t += ((tm->tm_wday * 60 * 60 * 24) +
+		      (tm->tm_hour * 60 * 60) +
+		      (tm->tm_min  * 60) +
+		       tm->tm_sec);
+		break;
+
+	      case 'd':
+		if (t > 1) {
+		  t--;
+		  t *= (60 * 60 * 24);
+		}
+		t += ((tm->tm_hour * 60 * 60) +
+		      (tm->tm_min  * 60) +
+		       tm->tm_sec);
+		break;
+
+	      case 'H':
+		if (t > 1) {
+		  t--;
+		  t *= (60 * 60);
+		}
+		t += ((tm->tm_min * 60) +
+		       tm->tm_sec);
+		break;
+
+	      case 'M':
+		if (t > 1) {
+		  t--;
+		  t *= (60);
+		}
+		t += (tm->tm_sec);
+		break;
+
+	      default:
+		break;
+	    }
+	    i += t;
+	  }
+
+	  if (i < 0)
+	    i *= -1;
+
+	  if (((T > i) || (T < (-1*i))) ^ invert)
+	    optional = 0;
+	  break;
+	}
 
 	p = dest;
 
@@ -411,7 +551,10 @@ hdr_format_str (char *dest,
 	if (do_locales)
 	  setlocale (LC_TIME, "C");
 
-	mutt_format_s (dest, destlen, prefix, buf2);
+	colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_DATE);
+	mutt_format_s (dest + colorlen, destlen - colorlen, prefix, buf2);
+	add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
+
 	if (len > 0 && op != 'd' && op != 'D') /* Skip ending op */
 	  src = cp + 1;
       }
@@ -441,13 +584,28 @@ hdr_format_str (char *dest,
     case 'F':
       if (!optional)
       {
+        colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_AUTHOR);
         make_from (hdr->env, buf2, sizeof (buf2), 0);
-	mutt_format_s (dest, destlen, prefix, buf2);
+        mutt_format_s (dest + colorlen, destlen - colorlen, prefix, buf2);
+        add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
       }
       else if (mutt_addr_is_user (hdr->env->from))
         optional = 0;
       break;
 
+#ifdef USE_NOTMUCH
+    case 'g':
+      if (!optional)
+      {
+        colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_TAGS);
+        mutt_format_s (dest+colorlen, destlen-colorlen, prefix, nm_header_get_tags_transformed(hdr));
+        add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
+      }
+      else if (!nm_header_get_tags_transformed(hdr))
+        optional = 0;
+      break;
+#endif
+
     case 'H':
       /* (Hormel) spam score */
       if (optional)
@@ -460,15 +618,45 @@ hdr_format_str (char *dest,
 
       break;
 
+#ifdef USE_NNTP
+    case 'q':
+      mutt_format_s (dest, destlen, prefix, hdr->env->newsgroups ? hdr->env->newsgroups : "");
+      break;
+#endif
+
     case 'i':
       mutt_format_s (dest, destlen, prefix, hdr->env->message_id ? hdr->env->message_id : "<no.id>");
       break;
 
+    case 'I':
+      {
+	int iflag = FALSE;
+	int j = 0;
+
+	for (i = 0; hdr->env->from && hdr->env->from->personal &&
+		    hdr->env->from->personal[i] && (j < (SHORT_STRING - 1)); i++) {
+	  if (isalpha ((int) hdr->env->from->personal[i])) {
+	    if (!iflag) {
+	      buf2[j++] = hdr->env->from->personal[i];
+	      iflag = TRUE;
+	    }
+	  } else {
+	    iflag = FALSE;
+	  }
+	}
+
+	buf2[j] = '\0';
+      }
+      mutt_format_s (dest, destlen, prefix, buf2);
+      break;
+
     case 'l':
       if (!optional)
       {
 	snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
-	snprintf (dest, destlen, fmt, (int) hdr->lines);
+	colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_SIZE);
+	snprintf (dest + colorlen, destlen - colorlen, fmt, (int) hdr->lines);
+	add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
       }
       else if (hdr->lines <= 0)
         optional = 0;
@@ -477,8 +665,10 @@ hdr_format_str (char *dest,
     case 'L':
       if (!optional)
       {
+	colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_AUTHOR);
 	make_from (hdr->env, buf2, sizeof (buf2), 1);
-	mutt_format_s (dest, destlen, prefix, buf2);
+	mutt_format_s (dest + colorlen, destlen - colorlen, prefix, buf2);
+	add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
       }
       else if (!check_for_mailing_list (hdr->env->to, NULL, NULL, 0) &&
 	       !check_for_mailing_list (hdr->env->cc, NULL, NULL, 0))
@@ -498,7 +688,9 @@ hdr_format_str (char *dest,
       break;
 
     case 'n':
-      mutt_format_s (dest, destlen, prefix, mutt_get_name (hdr->env->from));
+      colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_AUTHOR);
+      mutt_format_s (dest + colorlen, destlen - colorlen, prefix, mutt_get_name (hdr->env->from));
+      add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
       break;
 
     case 'N':
@@ -533,10 +725,18 @@ hdr_format_str (char *dest,
       snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
       if (!optional)
       {
+	colorlen = add_index_color (dest, destlen, flags,
+				   MT_COLOR_INDEX_COLLAPSED);
 	if (threads && is_index && hdr->collapsed && hdr->num_hidden > 1)
-	  snprintf (dest, destlen, fmt, hdr->num_hidden);
+	{
+	  snprintf (dest + colorlen, destlen - colorlen, fmt, hdr->num_hidden);
+	  add_index_color (dest, destlen - colorlen, flags, MT_COLOR_INDEX);
+	}
 	else if (is_index && threads)
-	  mutt_format_s (dest, destlen, prefix, " ");
+	{
+	  mutt_format_s (dest + colorlen, destlen - colorlen, prefix, " ");
+	  add_index_color (dest, destlen - colorlen, flags, MT_COLOR_INDEX);
+	}
 	else
 	  *dest = '\0';
       }
@@ -573,7 +773,9 @@ hdr_format_str (char *dest,
       {
 	if (flags & MUTT_FORMAT_FORCESUBJ)
 	{
-	  mutt_format_s (dest, destlen, "", NONULL (hdr->env->subject));
+	  colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_SUBJECT);
+	  mutt_format_s (dest + colorlen, destlen - colorlen, "", NONULL (hdr->env->subject));
+	  add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
 	  snprintf (buf2, sizeof (buf2), "%s%s", hdr->tree, dest);
 	  mutt_format_s_tree (dest, destlen, prefix, buf2);
 	}
@@ -581,7 +783,11 @@ hdr_format_str (char *dest,
 	  mutt_format_s_tree (dest, destlen, prefix, hdr->tree);
       }
       else
-	mutt_format_s (dest, destlen, prefix, NONULL (hdr->env->subject));
+      {
+	colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_SUBJECT);
+	mutt_format_s (dest + colorlen, destlen - colorlen, prefix, NONULL (hdr->env->subject));
+	add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
+      }
       break;
 
     case 'S':
@@ -604,8 +810,11 @@ hdr_format_str (char *dest,
 
       /* FOO - this is probably unsafe, but we are not likely to have such
 	 a short string passed into this routine */
-      *dest = ch;
-      *(dest + 1) = 0;
+      buf2[0] = ch;
+      buf2[1] = 0;
+      colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_FLAGS);
+      mutt_format_s (dest + colorlen, destlen - colorlen, prefix, buf2);
+      add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
       break;
 
     case 't':
@@ -656,6 +865,22 @@ hdr_format_str (char *dest,
       mutt_format_s (dest, destlen, prefix, buf2);
       break;
 
+    case 'W':
+      if (!optional)
+	mutt_format_s (dest, destlen, prefix, hdr->env->organization ? hdr->env->organization : "");
+      else if (!hdr->env->organization)
+	optional = 0;
+      break;
+
+#ifdef USE_NNTP
+    case 'x':
+      if (!optional)
+	mutt_format_s (dest, destlen, prefix, hdr->env->x_comment_to ? hdr->env->x_comment_to : "");
+      else if (!hdr->env->x_comment_to)
+	optional = 0;
+      break;
+#endif
+
     case 'Z':
     
       ch = ' ';
@@ -677,7 +902,9 @@ hdr_format_str (char *dest,
 		hdr->tagged ? '*' :
 		(hdr->flagged ? '!' :
 		 (Tochars && ((i = mutt_user_is_recipient (hdr)) < mutt_strlen (Tochars)) ? Tochars[i] : ' ')));
-      mutt_format_s (dest, destlen, prefix, buf2);
+      colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_FLAGS);
+      mutt_format_s (dest + colorlen, destlen - colorlen, prefix, buf2);
+      add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
       break;
 
     case 'X':
@@ -695,40 +922,101 @@ hdr_format_str (char *dest,
 
      case 'y':
        if (optional)
-	 optional = hdr->env->x_label ? 1 : 0;
+	 optional = hdr->env->labels ? 1 : 0;
 
-       mutt_format_s (dest, destlen, prefix, NONULL (hdr->env->x_label));
+       colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_LABEL);
+       mutt_format_s (dest + colorlen, destlen - colorlen, prefix, mutt_labels(NULL, 0, hdr->env, NULL));
+       add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
        break;
  
     case 'Y':
-      if (hdr->env->x_label)
+      if (hdr->env->labels == NULL)
       {
-	i = 1;	/* reduce reuse recycle */
-	htmp = NULL;
-	if (flags & MUTT_FORMAT_TREE
-	    && (hdr->thread->prev && hdr->thread->prev->message
-		&& hdr->thread->prev->message->env->x_label))
-	  htmp = hdr->thread->prev->message;
-	else if (flags & MUTT_FORMAT_TREE
-		 && (hdr->thread->parent && hdr->thread->parent->message
-		     && hdr->thread->parent->message->env->x_label))
-	  htmp = hdr->thread->parent->message;
-	if (htmp && mutt_strcasecmp (hdr->env->x_label,
-				     htmp->env->x_label) == 0)
-	  i = 0;
+        if (optional)
+          optional = 0;
+        mutt_format_s(dest, destlen, prefix, "");
+        break;
       }
       else
-	i = 0;
+      {
+        char labels[HUGE_STRING];
+        char labelstmp[HUGE_STRING];
+
+        i = 1;  /* reduce reuse recycle */
+        htmp = NULL;
+        if ((flags & MUTT_FORMAT_TREE) &&
+            hdr->thread->prev &&
+            hdr->thread->prev->message &&
+            hdr->thread->prev->message->env->labels)
+          htmp = hdr->thread->prev->message;
+        else if ((flags & MUTT_FORMAT_TREE) &&
+                 hdr->thread->parent &&
+                 hdr->thread->parent->message &&
+                 hdr->thread->parent->message->env->labels)
+          htmp = hdr->thread->parent->message;
+
+        mutt_labels(labels, sizeof(labels), hdr->env, NULL);
+        if (htmp)
+        {
+          mutt_labels(labelstmp, sizeof(labelstmp), htmp->env, NULL);
+          if (htmp && mutt_strcasecmp (labels, labelstmp) == 0)
+            i = 0;
+        }
+
+        if (optional)
+	  optional = i;
+
+        colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_LABEL);
+        if (i)
+	  mutt_format_s (dest + colorlen, destlen - colorlen, prefix, labels);
+        else
+          mutt_format_s (dest + colorlen, destlen - colorlen, prefix, "");
+        add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
+      }
 
-      if (optional)
-	optional = i;
+      break;
 
-      if (i)
-        mutt_format_s (dest, destlen, prefix, NONULL (hdr->env->x_label));
+#ifdef USE_NOTMUCH
+    case 'G':
+    {
+      char *tag_transformed;
+      char format[3];
+      char *tag;
+
+      if (!optional)
+      {
+        format[0] = op;
+        format[1] = *src;
+        format[2] = 0;
+
+        tag = hash_find(TagFormats, format);
+        if (tag != NULL)
+        {
+            tag_transformed = nm_header_get_tag_transformed(tag, hdr);
+
+            colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_TAG);
+            mutt_format_s (dest+colorlen, destlen-colorlen, prefix,
+                           (tag_transformed) ? tag_transformed : "");
+            add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
+        }
+
+        src++;
+      }
       else
-        mutt_format_s (dest, destlen, prefix, "");
+      {
+        format[0] = op;
+        format[1] = *prefix;
+        format[2] = 0;
+
+        tag = hash_find(TagFormats, format);
+        if (tag != NULL)
+          if (nm_header_get_tag_transformed(tag, hdr) == NULL)
+            optional = 0;
+      }
 
       break;
+    }
+#endif
 
     default:
       snprintf (dest, destlen, "%%%s%c", prefix, op);
diff --git a/headers.c b/headers.c
index 0a75998..3924488 100644
--- a/headers.c
+++ b/headers.c
@@ -114,6 +114,9 @@ void mutt_edit_headers (const char *editor,
      $edit_headers set, we remove References: as they're likely invalid;
      we can simply compare strings as we don't generate References for
      multiple Message-Ids in IRT anyways */
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
   if (msg->env->in_reply_to &&
       (!n->in_reply_to || mutt_strcmp (n->in_reply_to->data,
 				       msg->env->in_reply_to->data) != 0))
@@ -211,3 +214,197 @@ void mutt_edit_headers (const char *editor,
     }
   }
 }
+
+void mutt_label_ref_dec(ENVELOPE *env)
+{
+  uintptr_t count;
+  LIST *label;
+
+  if (!env || !env->labels || !Labels)
+    return;
+
+  for (label = env->labels; label; label = label->next)
+  {
+    if (label->data == NULL)
+      continue;
+    count = (uintptr_t)hash_find(Labels, label->data);
+    if (count)
+    {
+      hash_delete(Labels, label->data, NULL, NULL);
+      count--;
+      if (count > 0)
+        hash_insert(Labels, label->data, (void *)count, 0);
+    }
+    dprint(1, (debugfile, "--label %s: %d\n", label->data, count));
+  }
+}
+
+void mutt_label_ref_inc(ENVELOPE *env)
+{
+  uintptr_t count;
+  LIST *label;
+
+  if (!env || !env->labels || !Labels)
+    return;
+
+  for (label = env->labels; label; label = label->next)
+  {
+    if (label->data == NULL)
+      continue;
+    count = (uintptr_t)hash_find(Labels, label->data);
+    if (count)
+      hash_delete(Labels, label->data, NULL, NULL);
+    count++;  /* was zero if not found */
+    hash_insert(Labels, label->data, (void *)count, 0);
+    dprint(1, (debugfile, "++label %s: %d\n", label->data, count));
+  }
+}
+
+/*
+ * set labels on a message
+ */
+static int label_message(HEADER *hdr, char *new)
+{
+  if (hdr == NULL)
+    return 0;
+  if (hdr->env->labels == NULL && new == NULL)
+    return 0;
+  if (hdr->env->labels != NULL && new != NULL)
+  {
+    char old[HUGE_STRING];
+    mutt_labels(old, sizeof(old), hdr->env, NULL);
+    if (!strcmp(old, new))
+      return 0;
+  }
+
+  if (hdr->env->labels != NULL)
+  {
+    mutt_label_ref_dec(hdr->env);
+    mutt_free_list(&hdr->env->labels);
+  }
+
+  if (new == NULL)
+    hdr->env->labels = NULL;
+  else
+  {
+    char *last, *label;
+
+    for (label = strtok_r(new, ",", &last); label;
+         label = strtok_r(NULL, ",", &last)) 
+    {
+      SKIPWS(label);
+      if (mutt_find_list(hdr->env->labels, label))
+        continue;
+      if (hdr->env->labels == NULL)
+      {
+        hdr->env->labels = mutt_new_list();
+        hdr->env->labels->data = safe_strdup(label);
+      }
+      else
+        mutt_add_list(hdr->env->labels, label);
+    }
+    mutt_label_ref_inc(hdr->env);
+  }
+  return hdr->changed = hdr->label_changed = 1;
+}
+
+int mutt_label_message(HEADER *hdr)
+{
+  char buf[LONG_STRING], *new;
+  int i;
+  int changed;
+
+  *buf = '\0';
+  if (hdr != NULL && hdr->env->labels != NULL)
+    mutt_labels(buf, sizeof(buf)-2, hdr->env, NULL);
+
+  /* add a comma-space so that new typing is a new keyword */
+  if (buf[0])
+    strcat(buf, ", ");    /* __STRCAT_CHECKED__ */
+
+  if (mutt_get_field("Label: ", buf, sizeof(buf), MUTT_LABEL /* | MUTT_CLEAR */) != 0)
+    return 0;
+
+  new = buf;
+  SKIPWS(new);
+  if (new && *new)
+  {
+    char *p;
+    int len = strlen(new);
+    p = &new[len]; /* '\0' */
+    while (p > new)
+    {
+      if (!isspace((unsigned char)*(p-1)) && *(p-1) != ',')
+        break;
+      p--;
+    }
+    *p = '\0';
+  }
+  if (*new == '\0')
+    new = NULL;
+
+  changed = 0;
+  if (hdr != NULL) {
+    changed += label_message(hdr, new);
+  } else {
+#define HDR_OF(index) Context->hdrs[Context->v2r[(index)]]
+    for (i = 0; i < Context->vcount; ++i) {
+      if (HDR_OF(i)->tagged)
+        if (label_message(HDR_OF(i), new)) {
+          ++changed;
+        }
+    }
+  }
+
+  return changed;
+}
+
+/* scan a context (mailbox) and hash all labels we find */
+void mutt_scan_labels(CONTEXT *ctx)
+{
+  int i;
+
+  if (!ctx)
+    return;
+
+  for (i = 0; i < ctx->msgcount; i++)
+    if (ctx->hdrs[i]->env->labels)
+      mutt_label_ref_inc(ctx->hdrs[i]->env);
+}
+
+
+char *mutt_labels(char *dst, int sz, ENVELOPE *env, char *sep)
+{
+  static char sbuf[HUGE_STRING];
+  int off = 0;
+  int len;
+  LIST *label;
+
+  if (sep == NULL)
+    sep = ", ";
+
+  if (dst == NULL)
+  {
+    dst = sbuf;
+    sz = sizeof(sbuf);
+  }
+
+  *dst = '\0';
+
+  for (label = env->labels; label; label = label->next)
+  {
+    if (label->data == NULL)
+      continue;
+    len = MIN(mutt_strlen(label->data), sz-off);
+    strfcpy(&dst[off], label->data, len+1);
+    off += len;
+    if (label->next)
+    {
+      len = MIN(mutt_strlen(sep), sz-off);
+      strfcpy(&dst[off], sep, len+1);
+      off += len;
+    }
+  }
+
+  return dst;
+}
diff --git a/hook.c b/hook.c
index 1b906c3..dbf78d5 100644
--- a/hook.c
+++ b/hook.c
@@ -24,6 +24,10 @@
 #include "mailbox.h"
 #include "mutt_crypt.h"
 
+#ifdef USE_COMPRESSED
+#include "compress.h"
+#endif
+
 #include <limits.h>
 #include <string.h>
 #include <stdlib.h>
@@ -109,6 +113,14 @@ int mutt_parse_hook (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
     memset (&pattern, 0, sizeof (pattern));
     pattern.data = safe_strdup (path);
   }
+#ifdef USE_COMPRESSED
+  else if (data & (MUTT_APPENDHOOK | MUTT_OPENHOOK | MUTT_CLOSEHOOK)) {
+    if (comp_valid_command (command.data) == 0) {
+      strfcpy (err->data, _("badly formatted command string"), err->dsize);
+      return -1;
+    }
+  }
+#endif
   else if (DefaultHook && !(data & (MUTT_CHARSETHOOK | MUTT_ICONVHOOK | MUTT_ACCOUNTHOOK))
            && (!WithCrypto || !(data & MUTT_CRYPTHOOK))
       )
@@ -142,7 +154,7 @@ int mutt_parse_hook (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
 	ptr->rx.not == not &&
 	!mutt_strcmp (pattern.data, ptr->rx.pattern))
     {
-      if (data & (MUTT_FOLDERHOOK | MUTT_SENDHOOK | MUTT_SEND2HOOK | MUTT_MESSAGEHOOK | MUTT_ACCOUNTHOOK | MUTT_REPLYHOOK | MUTT_CRYPTHOOK))
+      if (data & (MUTT_FOLDERHOOK | MUTT_SENDHOOK | MUTT_SEND2HOOK | MUTT_MESSAGEHOOK | MUTT_ACCOUNTHOOK | MUTT_REPLYHOOK | MUTT_CRYPTHOOK | MUTT_TIMEOUTHOOK))
       {
 	/* these hooks allow multiple commands with the same
 	 * pattern, so if we've already seen this pattern/command pair, just
@@ -362,7 +374,7 @@ void mutt_message_hook (CONTEXT *ctx, HEADER *hdr, int type)
 
     if (hook->type & type)
       if ((mutt_pattern_exec (hook->pattern, 0, ctx, hdr) > 0) ^ hook->rx.not)
-	if (mutt_parse_rc_line (hook->command, &token, &err) != 0)
+	if (mutt_parse_rc_line (hook->command, &token, &err) == -1)
 	{
 	  FREE (&token.data);
 	  mutt_error ("%s", err.data);
@@ -542,3 +554,32 @@ void mutt_account_hook (const char* url)
   FREE (&err.data);
 }
 #endif
+
+void mutt_timeout_hook (void)
+{
+  HOOK *hook;
+  BUFFER token;
+  BUFFER err;
+  char buf[STRING];
+
+  err.data = buf;
+  err.dsize = sizeof (buf);
+  memset (&token, 0, sizeof (token));
+
+  for (hook = Hooks; hook; hook = hook->next)
+  {
+    if (!(hook->command && (hook->type & MUTT_TIMEOUTHOOK)))
+      continue;
+
+    if (mutt_parse_rc_line (hook->command, &token, &err) == -1)
+    {
+      FREE (&token.data);
+      mutt_error ("%s", err.data);
+      mutt_sleep (1);
+
+      /* The hooks should be independent of each other, so even though this on
+       * failed, we'll carry on with the others. */
+    }
+  }
+}
+
diff --git a/imap/imap.c b/imap/imap.c
index 2e3d27d..f560161 100644
--- a/imap/imap.c
+++ b/imap/imap.c
@@ -306,7 +306,7 @@ static int imap_check_capabilities (IMAP_DATA* idata)
   if (!(mutt_bit_isset(idata->capabilities,IMAP4)
       ||mutt_bit_isset(idata->capabilities,IMAP4REV1)))
   {
-    mutt_error _("This IMAP server is ancient. Mutt does not work with it.");
+    mutt_error _("This IMAP server is ancient. NeoMutt does not work with it.");
     mutt_sleep (2);	/* pause a moment to let the user see the error */
 
     return -1;
@@ -1240,7 +1240,7 @@ int imap_sync_mailbox (CONTEXT* ctx, int expunge, int* index_hint)
        * we delete the message and reupload it.
        * This works better if we're expunging, of course. */
       if ((h->env && (h->env->refs_changed || h->env->irt_changed)) ||
-	  h->attach_del)
+	  h->attach_del || h->label_changed)
       {
         mutt_message (_("Saving changed messages... [%d/%d]"), n+1,
                       ctx->msgcount);
@@ -1250,6 +1250,7 @@ int imap_sync_mailbox (CONTEXT* ctx, int expunge, int* index_hint)
 	  dprint (1, (debugfile, "imap_sync_mailbox: Error opening mailbox in append mode\n"));
 	else
 	  _mutt_save_message (h, appendctx, 1, 0, 0);
+	h->label_changed = 0;
       }
     }
   }
diff --git a/imap/message.c b/imap/message.c
index 5ce5858..8211d3a 100644
--- a/imap/message.c
+++ b/imap/message.c
@@ -69,7 +69,7 @@ int imap_read_headers (IMAP_DATA* idata, int msgbegin, int msgend)
   int rc, mfhrc, oldmsgcount;
   int fetchlast = 0;
   int maxuid = 0;
-  static const char * const want_headers = "DATE FROM SUBJECT TO CC MESSAGE-ID REFERENCES CONTENT-TYPE CONTENT-DESCRIPTION IN-REPLY-TO REPLY-TO LINES LIST-POST X-LABEL";
+  static const char * const want_headers = "DATE FROM SUBJECT TO CC MESSAGE-ID REFERENCES CONTENT-TYPE CONTENT-DESCRIPTION IN-REPLY-TO REPLY-TO LINES LIST-POST X-LABEL X-KEYWORDS X-MOZILLA-KEYS KEYWORDS";
   progress_t progress;
   int retval = -1;
 
@@ -407,6 +407,7 @@ int imap_fetch_message (CONTEXT *ctx, MESSAGE *msg, int msgno)
   IMAP_CACHE *cache;
   int read;
   int rc;
+
   /* Sam's weird courier server returns an OK response even when FETCH
    * fails. Thanks Sam. */
   short fetched = 0;
diff --git a/init.c b/init.c
index 0586638..800e07e 100644
--- a/init.c
+++ b/init.c
@@ -32,12 +32,15 @@
 #include "mutt_crypt.h"
 #include "mutt_idna.h"
 #include "group.h"
+#include "version.h"
 
 #if defined(USE_SSL)
 #include "mutt_ssl.h"
 #endif
 
-
+#if USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
 
 #include "mx.h"
 #include "init.h"
@@ -76,6 +79,12 @@ static void myvar_set (const char* var, const char* val);
 static const char* myvar_get (const char* var);
 static void myvar_del (const char* var);
 
+#if USE_NOTMUCH
+/* List of tags found in last call to mutt_nm_query_complete(). */
+static char **nm_tags;
+#endif
+
+
 static void toggle_quadoption (int opt)
 {
   int n = opt/4;
@@ -601,6 +610,125 @@ static void remove_from_list (LIST **l, const char *str)
   }
 }
 
+/**
+ * finish_source - 'finish' command: stop processing current config file
+ * @tmp:  Temporary space shared by all command handlers
+ * @s:    Current line of the config file
+ * @data: data field from init.h:struct command_t
+ * @err:  Buffer for any error message
+ *
+ * If the 'finish' command is found, we should stop reading the current file.
+ *
+ * Returns:
+ *       1 Stop processing the current file
+ *      -1 Failed
+ */
+static int finish_source (BUFFER *tmp, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  if (MoreArgs (s))
+  {
+    snprintf (err->data, err->dsize, _("finish: too many arguments"));
+    return -1;
+  }
+
+  return 1;
+}
+
+/**
+ * parse_ifdef - 'ifdef' command: conditional config
+ * @tmp:  Temporary space shared by all command handlers
+ * @s:    Current line of the config file
+ * @data: data field from init.h:struct command_t
+ * @err:  Buffer for any error message
+ *
+ * The 'ifdef' command allows conditional elements in the config file.
+ * If a given variable, function, command or compile-time symbol exists, then
+ * read the rest of the line of config commands.
+ * e.g.
+ *      ifdef USE_SIDEBAR source ~/.mutt/sidebar.rc
+ *
+ * If (data == 1) then it means use the 'ifndef' (if-not-defined) command.
+ * e.g.
+ *      ifndef USE_IMAP finish
+ *
+ * Returns:
+ *       0 Success
+ *      -1 Failed
+ */
+static int parse_ifdef (BUFFER *tmp, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  int i, j, res = 0;
+  BUFFER token;
+
+  memset (&token, 0, sizeof (token));
+  mutt_extract_token (tmp, s, 0);
+
+  /* is the item defined as a variable? */
+  res = (mutt_option_index (tmp->data) != -1);
+
+  /* is the item a compiled-in feature? */
+  if (!res)
+  {
+    res = feature_enabled (tmp->data);
+  }
+
+  /* or a function? */
+  if (!res)
+  {
+    for (i = 0; !res && (i < MENU_MAX); i++)
+    {
+      const struct binding_t *b = km_get_table (Menus[i].value);
+      if (!b)
+        continue;
+
+      for (j = 0; b[j].name; j++)
+      {
+        if (mutt_strcmp (tmp->data, b[j].name) == 0)
+        {
+          res = 1;
+          break;
+        }
+      }
+    }
+  }
+
+  /* or a command? */
+  if (!res)
+  {
+    for (i = 0; Commands[i].name; i++)
+    {
+      if (mutt_strcmp (tmp->data, Commands[i].name) == 0)
+      {
+        res = 1;
+        break;
+      }
+    }
+  }
+
+  if (!MoreArgs (s))
+  {
+    snprintf (err->data, err->dsize, _("%s: too few arguments"),
+      (data ? "ifndef" : "ifdef"));
+    return -1;
+  }
+  mutt_extract_token (tmp, s, MUTT_TOKEN_SPACE);
+
+  /* ifdef KNOWN_SYMBOL or ifndef UNKNOWN_SYMBOL */
+  if ((res && (data == 0)) || (!res && (data == 1)))
+  {
+                int rc = mutt_parse_rc_line (tmp->data, &token, err);
+    if (rc == -1)
+    {
+      mutt_error ("Error: %s", err->data);
+      FREE(&token.data);
+      return -1;
+    }
+    FREE(&token.data);
+                return rc;
+  }
+  return 0;
+}
+
 static int parse_unignore (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
 {
   do
@@ -2253,7 +2381,7 @@ static int parse_set (BUFFER *tmp, BUFFER *s, unsigned long data, BUFFER *err)
 static int source_rc (const char *rcfile, BUFFER *err)
 {
   FILE *f;
-  int line = 0, rc = 0, conv = 0;
+  int line = 0, rc = 0, conv = 0, line_rc;
   BUFFER token;
   char *linebuf = NULL;
   char *currentline = NULL;
@@ -2282,17 +2410,17 @@ static int source_rc (const char *rcfile, BUFFER *err)
     else 
       currentline=linebuf;
 
-    if (mutt_parse_rc_line (currentline, &token, err) == -1)
-    {
+    line_rc = mutt_parse_rc_line (currentline, &token, err);
+    if (line_rc == -1) {
       mutt_error (_("Error in %s, line %d: %s"), rcfile, line, err->data);
       if (--rc < -MAXERRS) 
       {
         if (conv) FREE(&currentline);
         break;
       }
-    }
-    else
-    {
+    } else if (line_rc == 1) {
+      break;	/* Found "finish" command */
+    } else {
       if (rc < 0)
         rc = -1;
     }
@@ -2347,7 +2475,7 @@ static int parse_source (BUFFER *tmp, BUFFER *s, unsigned long data, BUFFER *err
    err		where to write error messages */
 int mutt_parse_rc_line (/* const */ char *line, BUFFER *token, BUFFER *err)
 {
-  int i, r = -1;
+  int i, r = 0;
   BUFFER expn;
 
   if (!line || !*line)
@@ -2374,22 +2502,24 @@ int mutt_parse_rc_line (/* const */ char *line, BUFFER *token, BUFFER *err)
     {
       if (!mutt_strcmp (token->data, Commands[i].name))
       {
-	if (Commands[i].func (token, &expn, Commands[i].data, err) != 0)
-	  goto finish;
-        break;
+        r = Commands[i].func (token, &expn, Commands[i].data, err);
+        if (r != 0) {   /* -1 Error, +1 Finish */
+          goto finish;  /* Propagate return code */
+        }
+        break;          /* Continue with next command */
       }
     }
     if (!Commands[i].name)
     {
       snprintf (err->data, err->dsize, _("%s: unknown command"), NONULL (token->data));
-      goto finish;
+      r = -1;
+      break;            /* Ignore the rest of the line */
     }
   }
-  r = 0;
 finish:
   if (expn.destroy)
     FREE (&expn.data);
-  return (r);
+  return r;
 }
 
 
@@ -2648,6 +2778,182 @@ int mutt_var_value_complete (char *buffer, size_t len, int pos)
   return 0;
 }
 
+#if USE_NOTMUCH
+
+/* Fetch a list of all notmuch tags and insert them into the completion
+ * machinery.
+ */
+static int complete_all_nm_tags (const char *pt)
+{
+  int num;
+  int tag_count_1 = 0;
+  int tag_count_2 = 0;
+
+  Num_matched = 0;
+  strfcpy (User_typed, pt, sizeof (User_typed));
+  memset (Matches, 0, Matches_listsize);
+  memset (Completed, 0, sizeof (Completed));
+
+  nm_longrun_init(Context, FALSE);
+
+  /* Work out how many tags there are. */
+  if (nm_get_all_tags(Context, NULL, &tag_count_1) || tag_count_1 == 0)
+    goto done;
+
+  /* Free the old list, if any. */
+  if (nm_tags != NULL) {
+    int i;
+    for (i = 0; nm_tags[i] != NULL; i++)
+      FREE (&nm_tags[i]);
+    FREE (&nm_tags);
+  }
+  /* Allocate a new list, with sentinel. */
+  nm_tags = safe_malloc((tag_count_1 + 1) * sizeof (char *));
+  nm_tags[tag_count_1] = NULL;
+
+  /* Get all the tags. */
+  if (nm_get_all_tags(Context, nm_tags, &tag_count_2) ||
+      tag_count_1 != tag_count_2) {
+    FREE (&nm_tags);
+    nm_tags = NULL;
+    nm_longrun_done(Context);
+    return -1;
+  }
+
+  /* Put them into the completion machinery. */
+  for (num = 0; num < tag_count_1; num++) {
+    candidate (Completed, User_typed, nm_tags[num], sizeof (Completed));
+  }
+
+  matches_ensure_morespace (Num_matched);
+  Matches[Num_matched++] = User_typed;
+
+done:
+  nm_longrun_done(Context);
+  return 0;
+}
+
+/* Return the last instance of needle in the haystack, or NULL.
+ * Like strstr(), only backwards, and for a limited haystack length.
+ */
+static const char* rstrnstr(const char* haystack,
+                            size_t haystack_length,
+                            const char* needle)
+{
+  int needle_length = strlen(needle);
+  const char* haystack_end = haystack + haystack_length - needle_length;
+  const char* p;
+
+  for (p = haystack_end; p >= haystack; --p)
+  {
+    size_t i;
+    for (i = 0; i < needle_length; ++i) {
+      if (p[i] != needle[i])
+        goto next;
+    }
+    return p;
+
+    next:;
+  }
+  return NULL;
+}
+
+/* Complete the nearest "tag:"-prefixed string previous to pos. */
+int mutt_nm_query_complete (char *buffer, size_t len, int pos, int numtabs)
+{
+  char *pt = buffer;
+  int spaces;
+
+  SKIPWS (buffer);
+  spaces = buffer - pt;
+
+  pt = (char *)rstrnstr((char *)buffer, pos, "tag:");
+  if (pt != NULL) {
+    pt += 4;
+    if (numtabs == 1) {
+      /* First TAB. Collect all the matches */
+      complete_all_nm_tags(pt);
+
+      /* All matches are stored. Longest non-ambiguous string is ""
+       * i.e. don't change 'buffer'. Fake successful return this time.
+       */
+      if (User_typed[0] == 0)
+	return 1;
+    }
+
+    if (Completed[0] == 0 && User_typed[0])
+      return 0;
+
+    /* Num_matched will _always_ be atleast 1 since the initial
+     * user-typed string is always stored */
+    if (numtabs == 1 && Num_matched == 2)
+      snprintf(Completed, sizeof(Completed),"%s", Matches[0]);
+    else if (numtabs > 1 && Num_matched > 2)
+      /* cycle thru all the matches */
+      snprintf(Completed, sizeof(Completed), "%s",
+	       Matches[(numtabs - 2) % Num_matched]);
+
+    /* return the completed query */
+    strncpy (pt, Completed, buffer + len - pt - spaces);
+  }
+  else
+    return 0;
+
+  return 1;
+}
+
+/* Complete the nearest "+" or "-" -prefixed string previous to pos. */
+int mutt_nm_tag_complete (char *buffer, size_t len, int pos, int numtabs)
+{
+  char *pt = buffer;
+  int spaces;
+  const char *first_plus = NULL;
+  const char *first_minus = NULL;
+
+  SKIPWS (buffer);
+  spaces = buffer - pt;
+
+  first_plus = rstrnstr((char *)buffer, pos, "+");
+  first_minus = rstrnstr((char *)buffer, pos, "-");
+  pt = (char *)MAX(first_plus, first_minus);
+
+  if (pt != NULL) {
+    pt++;
+
+    if (numtabs == 1)
+    {
+      /* First TAB. Collect all the matches */
+      complete_all_nm_tags(pt);
+
+      /* All matches are stored. Longest non-ambiguous string is ""
+       * i.e. don't change 'buffer'. Fake successful return this time.
+       */
+      if (User_typed[0] == 0)
+	return 1;
+    }
+
+    if (Completed[0] == 0 && User_typed[0])
+      return 0;
+
+    /* Num_matched will _always_ be atleast 1 since the initial
+     * user-typed string is always stored */
+    if (numtabs == 1 && Num_matched == 2)
+      snprintf(Completed, sizeof(Completed),"%s", Matches[0]);
+    else if (numtabs > 1 && Num_matched > 2)
+      /* cycle thru all the matches */
+      snprintf(Completed, sizeof(Completed), "%s",
+	       Matches[(numtabs - 2) % Num_matched]);
+
+    /* return the completed query */
+    strncpy (pt, Completed, buffer + len - pt - spaces);
+  }
+  else
+    return 0;
+
+  return 1;
+}
+#endif
+
 static int var_to_string (int idx, char* val, size_t len)
 {
   char tmp[LONG_STRING];
@@ -2844,15 +3150,15 @@ static void start_debug (void)
   /* rotate the old debug logs */
   for (i=3; i>=0; i--)
   {
-    snprintf (buf, sizeof(buf), "%s/.muttdebug%d", NONULL(Homedir), i);
-    snprintf (buf2, sizeof(buf2), "%s/.muttdebug%d", NONULL(Homedir), i+1);
+    snprintf (buf, sizeof(buf), "%s/.nmuttdebug%d", NONULL(Homedir), i);
+    snprintf (buf2, sizeof(buf2), "%s/.nmuttdebug%d", NONULL(Homedir), i+1);
     rename (buf, buf2);
   }
   if ((debugfile = safe_fopen(buf, "w")) != NULL)
   {
     setbuf (debugfile, NULL); /* don't buffer the debugging output! */
-    dprint(1,(debugfile,"Mutt/%s (%s) debugging at level %d\n",
-	      MUTT_VERSION, ReleaseDate, debuglevel));
+    dprint(1,(debugfile,"NeoMutt/%s (%s) debugging at level %d\n",
+				PACKAGE_VERSION, OldMuttVer, debuglevel));
   }
 }
 #endif
@@ -2867,7 +3173,7 @@ static int mutt_execute_commands (LIST *p)
   mutt_buffer_init (&token);
   for (; p; p = p->next)
   {
-    if (mutt_parse_rc_line (p->data, &token, &err) != 0)
+    if (mutt_parse_rc_line (p->data, &token, &err) == -1)
     {
       fprintf (stderr, _("Error in command line: %s\n"), err.data);
       FREE (&token.data);
@@ -2882,23 +3188,6 @@ static int mutt_execute_commands (LIST *p)
   return 0;
 }
 
-static void mutt_srandom (void)
-{
-  struct timeval tv;
-  unsigned seed;
-
-  gettimeofday(&tv, NULL);
-  /* POSIX.1-2008 states that seed is 'unsigned' without specifying its width.
-   * Use as many of the lower order bits from the current time of day as the seed.
-   * If the upper bound is truncated, that is fine.
-   *
-   * tv_sec is integral of type integer or float.  Cast to 'long long' before
-   * bitshift in case it is a float.
-   */
-  seed = ((LONGLONG) tv.tv_sec << 20) | tv.tv_usec;
-  srandom(seed);
-}
-
 void mutt_init (int skip_sys_rc, LIST *commands)
 {
   struct passwd *pw;
@@ -2915,15 +3204,15 @@ void mutt_init (int skip_sys_rc, LIST *commands)
 
   Groups = hash_create (1031, 0);
   ReverseAlias = hash_create (1031, 1);
-  
+#ifdef USE_NOTMUCH
+  TagTransforms = hash_create (64, 1);
+  TagFormats = hash_create (64, 0);
+#endif
+
   mutt_menu_init ();
-  mutt_srandom ();
 
-  /* 
-   * XXX - use something even more difficult to predict?
-   */
   snprintf (AttachmentMarker, sizeof (AttachmentMarker),
-	    "\033]9;%ld\a", (long) time (NULL));
+	    "\033]9;%" PRIu64 "\a", mutt_rand64());
   
   /* on one of the systems I use, getcwd() does not return the same prefix
      as is listed in the passwd file */
@@ -3017,6 +3306,28 @@ void mutt_init (int skip_sys_rc, LIST *commands)
     Fqdn = safe_strdup(utsname.nodename);
 
 
+#ifdef USE_NNTP
+  {
+    FILE *f;
+    char *i;
+
+    if ((f = safe_fopen (SYSCONFDIR "/nntpserver", "r")))
+    {
+      buffer[0] = '\0';
+      fgets (buffer, sizeof (buffer), f);
+      p = buffer;
+      SKIPWS (p);
+      i = p;
+      while (*i && (*i != ' ') && (*i != '\t') && (*i != '\r') && (*i != '\n')) i++;
+      *i = '\0';
+      NewsServer = safe_strdup (p);
+      fclose (f);
+    }
+  }
+  if ((p = getenv ("NNTPSERVER")))
+    NewsServer = safe_strdup (p);
+#endif
+
   if ((p = getenv ("MAIL")))
     Spoolfile = safe_strdup (p);
   else if ((p = getenv ("MAILDIR")))
@@ -3109,33 +3420,42 @@ void mutt_init (int skip_sys_rc, LIST *commands)
    */
   add_to_list(&MailtoAllow, "body");
   add_to_list(&MailtoAllow, "subject");
-  
-  
-  
-  /*
-   * 
-   *			   BIG FAT WARNING
-   * 
-   * When changing the code which looks for a configuration file,
-   * please also change the corresponding code in muttbug.sh.in.
-   * 
-   * 
-   */
-  
-  
-  
-  
+
   if (!Muttrc)
   {
-    snprintf (buffer, sizeof(buffer), "%s/.muttrc-%s", NONULL(Homedir), MUTT_VERSION);
-    if (access(buffer, F_OK) == -1)
-      snprintf (buffer, sizeof(buffer), "%s/.muttrc", NONULL(Homedir));
-    if (access(buffer, F_OK) == -1)
-      snprintf (buffer, sizeof (buffer), "%s/.mutt/muttrc-%s", NONULL(Homedir), MUTT_VERSION);
-    if (access(buffer, F_OK) == -1)
-      snprintf (buffer, sizeof (buffer), "%s/.mutt/muttrc", NONULL(Homedir));
-    if (access(buffer, F_OK) == -1) /* default to .muttrc for alias_file */
-      snprintf (buffer, sizeof(buffer), "%s/.muttrc", NONULL(Homedir));
+    do
+    {
+      if (mutt_set_xdg_path (kXDGConfigHome, buffer, sizeof buffer))
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/.neomuttrc", NONULL(Homedir));
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/.mutt/neomuttrc", NONULL(Homedir));
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/.muttrc-%s", NONULL(Homedir), PACKAGE_VERSION);
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/.muttrc", NONULL(Homedir));
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/.mutt/muttrc-%s", NONULL(Homedir), PACKAGE_VERSION);
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/.mutt/muttrc", NONULL(Homedir));
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      /* default to .muttrc for alias_file */
+      snprintf (buffer, sizeof buffer, "%s/.muttrc", NONULL(Homedir));
+    }
+    while (0);
 
     default_rc = 1;
     Muttrc = safe_strdup (buffer);
@@ -3154,14 +3474,30 @@ void mutt_init (int skip_sys_rc, LIST *commands)
      requested not to via "-n".  */
   if (!skip_sys_rc)
   {
-    snprintf (buffer, sizeof(buffer), "%s/Muttrc-%s", SYSCONFDIR, MUTT_VERSION);
-    if (access (buffer, F_OK) == -1)
-      snprintf (buffer, sizeof(buffer), "%s/Muttrc", SYSCONFDIR);
-    if (access (buffer, F_OK) == -1)
-      snprintf (buffer, sizeof (buffer), "%s/Muttrc-%s", PKGDATADIR, MUTT_VERSION);
-    if (access (buffer, F_OK) == -1)
-      snprintf (buffer, sizeof (buffer), "%s/Muttrc", PKGDATADIR);
-    if (access (buffer, F_OK) != -1)
+    do
+    {
+      if (mutt_set_xdg_path (kXDGConfigDirs, buffer, sizeof buffer))
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/NeoMuttrc", SYSCONFDIR);
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/Muttrc-%s", SYSCONFDIR, PACKAGE_VERSION);
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/Muttrc", SYSCONFDIR);
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/Muttrc-%s", PKGDATADIR, PACKAGE_VERSION);
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/Muttrc", PKGDATADIR);
+    } while (0);
+    if (access (buffer, F_OK) == 0)
     {
       if (source_rc (buffer, &err) != 0)
       {
@@ -3203,6 +3539,11 @@ void mutt_init (int skip_sys_rc, LIST *commands)
 
   mutt_read_histfile ();
 
+#ifdef USE_NOTMUCH
+  if (option (OPTVIRTSPOOLFILE) && VirtIncoming)
+    mutt_str_replace(&Spoolfile, VirtIncoming->path);
+#endif
+
 #if 0
   set_option (OPTWEED); /* turn weeding on by default */
 #endif
@@ -3250,6 +3591,70 @@ static int parse_group_context (group_context_t **ctx, BUFFER *buf, BUFFER *s, u
   return -1;
 }
 
+#ifdef USE_NOTMUCH
+int parse_tag_transforms (BUFFER *b, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  char *tmp;
+
+  while (MoreArgs (s))
+  {
+    char *tag, *transform;
+
+    mutt_extract_token (b, s, 0);
+    if (b->data && *b->data)
+      tag = safe_strdup (b->data);
+    else
+      continue;
+
+    mutt_extract_token (b, s, 0);
+    transform = safe_strdup (b->data);
+
+    /* avoid duplicates */
+    tmp = hash_find(TagTransforms, tag);
+    if (tmp) {
+      dprint(3,(debugfile,"tag transform '%s' already registered as '%s'\n", tag, tmp));
+      FREE(&tag);
+      FREE(&transform);
+      continue;
+    }
+
+    hash_insert(TagTransforms, tag, transform, 0);
+  }
+  return 0;
+}
+
+int parse_tag_formats (BUFFER *b, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  char *tmp;
+
+  while (MoreArgs (s))
+  {
+    char *tag, *format;
+
+    mutt_extract_token (b, s, 0);
+    if (b->data && *b->data)
+      tag = safe_strdup (b->data);
+    else
+      continue;
+
+    mutt_extract_token (b, s, 0);
+    format = safe_strdup (b->data);
+
+    /* avoid duplicates */
+    tmp = hash_find(TagFormats, format);
+    if (tmp) {
+      dprint(3,(debugfile,"tag format '%s' already registered as '%s'\n", format, tmp));
+      FREE(&tag);
+      FREE(&format);
+      continue;
+    }
+
+    hash_insert(TagFormats, format, tag, 0);
+  }
+  return 0;
+}
+#endif
+
 static void myvar_set (const char* var, const char* val)
 {
   myvar_t** cur;
@@ -3297,3 +3702,58 @@ static const char* myvar_get (const char* var)
 
   return NULL;
 }
+
+int mutt_label_complete (char *buffer, size_t len, int pos, int numtabs)
+{
+  char *pt = buffer;
+  int spaces; /* keep track of the number of leading spaces on the line */
+  int prefix;
+
+  SKIPWS (buffer);
+  spaces = buffer - pt;
+
+  for (pt = buffer; pt && *pt && *(pt+1); pt++);
+  for (; pt > buffer && !isspace(*(pt-1)); pt--);
+  prefix = pt - buffer;
+
+  /* first TAB. Collect all the matches */
+  if (numtabs == 1)
+  {
+    struct hash_elem *entry;
+    struct hash_walk_state state;
+
+    Num_matched = 0;
+    strfcpy (User_typed, pt, sizeof (User_typed));
+    memset (Matches, 0, Matches_listsize);
+    memset (Completed, 0, sizeof (Completed));
+    memset (&state, 0, sizeof(state));
+    while ((entry = hash_walk(Labels, &state)))
+      candidate (Completed, User_typed, entry->key, sizeof (Completed));
+    matches_ensure_morespace (Num_matched);
+    qsort(Matches, Num_matched, sizeof(char *), (sort_t *) mutt_strcasecmp);
+    Matches[Num_matched++] = User_typed;
+
+    /* All matches are stored. Longest non-ambiguous string is ""
+     * i.e. dont change 'buffer'. Fake successful return this time */
+    if (User_typed[0] == 0)
+      return 1;
+  }
+
+  if (Completed[0] == 0 && User_typed[0])
+    return 0;
+
+   /* Num_matched will _always_ be atleast 1 since the initial
+    * user-typed string is always stored */
+  if (numtabs == 1 && Num_matched == 2)
+    snprintf(Completed, sizeof(Completed), "%s", Matches[0]);
+  else if (numtabs > 1 && Num_matched > 2)
+    /* cycle thru all the matches */
+    snprintf(Completed, sizeof(Completed), "%s", 
+             Matches[(numtabs - 2) % Num_matched]);
+
+  /* return the completed label */
+  strncpy (&buffer[prefix], Completed, len - spaces);
+
+  return 1;
+}
+
diff --git a/init.h b/init.h
index 3f3f96d..dff4dd0 100644
--- a/init.h
+++ b/init.h
@@ -179,6 +179,20 @@ struct option_t MuttVars[] = {
   ** If \fIset\fP, Mutt will prompt you for carbon-copy (Cc) recipients before
   ** editing the body of an outgoing message.
   */
+#ifdef USE_NNTP
+  { "ask_follow_up",	DT_BOOL, R_NONE, OPTASKFOLLOWUP, 0 },
+  /*
+  ** .pp
+  ** If set, Mutt will prompt you for follow-up groups before editing
+  ** the body of an outgoing message.
+  */
+  { "ask_x_comment_to",	DT_BOOL, R_NONE, OPTASKXCOMMENTTO, 0 },
+  /*
+  ** .pp
+  ** If set, Mutt will prompt you for x-comment-to field before editing
+  ** the body of an outgoing message.
+  */
+#endif
   { "assumed_charset", DT_STR, R_NONE, UL &AssumedCharset, UL 0},
   /*
   ** .pp
@@ -293,6 +307,13 @@ struct option_t MuttVars[] = {
   { "beep",		DT_BOOL, R_NONE, OPTBEEP, 1 },
   /*
   ** .pp
+  ** If \fIset\fP, Mutt will call this command after a new message is received.
+  ** See the $$status_format documentation for the values that can be formatted
+  ** into this command.
+  */
+  { "new_mail_command",	DT_PATH, R_NONE, UL &NewMailCmd, UL NULL },
+  /*
+  ** .pp
   ** When this variable is \fIset\fP, mutt will beep when an error occurs.
   */
   { "beep_new",		DT_BOOL, R_NONE, OPTBEEPNEW, 0 },
@@ -325,6 +346,14 @@ struct option_t MuttVars[] = {
   ** follow these menus.  The option is \fIunset\fP by default because many
   ** visual terminals don't permit making the cursor invisible.
   */
+#ifdef USE_NNTP
+  { "catchup_newsgroup", DT_QUAD, R_NONE, OPT_CATCHUP, MUTT_ASKYES },
+  /*
+  ** .pp
+  ** If this variable is \fIset\fP, Mutt will mark all articles in newsgroup
+  ** as read when you quit the newsgroup (catchup newsgroup).
+  */
+#endif
 #if defined(USE_SSL)
   { "certificate_file",	DT_PATH, R_NONE, UL &SslCertFile, UL "~/.mutt_certificates" },
   /*
@@ -392,7 +421,7 @@ struct option_t MuttVars[] = {
   ** When \fIunset\fP, Mutt will not collapse a thread if it contains any
   ** unread messages.
   */
-  { "compose_format",	DT_STR,	 R_BOTH, UL &ComposeFormat, UL "-- Mutt: Compose  [Approx. msg size: %l   Atts: %a]%>-" },
+  { "compose_format",	DT_STR,	 R_BOTH, UL &ComposeFormat, UL "-- NeoMutt: Compose  [Approx. msg size: %l   Atts: %a]%>-" },
   /*
   ** .pp
   ** Controls the format of the status line displayed in the ``compose''
@@ -852,6 +881,16 @@ struct option_t MuttVars[] = {
   ** sent to both the list and your address, resulting in two copies
   ** of the same email for you.
   */
+#ifdef USE_NNTP
+  { "followup_to_poster", DT_QUAD, R_NONE, OPT_FOLLOWUPTOPOSTER, MUTT_ASKYES },
+  /*
+  ** .pp
+  ** If this variable is \fIset\fP and the keyword "poster" is present in
+  ** \fIFollowup-To\fP header, follow-up to newsgroup function is not
+  ** permitted.  The message will be mailed to the submitter of the
+  ** message via mail.
+  */
+#endif
   { "force_name",	DT_BOOL, R_NONE, OPTFORCENAME, 0 },
   /*
   ** .pp
@@ -934,6 +973,26 @@ struct option_t MuttVars[] = {
   ** a regular expression that will match the whole name so mutt will expand
   ** ``Franklin'' to ``Franklin, Steve''.
   */
+#ifdef USE_NNTP
+  { "group_index_format", DT_STR, R_BOTH, UL &GroupFormat, UL "%4C %M%N %5s  %-45.45f %d" },
+  /*
+  ** .pp
+  ** This variable allows you to customize the newsgroup browser display to
+  ** your personal taste.  This string is similar to ``$index_format'', but
+  ** has its own set of printf()-like sequences:
+  ** .dl
+  ** .dt %C  .dd current newsgroup number
+  ** .dt %d  .dd description of newsgroup (becomes from server)
+  ** .dt %f  .dd newsgroup name
+  ** .dt %M  .dd - if newsgroup not allowed for direct post (moderated for example)
+  ** .dt %N  .dd N if newsgroup is new, u if unsubscribed, blank otherwise
+  ** .dt %n  .dd number of new articles in newsgroup
+  ** .dt %s  .dd number of unread articles in newsgroup
+  ** .dt %>X .dd right justify the rest of the string and pad with character "X"
+  ** .dt %|X .dd pad to the end of the line with character "X"
+  ** .de
+  */
+#endif
   { "hdr_format",	DT_SYN,  R_NONE, UL "index_format", 0 },
   /*
   */
@@ -1326,6 +1385,8 @@ struct option_t MuttVars[] = {
   ** .dt %E .dd number of messages in current thread
   ** .dt %f .dd sender (address + real name), either From: or Return-Path:
   ** .dt %F .dd author name, or recipient name if the message is from you
+  ** .dt %g .dd newsgroup name (if compiled with NNTP support)
+  ** .dt %g .dd message labels (e.g. notmuch tags)
   ** .dt %H .dd spam attribute(s) of this message
   ** .dt %i .dd message-id of the current message
   ** .dt %l .dd number of lines in the message (does not work with maildir,
@@ -1349,6 +1410,8 @@ struct option_t MuttVars[] = {
   ** .dt %T .dd the appropriate character from the $$to_chars string
   ** .dt %u .dd user (login) name of the author
   ** .dt %v .dd first name of the author, or the recipient if the message is from you
+  ** .dt %W .dd name of organization of author (``Organization:'' field)
+  ** .dt %x .dd ``X-Comment-To:'' field (if present and compiled with NNTP support)
   ** .dt %X .dd number of attachments
   **            (please see the ``$attachments'' section for possible speed effects)
   ** .dt %y .dd ``X-Label:'' field, if present
@@ -1372,6 +1435,10 @@ struct option_t MuttVars[] = {
   ** .dt %*X    .dd soft-fill with character ``X'' as pad
   ** .de
   ** .pp
+  ** Date format expressions can be constructed based on relative dates. Using
+  ** the date formatting operators along with nested conditionals, the date
+  ** format can be modified based on how old a message is.  See the section on
+  ** ``Conditional Dates'' for an explanation and examples
   ** ``Soft-fill'' deserves some explanation: Normal right-justification
   ** will print everything to the left of the ``%>'', displaying padding and
   ** whatever lies to the right only if there's room. By contrast,
@@ -1383,6 +1450,25 @@ struct option_t MuttVars[] = {
   ** Note that these expandos are supported in
   ** ``$save-hook'', ``$fcc-hook'' and ``$fcc-save-hook'', too.
   */
+#ifdef USE_NNTP
+  { "inews",		DT_PATH, R_NONE, UL &Inews, UL "" },
+  /*
+  ** .pp
+  ** If set, specifies the program and arguments used to deliver news posted
+  ** by Mutt.  Otherwise, mutt posts article using current connection to
+  ** news server.  The following printf-style sequence is understood:
+  ** .dl
+  ** .dt %a .dd account url
+  ** .dt %p .dd port
+  ** .dt %P .dd port if specified
+  ** .dt %s .dd news server name
+  ** .dt %S .dd url schema
+  ** .dt %u .dd username
+  ** .de
+  ** .pp
+  ** Example: set inews="/usr/local/bin/inews -hS"
+  */
+#endif
   { "ispell",		DT_PATH, R_NONE, UL &Ispell, UL ISPELL },
   /*
   ** .pp
@@ -1395,6 +1481,28 @@ struct option_t MuttVars[] = {
   ** from your spool mailbox to your $$mbox mailbox, or as a result of
   ** a ``$mbox-hook'' command.
   */
+  { "keywords_legacy", DT_BOOL, R_NONE, OPTKEYWORDSLEGACY, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP, keywords/labels/tags will be written to whatever
+  ** legacy, nonstandard headers (X-Label, X-Keywords, X-Mozilla-Keys)
+  ** they were sourced from.
+  ** .pp
+  ** If both ``$$keywords_legacy'' and
+  ** ``$$keywords_standard'' are \fCfalse\fP, mutt will save keywords
+  ** to legacy headers to ensure that it does not lose your labels.
+  */
+  { "keywords_standard", DT_BOOL, R_NONE, OPTKEYWORDSSTANDARD, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, keywords/labels/tags will be written to the
+  ** RFC2822-standard Keywords: header; this may imply a conversion from
+  ** legacy headers.
+  ** .pp
+  ** If both ``$$keywords_legacy'' and
+  ** ``$$keywords_standard'' are \fCfalse\fP, mutt will save keywords
+  ** to legacy headers to ensure that it does not lose your labels.
+  */
   { "locale",		DT_STR,  R_BOTH, UL &Locale, UL "C" },
   /*
   ** .pp
@@ -1643,6 +1751,15 @@ struct option_t MuttVars[] = {
   ** menu, attachments which cannot be decoded in a reasonable manner will
   ** be attached to the newly composed message if this option is \fIset\fP.
   */
+#ifdef USE_NNTP
+  { "mime_subject",	DT_BOOL, R_NONE, OPTMIMESUBJECT, 1 },
+  /*
+  ** .pp
+  ** If \fIunset\fP, 8-bit ``subject:'' line in article header will not be
+  ** encoded according to RFC2047 to base64.  This is useful when message
+  ** is Usenet article, because MIME for news is nonstandard feature.
+  */
+#endif
 #ifdef MIXMASTER
   { "mix_entry_format", DT_STR,  R_NONE, UL &MixEntryFormat, UL "%4n %c %-16s %a" },
   /*
@@ -1690,6 +1807,160 @@ struct option_t MuttVars[] = {
    ** See also $$read_inc, $$write_inc and $$net_inc.
    */
 #endif
+#ifdef USE_NNTP
+  { "news_cache_dir",	DT_PATH, R_NONE, UL &NewsCacheDir, UL "~/.mutt" },
+  /*
+  ** .pp
+  ** This variable pointing to directory where Mutt will save cached news
+  ** articles and headers in. If \fIunset\fP, articles and headers will not be
+  ** saved at all and will be reloaded from the server each time.
+  */
+  { "news_server",	DT_STR, R_NONE, UL &NewsServer, 0 },
+  /*
+  ** .pp
+  ** This variable specifies domain name or address of NNTP server. It
+  ** defaults to the news server specified in the environment variable
+  ** $$$NNTPSERVER or contained in the file /etc/nntpserver.  You can also
+  ** specify username and an alternative port for each news server, ie:
+  ** .pp
+  ** [[s]news://][username[:password]@]server[:port]
+  */
+  { "newsgroups_charset", DT_STR, R_NONE, UL &NewsgroupsCharset, UL "utf-8" },
+  /*
+  ** .pp
+  ** Character set of newsgroups descriptions.
+  */
+  { "newsrc",		DT_PATH, R_NONE, UL &NewsRc, UL "~/.newsrc" },
+  /*
+  ** .pp
+  ** The file, containing info about subscribed newsgroups - names and
+  ** indexes of read articles.  The following printf-style sequence
+  ** is understood:
+  ** .dl
+  ** .dt %a .dd account url
+  ** .dt %p .dd port
+  ** .dt %P .dd port if specified
+  ** .dt %s .dd news server name
+  ** .dt %S .dd url schema
+  ** .dt %u .dd username
+  ** .de
+  */
+  { "nntp_authenticators", DT_STR, R_NONE, UL &NntpAuthenticators, UL 0 },
+  /*
+  ** .pp
+  ** This is a colon-delimited list of authentication methods mutt may
+  ** attempt to use to log in to a news server, in the order mutt should
+  ** try them.  Authentication methods are either ``user'' or any
+  ** SASL mechanism, e.g. ``digest-md5'', ``gssapi'' or ``cram-md5''.
+  ** This option is case-insensitive.  If it's \fIunset\fP (the default)
+  ** mutt will try all available methods, in order from most-secure to
+  ** least-secure.
+  ** .pp
+  ** Example:
+  ** .ts
+  ** set nntp_authenticators="digest-md5:user"
+  ** .te
+  ** .pp
+  ** \fBNote:\fP Mutt will only fall back to other authentication methods if
+  ** the previous methods are unavailable. If a method is available but
+  ** authentication fails, mutt will not connect to the IMAP server.
+  */
+  { "nntp_context",	DT_NUM, R_NONE, UL &NntpContext, 1000 },
+  /*
+  ** .pp
+  ** This variable defines number of articles which will be in index when
+  ** newsgroup entered.  If active newsgroup have more articles than this
+  ** number, oldest articles will be ignored.  Also controls how many
+  ** articles headers will be saved in cache when you quit newsgroup.
+  */
+  { "nntp_listgroup",	DT_BOOL, R_NONE, OPTLISTGROUP, 1 },
+  /*
+  ** .pp
+  ** This variable controls whether or not existence of each article is
+  ** checked when newsgroup is entered.
+  */
+  { "nntp_load_description", DT_BOOL, R_NONE, OPTLOADDESC, 1 },
+  /*
+  ** .pp
+  ** This variable controls whether or not descriptions for each newsgroup
+  ** must be loaded when newsgroup is added to list (first time list
+  ** loading or new newsgroup adding).
+  */
+  { "nntp_user",	DT_STR, R_NONE, UL &NntpUser, UL "" },
+  /*
+  ** .pp
+  ** Your login name on the NNTP server.  If \fIunset\fP and NNTP server requires
+  ** authentication, Mutt will prompt you for your account name when you
+  ** connect to news server.
+  */
+  { "nntp_pass",	DT_STR, R_NONE, UL &NntpPass, UL "" },
+  /*
+  ** .pp
+  ** Your password for NNTP account.
+  */
+  { "nntp_poll",	DT_NUM, R_NONE, UL &NewsPollTimeout, 60 },
+  /*
+  ** .pp
+  ** The time in seconds until any operations on newsgroup except post new
+  ** article will cause recheck for new news.  If set to 0, Mutt will
+  ** recheck newsgroup on each operation in index (stepping, read article,
+  ** etc.).
+  */
+#endif
+#ifdef USE_NOTMUCH
+  { "nm_open_timeout", DT_NUM, R_NONE, UL &NotmuchOpenTimeout, 5 },
+  /*
+   ** .pp
+   ** This variable specifies the timeout for database open in seconds.
+   */
+
+  { "nm_default_uri", DT_STR, R_NONE, UL &NotmuchDefaultUri, 0 },
+  /*
+   ** .pp
+   ** This variable specifies the default Notmuch database in format
+   ** notmuch://<absolute path>.
+   */
+
+  { "nm_hidden_tags", DT_STR, R_NONE, UL &NotmuchHiddenTags, UL "unread,draft,flagged,passed,replied,attachment,signed,encrypted" },
+  /*
+   ** .pp
+   ** This variable specifies private notmuch tags which should not be printed
+   ** on screen.
+   */
+  { "nm_exclude_tags", DT_STR,  R_NONE, UL &NotmuchExcludeTags, 0 },
+  /*
+   ** .pp
+   ** The messages tagged with these tags are excluded and not loaded
+   ** from notmuch DB to mutt unless specified explicitly.
+   */
+  { "nm_unread_tag", DT_STR, R_NONE, UL &NotmuchUnreadTag, UL "unread" },
+  /*
+   ** .pp
+   ** This variable specifies notmuch tag which is used for unread messages. The
+   ** variable is used to count unread messages in DB only. All other mutt commands
+   ** use standard (e.g. maildir) flags.
+   */
+  { "nm_db_limit", DT_NUM, R_NONE, UL &NotmuchDBLimit, 0 },
+  /*
+   ** .pp
+   ** This variable specifies the default limit used in notmuch queries.
+   */
+  { "nm_query_type", DT_STR, R_NONE, UL &NotmuchQueryType, UL "messages" },
+  /*
+   ** .pp
+   ** This variable specifies the default query type (threads or messages) used in notmuch queries.
+   */
+  { "nm_record", DT_BOOL, R_NONE, OPTNOTMUCHRECORD, 0 },
+  /*
+   ** .pp
+   ** This variable specifies if the mutt record should indexed by notmuch.
+   */
+  { "nm_record_tags", DT_STR, R_NONE, UL &NotmuchRecordTags, 0 },
+  /*
+   ** .pp
+   ** This variable specifies the default tags applied to messages stored to the mutt record.
+   */
+#endif
   { "pager",		DT_PATH, R_NONE, UL &Pager, UL "builtin" },
   /*
   ** .pp
@@ -2216,6 +2487,16 @@ struct option_t MuttVars[] = {
   { "post_indent_str",  DT_SYN,  R_NONE, UL "post_indent_string", 0 },
   /*
   */
+#ifdef USE_NNTP
+  { "post_moderated",	DT_QUAD, R_NONE, OPT_TOMODERATED, MUTT_ASKYES },
+  /*
+  ** .pp
+  ** If set to \fIyes\fP, Mutt will post article to newsgroup that have
+  ** not permissions to posting (e.g. moderated).  \fBNote:\fP if news server
+  ** does not support posting to that newsgroup or totally read-only, that
+  ** posting will not have an effect.
+  */
+#endif
   { "postpone",		DT_QUAD, R_NONE, OPT_POSTPONE, MUTT_ASKYES },
   /*
   ** .pp
@@ -2692,6 +2973,28 @@ struct option_t MuttVars[] = {
   ** Command to use when spawning a subshell.  By default, the user's login
   ** shell from \fC/etc/passwd\fP is used.
   */
+#ifdef USE_NNTP
+  { "save_unsubscribed", DT_BOOL, R_NONE, OPTSAVEUNSUB, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, info about unsubscribed newsgroups will be saved into
+  ** ``newsrc'' file and into cache.
+  */
+  { "show_new_news",	DT_BOOL, R_NONE, OPTSHOWNEWNEWS, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP, news server will be asked for new newsgroups on entering
+  ** the browser.  Otherwise, it will be done only once for a news server.
+  ** Also controls whether or not number of new articles of subscribed
+  ** newsgroups will be then checked.
+  */
+  { "show_only_unread",	DT_BOOL, R_NONE, OPTSHOWONLYUNREAD, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, only subscribed newsgroups that contain unread articles
+  ** will be displayed in browser.
+  */
+#endif
 #ifdef USE_SIDEBAR
   { "sidebar_divider_char", DT_STR, R_SIDEBAR, UL &SidebarDividerChar, UL "|" },
   /*
@@ -2780,6 +3083,11 @@ struct option_t MuttVars[] = {
   ** \fC<sidebar-prev-new>\fP command is similarly affected, wrapping around to
   ** the end of the list.
   */
+  { "sidebar_on_right", DT_BOOL, R_BOTH|R_REFLOW, UL OPTSIDEBARONRIGHT, 0 },
+  /*
+  ** .pp
+  ** When set, the sidebar will appear on the right-hand side of the screen.
+  */
   { "sidebar_short_path", DT_BOOL, R_SIDEBAR, OPTSIDEBARSHORTPATH, 0 },
   /*
   ** .pp
@@ -2866,6 +3174,12 @@ struct option_t MuttVars[] = {
   ** replacing ``%s'' with the supplied string.
   ** For the default value, ``joe'' would be expanded to: ``~f joe | ~s joe''.
   */
+  { "skip_quoted_offset", DT_NUM, R_NONE, UL &SkipQuotedOffset, 0 },
+  /*
+  ** .pp
+  ** Lines of quoted text that are displayed before the unquoted text after
+  ** "skip to quoted" command (S)
+  */
   { "sleep_time",	DT_NUM, R_NONE, UL &SleepTime, 1 },
   /*
   ** .pp
@@ -2971,6 +3285,12 @@ struct option_t MuttVars[] = {
   ** possible \fCprintf(3)\fP-like sequences.
   ** (S/MIME only)
   */
+  { "smime_encrypt_self",		DT_QUAD,	 R_NONE, OPT_SMIMEENCRYPTSELF, MUTT_NO },
+  /*
+  ** .pp
+  ** Encrypt the message to $$smime_default_key too.
+  ** (S/MIME only)
+  */
   { "smime_encrypt_with",	DT_STR,	 R_NONE, UL &SmimeCryptAlg, UL "aes256" },
   /*
   ** .pp
@@ -3209,7 +3529,10 @@ struct option_t MuttVars[] = {
   ** entries are sorted alphabetically.  Valid values:
   ** .il
   ** .dd alpha (alphabetically)
+  ** .dd count (all message count)
   ** .dd date
+  ** .dd desc (description)
+  ** .dd new (new message count)
   ** .dd size
   ** .dd unsorted
   ** .ie
@@ -3220,14 +3543,15 @@ struct option_t MuttVars[] = {
   { "sort_re",		DT_BOOL, R_INDEX|R_RESORT|R_RESORT_INIT, OPTSORTRE, 1 },
   /*
   ** .pp
-  ** This variable is only useful when sorting by threads with
-  ** $$strict_threads \fIunset\fP.  In that case, it changes the heuristic
-  ** mutt uses to thread messages by subject.  With $$sort_re \fIset\fP, mutt will
-  ** only attach a message as the child of another message by subject if
-  ** the subject of the child message starts with a substring matching the
-  ** setting of $$reply_regexp.  With $$sort_re \fIunset\fP, mutt will attach
-  ** the message whether or not this is the case, as long as the
-  ** non-$$reply_regexp parts of both messages are identical.
+  ** This variable is only useful when sorting by mailboxes in sidebar. By default,
+  ** entries are unsorted.  Valid values:
+  ** .il
+  ** .dd count (all message count)
+  ** .dd desc  (virtual mailbox description)
+  ** .dd new (new message count)
+  ** .dd path
+  ** .dd unsorted
+  ** .ie
   */
   { "spam_separator",   DT_STR, R_NONE, UL &SpamSep, UL "," },
   /*
@@ -3377,7 +3701,7 @@ struct option_t MuttVars[] = {
   ** message mode (Certain operations like composing a new mail, replying,
   ** forwarding, etc. are not permitted in this mode).
   */
-  { "status_format",	DT_STR,	 R_BOTH, UL &Status, UL "-%r-Mutt: %f [Msgs:%?M?%M/?%m%?n? New:%n?%?o? Old:%o?%?d? Del:%d?%?F? Flag:%F?%?t? Tag:%t?%?p? Post:%p?%?b? Inc:%b?%?l? %l?]---(%s/%S)-%>-(%P)---" },
+  { "status_format",	DT_STR,	 R_BOTH, UL &Status, UL "-%r-NeoMutt: %f [Msgs:%?M?%M/?%m%?n? New:%n?%?o? Old:%o?%?d? Del:%d?%?F? Flag:%F?%?t? Tag:%t?%?p? Post:%p?%?b? Inc:%b?%?l? %l?]---(%s/%S)-%>-(%P)---" },
   /*
   ** .pp
   ** Controls the format of the status line displayed in the ``index''
@@ -3585,7 +3909,7 @@ struct option_t MuttVars[] = {
   ** Controls whether mutt tries to set the terminal status line and icon name.
   ** Most terminal emulators emulate the status line in the window title.
   */
-  {"ts_status_format",	DT_STR,   R_BOTH, UL &TSStatusFormat, UL "Mutt with %?m?%m messages&no messages?%?n? [%n NEW]?"},
+  {"ts_status_format",	DT_STR,   R_BOTH, UL &TSStatusFormat, UL "NeoMutt with %?m?%m messages&no messages?%?n? [%n NEW]?"},
   /*
   ** .pp
   ** Controls the format of the terminal status line (or window title),
@@ -3680,6 +4004,31 @@ struct option_t MuttVars[] = {
   ** Specifies the visual editor to invoke when the ``\fC~v\fP'' command is
   ** given in the built-in editor.
   */
+#ifdef USE_NOTMUCH
+  { "vfolder_format",	DT_STR,	 R_INDEX, UL &VirtFolderFormat, UL " %6n(%6N) %f " },
+  /*
+  ** .pp
+  ** This variable allows you to customize the file browser display for virtual
+  ** folders to your ** personal taste.  This string is similar to $$index_format,
+  ** but has its own set of \fCprintf(3)\fP-like sequences:
+  ** .dl
+  ** .dt %f  .dd folder name (description)
+  ** .dt %n  .dd number of all messages
+  ** .dt %N  .dd number of new messages
+  ** .dt %>X .dd right justify the rest of the string and pad with character ``X''
+  ** .dt %|X .dd pad to the end of the line with character ``X''
+  ** .dt %*X .dd soft-fill with character ``X'' as pad
+  ** .de
+  ** .pp
+  ** For an explanation of ``soft-fill'', see the $$index_format documentation.
+  */
+  { "virtual_spoolfile", DT_BOOL, R_NONE, OPTVIRTSPOOLFILE, 0 },
+  /*
+  ** .pp
+  ** When \fset\fP, mutt will use the first defined virtual mailbox (see
+  ** virtual-mailboxes) as a spool file.
+  */
+#endif
   { "wait_key",		DT_BOOL, R_NONE, OPTWAITKEY, 1 },
   /*
   ** .pp
@@ -3763,6 +4112,28 @@ struct option_t MuttVars[] = {
   {"xterm_set_titles",	DT_SYN,  R_NONE, UL "ts_enabled", 0 },
   /*
   */
+  { "xlabel_delimiter", DT_STR, R_NONE, UL &XlabelDelim, UL "" },
+  /*
+  ** .pp
+  ** The character used to delimit distinct keywords in X-Label headers.
+  ** X-Label is primarily a Mutt artifact, and the semantics of the field
+  ** were never defined: it is free-form text.  However interaction with
+  ** X-Keywords:, X-Mozilla-Keys:, and Keywords: requires that we adopt
+  ** some means of identifying separate keywords within the field.  Set
+  ** this to your personal convention.
+  ** .pp
+  ** This affect both parsing existing X-Label headers and writing new
+  ** X-Label headers.  You can modify this variable in runtime to accomplish
+  ** various kinds of conversion.
+  */
+#ifdef USE_NNTP
+  { "x_comment_to",	DT_BOOL, R_NONE, OPTXCOMMENTTO, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, Mutt will add ``X-Comment-To:'' field (that contains full
+  ** name of original article author) to article that followuped to newsgroup.
+  */
+#endif
   /*--*/
   { NULL, 0, 0, 0, 0 }
 };
@@ -3779,6 +4150,7 @@ const struct mapping_t SortMethods[] = {
   { "to",		SORT_TO },
   { "score",		SORT_SCORE },
   { "spam",		SORT_SPAM },
+  { "label",		SORT_LABEL },
   { NULL,               0 }
 };
 
@@ -3798,13 +4170,17 @@ const struct mapping_t SortAuxMethods[] = {
   { "to",		SORT_TO },
   { "score",		SORT_SCORE },
   { "spam",		SORT_SPAM },
+  { "label",		SORT_LABEL },
   { NULL,               0 }
 };
 
 
 const struct mapping_t SortBrowserMethods[] = {
   { "alpha",	SORT_SUBJECT },
+  { "count",	SORT_COUNT },
   { "date",	SORT_DATE },
+  { "desc",	SORT_DESC },
+  { "new",	SORT_COUNT_NEW },
   { "size",	SORT_SIZE },
   { "unsorted",	SORT_ORDER },
   { NULL,       0 }
@@ -3828,6 +4204,7 @@ const struct mapping_t SortKeyMethods[] = {
 const struct mapping_t SortSidebarMethods[] = {
   { "alpha",		SORT_PATH },
   { "count",		SORT_COUNT },
+  { "desc",		SORT_DESC },
   { "flagged",		SORT_FLAGGED },
   { "mailbox-order",	SORT_ORDER },
   { "name",		SORT_PATH },
@@ -3850,6 +4227,8 @@ static int parse_lists (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_unlists (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_alias (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_unalias (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int finish_source (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_ifdef (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_ignore (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_unignore (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_source (BUFFER *, BUFFER *, unsigned long, BUFFER *);
@@ -3861,13 +4240,16 @@ static int parse_unsubscribe (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_attachments (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_unattachments (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 
-
 static int parse_alternates (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_unalternates (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 
 /* Parse -group arguments */
 static int parse_group_context (group_context_t **ctx, BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err);
 
+#ifdef USE_NOTMUCH
+static int parse_tag_transforms (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_tag_formats (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+#endif
 
 struct command_t
 {
@@ -3897,9 +4279,17 @@ const struct command_t Commands[] = {
   { "fcc-hook",		mutt_parse_hook,	MUTT_FCCHOOK },
   { "fcc-save-hook",	mutt_parse_hook,	MUTT_FCCHOOK | MUTT_SAVEHOOK },
   { "folder-hook",	mutt_parse_hook,	MUTT_FOLDERHOOK },
+#ifdef USE_COMPRESSED
+  { "open-hook",	mutt_parse_hook,	MUTT_OPENHOOK },
+  { "close-hook",	mutt_parse_hook,	MUTT_CLOSEHOOK },
+  { "append-hook",	mutt_parse_hook,	MUTT_APPENDHOOK },
+#endif
   { "group",		parse_group,		MUTT_GROUP },
   { "ungroup",		parse_group,		MUTT_UNGROUP },
   { "hdr_order",	parse_list,		UL &HeaderOrderList },
+  { "ifdef",		parse_ifdef,		0 },
+  { "ifndef",		parse_ifdef,		1 },
+  { "finish",		finish_source,		0 },
 #ifdef HAVE_ICONV
   { "iconv-hook",	mutt_parse_hook,	MUTT_ICONVHOOK },
 #endif
@@ -3908,6 +4298,11 @@ const struct command_t Commands[] = {
   { "macro",		mutt_parse_macro,	0 },
   { "mailboxes",	mutt_parse_mailboxes,	MUTT_MAILBOXES },
   { "unmailboxes",	mutt_parse_mailboxes,	MUTT_UNMAILBOXES },
+#ifdef USE_NOTMUCH
+  { "virtual-mailboxes",mutt_parse_virtual_mailboxes, 0 },
+  { "tag-transforms",	parse_tag_transforms,	0 },
+  { "tag-formats",	parse_tag_formats,	0 },
+#endif
   { "mailto_allow",	parse_list,		UL &MailtoAllow },
   { "unmailto_allow",	parse_unlist,		UL &MailtoAllow },
   { "message-hook",	mutt_parse_hook,	MUTT_MESSAGEHOOK },
@@ -3933,6 +4328,7 @@ const struct command_t Commands[] = {
   { "spam",		parse_spam_list,	MUTT_SPAM },
   { "nospam",		parse_spam_list,	MUTT_NOSPAM },
   { "subscribe",	parse_subscribe,	0 },
+  { "timeout-hook",	mutt_parse_hook,	MUTT_TIMEOUTHOOK },
   { "toggle",		parse_set,		MUTT_SET_INV },
   { "unalias",		parse_unalias,		0 },
   { "unalternative_order",parse_unlist,		UL &AlternativeOrderList },
diff --git a/keymap.c b/keymap.c
index 8b8b972..e704c40 100644
--- a/keymap.c
+++ b/keymap.c
@@ -76,10 +76,8 @@ static struct mapping_t KeyNames[] = {
   { "<Insert>",	KEY_IC },
   { "<Home>",	KEY_HOME },
   { "<End>",	KEY_END },
-#ifdef KEY_ENTER
-  { "<Enter>",	KEY_ENTER },
-#endif
-  { "<Return>",	MUTT_ENTER_C },
+  { "<Enter>",	'\n' },
+  { "<Return>",	'\r' },
   { "<Esc>",	'\033' },
   { "<Tab>",	'\t' },
   { "<Space>",	' ' },
@@ -785,6 +783,7 @@ void km_init (void)
   km_bindkey ("8", MENU_GENERIC, OP_JUMP);
   km_bindkey ("9", MENU_GENERIC, OP_JUMP);
 
+  km_bindkey ("<return>", MENU_GENERIC, OP_GENERIC_SELECT_ENTRY);
   km_bindkey ("<enter>", MENU_GENERIC, OP_GENERIC_SELECT_ENTRY);
 
   /* Miscellaneous extra bindings */
@@ -796,10 +795,10 @@ void km_init (void)
   km_bindkey ("K", MENU_MAIN, OP_PREV_ENTRY);
   km_bindkey ("x", MENU_MAIN, OP_EXIT);
 
+  km_bindkey ("<return>", MENU_MAIN, OP_DISPLAY_MESSAGE);
   km_bindkey ("<enter>", MENU_MAIN, OP_DISPLAY_MESSAGE);
 
   km_bindkey ("x", MENU_PAGER, OP_EXIT);
-  km_bindkey ("i", MENU_PAGER, OP_EXIT);
   km_bindkey ("<backspace>", MENU_PAGER, OP_PREV_LINE);
   km_bindkey ("<pagedown>", MENU_PAGER, OP_NEXT_PAGE);
   km_bindkey ("<pageup>", MENU_PAGER, OP_PREV_PAGE);
@@ -819,13 +818,16 @@ void km_init (void)
   km_bindkey ("8", MENU_PAGER, OP_JUMP);
   km_bindkey ("9", MENU_PAGER, OP_JUMP);
 
+  km_bindkey ("<return>", MENU_PAGER, OP_NEXT_LINE);
   km_bindkey ("<enter>", MENU_PAGER, OP_NEXT_LINE);
   
   km_bindkey ("<return>", MENU_ALIAS, OP_GENERIC_SELECT_ENTRY);
   km_bindkey ("<enter>",  MENU_ALIAS, OP_GENERIC_SELECT_ENTRY);
   km_bindkey ("<space>", MENU_ALIAS, OP_TAG);
 
+  km_bindkey ("<return>", MENU_ATTACH, OP_VIEW_ATTACH);
   km_bindkey ("<enter>", MENU_ATTACH, OP_VIEW_ATTACH);
+  km_bindkey ("<return>", MENU_COMPOSE, OP_VIEW_ATTACH);
   km_bindkey ("<enter>", MENU_COMPOSE, OP_VIEW_ATTACH);
 
   /* edit-to (default "t") hides generic tag-entry in Compose menu
diff --git a/lib.c b/lib.c
index 224232b..5f7c38f 100644
--- a/lib.c
+++ b/lib.c
@@ -219,8 +219,10 @@ int safe_fsync_close (FILE **f)
   {
     if (fflush (*f) || fsync (fileno (*f)))
     {
+      int save_errno = errno;
       r = -1;
       safe_fclose (f);
+      errno = save_errno;
     }
     else
       r = safe_fclose (f);
@@ -367,6 +369,7 @@ int mutt_copy_bytes (FILE *in, FILE *out, size_t size)
     size -= chunk;
   }
 
+  if (fflush(out) != 0) return -1;
   return 0;
 }
 
@@ -381,6 +384,7 @@ int mutt_copy_stream (FILE *fin, FILE *fout)
       return (-1);
   }
 
+  if (fflush(fout) != 0) return -1;
   return 0;
 }
 
diff --git a/mailbox.h b/mailbox.h
index 35fb601..9b2443c 100644
--- a/mailbox.h
+++ b/mailbox.h
@@ -48,6 +48,7 @@ typedef struct _message
 {
   FILE *fp;	/* pointer to the message data */
   char *path;	/* path to temp file */
+  char *commited_path; /* the final path generated by mx_commit_message() */
   short write;	/* nonzero if message is open for writing */
   struct {
     unsigned read : 1;
@@ -78,6 +79,9 @@ int mx_is_imap (const char *);
 #ifdef USE_POP
 int mx_is_pop (const char *);
 #endif
+#ifdef USE_NNTP
+int mx_is_nntp (const char *);
+#endif
 
 int mx_access (const char*, int);
 int mx_check_empty (const char *);
diff --git a/main.c b/main.c
index b654169..27a916f 100644
--- a/main.c
+++ b/main.c
@@ -31,6 +31,7 @@
 #include "url.h"
 #include "mutt_crypt.h"
 #include "mutt_idna.h"
+#include "version.h"
 #ifdef USE_SIDEBAR
 #include "sidebar.h"
 #endif
@@ -65,45 +66,9 @@
 #include <idn/stringprep.h>
 #endif
 
-static const char *ReachingUs = N_("\
-To contact the developers, please mail to <mutt-dev@mutt.org>.\n\
-To report a bug, please visit http://bugs.mutt.org/.\n");
-
-static const char *Notice = N_("\
-Copyright (C) 1996-2016 Michael R. Elkins and others.\n\
-Mutt comes with ABSOLUTELY NO WARRANTY; for details type `mutt -vv'.\n\
-Mutt is free software, and you are welcome to redistribute it\n\
-under certain conditions; type `mutt -vv' for details.\n");
-
-static const char *Copyright = N_("\
-Copyright (C) 1996-2016 Michael R. Elkins <me@mutt.org>\n\
-Copyright (C) 1996-2002 Brandon Long <blong@fiction.net>\n\
-Copyright (C) 1997-2009 Thomas Roessler <roessler@does-not-exist.org>\n\
-Copyright (C) 1998-2005 Werner Koch <wk@isil.d.shuttle.de>\n\
-Copyright (C) 1999-2014 Brendan Cully <brendan@kublai.com>\n\
-Copyright (C) 1999-2002 Tommi Komulainen <Tommi.Komulainen@iki.fi>\n\
-Copyright (C) 2000-2004 Edmund Grimley Evans <edmundo@rano.org>\n\
-Copyright (C) 2006-2009 Rocco Rutte <pdmef@gmx.net>\n\
-Copyright (C) 2014-2016 Kevin J. McCarthy <kevin@8t8.us>\n\
-\n\
-Many others not mentioned here contributed code, fixes,\n\
-and suggestions.\n");
-
-static const char *Licence = N_("\
-    This program is free software; you can redistribute it and/or modify\n\
-    it under the terms of the GNU General Public License as published by\n\
-    the Free Software Foundation; either version 2 of the License, or\n\
-    (at your option) any later version.\n\
-\n\
-    This program is distributed in the hope that it will be useful,\n\
-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
-    GNU General Public License for more details.\n");
-static const char *Obtaining = N_("\
-    You should have received a copy of the GNU General Public License\n\
-    along with this program; if not, write to the Free Software\n\
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\
-");
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
 
 void mutt_exit (int code)
 {
@@ -141,6 +106,8 @@ options:\n\
   -e <command>\tspecify a command to be executed after initialization\n\
   -f <file>\tspecify which mailbox to read\n\
   -F <file>\tspecify an alternate muttrc file\n\
+  -g <server>\tspecify a news server (if compiled with NNTP)\n\
+  -G\t\tselect a newsgroup (if compiled with NNTP)\n\
   -H <file>\tspecify a draft file to read header and body from\n\
   -i <file>\tspecify a file which Mutt should include in the body\n\
   -m <type>\tspecify a default mailbox type\n\
@@ -161,365 +128,6 @@ options:\n\
   exit (0);
 }
 
-extern const char cc_version[];
-extern const char cc_cflags[];
-extern const char configure_options[];
-
-static char *
-rstrip_in_place(char *s)
-{
-  char *p;
-
-  p = &s[strlen(s)];
-  if (p == s)
-    return s;
-  p--;
-  while (p >= s && (*p == '\n' || *p == '\r'))
-    *p-- = '\0';
-  return s;
-}
-
-static void show_version (void)
-{
-  struct utsname uts;
-
-  puts (mutt_make_version());
-  puts (_(Notice));
-
-  uname (&uts);
-
-#ifdef _AIX
-  printf ("System: %s %s.%s", uts.sysname, uts.version, uts.release);
-#elif defined (SCO)
-  printf ("System: SCO %s", uts.release);
-#else
-  printf ("System: %s %s", uts.sysname, uts.release);
-#endif
-
-  printf (" (%s)", uts.machine);
-
-#ifdef NCURSES_VERSION
-  printf ("\nncurses: %s (compiled with %s)", curses_version(), NCURSES_VERSION);
-#elif defined(USE_SLANG_CURSES)
-  printf ("\nslang: %d", SLANG_VERSION);
-#endif
-
-#ifdef _LIBICONV_VERSION
-  printf ("\nlibiconv: %d.%d", _LIBICONV_VERSION >> 8,
-	  _LIBICONV_VERSION & 0xff);
-#endif
-
-#ifdef HAVE_LIBIDN
-  printf ("\nlibidn: %s (compiled with %s)", stringprep_check_version (NULL), 
-	  STRINGPREP_VERSION);
-#endif
-
-#ifdef USE_HCACHE
-  printf ("\nhcache backend: %s", mutt_hcache_backend ());
-#endif
-
-  puts ("\n\nCompiler:");
-  rstrip_in_place((char *)cc_version);
-  puts (cc_version);
-
-  rstrip_in_place((char *)configure_options);
-  printf ("\nConfigure options: %s\n", configure_options);
-
-  rstrip_in_place((char *)cc_cflags);
-  printf ("\nCompilation CFLAGS: %s\n", cc_cflags);
-
-  puts (_("\nCompile options:"));
-
-#ifdef DOMAIN
-  printf ("DOMAIN=\"%s\"\n", DOMAIN);
-#else
-  puts ("-DOMAIN");
-#endif
-
-#ifdef DEBUG
-  puts ("+DEBUG");
-#else
-  puts ("-DEBUG");
-#endif
-  
-
-  
-  puts (
-
-#ifdef HOMESPOOL
-	"+HOMESPOOL  "
-#else
-	"-HOMESPOOL  "
-#endif
-
-#ifdef USE_SETGID
-	"+USE_SETGID  "
-#else
-	"-USE_SETGID  "
-#endif
-
-#ifdef USE_DOTLOCK
-	"+USE_DOTLOCK  "
-#else
-	"-USE_DOTLOCK  "
-#endif
-
-#ifdef DL_STANDALONE
-	"+DL_STANDALONE  "
-#else
-	"-DL_STANDALONE  "
-#endif
-
-#ifdef USE_FCNTL
-	"+USE_FCNTL  "
-#else
-	"-USE_FCNTL  "
-#endif
-
-#ifdef USE_FLOCK
-	"+USE_FLOCK   "
-#else
-	"-USE_FLOCK   "
-#endif
-    );
-  puts (
-#ifdef USE_POP
-	"+USE_POP  "
-#else
-	"-USE_POP  "
-#endif
-
-#ifdef USE_IMAP
-        "+USE_IMAP  "
-#else
-        "-USE_IMAP  "
-#endif
-
-#ifdef USE_SMTP
-	"+USE_SMTP  "
-#else
-	"-USE_SMTP  "
-#endif
-	"\n"
-	
-#ifdef USE_SSL_OPENSSL
-	"+USE_SSL_OPENSSL  "
-#else
-	"-USE_SSL_OPENSSL  "
-#endif
-
-#ifdef USE_SSL_GNUTLS
-	"+USE_SSL_GNUTLS  "
-#else
-	"-USE_SSL_GNUTLS  "
-#endif
-
-#ifdef USE_SASL
-	"+USE_SASL  "
-#else
-	"-USE_SASL  "
-#endif
-#ifdef USE_GSS
-	"+USE_GSS  "
-#else
-	"-USE_GSS  "
-#endif
-
-#if HAVE_GETADDRINFO
-	"+HAVE_GETADDRINFO  "
-#else
-	"-HAVE_GETADDRINFO  "
-#endif
-        );
-  	
-  puts (
-#ifdef HAVE_REGCOMP
-	"+HAVE_REGCOMP  "
-#else
-	"-HAVE_REGCOMP  "
-#endif
-
-#ifdef USE_GNU_REGEX
-	"+USE_GNU_REGEX  "
-#else
-	"-USE_GNU_REGEX  "
-#endif
-
-	"\n"
-	
-#ifdef HAVE_COLOR
-	"+HAVE_COLOR  "
-#else
-	"-HAVE_COLOR  "
-#endif
-	
-#ifdef HAVE_START_COLOR
-	"+HAVE_START_COLOR  "
-#else
-	"-HAVE_START_COLOR  "
-#endif
-	
-#ifdef HAVE_TYPEAHEAD
-	"+HAVE_TYPEAHEAD  "
-#else
-	"-HAVE_TYPEAHEAD  "
-#endif
-	
-#ifdef HAVE_BKGDSET
-	"+HAVE_BKGDSET  "
-#else
-	"-HAVE_BKGDSET  "
-#endif
-
-	"\n"
-	
-#ifdef HAVE_CURS_SET
-	"+HAVE_CURS_SET  "
-#else
-	"-HAVE_CURS_SET  "
-#endif
-	
-#ifdef HAVE_META
-	"+HAVE_META  "
-#else
-	"-HAVE_META  "
-#endif
-	
-#ifdef HAVE_RESIZETERM
-	"+HAVE_RESIZETERM  "
-#else
-	"-HAVE_RESIZETERM  "
-#endif
-        );	
-  
-  puts (
-#ifdef CRYPT_BACKEND_CLASSIC_PGP
-        "+CRYPT_BACKEND_CLASSIC_PGP  "
-#else
-        "-CRYPT_BACKEND_CLASSIC_PGP  "
-#endif
-#ifdef CRYPT_BACKEND_CLASSIC_SMIME
-        "+CRYPT_BACKEND_CLASSIC_SMIME  "
-#else
-        "-CRYPT_BACKEND_CLASSIC_SMIME  "
-#endif
-#ifdef CRYPT_BACKEND_GPGME
-        "+CRYPT_BACKEND_GPGME  "
-#else
-        "-CRYPT_BACKEND_GPGME  "
-#endif
-        );
-  
-  puts (
-#ifdef EXACT_ADDRESS
-	"+EXACT_ADDRESS  "
-#else
-	"-EXACT_ADDRESS  "
-#endif
-
-#ifdef SUN_ATTACHMENT
-	"+SUN_ATTACHMENT  "
-#else
-	"-SUN_ATTACHMENT  "
-#endif
-
-	"\n"
-	
-#ifdef ENABLE_NLS
-	"+ENABLE_NLS  "
-#else
-	"-ENABLE_NLS  "
-#endif
-
-#ifdef LOCALES_HACK
-	"+LOCALES_HACK  "
-#else
-	"-LOCALES_HACK  "
-#endif
-	      
-#ifdef HAVE_WC_FUNCS
-	"+HAVE_WC_FUNCS  "
-#else
-	"-HAVE_WC_FUNCS  "
-#endif
-	
-#ifdef HAVE_LANGINFO_CODESET
-	"+HAVE_LANGINFO_CODESET  "
-#else
-	"-HAVE_LANGINFO_CODESET  "
-#endif
-
-	
-#ifdef HAVE_LANGINFO_YESEXPR
- 	"+HAVE_LANGINFO_YESEXPR  "
-#else
- 	"-HAVE_LANGINFO_YESEXPR  "
-#endif
-	
-	"\n"
-
-#if HAVE_ICONV
-	"+HAVE_ICONV  "
-#else
-	"-HAVE_ICONV  "
-#endif
-
-#if ICONV_NONTRANS
-	"+ICONV_NONTRANS  "
-#else
-	"-ICONV_NONTRANS  "
-#endif
-
-#if HAVE_LIBIDN
-	"+HAVE_LIBIDN  "
-#else
-	"-HAVE_LIBIDN  "
-#endif
-	
-#if HAVE_GETSID
-	"+HAVE_GETSID  "
-#else
-	"-HAVE_GETSID  "
-#endif
-
-#if USE_HCACHE
-	"+USE_HCACHE  "
-#else
-	"-USE_HCACHE  "
-#endif
-
-#ifdef USE_SIDEBAR
-	"+USE_SIDEBAR  "
-#else
-	"-USE_SIDEBAR  "
-#endif
-
-	);
-
-#ifdef ISPELL
-  printf ("ISPELL=\"%s\"\n", ISPELL);
-#else
-  puts ("-ISPELL");
-#endif
-
-  printf ("SENDMAIL=\"%s\"\n", SENDMAIL);
-  printf ("MAILPATH=\"%s\"\n", MAILPATH);
-  printf ("PKGDATADIR=\"%s\"\n", PKGDATADIR);
-  printf ("SYSCONFDIR=\"%s\"\n", SYSCONFDIR);
-  printf ("EXECSHELL=\"%s\"\n", EXECSHELL);
-#ifdef MIXMASTER
-  printf ("MIXMASTER=\"%s\"\n", MIXMASTER);
-#else
-  puts ("-MIXMASTER");
-#endif
-
-  puts(_(ReachingUs));
-
-  mutt_print_patchlist();
-  
-  exit (0);
-}
-
 static void start_curses (void)
 {
   km_init (); /* must come before mutt_init */
@@ -549,6 +157,7 @@ static void start_curses (void)
   keypad (stdscr, TRUE);
   cbreak ();
   noecho ();
+  nonl ();
 #if HAVE_TYPEAHEAD
   typeahead (-1);       /* simulate smooth scrolling */
 #endif
@@ -564,6 +173,9 @@ init_extended_keys();
 #define MUTT_NOSYSRC (1<<2)	/* -n */
 #define MUTT_RO      (1<<3)	/* -R */
 #define MUTT_SELECT  (1<<4)	/* -y */
+#ifdef USE_NNTP
+#define MUTT_NEWS    (1<<5)	/* -g and -G */
+#endif
 
 int main (int argc, char **argv)
 {
@@ -608,7 +220,7 @@ int main (int argc, char **argv)
 
   mutt_error = mutt_nocurses_error;
   mutt_message = mutt_nocurses_error;
-  SRAND (time (NULL));
+  (void)mutt_rand32();
   umask (077);
 
   memset (Options, 0, sizeof (Options));
@@ -637,7 +249,11 @@ int main (int argc, char **argv)
         argv[nargc++] = argv[optind];
     }
 
+#ifdef USE_NNTP
+    if ((i = getopt (argc, argv, "+A:a:b:F:f:c:Dd:Ee:g:GH:s:i:hm:npQ:RvxyzZ")) != EOF)
+#else
     if ((i = getopt (argc, argv, "+A:a:b:F:f:c:Dd:Ee:H:s:i:hm:npQ:RvxyzZ")) != EOF)
+#endif
       switch (i)
       {
       case 'A':
@@ -738,6 +354,20 @@ int main (int argc, char **argv)
 	flags |= MUTT_SELECT;
 	break;
 
+#ifdef USE_NNTP
+      case 'g': /* Specify a news server */
+	{
+	  char buf[LONG_STRING];
+
+	  snprintf (buf, sizeof (buf), "set news_server=%s", optarg);
+	  commands = mutt_add_list (commands, buf);
+	}
+
+      case 'G': /* List of newsgroups */
+	flags |= MUTT_SELECT | MUTT_NEWS;
+	break;
+#endif
+
       case 'z':
 	flags |= MUTT_IGNORE;
 	break;
@@ -762,14 +392,10 @@ int main (int argc, char **argv)
     case 0:
       break;
     case 1:
-      show_version ();
-      break;
+      print_version();
+      exit (0);
     default:
-      puts (mutt_make_version ());
-      puts (_(Copyright));
-      puts (_(Licence));
-      puts (_(Obtaining));
-      puts (_(ReachingUs));
+      print_copyright();
       exit (0);
   }
 
@@ -1183,6 +809,18 @@ int main (int argc, char **argv)
     }
     else if (flags & MUTT_SELECT)
     {
+#ifdef USE_NNTP
+      if (flags & MUTT_NEWS)
+      {
+	set_option (OPTNEWS);
+	if(!(CurrentNewsSrv = nntp_select_server (NewsServer, 0)))
+	{
+	  mutt_endwin (Errorbuf);
+	  exit (1);
+	}
+      }
+      else
+#endif
       if (!Incoming) {
 	mutt_endwin _("No incoming mailboxes defined.");
 	exit (1);
@@ -1198,6 +836,15 @@ int main (int argc, char **argv)
 
     if (!folder[0])
       strfcpy (folder, NONULL(Spoolfile), sizeof (folder));
+
+#ifdef USE_NNTP
+    if (option (OPTNEWS))
+    {
+      unset_option (OPTNEWS);
+      nntp_expand_path (folder, sizeof (folder), &CurrentNewsSrv->conn->account);
+    }
+    else
+#endif
     mutt_expand_path (folder, sizeof (folder));
 
     mutt_str_replace (&CurrentFolder, folder);
@@ -1225,9 +872,13 @@ int main (int argc, char **argv)
 #ifdef USE_SIDEBAR
       mutt_sb_set_open_buffy ();
 #endif
+      Labels = hash_create (131, 0);
+      mutt_scan_labels(Context);
       mutt_index_menu ();
       if (Context)
 	FREE (&Context);
+      if (Labels)
+        hash_destroy(&Labels, NULL);
     }
 #ifdef USE_IMAP
     imap_logout_all ();
diff --git a/mbyte.c b/mbyte.c
index 3df143f..aa4d0bd 100644
--- a/mbyte.c
+++ b/mbyte.c
@@ -107,7 +107,7 @@ static size_t wcrtomb_iconv (char *s, wchar_t wc, iconv_t cd)
   char buf[MB_LEN_MAX+1];
   ICONV_CONST char *ib;
   char *ob;
-  size_t ibl, obl, r;
+  size_t ibl, obl;
 
   if (s)
   {
@@ -117,7 +117,7 @@ static size_t wcrtomb_iconv (char *s, wchar_t wc, iconv_t cd)
     ib = buf;
     ob = s;
     obl = MB_LEN_MAX;
-    r = iconv (cd, &ib, &ibl, &ob, &obl);
+    iconv (cd, &ib, &ibl, &ob, &obl);
   }
   else
   {
@@ -125,7 +125,7 @@ static size_t wcrtomb_iconv (char *s, wchar_t wc, iconv_t cd)
     ibl = 1;
     ob = buf;
     obl = sizeof (buf);
-    r = iconv (cd, &ib, &ibl, &ob, &obl);
+    iconv (cd, &ib, &ibl, &ob, &obl);
   }
   return ob - s;
 }
diff --git a/menu.c b/menu.c
index 3c45656..252760c 100644
--- a/menu.c
+++ b/menu.c
@@ -30,7 +30,51 @@
 
 char* SearchBuffers[MENU_MAX];
 
-static void print_enriched_string (int attr, unsigned char *s, int do_color)
+/**
+ * get_color - XXX
+ */
+static int
+get_color (int index, unsigned char *s)
+{
+  COLOR_LINE *color;
+  HEADER *hdr = Context->hdrs[Context->v2r[index]];
+  int type = *s;
+
+  switch (type)
+  {
+    case MT_COLOR_INDEX_AUTHOR:
+      color = ColorIndexAuthorList;
+      break;
+    case MT_COLOR_INDEX_FLAGS:
+      color = ColorIndexFlagsList;
+      break;
+    case MT_COLOR_INDEX_SUBJECT:
+      color = ColorIndexSubjectList;
+      break;
+#ifdef USE_NOTMUCH
+    case MT_COLOR_INDEX_TAG:
+      for (color = ColorIndexTagList; color; color = color->next)
+      {
+        const char * transform = hash_find(TagTransforms, color->pattern);
+        if (transform && (strncmp((const char *)(s+1),
+            transform, strlen(transform)) == 0))
+          return color->pair;
+      }
+      return 0;
+#endif
+    default:
+      return ColorDefs[type];
+  }
+
+  for (; color; color = color->next)
+    if (mutt_pattern_exec (color->color_pattern, MUTT_MATCH_FULL_ADDRESS,
+        Context, hdr))
+      return color->pair;
+
+  return 0;
+}
+
+static void print_enriched_string (int index, int attr, unsigned char *s, int do_color)
 {
   wchar_t wc;
   size_t k;
@@ -162,6 +206,30 @@ static void print_enriched_string (int attr, unsigned char *s, int do_color)
       }
       if (do_color) ATTRSET(attr);
     }
+    else if (*s == MUTT_SPECIAL_INDEX)
+    {
+      s++;
+      if (do_color)
+      {
+        if (*s == MT_COLOR_INDEX)
+	{
+          attrset (attr);
+	}
+	else
+	{
+          if (get_color (index, s) == 0)
+	  {
+            attron (attr);
+	  }
+	  else
+	  {
+            attron (get_color (index, s));
+	  }
+        }
+      }
+      s++;
+      n -= 2;
+    }
     else if ((k = mbrtowc (&wc, (char *)s, n, &mbstate)) > 0)
     {
       addnstr ((char *)s, k);
@@ -277,7 +345,7 @@ void menu_redraw_index (MUTTMENU *menu)
       else if (option(OPTARROWCURSOR))
 	addstr("   ");
 
-      print_enriched_string (attr, (unsigned char *) buf, do_color);
+      print_enriched_string (i, attr, (unsigned char *) buf, do_color);
     }
     else
     {
@@ -312,7 +380,7 @@ void menu_redraw_motion (MUTTMENU *menu)
       menu_make_entry (buf, sizeof (buf), menu, menu->oldcurrent);
       menu_pad_string (menu, buf, sizeof (buf));
       mutt_window_move (menu->indexwin, menu->oldcurrent + menu->offset - menu->top, 3);
-      print_enriched_string (menu->color(menu->oldcurrent), (unsigned char *) buf, 1);
+      print_enriched_string (menu->oldcurrent, menu->color (menu->oldcurrent), (unsigned char *) buf, 1);
     }
 
     /* now draw it in the new location */
@@ -324,14 +392,14 @@ void menu_redraw_motion (MUTTMENU *menu)
     /* erase the current indicator */
     menu_make_entry (buf, sizeof (buf), menu, menu->oldcurrent);
     menu_pad_string (menu, buf, sizeof (buf));
-    print_enriched_string (menu->color(menu->oldcurrent), (unsigned char *) buf, 1);
+    print_enriched_string (menu->oldcurrent, menu->color (menu->oldcurrent), (unsigned char *) buf, 1);
 
     /* now draw the new one to reflect the change */
     menu_make_entry (buf, sizeof (buf), menu, menu->current);
     menu_pad_string (menu, buf, sizeof (buf));
     SETCOLOR(MT_COLOR_INDICATOR);
     mutt_window_move (menu->indexwin, menu->current + menu->offset - menu->top, 0);
-    print_enriched_string (menu->color(menu->current), (unsigned char *) buf, 0);
+    print_enriched_string (menu->current, menu->color (menu->current), (unsigned char *) buf, 0);
   }
   menu->redraw &= REDRAW_STATUS;
   NORMAL_COLOR;
@@ -353,10 +421,10 @@ void menu_redraw_current (MUTTMENU *menu)
     ATTRSET(attr);
     addch (' ');
     menu_pad_string (menu, buf, sizeof (buf));
-    print_enriched_string (attr, (unsigned char *) buf, 1);
+    print_enriched_string (menu->current, attr, (unsigned char *) buf, 1);
   }
   else
-    print_enriched_string (attr, (unsigned char *) buf, 0);
+    print_enriched_string (menu->current, attr, (unsigned char *) buf, 0);
   menu->redraw &= REDRAW_STATUS;
   NORMAL_COLOR;
 }
diff --git a/mh.c b/mh.c
index 371656a..c90679e 100644
--- a/mh.c
+++ b/mh.c
@@ -56,6 +56,14 @@
 #include <sys/time.h>
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #define		INS_SORT_THRESHOLD		6
 
 static int maildir_check_mailbox (CONTEXT * ctx, int *index_hint);
@@ -355,8 +363,8 @@ static int mh_mkstemp (CONTEXT * dest, FILE ** fp, char **tgt)
   omask = umask (mh_umask (dest));
   FOREVER
   {
-    snprintf (path, _POSIX_PATH_MAX, "%s/.mutt-%s-%d-%d",
-	      dest->path, NONULL (Hostname), (int) getpid (), Counter++);
+    snprintf (path, _POSIX_PATH_MAX, "%s/.mutt-%s-%d-%" PRIu64,
+	      dest->path, NONULL (Hostname), (int) getpid (), mutt_rand64());
     if ((fd = open (path, O_WRONLY | O_EXCL | O_CREAT, 0666)) == -1)
     {
       if (errno != EEXIST)
@@ -661,7 +669,7 @@ static void maildir_free_maildir (struct maildir **md)
   }
 }
 
-static void maildir_parse_flags (HEADER * h, const char *path)
+void maildir_parse_flags (HEADER * h, const char *path)
 {
   char *p, *q = NULL;
 
@@ -744,40 +752,51 @@ static void maildir_update_mtime (CONTEXT * ctx)
  * Actually parse a maildir message.  This may also be used to fill
  * out a fake header structure generated by lazy maildir parsing.
  */
-static HEADER *maildir_parse_message (int magic, const char *fname,
+HEADER *maildir_parse_stream (int magic, FILE *f, const char *fname,
 				      int is_old, HEADER * _h)
 {
-  FILE *f;
   HEADER *h = _h;
   struct stat st;
 
-  if ((f = fopen (fname, "r")) != NULL)
-  {
-    if (!h)
-      h = mutt_new_header ();
-    h->env = mutt_read_rfc822_header (f, h, 0, 0);
+  if (!h)
+    h = mutt_new_header ();
+  h->env = mutt_read_rfc822_header (f, h, 0, 0);
 
-    fstat (fileno (f), &st);
-    safe_fclose (&f);
+  fstat (fileno (f), &st);
 
-    if (!h->received)
-      h->received = h->date_sent;
+  if (!h->received)
+    h->received = h->date_sent;
 
-    /* always update the length since we have fresh information available. */
-    h->content->length = st.st_size - h->content->offset;
+  /* always update the length since we have fresh information available. */
+  h->content->length = st.st_size - h->content->offset;
 
-    h->index = -1;
+  h->index = -1;
 
-    if (magic == MUTT_MAILDIR)
-    {
-      /* 
-       * maildir stores its flags in the filename, so ignore the
-       * flags in the header of the message 
-       */
+  if (magic == MUTT_MAILDIR)
+  {
+    /*
+     * maildir stores its flags in the filename, so ignore the
+     * flags in the header of the message
+     */
 
-      h->old = is_old;
-      maildir_parse_flags (h, fname);
-    }
+    h->old = is_old;
+    maildir_parse_flags (h, fname);
+  }
+  return h;
+}
+
+/*
+ * Actually parse a maildir message.  This may also be used to fill
+ * out a fake header structure generated by lazy maildir parsing.
+ */
+HEADER *maildir_parse_message (int magic, const char *fname,
+				      int is_old, HEADER * h)
+{
+  FILE *f;
+
+  if ((f = fopen (fname, "r")) != NULL) {
+    h = maildir_parse_stream (magic, f, fname, is_old, h);
+    safe_fclose (&f);
     return h;
   }
   return NULL;
@@ -1385,7 +1404,7 @@ static int ch_compar (const void *a, const void *b)
   return (int)( *((const char *) a) - *((const char *) b));
 }
 
-static void maildir_flags (char *dest, size_t destlen, HEADER * hdr)
+void maildir_flags (char *dest, size_t destlen, HEADER * hdr)
 {
   *dest = '\0';
 
@@ -1422,7 +1441,7 @@ static int maildir_mh_open_message (CONTEXT *ctx, MESSAGE *msg, int msgno,
 
   msg->fp = fopen (path, "r");
   if (msg->fp == NULL && errno == ENOENT && is_maildir)
-    msg->fp = maildir_open_find_message (ctx->path, cur->path);
+    msg->fp = maildir_open_find_message (ctx->path, cur->path, NULL);
 
   if (!msg->fp)
   {
@@ -1486,9 +1505,9 @@ static int maildir_open_new_message (MESSAGE * msg, CONTEXT * dest, HEADER * hdr
   omask = umask (mh_umask (dest));
   FOREVER
   {
-    snprintf (path, _POSIX_PATH_MAX, "%s/tmp/%s.%lld.%u_%d.%s%s",
-	      dest->path, subdir, (long long)time (NULL), (unsigned int)getpid (),
-	      Counter++, NONULL (Hostname), suffix);
+    snprintf (path, _POSIX_PATH_MAX, "%s/tmp/%s.%lld.R%" PRIu64 ".%s%s",
+	      dest->path, subdir, (long long)time (NULL), mutt_rand64(),
+              NONULL (Hostname), suffix);
 
     dprint (2, (debugfile, "maildir_open_new_message (): Trying %s.\n",
 		path));
@@ -1572,8 +1591,8 @@ static int _maildir_commit_message (CONTEXT * ctx, MESSAGE * msg, HEADER * hdr)
   /* construct a new file name. */
   FOREVER
   {
-    snprintf (path, _POSIX_PATH_MAX, "%s/%lld.%u_%d.%s%s", subdir,
-	      (long long)time (NULL), (unsigned int)getpid (), Counter++,
+    snprintf (path, _POSIX_PATH_MAX, "%s/%lld.R%" PRIu64 ".%s%s", subdir,
+	      (long long)time (NULL), mutt_rand64(),
 	      NONULL (Hostname), suffix);
     snprintf (full, _POSIX_PATH_MAX, "%s/%s", ctx->path, path);
 
@@ -1582,10 +1601,6 @@ static int _maildir_commit_message (CONTEXT * ctx, MESSAGE * msg, HEADER * hdr)
 
     if (safe_rename (msg->path, full) == 0)
     {
-      if (hdr)
-	mutt_str_replace (&hdr->path, path);
-      FREE (&msg->path);
-
       /*
        * Adjust the mtime on the file to match the time at which this
        * message was received.  Currently this is only set when copying
@@ -1601,11 +1616,23 @@ static int _maildir_commit_message (CONTEXT * ctx, MESSAGE * msg, HEADER * hdr)
 	if (utime (full, &ut))
 	{
 	  mutt_perror (_("_maildir_commit_message(): unable to set time on file"));
-	  return -1;
+	  goto post_rename_err;
 	}
       }
 
+#ifdef USE_NOTMUCH
+      if (ctx->magic == MUTT_NOTMUCH)
+	nm_update_filename(ctx, hdr->path, full, hdr);
+#endif
+      if (hdr)
+	mutt_str_replace (&hdr->path, path);
+      mutt_str_replace (&msg->commited_path, full);
+      FREE (&msg->path);
+
       return 0;
+
+post_rename_err:
+      return -1;
     }
     else if (errno != EEXIST)
     {
@@ -1686,6 +1713,7 @@ static int _mh_commit_message (CONTEXT * ctx, MESSAGE * msg, HEADER * hdr,
     {
       if (hdr)
 	mutt_str_replace (&hdr->path, tmp);
+      mutt_str_replace (&msg->commited_path, path);
       FREE (&msg->path);
       break;
     }
@@ -1790,7 +1818,7 @@ static int mh_sync_message (CONTEXT * ctx, int msgno)
 {
   HEADER *h = ctx->hdrs[msgno];
 
-  if (h->attach_del || 
+  if (h->attach_del || h->label_changed ||
       (h->env && (h->env->refs_changed || h->env->irt_changed)))
     if (mh_rewrite_message (ctx, msgno) != 0)
       return -1;
@@ -1802,7 +1830,7 @@ static int maildir_sync_message (CONTEXT * ctx, int msgno)
 {
   HEADER *h = ctx->hdrs[msgno];
 
-  if (h->attach_del || 
+  if (h->attach_del || h->label_changed ||
       (h->env && (h->env->refs_changed || h->env->irt_changed)))
   {
     /* when doing attachment deletion/rethreading, fall back to the MH case. */
@@ -1861,96 +1889,114 @@ static int maildir_sync_message (CONTEXT * ctx, int msgno)
   return (0);
 }
 
-int mh_sync_mailbox (CONTEXT * ctx, int *index_hint)
-{
-  char path[_POSIX_PATH_MAX], tmp[_POSIX_PATH_MAX];
-  int i, j;
-#if USE_HCACHE
-  header_cache_t *hc = NULL;
-#endif /* USE_HCACHE */
-  char msgbuf[STRING];
-  progress_t progress;
-
-  if (ctx->magic == MUTT_MH)
-    i = mh_check_mailbox (ctx, index_hint);
-  else 
-    i = maildir_check_mailbox (ctx, index_hint);
-      
-  if (i != 0)
-    return i;
-
 #if USE_HCACHE
-  if (ctx->magic == MUTT_MAILDIR || ctx->magic == MUTT_MH)
-    hc = mutt_hcache_open(HeaderCache, ctx->path, NULL);
-#endif /* USE_HCACHE */
-
-  if (!ctx->quiet)
-  {
-    snprintf (msgbuf, sizeof (msgbuf), _("Writing %s..."), ctx->path);
-    mutt_progress_init (&progress, msgbuf, MUTT_PROGRESS_MSG, WriteInc, ctx->msgcount);
-  }
-
-  for (i = 0; i < ctx->msgcount; i++)
-  {
-    if (!ctx->quiet)
-      mutt_progress_update (&progress, i, -1);
+int mh_sync_mailbox_message (CONTEXT * ctx, int msgno, header_cache_t *hc)
+#else
+int mh_sync_mailbox_message (CONTEXT * ctx, int msgno)
+#endif
+{
+    char path[_POSIX_PATH_MAX], tmp[_POSIX_PATH_MAX];
+    HEADER *h = ctx->hdrs[msgno];
 
-    if (ctx->hdrs[i]->deleted
-	&& (ctx->magic != MUTT_MAILDIR || !option (OPTMAILDIRTRASH)))
+    if (h->deleted && (ctx->magic != MUTT_MAILDIR || !option (OPTMAILDIRTRASH)))
     {
-      snprintf (path, sizeof (path), "%s/%s", ctx->path, ctx->hdrs[i]->path);
+      snprintf (path, sizeof (path), "%s/%s", ctx->path, h->path);
       if (ctx->magic == MUTT_MAILDIR
 	  || (option (OPTMHPURGE) && ctx->magic == MUTT_MH))
       {
 #if USE_HCACHE
-        if (ctx->magic == MUTT_MAILDIR)
-          mutt_hcache_delete (hc, ctx->hdrs[i]->path + 3, &maildir_hcache_keylen);
-	else if (ctx->magic == MUTT_MH)
-	  mutt_hcache_delete (hc, ctx->hdrs[i]->path, strlen);
+	if (hc) {
+           if (ctx->magic == MUTT_MAILDIR)
+              mutt_hcache_delete (hc, h->path + 3, &maildir_hcache_keylen);
+	   else if (ctx->magic == MUTT_MH)
+	      mutt_hcache_delete (hc, h->path, strlen);
+	}
 #endif /* USE_HCACHE */
 	unlink (path);
       }
       else if (ctx->magic == MUTT_MH)
       {
 	/* MH just moves files out of the way when you delete them */
-	if (*ctx->hdrs[i]->path != ',')
+	if (*h->path != ',')
 	{
-	  snprintf (tmp, sizeof (tmp), "%s/,%s", ctx->path,
-		    ctx->hdrs[i]->path);
+	  snprintf (tmp, sizeof (tmp), "%s/,%s", ctx->path, h->path);
 	  unlink (tmp);
 	  rename (path, tmp);
 	}
 
       }
     }
-    else if (ctx->hdrs[i]->changed || ctx->hdrs[i]->attach_del ||
+    else if (h->changed || h->attach_del ||
+	     h->label_changed ||
 	     (ctx->magic == MUTT_MAILDIR
-	      && (option (OPTMAILDIRTRASH) || ctx->hdrs[i]->trash)
-	      && (ctx->hdrs[i]->deleted != ctx->hdrs[i]->trash)))
+	      && (option (OPTMAILDIRTRASH) || h->trash)
+	      && (h->deleted != h->trash)))
     {
       if (ctx->magic == MUTT_MAILDIR)
       {
-	if (maildir_sync_message (ctx, i) == -1)
-	  goto err;
+	if (maildir_sync_message (ctx, msgno) == -1)
+	  return -1;
       }
       else
       {
-	if (mh_sync_message (ctx, i) == -1)
-	  goto err;
+	if (mh_sync_message (ctx, msgno) == -1)
+	  return -1;
       }
     }
 
 #if USE_HCACHE
-    if (ctx->hdrs[i]->changed)
+    if (hc && h->changed)
     {
       if (ctx->magic == MUTT_MAILDIR)
-	mutt_hcache_store (hc, ctx->hdrs[i]->path + 3, ctx->hdrs[i],
-			   0, &maildir_hcache_keylen, MUTT_GENERATE_UIDVALIDITY);
+	mutt_hcache_store (hc, h->path + 3, h, 0, &maildir_hcache_keylen, MUTT_GENERATE_UIDVALIDITY);
       else if (ctx->magic == MUTT_MH)
-	mutt_hcache_store (hc, ctx->hdrs[i]->path, ctx->hdrs[i], 0, strlen, MUTT_GENERATE_UIDVALIDITY);
+	mutt_hcache_store (hc, h->path, h, 0, strlen, MUTT_GENERATE_UIDVALIDITY);
     }
 #endif
 
+    return 0;
+}
+
+int mh_sync_mailbox (CONTEXT * ctx, int *index_hint)
+{
+  int i, j;
+#if USE_HCACHE
+  header_cache_t *hc = NULL;
+#endif /* USE_HCACHE */
+  char msgbuf[STRING];
+  progress_t progress;
+
+  if (ctx->magic == MUTT_MH)
+    i = mh_check_mailbox (ctx, index_hint);
+  else
+    i = maildir_check_mailbox (ctx, index_hint);
+
+  if (i != 0)
+    return i;
+
+#if USE_HCACHE
+  if (ctx->magic == MUTT_MAILDIR || ctx->magic == MUTT_MH)
+    hc = mutt_hcache_open(HeaderCache, ctx->path, NULL);
+#endif /* USE_HCACHE */
+
+  if (!ctx->quiet)
+  {
+    snprintf (msgbuf, sizeof (msgbuf), _("Writing %s..."), ctx->path);
+    mutt_progress_init (&progress, msgbuf, MUTT_PROGRESS_MSG, WriteInc, ctx->msgcount);
+  }
+
+  for (i = 0; i < ctx->msgcount; i++)
+  {
+    if (!ctx->quiet)
+      mutt_progress_update (&progress, i, -1);
+
+#if USE_HCACHE
+    if (mh_sync_mailbox_message (ctx, i, hc) == -1)
+      goto err;
+#else
+    if (mh_sync_mailbox_message (ctx, i) == -1)
+      goto err;
+#endif
   }
 
 #if USE_HCACHE
@@ -2029,7 +2075,7 @@ static void maildir_update_tables (CONTEXT *ctx, int *index_hint)
   mutt_clear_threads (ctx);
 }
 
-static void maildir_update_flags (CONTEXT *ctx, HEADER *o, HEADER *n)
+void maildir_update_flags (CONTEXT *ctx, HEADER *o, HEADER *n)
 {
   /* save the global state here so we can reset it at the
    * end of list block if required.
@@ -2332,7 +2378,7 @@ static int mh_check_mailbox (CONTEXT * ctx, int *index_hint)
  */
 
 static FILE *_maildir_open_find_message (const char *folder, const char *unique,
-				  const char *subfolder)
+				  const char *subfolder, char **newname)
 {
   char dir[_POSIX_PATH_MAX];
   char tunique[_POSIX_PATH_MAX];
@@ -2368,11 +2414,15 @@ static FILE *_maildir_open_find_message (const char *folder, const char *unique,
 
   closedir (dp);
 
+  if (newname && fp)
+    *newname = safe_strdup(fname);
+
   errno = oe;
   return fp;
 }
 
-FILE *maildir_open_find_message (const char *folder, const char *msg)
+FILE *maildir_open_find_message (const char *folder, const char *msg,
+                                  char **newname)
 {
   char unique[_POSIX_PATH_MAX];
   FILE *fp;
@@ -2384,7 +2434,8 @@ FILE *maildir_open_find_message (const char *folder, const char *msg)
   if (
       (fp =
        _maildir_open_find_message (folder, unique,
-				   new_hits > cur_hits ? "new" : "cur"))
+				   new_hits > cur_hits ? "new" : "cur",
+				   newname))
       || errno != ENOENT)
   {
     if (new_hits < UINT_MAX && cur_hits < UINT_MAX)
@@ -2398,7 +2449,8 @@ FILE *maildir_open_find_message (const char *folder, const char *msg)
   if (
       (fp =
        _maildir_open_find_message (folder, unique,
-				   new_hits > cur_hits ? "cur" : "new"))
+				   new_hits > cur_hits ? "cur" : "new",
+				   newname))
       || errno != ENOENT)
   {
     if (new_hits < UINT_MAX && cur_hits < UINT_MAX)
diff --git a/mutt.h b/mutt.h
index 2cf55b1..e7ecdff 100644
--- a/mutt.h
+++ b/mutt.h
@@ -52,6 +52,11 @@
 #include <limits.h>
 #endif
 
+/* PATH_MAX is undefined on the hurd */
+#ifndef PATH_MAX
+#define PATH_MAX _POSIX_PATH_MAX
+#endif
+
 #include <pwd.h>
 #include <grp.h>
 
@@ -66,6 +71,14 @@
 # define MB_LEN_MAX 16
 #endif
 
+#ifdef HAVE_FGETS_UNLOCKED
+# define fgets fgets_unlocked
+#endif
+
+#ifdef HAVE_FGETC_UNLOCKED
+# define fgetc fgetc_unlocked
+#endif
+
 /* nifty trick I stole from ELM 2.5alpha. */
 #ifdef MAIN_C
 #define WHERE 
@@ -88,6 +101,11 @@
 #define  MUTT_CLEAR   (1<<5) /* clear input if printable character is pressed */
 #define  MUTT_COMMAND (1<<6) /* do command completion */
 #define  MUTT_PATTERN (1<<7) /* pattern mode - only used for history classes */
+#define  MUTT_LABEL   (1<<8) /* do label completion */
+#if USE_NOTMUCH
+#define  MUTT_NM_QUERY (1<<9) /* Notmuch query mode. */
+#define  MUTT_NM_TAG   (1<<10) /* Notmuch tag +/- mode. */
+#endif
 
 /* flags for mutt_get_token() */
 #define MUTT_TOKEN_EQUAL      1       /* treat '=' as a special */
@@ -141,6 +159,12 @@ typedef enum
 #define MUTT_ACCOUNTHOOK (1<<9)
 #define MUTT_REPLYHOOK   (1<<10)
 #define MUTT_SEND2HOOK   (1<<11)
+#ifdef USE_COMPRESSED
+#define MUTT_OPENHOOK    (1<<12)
+#define MUTT_APPENDHOOK  (1<<13)
+#define MUTT_CLOSEHOOK   (1<<14)
+#endif
+#define MUTT_TIMEOUTHOOK (1<<15)
 
 /* tree characters for linearize_tree and print_enriched_string */
 #define MUTT_TREE_LLCORNER      1
@@ -158,6 +182,8 @@ typedef enum
 #define MUTT_TREE_MISSING       13
 #define MUTT_TREE_MAX           14
 
+#define MUTT_SPECIAL_INDEX		MUTT_TREE_MAX
+
 #define MUTT_THREAD_COLLAPSE    (1<<0)
 #define MUTT_THREAD_UNCOLLAPSE  (1<<1)
 #define MUTT_THREAD_GET_HIDDEN  (1<<2)
@@ -225,7 +251,13 @@ enum
   MUTT_CRYPT_ENCRYPT,
   MUTT_PGP_KEY,
   MUTT_XLABEL,
+#ifdef USE_NOTMUCH
+  MUTT_NOTMUCH_LABEL,
+#endif
   MUTT_MIMEATTACH,
+#ifdef USE_NNTP
+  MUTT_NEWSGROUPS,
+#endif
   
   /* Options for Mailcap lookup */
   MUTT_EDIT,
@@ -268,6 +300,7 @@ enum
   OPT_MIMEFWDREST,
   OPT_MOVE,
   OPT_PGPMIMEAUTO,     /* ask to revert to PGP/MIME when inline fails */
+  OPT_SMIMEENCRYPTSELF,
 #ifdef USE_POP
   OPT_POPDELETE,
   OPT_POPRECONNECT,
@@ -282,6 +315,11 @@ enum
 #endif
   OPT_SUBJECT,
   OPT_VERIFYSIG,      /* verify PGP signatures */
+#ifdef USE_NNTP
+  OPT_TOMODERATED,
+  OPT_CATCHUP,
+  OPT_FOLLOWUPTOPOSTER,
+#endif
     
   /* THIS MUST BE THE LAST VALUE. */
   OPT_MAX
@@ -300,6 +338,7 @@ enum
 #define SENDPOSTPONEDFCC	(1<<9) /* used by mutt_get_postponed() to signal that the x-mutt-fcc header field was present */
 #define SENDNOFREEHEADER	(1<<10)   /* Used by the -E flag */
 #define SENDDRAFTFILE		(1<<11)   /* Used by the -H flag */
+#define SENDNEWS	(1<<12)
 
 /* flags for mutt_compose_menu() */
 #define MUTT_COMPOSE_NOFREEHEADER (1<<0)
@@ -308,11 +347,18 @@ enum
 #define MUTT_SEL_BUFFY  (1<<0)
 #define MUTT_SEL_MULTI  (1<<1)
 #define MUTT_SEL_FOLDER (1<<2)
+#define MUTT_SEL_VFOLDER	(1<<3)
 
 /* flags for parse_spam_list */
 #define MUTT_SPAM          1
 #define MUTT_NOSPAM        2
 
+/* flags for keywords headers */
+#define MUTT_X_LABEL         (1<<0)  /* introduced to mutt in 2000 */
+#define MUTT_X_KEYWORDS      (1<<1)  /* used in c-client, dovecot */
+#define MUTT_X_MOZILLA_KEYS  (1<<2)  /* tbird */
+#define MUTT_KEYWORDS        (1<<3)  /* rfc2822 */
+
 /* boolean vars */
 enum
 {
@@ -322,6 +368,8 @@ enum
   OPTASCIICHARS,
   OPTASKBCC,
   OPTASKCC,
+  OPTASKFOLLOWUP,
+  OPTASKXCOMMENTTO,
   OPTATTACHSPLIT,
   OPTAUTOEDIT,
   OPTAUTOTAG,
@@ -388,6 +436,8 @@ enum
   OPTIMPLICITAUTOVIEW,
   OPTINCLUDEONLYFIRST,
   OPTKEEPFLAGGED,
+  OPTKEYWORDSLEGACY,
+  OPTKEYWORDSSTANDARD,
   OPTMAILCAPSANITIZE,
   OPTMAILCHECKRECENT,
   OPTMAILCHECKSTATS,
@@ -404,6 +454,9 @@ enum
   OPTMETOO,
   OPTMHPURGE,
   OPTMIMEFORWDECODE,
+#ifdef USE_NNTP
+  OPTMIMESUBJECT,	/* encode subject line with RFC2047 */
+#endif
   OPTNARROWTREE,
   OPTPAGERSTOP,
   OPTPIPEDECODE,
@@ -437,6 +490,7 @@ enum
   OPTSIDEBARNEWMAILONLY,
   OPTSIDEBARNEXTNEWWRAP,
   OPTSIDEBARSHORTPATH,
+  OPTSIDEBARONRIGHT,
 #endif
   OPTSIGDASHES,
   OPTSIGONTOP,
@@ -501,6 +555,17 @@ enum
   OPTPGPAUTOINLINE,
   OPTPGPREPLYINLINE,
 
+  /* news options */
+
+#ifdef USE_NNTP
+  OPTSHOWNEWNEWS,
+  OPTSHOWONLYUNREAD,
+  OPTSAVEUNSUB,
+  OPTLISTGROUP,
+  OPTLOADDESC,
+  OPTXCOMMENTTO,
+#endif
+
   /* pseudo options */
 
   OPTAUXSORT,		/* (pseudo) using auxiliary sort function */
@@ -521,6 +586,7 @@ enum
   OPTSORTSUBTHREADS,	/* (pseudo) used when $sort_aux changes */
   OPTNEEDRESCORE,	/* (pseudo) set when the `score' command is used */
   OPTATTACHMSG,		/* (pseudo) used by attach-message */
+  OPTHIDEREAD,		/* (pseudo) whether or not hide read messages */
   OPTKEEPQUIET,		/* (pseudo) shut up the message and refresh
 			 * 	    functions while we are executing an
 			 * 	    external program.
@@ -531,6 +597,15 @@ enum
   OPTDONTHANDLEPGPKEYS,	/* (pseudo) used to extract PGP keys */
   OPTIGNOREMACROEVENTS, /* (pseudo) don't process macro/push/exec events while set */
 
+#ifdef USE_NNTP
+  OPTNEWS,		/* (pseudo) used to change reader mode */
+  OPTNEWSSEND,		/* (pseudo) used to change behavior when posting */
+#endif
+#ifdef USE_NOTMUCH
+  OPTVIRTSPOOLFILE,
+  OPTNOTMUCHRECORD,
+#endif
+
   OPTMAX
 };
 
@@ -610,10 +685,19 @@ typedef struct envelope
   char *supersedes;
   char *date;
   char *x_label;
+  char *organization;
+#ifdef USE_NNTP
+  char *newsgroups;
+  char *xref;
+  char *followup_to;
+  char *x_comment_to;
+#endif
   BUFFER *spam;
   LIST *references;		/* message references (in reverse order) */
   LIST *in_reply_to;		/* in-reply-to header content */
   LIST *userhdrs;		/* user defined headers */
+  LIST *labels;
+  int kwtypes;
 
   unsigned int irt_changed : 1; /* In-Reply-To changed to link/break threads */
   unsigned int refs_changed : 1; /* References changed to break thread */
@@ -731,6 +815,7 @@ typedef struct header
   unsigned int tagged : 1;
   unsigned int deleted : 1;
   unsigned int purge : 1;               /* skip trash folder when deleting */
+  unsigned int quasi_deleted : 1;	/* deleted from mutt, but not modified on disk */
   unsigned int changed : 1;
   unsigned int attach_del : 1; 		/* has an attachment marked for deletion */
   unsigned int old : 1;
@@ -747,6 +832,7 @@ typedef struct header
 					 * This flag is used by the maildir_trash
 					 * option.
 					 */
+  unsigned int label_changed : 1;	/* editable - used for syncing */
   
   /* timezone of the sender of this message */
   unsigned int zhours : 5;
@@ -795,8 +881,9 @@ typedef struct header
   int refno;			/* message number on server */
 #endif
 
-#if defined USE_POP || defined USE_IMAP
+#if defined USE_POP || defined USE_IMAP || defined USE_NNTP || defined USE_NOTMUCH
   void *data;            	/* driver-specific data */
+  void (*free_cb)(struct header *); /* driver-specific data free function */
 #endif
   
   char *maildir_flags;		/* unknown maildir flags */
@@ -946,6 +1033,10 @@ typedef struct _context
   unsigned int closing : 1;	/* mailbox is being closed */
   unsigned int peekonly : 1;	/* just taking a glance, revert atime */
 
+#ifdef USE_COMPRESSED
+  void *compress_info;		/* compressed mbox module private data */
+#endif /* USE_COMPRESSED */
+
   /* driver hooks */
   void *data;			/* driver specific data */
   struct mx_ops *mx_ops;
diff --git a/mutt_curses.h b/mutt_curses.h
index 6200449..5ffcdb6 100644
--- a/mutt_curses.h
+++ b/mutt_curses.h
@@ -33,13 +33,6 @@
 #define KEY_DC SL_KEY_DELETE
 #define KEY_IC SL_KEY_IC
 
-/*
- * ncurses and SLang seem to send different characters when the Enter key is
- * pressed, so define some macros to properly detect the Enter key.
- */
-#define MUTT_ENTER_C '\r'
-#define MUTT_ENTER_S "\r"
-
 #else /* USE_SLANG_CURSES */
 
 #if HAVE_NCURSESW_NCURSES_H
@@ -52,9 +45,6 @@
 # include <curses.h>
 #endif
 
-#define MUTT_ENTER_C '\n'
-#define MUTT_ENTER_S "\n"
-
 #endif /* USE_SLANG_CURSES */
 
 /* AIX defines ``lines'' in <term.h>, but it's used as a var name in
@@ -121,8 +111,8 @@ enum
   MT_COLOR_SEARCH,
   MT_COLOR_BOLD,
   MT_COLOR_UNDERLINE,
-  MT_COLOR_INDEX,
   MT_COLOR_PROMPT,
+  MT_COLOR_PROGRESS,
 #ifdef USE_SIDEBAR
   MT_COLOR_DIVIDER,
   MT_COLOR_FLAGGED,
@@ -131,12 +121,28 @@ enum
   MT_COLOR_SB_INDICATOR,
   MT_COLOR_SB_SPOOLFILE,
 #endif
+  /* please no non-MT_COLOR_INDEX objects after this point */
+  MT_COLOR_INDEX,
+  MT_COLOR_INDEX_AUTHOR,
+  MT_COLOR_INDEX_FLAGS,
+  MT_COLOR_INDEX_SUBJECT,
+  /* below here - only index coloring stuff that doesn't have a pattern */
+  MT_COLOR_INDEX_COLLAPSED,
+  MT_COLOR_INDEX_DATE,
+  MT_COLOR_INDEX_LABEL,
+  MT_COLOR_INDEX_NUMBER,
+  MT_COLOR_INDEX_SIZE,
+#ifdef USE_NOTMUCH
+  MT_COLOR_INDEX_TAG,
+  MT_COLOR_INDEX_TAGS,
+#endif
   MT_COLOR_MAX
 };
 
 typedef struct color_line
 {
   regex_t rx;
+  int match; /* which substringmap 0 for old behaviour */
   char *pattern;
   pattern_t *color_pattern; /* compiled pattern to speed up index color
                                calculation */
@@ -212,7 +218,15 @@ extern int ColorQuoteUsed;
 extern int ColorDefs[];
 extern COLOR_LINE *ColorHdrList;
 extern COLOR_LINE *ColorBodyList;
+extern COLOR_LINE *ColorStatusList;
 extern COLOR_LINE *ColorIndexList;
+extern COLOR_LINE *ColorIndexAuthorList;
+extern COLOR_LINE *ColorIndexFlagsList;
+extern COLOR_LINE *ColorIndexSubjectList;
+
+#ifdef USE_NOTMUCH
+extern COLOR_LINE *ColorIndexTagList;
+#endif
 
 void ci_init_color (void);
 void ci_start_color (void);
diff --git a/mutt_menu.h b/mutt_menu.h
index b229fd4..d5c97d0 100644
--- a/mutt_menu.h
+++ b/mutt_menu.h
@@ -126,4 +126,6 @@ int mutt_menuLoop (MUTTMENU *);
 void index_make_entry (char *, size_t, struct menu_t *, int);
 int index_color (int);
 
+int mutt_limit_current_thread (HEADER *h);
+
 #endif /* _MUTT_MENU_H_ */
diff --git a/mutt_notmuch.c b/mutt_notmuch.c
new file mode 100644
index 0000000..e592dbd
--- /dev/null
+++ b/mutt_notmuch.c
@@ -0,0 +1,2028 @@
+/*
+ * Notmuch support for mutt
+ *
+ * Copyright (C) 2011, 2012 Karel Zak <kzak@redhat.com>
+ *
+ * Notes:
+ *
+ * - notmuch uses private CONTEXT->data and private HEADER->data
+ *
+ * - all exported functions are usable within notmuch context only
+ *
+ * - all functions have to be covered by "ctx->magic == MUTT_NOTMUCH" check
+ *   (it's implemented in get_ctxdata() and init_context() functions).
+ *
+ * - exception are nm_nonctx_* functions -- these functions use nm_default_uri
+ *   (or parse URI from another resource)
+ */
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mx.h"
+#include "rfc2047.h"
+#include "sort.h"
+#include "mailbox.h"
+#include "copy.h"
+#include "keymap.h"
+#include "url.h"
+#include "buffy.h"
+
+#include <dirent.h>
+#include <fcntl.h>
+#include <sys/file.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <utime.h>
+
+#include <notmuch.h>
+
+#include "mutt_notmuch.h"
+#include "mutt_curses.h"
+
+#ifdef LIBNOTMUCH_CHECK_VERSION
+#undef LIBNOTMUCH_CHECK_VERSION
+#endif
+
+/* The definition in <notmuch.h> is broken */
+#define LIBNOTMUCH_CHECK_VERSION(major, minor, micro)                               \
+    (LIBNOTMUCH_MAJOR_VERSION > (major) ||                                          \
+     (LIBNOTMUCH_MAJOR_VERSION == (major) && LIBNOTMUCH_MINOR_VERSION > (minor)) || \
+     (LIBNOTMUCH_MAJOR_VERSION == (major) && LIBNOTMUCH_MINOR_VERSION == (minor) && \
+      LIBNOTMUCH_MICRO_VERSION >= (micro)))
+
+
+/* read whole-thread or matching messages only? */
+enum {
+	NM_QUERY_TYPE_MESGS = 1,	/* default */
+	NM_QUERY_TYPE_THREADS
+};
+
+/*
+ * Parsed URI arguments
+ */
+struct uri_tag {
+	char *name;
+	char *value;
+	struct uri_tag *next;
+};
+
+/*
+ * HEADER->(nm_hdrdata *)data->tag_list node
+ */
+struct nm_hdrtag
+{
+  char *tag;
+  char *transformed;
+  struct nm_hdrtag *next;
+};
+
+/*
+ * HEADER->data
+ */
+struct nm_hdrdata {
+	char *folder;
+	char *tags;
+	char *tags_transformed;
+	struct nm_hdrtag *tag_list;
+	char *oldpath;
+	char *virtual_id;
+	int magic;
+};
+
+/*
+ * CONTEXT->data
+ */
+struct nm_ctxdata {
+	notmuch_database_t *db;
+
+	char *db_filename;
+	char *db_query;
+	int db_limit;
+	int query_type;
+
+	struct uri_tag *query_items;
+
+	progress_t progress;
+	int oldmsgcount;
+	int ignmsgcount;	/* ingored messages */
+
+	unsigned int noprogress : 1,
+		     longrun : 1,
+		     trans : 1,
+		     progress_ready : 1;
+
+};
+
+static HEADER *get_mutt_header(CONTEXT *ctx, notmuch_message_t *msg);
+static notmuch_message_t *get_nm_message(notmuch_database_t *db, HEADER *hdr);
+
+static void url_free_tags(struct uri_tag *tags)
+{
+	while (tags) {
+		struct uri_tag *next = tags->next;
+		FREE(&tags->name);
+		FREE(&tags->value);
+		FREE(&tags);
+		tags = next;
+	}
+}
+
+static int url_parse_query(char *url, char **filename, struct uri_tag **tags)
+{
+	char *p = strstr(url, "://");	/* remote unsupported */
+	char *e;
+	struct uri_tag *tag, *last = NULL;
+
+	*filename = NULL;
+	*tags = NULL;
+
+	if (!p || !*(p + 3))
+		return -1;
+
+	p += 3;
+	*filename = p;
+
+	e = strchr(p, '?');
+
+	*filename = e ? e == p ? NULL : strndup(p, e - p) : safe_strdup(p);
+	if (!e)
+		return 0;
+
+	if (*filename && url_pct_decode(*filename) < 0)
+		goto err;
+	if (!e)
+		return 0;	/* only filename */
+
+	++e;	/* skip '?' */
+	p = e;
+
+	while (p && *p) {
+		tag = safe_calloc(1, sizeof(struct uri_tag));
+		if (!tag)
+			goto err;
+
+		if (!*tags)
+			last = *tags = tag;
+		else {
+			last->next = tag;
+			last = tag;
+		}
+
+		e = strchr(p, '=');
+		if (!e)
+			e = strchr(p, '&');
+		tag->name = e ? strndup(p, e - p) : safe_strdup(p);
+		if (!tag->name || url_pct_decode(tag->name) < 0)
+			goto err;
+		if (!e)
+			break;
+
+		p = e + 1;
+
+		if (*e == '&')
+			continue;
+
+		e = strchr(p, '&');
+		tag->value = e ? strndup(p, e - p) : safe_strdup(p);
+		if (!tag->value || url_pct_decode(tag->value) < 0)
+			goto err;
+		if (!e)
+			break;
+		p = e + 1;
+	}
+
+	return 0;
+err:
+	FREE(&(*filename));
+	url_free_tags(*tags);
+	return -1;
+}
+
+static void free_tag_list(struct nm_hdrtag **tag_list)
+{
+	struct nm_hdrtag *tmp;
+
+	while ((tmp = *tag_list) != NULL)
+	{
+		*tag_list = tmp->next;
+		FREE(&tmp->tag);
+		FREE(&tmp->transformed);
+		FREE(&tmp);
+	}
+
+	*tag_list = 0;
+}
+
+static void free_hdrdata(struct nm_hdrdata *data)
+{
+	if (!data)
+		return;
+
+	dprint(2, (debugfile, "nm: freeing header %p\n", data));
+	FREE(&data->folder);
+	FREE(&data->tags);
+	FREE(&data->tags_transformed);
+	free_tag_list(&data->tag_list);
+	FREE(&data->oldpath);
+	FREE(&data->virtual_id);
+	FREE(&data);
+}
+
+static void free_ctxdata(struct nm_ctxdata *data)
+{
+	if (!data)
+		return;
+
+	dprint(1, (debugfile, "nm: freeing context data %p\n", data));
+
+	if (data->db)
+#ifdef NOTMUCH_API_3
+	        notmuch_database_destroy(data->db);
+#else
+		notmuch_database_close(data->db);
+#endif
+	data->db = NULL;
+
+	FREE(&data->db_filename);
+	FREE(&data->db_query);
+	url_free_tags(data->query_items);
+	FREE(&data);
+}
+
+static struct nm_ctxdata *new_ctxdata(char *uri)
+{
+	struct nm_ctxdata *data;
+
+	if (!uri)
+		return NULL;
+
+	data = safe_calloc(1, sizeof(struct nm_ctxdata));
+	dprint(1, (debugfile, "nm: initialize context data %p\n", data));
+
+	data->db_limit = NotmuchDBLimit;
+
+	if (url_parse_query(uri, &data->db_filename, &data->query_items)) {
+		mutt_error(_("failed to parse notmuch uri: %s"), uri);
+		data->db_filename = NULL;
+		data->query_items = NULL;
+		data->query_type = 0;
+		return NULL;
+	}
+
+	return data;
+}
+
+static int deinit_context(CONTEXT *ctx)
+{
+	int i;
+
+	if (!ctx || ctx->magic != MUTT_NOTMUCH)
+		return -1;
+
+	for (i = 0; i < ctx->msgcount; i++) {
+		HEADER *h = ctx->hdrs[i];
+
+		if (h) {
+			free_hdrdata(h->data);
+			h->data = NULL;
+		}
+	}
+
+	free_ctxdata(ctx->data);
+	ctx->data = NULL;
+	return 0;
+}
+
+static int init_context(CONTEXT *ctx)
+{
+	if (!ctx || ctx->magic != MUTT_NOTMUCH)
+		return -1;
+
+	if (ctx->data)
+		return 0;
+
+	ctx->data = new_ctxdata(ctx->path);
+	if (!ctx->data)
+		return -1;
+
+	return 0;
+}
+
+char *nm_header_get_folder(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->folder : NULL;
+}
+
+/* returns all unhidden tags */
+char *nm_header_get_tags(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->tags : NULL;
+}
+
+char *nm_header_get_tags_transformed(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->tags_transformed : NULL;
+}
+
+char *nm_header_get_tag_transformed(char *tag, HEADER *h)
+{
+	struct nm_hdrtag *tmp;
+
+	if (!h || !h->data)
+		return NULL;
+
+	for (tmp = ((struct nm_hdrdata *) h->data)->tag_list;
+	     tmp != NULL;
+	     tmp = tmp->next)
+	{
+		if (strcmp(tag, tmp->tag) == 0)
+			return tmp->transformed;
+	}
+
+	return NULL;
+}
+
+int nm_header_get_magic(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->magic : 0;
+}
+
+/*
+ * Returns notmuch message Id.
+ */
+static char *nm_header_get_id(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->virtual_id : NULL;
+}
+
+
+char *nm_header_get_fullpath(HEADER *h, char *buf, size_t bufsz)
+{
+	snprintf(buf, bufsz, "%s/%s", nm_header_get_folder(h), h->path);
+	/*dprint(2, (debugfile, "nm: returns fullpath '%s'\n", buf));*/
+	return buf;
+}
+
+
+static struct nm_ctxdata *get_ctxdata(CONTEXT *ctx)
+{
+	if (ctx && ctx->magic == MUTT_NOTMUCH)
+		return ctx->data;
+
+	return NULL;
+}
+
+static int string_to_guery_type(const char *str)
+{
+	if (!str)
+		str = NotmuchQueryType;		/* user's default */
+	if (!str)
+		return NM_QUERY_TYPE_MESGS;	/* hardcoded default */
+
+	if (strcmp(str, "threads") == 0)
+		return NM_QUERY_TYPE_THREADS;
+	else if (strcmp(str, "messages") == 0)
+		return NM_QUERY_TYPE_MESGS;
+
+	mutt_error (_("failed to parse notmuch query type: %s"), str);
+	return NM_QUERY_TYPE_MESGS;
+}
+
+static char *get_query_string(struct nm_ctxdata *data)
+{
+	struct uri_tag *item;
+
+	if (!data)
+		return NULL;
+	if (data->db_query)
+		return data->db_query;
+
+	for (item = data->query_items; item; item = item->next) {
+		if (!item->value || !item->name)
+			continue;
+
+		if (strcmp(item->name, "limit") == 0) {
+			if (mutt_atoi(item->value, &data->db_limit))
+				mutt_error (_("failed to parse notmuch limit: %s"), item->value);
+
+		} else if (strcmp(item->name, "type") == 0)
+			data->query_type = string_to_guery_type(item->value);
+
+		else if (strcmp(item->name, "query") == 0)
+			data->db_query = safe_strdup(item->value);
+	}
+
+	if (!data->query_type)
+		data->query_type = string_to_guery_type(NULL);
+
+	dprint(2, (debugfile, "nm: query '%s'\n", data->db_query));
+
+	return data->db_query;
+}
+
+static int get_limit(struct nm_ctxdata *data)
+{
+	return data ? data->db_limit : 0;
+}
+
+static int get_query_type(struct nm_ctxdata *data)
+{
+	return (data && data->query_type) ? data->query_type : string_to_guery_type(NULL);
+}
+
+static const char *get_db_filename(struct nm_ctxdata *data)
+{
+	char *db_filename;
+
+	if (!data)
+		return NULL;
+
+	db_filename = data->db_filename ? data->db_filename : NotmuchDefaultUri;
+	if (!db_filename)
+		db_filename = Maildir;
+	if (!db_filename)
+		return NULL;
+	if (strncmp(db_filename, "notmuch://", 10) == 0)
+		db_filename += 10;
+
+	dprint(2, (debugfile, "nm: db filename '%s'\n", db_filename));
+	return db_filename;
+}
+
+static notmuch_database_t *do_database_open(const char *filename,
+					    int writable, int verbose)
+{
+	notmuch_database_t *db = NULL;
+	unsigned int ct = 0;
+	notmuch_status_t st = NOTMUCH_STATUS_SUCCESS;
+
+	dprint(1, (debugfile, "nm: db open '%s' %s (timeout %d)\n", filename,
+			writable ? "[WRITE]" : "[READ]", NotmuchOpenTimeout));
+	do {
+#ifdef NOTMUCH_API_3
+		st = notmuch_database_open(filename,
+					writable ? NOTMUCH_DATABASE_MODE_READ_WRITE :
+					NOTMUCH_DATABASE_MODE_READ_ONLY, &db);
+#else
+		db = notmuch_database_open(filename,
+					writable ? NOTMUCH_DATABASE_MODE_READ_WRITE :
+					NOTMUCH_DATABASE_MODE_READ_ONLY);
+#endif
+		if (db || !NotmuchOpenTimeout || ct / 2 > NotmuchOpenTimeout)
+			break;
+
+		if (verbose && ct && ct % 2 == 0)
+			mutt_error(_("Waiting for notmuch DB... (%d sec)"), ct / 2);
+		usleep(500000);
+		ct++;
+	} while (1);
+
+	if (verbose) {
+		if (!db)
+			mutt_error (_("Cannot open notmuch database: %s: %s"),
+				    filename,
+				    st ? notmuch_status_to_string(st) :
+					 _("unknown reason"));
+		else if (ct > 1)
+			mutt_clear_error();
+	}
+	return db;
+}
+
+static notmuch_database_t *get_db(struct nm_ctxdata *data, int writable)
+{
+	if (!data)
+	       return NULL;
+	if (!data->db) {
+		const char *db_filename = get_db_filename(data);
+
+		if (db_filename)
+			data->db = do_database_open(db_filename, writable, TRUE);
+	}
+	return data->db;
+}
+
+static int release_db(struct nm_ctxdata *data)
+{
+	if (data && data->db) {
+		dprint(1, (debugfile, "nm: db close\n"));
+#ifdef NOTMUCH_API_3
+		notmuch_database_destroy(data->db);
+#else
+		notmuch_database_close(data->db);
+#endif
+		data->db = NULL;
+		data->longrun = 0;
+		return 0;
+	}
+
+	return -1;
+}
+
+/* returns:	< 0 = error
+ *		  1 = new transaction started
+ *		  0 = already within transaction
+ */
+static int db_trans_begin(struct nm_ctxdata *data)
+{
+	if (!data || !data->db)
+		return -1;
+
+	if (!data->trans) {
+		dprint(2, (debugfile, "nm: db trans start\n"));
+		if (notmuch_database_begin_atomic(data->db))
+			return -1;
+		data->trans = 1;
+		return 1;
+	}
+
+	return 0;
+}
+
+static int db_trans_end(struct nm_ctxdata *data)
+{
+	if (!data || !data->db)
+		return -1;
+
+	if (data->trans) {
+		dprint(2, (debugfile, "nm: db trans end\n"));
+		data->trans = 0;
+		if (notmuch_database_end_atomic(data->db))
+			return -1;
+	}
+
+	return 0;
+}
+
+void nm_longrun_init(CONTEXT *ctx, int writable)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (data && get_db(data, writable)) {
+		data->longrun = 1;
+		dprint(2, (debugfile, "nm: long run initialized\n"));
+	}
+}
+
+void nm_longrun_done(CONTEXT *ctx)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (data && release_db(data) == 0)
+		dprint(2, (debugfile, "nm: long run deinitialized\n"));
+}
+
+static int is_longrun(struct nm_ctxdata *data)
+{
+	return data && data->longrun;
+}
+
+void nm_debug_check(CONTEXT *ctx)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (!data)
+		return;
+
+	if (data->db) {
+		dprint(1, (debugfile, "nm: ERROR: db is open, closing\n"));
+		release_db(data);
+	}
+}
+
+static int get_database_mtime(struct nm_ctxdata *data, time_t *mtime)
+{
+	char path[_POSIX_PATH_MAX];
+	struct stat st;
+
+	if (!data)
+	       return -1;
+
+	snprintf(path, sizeof(path), "%s/.notmuch/xapian", get_db_filename(data));
+	dprint(2, (debugfile, "nm: checking '%s' mtime\n", path));
+
+	if (stat(path, &st))
+		return -1;
+
+	if (mtime)
+		*mtime = st.st_mtime;
+
+	return 0;
+}
+
+static void apply_exclude_tags(notmuch_query_t *query)
+{
+	char *buf, *p, *end = NULL, *tag = NULL;
+
+	if (!NotmuchExcludeTags || !*NotmuchExcludeTags)
+		return;
+	buf = safe_strdup(NotmuchExcludeTags);
+
+	for (p = buf; p && *p; p++) {
+		if (!tag && isspace(*p))
+			continue;
+		if (!tag)
+			tag = p;		/* begin of the tag */
+		if (*p == ',' || *p == ' ')
+			end = p;		/* terminate the tag */
+		else if (*(p + 1) == '\0')
+			end = p + 1;		/* end of optstr */
+		if (!tag || !end)
+			continue;
+		if (tag >= end)
+			break;
+		*end = '\0';
+
+		dprint(2, (debugfile, "nm: query exclude tag '%s'\n", tag));
+		notmuch_query_add_tag_exclude(query, tag);
+		end = tag = NULL;
+	}
+	notmuch_query_set_omit_excluded(query, 1);
+	FREE(&buf);
+}
+
+static notmuch_query_t *get_query(struct nm_ctxdata *data, int writable)
+{
+	notmuch_database_t *db = NULL;
+	notmuch_query_t *q = NULL;
+	const char *str;
+
+	if (!data)
+		return NULL;
+
+	db = get_db(data, writable);
+	str = get_query_string(data);
+
+	if (!db || !str)
+		goto err;
+
+	q = notmuch_query_create(db, str);
+	if (!q)
+		goto err;
+
+	apply_exclude_tags(q);
+	notmuch_query_set_sort(q, NOTMUCH_SORT_NEWEST_FIRST);
+	dprint(2, (debugfile, "nm: query successfully initialized\n"));
+	return q;
+err:
+	if (!is_longrun(data))
+		release_db(data);
+	return NULL;
+}
+
+static void append_str_item(char **str, const char *item, int sep)
+{
+	char *p;
+	size_t sz = strlen(item);
+	size_t ssz = *str ? strlen(*str) : 0;
+
+	safe_realloc(str, ssz + (ssz && sep ? 1 : 0) + sz + 1);
+	p = *str + ssz;
+	if (sep && ssz)
+	    *p++ = sep;
+	memcpy(p, item, sz + 1);
+}
+
+static int update_header_tags(HEADER *h, notmuch_message_t *msg)
+{
+	struct nm_hdrdata *data = h->data;
+	notmuch_tags_t *tags;
+	char *tstr = NULL, *ttstr = NULL;
+	struct nm_hdrtag *tag_list = NULL, *tmp;
+
+	dprint(2, (debugfile, "nm: tags update requested (%s)\n", data->virtual_id));
+
+	for (tags = notmuch_message_get_tags(msg);
+	     tags && notmuch_tags_valid(tags);
+	     notmuch_tags_move_to_next(tags)) {
+
+		const char *t = notmuch_tags_get(tags);
+		const char *tt = NULL;
+
+		if (!t || !*t)
+			continue;
+
+		tt = hash_find(TagTransforms, t);
+		if (!tt)
+			tt = t;
+
+		/* tags list contains all tags */
+		tmp = safe_calloc(1, sizeof(*tmp));
+		tmp->tag = safe_strdup(t);
+		tmp->transformed = safe_strdup(tt);
+		tmp->next = tag_list;
+		tag_list = tmp;
+
+		/* filter out hidden tags */
+		if (NotmuchHiddenTags) {
+			char *p = strstr(NotmuchHiddenTags, t);
+			size_t xsz = p ? strlen(t) : 0;
+
+			if (p && (p == NotmuchHiddenTags
+				  || *(p - 1) == ','
+				  || *(p - 1) == ' ')
+			    && (*(p + xsz) == '\0'
+				  || *(p + xsz) == ','
+				  || *(p + xsz) == ' '))
+				continue;
+		}
+
+		/* expand the transformed tag string */
+		append_str_item(&ttstr, tt, ' ');
+
+		/* expand the un-transformed tag string */
+		append_str_item(&tstr, t, ' ');
+	}
+
+	free_tag_list(&data->tag_list);
+	data->tag_list = tag_list;
+
+	if (data->tags && tstr && strcmp(data->tags, tstr) == 0) {
+		FREE(&tstr);
+		FREE(&ttstr);
+		dprint(2, (debugfile, "nm: tags unchanged\n"));
+		return 1;
+	}
+
+	/* free old version */
+	FREE(&data->tags);
+	FREE(&data->tags_transformed);
+
+	/* new version */
+	data->tags = tstr;
+	dprint(2, (debugfile, "nm: new tags: '%s'\n", tstr));
+
+	data->tags_transformed = ttstr;
+	dprint(2, (debugfile, "nm: new tag transforms: '%s'\n", ttstr));
+
+	return 0;
+}
+
+/*
+ * set/update HEADER->path and HEADER->data->path
+ */
+static int update_message_path(HEADER *h, const char *path)
+{
+	struct nm_hdrdata *data = h->data;
+	char *p;
+
+	dprint(2, (debugfile, "nm: path update requested path=%s, (%s)\n",
+				path, data->virtual_id));
+
+	p = strrchr(path, '/');
+	if (p && p - path > 3 &&
+	    (strncmp(p - 3, "cur", 3) == 0 ||
+	     strncmp(p - 3, "new", 3) == 0 ||
+	     strncmp(p - 3, "tmp", 3) == 0)) {
+
+		data->magic = MUTT_MAILDIR;
+
+		FREE(&h->path);
+		FREE(&data->folder);
+
+		p -= 3;				/* skip subfolder (e.g. "new") */
+		h->path = safe_strdup(p);
+
+		for (; p > path && *(p - 1) == '/'; p--);
+
+		data->folder = strndup(path, p - path);
+
+		dprint(2, (debugfile, "nm: folder='%s', file='%s'\n", data->folder, h->path));
+		return 0;
+	}
+
+	return 1;
+}
+
+static char *get_folder_from_path(const char *path)
+{
+	char *p = strrchr(path, '/');
+
+	if (p && p - path > 3 &&
+	    (strncmp(p - 3, "cur", 3) == 0 ||
+	     strncmp(p - 3, "new", 3) == 0 ||
+	     strncmp(p - 3, "tmp", 3) == 0)) {
+
+		p -= 3;
+		for (; p > path && *(p - 1) == '/'; p--);
+
+		return strndup(path, p - path);
+	}
+
+	return NULL;
+}
+
+static void deinit_header(HEADER *h)
+{
+	if (h) {
+		free_hdrdata(h->data);
+		h->data = NULL;
+	}
+}
+
+/* converts notmuch message Id to mutt message <Id> */
+static char *nm2mutt_message_id(const char *id)
+{
+	size_t sz;
+	char *mid;
+
+	if (!id)
+		return NULL;
+	sz = strlen(id) + 3;
+	mid = safe_malloc(sz);
+
+	snprintf(mid, sz, "<%s>", id);
+	return mid;
+}
+
+static int init_header(HEADER *h, const char *path, notmuch_message_t *msg)
+{
+	const char *id;
+
+	if (h->data)
+		return 0;
+
+	id = notmuch_message_get_message_id(msg);
+
+	h->data = safe_calloc(1, sizeof(struct nm_hdrdata));
+	h->free_cb = deinit_header;
+
+	/*
+	 * Notmuch ensures that message Id exists (if not notmuch Notmuch will
+	 * generate an ID), so it's more safe than use mutt HEADER->env->id
+	 */
+	((struct nm_hdrdata *) h->data)->virtual_id = safe_strdup( id );
+
+	dprint(2, (debugfile, "nm: initialize header data: [hdr=%p, data=%p] (%s)\n",
+				h, h->data, id));
+
+	if (!h->env->message_id)
+		h->env->message_id = nm2mutt_message_id( id );
+
+	if (update_message_path(h, path))
+		return -1;
+
+	update_header_tags(h, msg);
+
+	return 0;
+}
+
+/**
+static void debug_print_filenames(notmuch_message_t *msg)
+{
+	notmuch_filenames_t *ls;
+	const char *id = notmuch_message_get_message_id(msg);
+
+	for (ls = notmuch_message_get_filenames(msg);
+	     ls && notmuch_filenames_valid(ls);
+	     notmuch_filenames_move_to_next(ls)) {
+
+		dprint(2, (debugfile, "nm: %s: %s\n", id, notmuch_filenames_get(ls)));
+	}
+}
+
+static void debug_print_tags(notmuch_message_t *msg)
+{
+	notmuch_tags_t *tags;
+	const char *id = notmuch_message_get_message_id(msg);
+
+	for (tags = notmuch_message_get_tags(msg);
+	     tags && notmuch_tags_valid(tags);
+	     notmuch_tags_move_to_next(tags)) {
+
+		dprint(2, (debugfile, "nm: %s: %s\n", id, notmuch_tags_get(tags)));
+	}
+}
+***/
+
+static const char *get_message_last_filename(notmuch_message_t *msg)
+{
+	notmuch_filenames_t *ls;
+	const char *name = NULL;
+
+	for (ls = notmuch_message_get_filenames(msg);
+	     ls && notmuch_filenames_valid(ls);
+	     notmuch_filenames_move_to_next(ls)) {
+
+		name = notmuch_filenames_get(ls);
+	}
+
+	return name;
+}
+
+static void nm_progress_reset(CONTEXT *ctx)
+{
+	struct nm_ctxdata *data;
+
+	if (ctx->quiet)
+		return;
+
+	data = get_ctxdata(ctx);
+
+	memset(&data->progress, 0, sizeof(data->progress));
+	data->oldmsgcount = ctx->msgcount;
+	data->ignmsgcount = 0;
+	data->noprogress = 0;
+	data->progress_ready = 0;
+}
+
+static void nm_progress_update(CONTEXT *ctx, notmuch_query_t *q)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (ctx->quiet || data->noprogress)
+		return;
+
+	if (!data->progress_ready && q) {
+		unsigned count;
+		static char msg[STRING];
+		snprintf(msg, sizeof(msg), _("Reading messages..."));
+
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+		if (notmuch_query_count_messages_st (q, &count) != NOTMUCH_STATUS_SUCCESS)
+			count = 0;	/* may not be defined on error */
+#else
+		count = notmuch_query_count_messages(q);
+#endif
+		mutt_progress_init(&data->progress, msg, MUTT_PROGRESS_MSG,
+			ReadInc, count);
+		data->progress_ready = 1;
+	}
+
+	if (data->progress_ready)
+		mutt_progress_update(&data->progress,
+				ctx->msgcount + data->ignmsgcount
+					      - data->oldmsgcount, -1);
+}
+
+static void append_message(CONTEXT *ctx,
+			   notmuch_query_t *q,
+			   notmuch_message_t *msg,
+			   int dedup)
+{
+	char *newpath = NULL;
+	const char *path;
+	HEADER *h = NULL;
+
+	/* deduplicate */
+	if (dedup && get_mutt_header(ctx, msg)) {
+		get_ctxdata(ctx)->ignmsgcount++;
+		nm_progress_update(ctx, q);
+	        dprint(2, (debugfile, "nm: ignore id=%s, already in the context\n",
+					notmuch_message_get_message_id(msg)));
+		return;
+	}
+
+	path = get_message_last_filename(msg);
+	if (!path)
+		return;
+
+	dprint(2, (debugfile, "nm: appending message, i=%d, id=%s, path=%s\n",
+				ctx->msgcount,
+				notmuch_message_get_message_id(msg),
+				path));
+
+	if (ctx->msgcount >= ctx->hdrmax) {
+		dprint(2, (debugfile, "nm: allocate mx memory\n"));
+		mx_alloc_memory(ctx);
+	}
+	if (access(path, F_OK) == 0)
+		h = maildir_parse_message(MUTT_MAILDIR, path, 0, NULL);
+	else {
+		/* maybe moved try find it... */
+		char *folder = get_folder_from_path(path);
+
+		if (folder) {
+			FILE *f = maildir_open_find_message(folder, path, &newpath);
+			if (f) {
+				h = maildir_parse_stream(MUTT_MAILDIR, f, newpath, 0, NULL);
+				fclose(f);
+
+				dprint(1, (debugfile, "nm: not up-to-date: %s -> %s\n",
+							path, newpath));
+			}
+		}
+		FREE(&folder);
+	}
+
+	if (!h) {
+		dprint(1, (debugfile, "nm: failed to parse message: %s\n", path));
+		goto done;
+	}
+	if (init_header(h, newpath ? newpath : path, msg) != 0) {
+		mutt_free_header(&h);
+		dprint(1, (debugfile, "nm: failed to append header!\n"));
+		goto done;
+	}
+
+	h->active = 1;
+	h->index = ctx->msgcount;
+	ctx->size += h->content->length
+		   + h->content->offset
+		   - h->content->hdr_offset;
+	ctx->hdrs[ctx->msgcount] = h;
+	ctx->msgcount++;
+
+	if (newpath) {
+		/* remember that file has been moved -- nm_sync() will update the DB */
+		struct nm_hdrdata *hd = (struct nm_hdrdata *) h->data;
+
+		if (hd) {
+			dprint(1, (debugfile, "nm: remember obsolete path: %s\n", path));
+			hd->oldpath = safe_strdup(path);
+		}
+	}
+	nm_progress_update(ctx, q);
+done:
+	FREE(&newpath);
+}
+
+/*
+ * add all the replies to a given messages into the display.
+ * Careful, this calls itself recursively to make sure we get
+ * everything.
+ */
+static void append_replies(CONTEXT *ctx,
+			   notmuch_query_t *q,
+			   notmuch_message_t *top,
+			   int dedup)
+{
+	notmuch_messages_t *msgs;
+
+	for (msgs = notmuch_message_get_replies(top);
+	     notmuch_messages_valid(msgs);
+	     notmuch_messages_move_to_next(msgs)) {
+
+		notmuch_message_t *m = notmuch_messages_get(msgs);
+		append_message(ctx, q, m, dedup);
+		/* recurse through all the replies to this message too */
+		append_replies(ctx, q, m, dedup);
+		notmuch_message_destroy(m);
+	}
+}
+
+/*
+ * add each top level reply in the thread, and then add each
+ * reply to the top level replies
+ */
+static void append_thread(CONTEXT *ctx,
+			  notmuch_query_t *q,
+			  notmuch_thread_t *thread,
+			  int dedup)
+{
+	notmuch_messages_t *msgs;
+
+	for (msgs = notmuch_thread_get_toplevel_messages(thread);
+	     notmuch_messages_valid(msgs);
+	     notmuch_messages_move_to_next(msgs)) {
+
+		notmuch_message_t *m = notmuch_messages_get(msgs);
+		append_message(ctx, q, m, dedup);
+		append_replies(ctx, q, m, dedup);
+		notmuch_message_destroy(m);
+	}
+}
+
+static void read_mesgs_query(CONTEXT *ctx, notmuch_query_t *q, int dedup)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	int limit;
+	notmuch_messages_t *msgs;
+
+	if (!data)
+		return;
+
+	limit = get_limit(data);
+
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+	if (notmuch_query_search_messages_st (q, &msgs) != NOTMUCH_STATUS_SUCCESS)
+		return;
+#else
+	msgs = notmuch_query_search_messages(q);
+#endif
+
+	for (; notmuch_messages_valid(msgs) &&
+		(limit == 0 || ctx->msgcount < limit);
+	     notmuch_messages_move_to_next(msgs)) {
+
+		notmuch_message_t *m = notmuch_messages_get(msgs);
+		append_message(ctx, q, m, dedup);
+		notmuch_message_destroy(m);
+	}
+}
+
+static void read_threads_query(CONTEXT *ctx, notmuch_query_t *q, int dedup, int limit)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	notmuch_threads_t *threads;
+
+	if (!data)
+		return;
+
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+	if (notmuch_query_search_threads_st (q, &threads) != NOTMUCH_STATUS_SUCCESS)
+		return;
+#else
+	threads = notmuch_query_search_threads(q);
+#endif
+
+	for (; notmuch_threads_valid(threads) &&
+		(limit == 0 || ctx->msgcount < limit);
+	     notmuch_threads_move_to_next(threads)) {
+
+		notmuch_thread_t *thread = notmuch_threads_get(threads);
+		append_thread(ctx, q, thread, dedup);
+		notmuch_thread_destroy(thread);
+	}
+}
+
+int nm_read_query(CONTEXT *ctx)
+{
+	notmuch_query_t *q;
+	struct nm_ctxdata *data;
+	int rc = -1;
+
+	if (init_context(ctx) != 0)
+		return -1;
+
+	data = get_ctxdata(ctx);
+	if (!data)
+		return -1;
+
+	dprint(1, (debugfile, "nm: reading messages...[current count=%d]\n",
+				ctx->msgcount));
+
+	nm_progress_reset(ctx);
+
+	q = get_query(data, FALSE);
+	if (q) {
+		switch(get_query_type(data)) {
+		case NM_QUERY_TYPE_MESGS:
+			read_mesgs_query(ctx, q, 0);
+			break;
+		case NM_QUERY_TYPE_THREADS:
+			read_threads_query(ctx, q, 0, get_limit(data));
+			break;
+		}
+		notmuch_query_destroy(q);
+		rc = 0;
+
+	}
+
+	if (!is_longrun(data))
+		release_db(data);
+
+	ctx->mtime = time(NULL);
+
+	mx_update_context(ctx, ctx->msgcount);
+	data->oldmsgcount = 0;
+
+	dprint(1, (debugfile, "nm: reading messages... done [rc=%d, count=%d]\n",
+				rc, ctx->msgcount));
+	return rc;
+}
+
+int nm_read_entire_thread(CONTEXT *ctx, HEADER *h)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	const char *id;
+	char *qstr = NULL;
+	notmuch_query_t *q = NULL;
+	notmuch_database_t *db = NULL;
+	notmuch_message_t *msg = NULL;
+	int rc = -1;
+
+	if (!data)
+		return -1;
+	if (!(db = get_db(data, FALSE)) || !(msg = get_nm_message(db, h)))
+		goto done;
+
+	dprint(1, (debugfile, "nm: reading entire-thread messages...[current count=%d]\n",
+				ctx->msgcount));
+
+	nm_progress_reset(ctx);
+	id = notmuch_message_get_thread_id(msg);
+	if (!id)
+		goto done;
+	append_str_item(&qstr, "thread:", 0);
+	append_str_item(&qstr, id, 0);
+
+	q = notmuch_query_create(db, qstr);
+	FREE(&qstr);
+	if (!q)
+		goto done;
+	apply_exclude_tags(q);
+	notmuch_query_set_sort(q, NOTMUCH_SORT_NEWEST_FIRST);
+
+	read_threads_query(ctx, q, 1, 0);
+	ctx->mtime = time(NULL);
+	rc = 0;
+
+	if (ctx->msgcount > data->oldmsgcount)
+		mx_update_context(ctx, ctx->msgcount - data->oldmsgcount);
+done:
+	if (q)
+		notmuch_query_destroy(q);
+	if (!is_longrun(data))
+		release_db(data);
+
+	if (ctx->msgcount == data->oldmsgcount)
+		mutt_message _("No more messages in the thread.");
+
+	data->oldmsgcount = 0;
+	dprint(1, (debugfile, "nm: reading entire-thread messages... done [rc=%d, count=%d]\n",
+				rc, ctx->msgcount));
+	return rc;
+}
+
+char *nm_uri_from_query(CONTEXT *ctx, char *buf, size_t bufsz)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	char uri[_POSIX_PATH_MAX + LONG_STRING + 32];	/* path to DB + query + URI "decoration" */
+
+	if (data)
+		snprintf(uri, sizeof(uri), "notmuch://%s?query=%s",
+			 get_db_filename(data), buf);
+	else if (NotmuchDefaultUri)
+		snprintf(uri, sizeof(uri), "%s?query=%s", NotmuchDefaultUri, buf);
+	else if (Maildir)
+		snprintf(uri, sizeof(uri), "notmuch://%s?query=%s", Maildir, buf);
+	else
+		return NULL;
+
+	strncpy(buf, uri, bufsz);
+	buf[bufsz - 1] = '\0';
+
+	dprint(1, (debugfile, "nm: uri from query '%s'\n", buf));
+	return buf;
+}
+
+/*
+ * returns message from notmuch database
+ */
+static notmuch_message_t *get_nm_message(notmuch_database_t *db, HEADER *hdr)
+{
+	notmuch_message_t *msg = NULL;
+	char *id = nm_header_get_id(hdr);
+
+	dprint(2, (debugfile, "nm: find message (%s)\n", id));
+
+	if (id && db)
+		notmuch_database_find_message(db, id, &msg);
+
+	return msg;
+}
+
+static int update_tags(notmuch_message_t *msg, const char *tags)
+{
+	char *tag = NULL, *end = NULL, *p;
+	char *buf = safe_strdup(tags);
+
+	if (!buf)
+		return -1;
+
+	notmuch_message_freeze(msg);
+
+	for (p = buf; p && *p; p++) {
+		if (!tag && isspace(*p))
+			continue;
+		if (!tag)
+			tag = p;		/* begin of the tag */
+		if (*p == ',' || *p == ' ')
+			end = p;		/* terminate the tag */
+		else if (*(p + 1) == '\0')
+			end = p + 1;		/* end of optstr */
+		if (!tag || !end)
+			continue;
+		if (tag >= end)
+			break;
+
+		*end = '\0';
+
+		if (*tag == '-') {
+			dprint(1, (debugfile, "nm: remove tag: '%s'\n", tag + 1));
+			notmuch_message_remove_tag(msg, tag + 1);
+		} else {
+			dprint(1, (debugfile, "nm: add tag: '%s'\n", *tag == '+' ? tag + 1 : tag));
+			notmuch_message_add_tag(msg, *tag == '+' ? tag + 1 : tag);
+		}
+		end = tag = NULL;
+	}
+
+	notmuch_message_thaw(msg);
+	FREE(&buf);
+	return 0;
+}
+
+int nm_modify_message_tags(CONTEXT *ctx, HEADER *hdr, char *buf)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	notmuch_database_t *db = NULL;
+	notmuch_message_t *msg = NULL;
+	int rc = -1;
+
+	if (!buf || !*buf || !data)
+		return -1;
+
+	if (!(db = get_db(data, TRUE)) || !(msg = get_nm_message(db, hdr)))
+		goto done;
+
+	dprint(1, (debugfile, "nm: tags modify: '%s'\n", buf));
+
+	update_tags(msg, buf);
+	update_header_tags(hdr, msg);
+	mutt_set_header_color(ctx, hdr);
+
+	rc = 0;
+	hdr->changed = TRUE;
+done:
+	if (!is_longrun(data))
+		release_db(data);
+	if (hdr->changed)
+		ctx->mtime = time(NULL);
+	dprint(1, (debugfile, "nm: tags modify done [rc=%d]\n", rc));
+	return rc;
+}
+
+static int rename_maildir_filename(const char *old, char *newpath, size_t newsz, HEADER *h)
+{
+	char filename[_POSIX_PATH_MAX];
+	char suffix[_POSIX_PATH_MAX];
+	char folder[_POSIX_PATH_MAX];
+	char *p;
+
+	strfcpy(folder, old, sizeof(folder));
+	p = strrchr(folder, '/');
+	if (p)
+		*p = '\0';
+
+	p++;
+	strfcpy(filename, p, sizeof(filename));
+
+	/* remove (new,cur,...) from folder path */
+	p = strrchr(folder, '/');
+	if (p)
+		*p = '\0';
+
+	/* remove old flags from filename */
+	if ((p = strchr(filename, ':')))
+		*p = '\0';
+
+	/* compose new flags */
+	maildir_flags(suffix, sizeof(suffix), h);
+
+	snprintf(newpath, newsz, "%s/%s/%s%s",
+			folder,
+			(h->read || h->old) ? "cur" : "new",
+			filename,
+			suffix);
+
+	if (strcmp(old, newpath) == 0)
+		return 1;
+
+	if (rename(old, newpath) != 0) {
+		dprint(1, (debugfile, "nm: rename(2) failed %s -> %s\n", old, newpath));
+		return -1;
+	}
+
+	return 0;
+}
+
+static int remove_filename(struct nm_ctxdata *data, const char *path)
+{
+	notmuch_status_t st;
+	notmuch_filenames_t *ls;
+	notmuch_message_t *msg = NULL;
+	notmuch_database_t *db = get_db(data, TRUE);
+	int trans;
+
+	dprint(2, (debugfile, "nm: remove filename '%s'\n", path));
+
+	if (!db)
+		return -1;
+	st = notmuch_database_find_message_by_filename(db, path, &msg);
+	if (st || !msg)
+		return -1;
+	trans = db_trans_begin(data);
+	if (trans < 0)
+		return -1;
+
+	/*
+	 * note that unlink() is probably unnecessary here, it's already removed
+	 * by mh_sync_mailbox_message(), but for sure...
+	 */
+	st = notmuch_database_remove_message(db, path);
+	switch (st) {
+	case NOTMUCH_STATUS_SUCCESS:
+		dprint(2, (debugfile, "nm: remove success, call unlink\n"));
+		unlink(path);
+		break;
+	case NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID:
+		dprint(2, (debugfile, "nm: remove success (duplicate), call unlink\n"));
+		unlink(path);
+		for (ls = notmuch_message_get_filenames(msg);
+		     ls && notmuch_filenames_valid(ls);
+		     notmuch_filenames_move_to_next(ls)) {
+
+			path = notmuch_filenames_get(ls);
+
+			dprint(2, (debugfile, "nm: remove duplicate: '%s'\n", path));
+			unlink(path);
+			notmuch_database_remove_message(db, path);
+		}
+		break;
+	default:
+		dprint(1, (debugfile, "nm: failed to remove '%s' [st=%d]\n", path, (int) st));
+		break;
+	}
+
+	notmuch_message_destroy(msg);
+	if (trans)
+		db_trans_end(data);
+	return 0;
+}
+
+static int rename_filename(struct nm_ctxdata *data,
+			const char *old, const char *new, HEADER *h)
+{
+	int rc = -1;
+	notmuch_status_t st;
+	notmuch_filenames_t *ls;
+	notmuch_message_t *msg;
+	notmuch_database_t *db = get_db(data, TRUE);
+	int trans;
+
+	if (!db || !new || !old || access(new, F_OK) != 0)
+		return -1;
+
+	dprint(1, (debugfile, "nm: rename filename, %s -> %s\n", old, new));
+	trans = db_trans_begin(data);
+	if (trans < 0)
+		return -1;
+
+	dprint(2, (debugfile, "nm: rename: add '%s'\n", new));
+	st = notmuch_database_add_message(db, new, &msg);
+
+	if (st != NOTMUCH_STATUS_SUCCESS &&
+	    st != NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID) {
+		dprint(1, (debugfile, "nm: failed to add '%s' [st=%d]\n", new, (int) st));
+		goto done;
+	}
+
+	dprint(2, (debugfile, "nm: rename: rem '%s'\n", old));
+	st = notmuch_database_remove_message(db, old);
+	switch (st) {
+	case NOTMUCH_STATUS_SUCCESS:
+		break;
+	case NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID:
+		dprint(2, (debugfile, "nm: rename: syncing duplicate filename\n"));
+		notmuch_message_destroy(msg);
+		msg = NULL;
+		notmuch_database_find_message_by_filename(db, new, &msg);
+
+		for (ls = notmuch_message_get_filenames(msg);
+		     msg && ls && notmuch_filenames_valid(ls);
+		     notmuch_filenames_move_to_next(ls)) {
+
+			const char *path = notmuch_filenames_get(ls);
+			char newpath[_POSIX_PATH_MAX];
+
+			if (strcmp(new, path) == 0)
+				continue;
+
+			dprint(2, (debugfile, "nm: rename: syncing duplicate: %s\n", path));
+
+			if (rename_maildir_filename(path, newpath, sizeof(newpath), h) == 0) {
+				dprint(2, (debugfile, "nm: rename dup %s -> %s\n", path, newpath));
+				notmuch_database_remove_message(db, path);
+				notmuch_database_add_message(db, newpath, NULL);
+			}
+		}
+		notmuch_message_destroy(msg);
+		msg = NULL;
+		notmuch_database_find_message_by_filename(db, new, &msg);
+		st = NOTMUCH_STATUS_SUCCESS;
+		break;
+	default:
+		dprint(1, (debugfile, "nm: failed to remove '%s' [st=%d]\n",
+					old, (int) st));
+		break;
+	}
+
+	if (st == NOTMUCH_STATUS_SUCCESS && h && msg) {
+		notmuch_message_maildir_flags_to_tags(msg);
+		update_header_tags(h, msg);
+		update_tags(msg, nm_header_get_tags(h));
+	}
+
+	rc = 0;
+done:
+	if (msg)
+		notmuch_message_destroy(msg);
+	if (trans)
+		db_trans_end(data);
+	return rc;
+}
+
+int nm_update_filename(CONTEXT *ctx, const char *old, const char *new, HEADER *h)
+{
+	char buf[PATH_MAX];
+	int rc;
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (!data || !new)
+		return -1;
+
+	if (!old && h && h->data) {
+		nm_header_get_fullpath(h, buf, sizeof(buf));
+		old = buf;
+	}
+
+	rc = rename_filename(data, old, new, h);
+
+	if (!is_longrun(data))
+		release_db(data);
+	ctx->mtime = time(NULL);
+	return rc;
+}
+
+int nm_sync(CONTEXT *ctx, int *index_hint)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	int i, rc = 0;
+	char msgbuf[STRING];
+	progress_t progress;
+	char *uri = ctx->path;
+	int changed = 0;
+
+	if (!data)
+		return -1;
+
+	dprint(1, (debugfile, "nm: sync start ...\n"));
+
+	if (!ctx->quiet) {
+		/* all is in this function so we don't use data->progress here */
+		snprintf(msgbuf, sizeof (msgbuf), _("Writing %s..."), ctx->path);
+		mutt_progress_init(&progress, msgbuf, MUTT_PROGRESS_MSG,
+				   WriteInc, ctx->msgcount);
+	}
+
+	for (i = 0; i < ctx->msgcount; i++) {
+		char old[_POSIX_PATH_MAX], new[_POSIX_PATH_MAX];
+		HEADER *h = ctx->hdrs[i];
+		struct nm_hdrdata *hd = h->data;
+
+		if (!ctx->quiet)
+			mutt_progress_update(&progress, i, -1);
+
+		*old = *new = '\0';
+
+		if (hd->oldpath) {
+			strncpy(old, hd->oldpath, sizeof(old));
+			old[sizeof(old) - 1] = '\0';
+			dprint(2, (debugfile, "nm: fixing obsolete path '%s'\n", old));
+		} else
+			nm_header_get_fullpath(h, old, sizeof(old));
+
+		ctx->path = hd->folder;
+		ctx->magic = hd->magic;
+#if USE_HCACHE
+		rc = mh_sync_mailbox_message(ctx, i, NULL);
+#else
+		rc = mh_sync_mailbox_message(ctx, i);
+#endif
+		ctx->path = uri;
+		ctx->magic = MUTT_NOTMUCH;
+
+		if (rc)
+			break;
+
+		if (!h->deleted)
+			nm_header_get_fullpath(h, new, sizeof(new));
+
+		if (h->deleted || strcmp(old, new) != 0) {
+			if (h->deleted && remove_filename(data, old) == 0)
+				changed = 1;
+			else if (*new && *old && rename_filename(data, old, new, h) == 0)
+				changed = 1;
+		}
+
+		FREE(&hd->oldpath);
+	}
+
+	ctx->path = uri;
+	ctx->magic = MUTT_NOTMUCH;
+
+	if (!is_longrun(data))
+		release_db(data);
+	if (changed)
+		ctx->mtime = time(NULL);
+
+	dprint(1, (debugfile, "nm: .... sync done [rc=%d]\n", rc));
+	return rc;
+}
+
+static unsigned count_query(notmuch_database_t *db, const char *qstr)
+{
+	unsigned res = 0;
+	notmuch_query_t *q = notmuch_query_create(db, qstr);
+
+	if (q) {
+		apply_exclude_tags(q);
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+		if (notmuch_query_count_messages_st (q, &res) != NOTMUCH_STATUS_SUCCESS)
+			res = 0;	/* may not be defined on error */
+#else
+		res = notmuch_query_count_messages(q);
+#endif
+		notmuch_query_destroy(q);
+		dprint(1, (debugfile, "nm: count '%s', result=%d\n", qstr, res));
+	}
+	return res;
+}
+
+int nm_nonctx_get_count(char *path, int *all, int *new)
+{
+	struct uri_tag *query_items = NULL, *item;
+	char *db_filename = NULL, *db_query = NULL;
+	notmuch_database_t *db = NULL;
+	int rc = -1, dflt = 0;
+
+	dprint(1, (debugfile, "nm: count\n"));
+
+	if (url_parse_query(path, &db_filename, &query_items)) {
+		mutt_error(_("failed to parse notmuch uri: %s"), path);
+		goto done;
+	}
+	if (!query_items)
+		goto done;
+
+	for (item = query_items; item; item = item->next) {
+		if (item->value && strcmp(item->name, "query") == 0) {
+			db_query = item->value;
+			break;
+		}
+	}
+
+	if (!db_query)
+		goto done;
+
+	if (!db_filename) {
+		if (NotmuchDefaultUri) {
+			if (strncmp(NotmuchDefaultUri, "notmuch://", 10) == 0)
+				db_filename = NotmuchDefaultUri + 10;
+			else
+				db_filename = NotmuchDefaultUri;
+		} else if (Maildir)
+			db_filename = Maildir;
+		dflt = 1;
+	}
+
+	/* don't be verbose about connection, as we're called from
+	 * sidebar/buffy very often */
+	db = do_database_open(db_filename, FALSE, FALSE);
+	if (!db)
+		goto done;
+
+	/* all emails */
+	if (all)
+		*all = count_query(db, db_query);
+
+	/* new messages */
+	if (new) {
+		char *qstr;
+
+		safe_asprintf(&qstr, "( %s ) tag:%s",
+				db_query, NotmuchUnreadTag);
+		*new = count_query(db, qstr);
+		FREE(&qstr);
+	}
+
+	rc = 0;
+done:
+	if (db) {
+#ifdef NOTMUCH_API_3
+		notmuch_database_destroy(db);
+#else
+		notmuch_database_close(db);
+#endif
+		dprint(1, (debugfile, "nm: count close DB\n"));
+	}
+	if (!dflt)
+		FREE(&db_filename);
+	url_free_tags(query_items);
+
+	dprint(1, (debugfile, "nm: count done [rc=%d]\n", rc));
+	return rc;
+}
+
+char *nm_get_description(CONTEXT *ctx)
+{
+	BUFFY *p;
+
+	for (p = VirtIncoming; p; p = p->next)
+		if (p->desc && strcmp(p->path, ctx->path) == 0)
+			return p->desc;
+
+	return NULL;
+}
+
+int nm_description_to_path(const char *desc, char *buf, size_t bufsz)
+{
+	BUFFY *p;
+
+	if (!desc || !buf || !bufsz)
+		return -EINVAL;
+
+	for (p = VirtIncoming; p; p = p->next)
+		if (p->desc && strcmp(desc, p->desc) == 0) {
+			strncpy(buf, p->path, bufsz);
+			buf[bufsz - 1] = '\0';
+			return 0;
+		}
+
+	return -1;
+}
+
+/*
+ * returns header from mutt context
+ */
+static HEADER *get_mutt_header(CONTEXT *ctx, notmuch_message_t *msg)
+{
+	char *mid;
+	const char *id;
+	HEADER *h;
+
+	if (!ctx || !msg)
+		return NULL;
+
+	id = notmuch_message_get_message_id(msg);
+	if (!id)
+		return NULL;
+
+	dprint(2, (debugfile, "nm: mutt header, id='%s'\n", id));
+
+	if (!ctx->id_hash) {
+		dprint(2, (debugfile, "nm: init hash\n"));
+		ctx->id_hash = mutt_make_id_hash(ctx);
+		if (!ctx->id_hash)
+			return NULL;
+	}
+
+	mid = nm2mutt_message_id( id );
+	dprint(2, (debugfile, "nm: mutt id='%s'\n", mid));
+
+	h = hash_find(ctx->id_hash, mid);
+	FREE(&mid);
+	return h;
+}
+
+static int nm_check_database(CONTEXT *ctx, int *index_hint)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	time_t mtime = 0;
+	notmuch_query_t *q;
+	notmuch_messages_t *msgs;
+	int i, limit, occult = 0, new_flags = 0;
+
+	if (!data || get_database_mtime(data, &mtime) != 0)
+		return -1;
+
+	if (ctx->mtime >= mtime) {
+		dprint(2, (debugfile, "nm: check unnecessary (db=%d ctx=%d)\n", mtime, ctx->mtime));
+		return 0;
+	}
+
+	dprint(1, (debugfile, "nm: checking (db=%d ctx=%d)\n", mtime, ctx->mtime));
+
+	q = get_query(data, FALSE);
+	if (!q)
+		goto done;
+
+	dprint(1, (debugfile, "nm: start checking (count=%d)\n", ctx->msgcount));
+	data->oldmsgcount = ctx->msgcount;
+	data->noprogress = 1;
+
+	for (i = 0; i < ctx->msgcount; i++)
+		ctx->hdrs[i]->active = 0;
+
+	limit = get_limit(data);
+
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+	if (notmuch_query_search_messages_st (q, &msgs) != NOTMUCH_STATUS_SUCCESS)
+		goto done;
+#else
+	msgs = notmuch_query_search_messages(q);
+#endif
+
+	for (i = 0;
+	     notmuch_messages_valid(msgs) && (limit == 0 || i < limit);
+	     notmuch_messages_move_to_next(msgs), i++) {
+
+		char old[_POSIX_PATH_MAX];
+		const char *new;
+
+		notmuch_message_t *m = notmuch_messages_get(msgs);
+		HEADER *h = get_mutt_header(ctx, m);
+
+		if (!h) {
+			/* new email */
+			append_message(ctx, NULL, m, 0);
+			notmuch_message_destroy(m);
+			continue;
+		}
+
+		/* message already exists, merge flags */
+		h->active = 1;
+
+		/* check to see if the message has moved to a different
+		 * subdirectory.  If so, update the associated filename.
+		 */
+		new = get_message_last_filename(m);
+		nm_header_get_fullpath(h, old, sizeof(old));
+
+		if (mutt_strcmp(old, new) != 0)
+			update_message_path(h, new);
+
+		if (!h->changed) {
+			/* if the user hasn't modified the flags on
+			 * this message, update the flags we just
+			 * detected.
+			 */
+			HEADER tmp;
+			memset(&tmp, 0, sizeof(tmp));
+			maildir_parse_flags(&tmp, new);
+			maildir_update_flags(ctx, h, &tmp);
+		}
+
+		if (update_header_tags(h, m) == 0)
+			new_flags++;
+
+		notmuch_message_destroy(m);
+	}
+
+	for (i = 0; i < ctx->msgcount; i++) {
+		if (ctx->hdrs[i]->active == 0) {
+			occult = 1;
+			break;
+		}
+	}
+
+	if (ctx->msgcount > data->oldmsgcount)
+		mx_update_context(ctx, ctx->msgcount - data->oldmsgcount);
+done:
+	if (q)
+		notmuch_query_destroy(q);
+
+	if (!is_longrun(data))
+		release_db(data);
+
+	ctx->mtime = time(NULL);
+
+	dprint(1, (debugfile, "nm: ... check done [count=%d, new_flags=%d, occult=%d]\n",
+				ctx->msgcount, new_flags, occult));
+
+	return occult ? MUTT_REOPENED :
+	       ctx->msgcount > data->oldmsgcount ? MUTT_NEW_MAIL :
+	       new_flags ? MUTT_FLAGS : 0;
+}
+
+int nm_record_message(CONTEXT *ctx, char *path, HEADER *h)
+{
+	notmuch_database_t *db;
+	notmuch_status_t st;
+	notmuch_message_t *msg = NULL;
+	int rc = -1, trans;
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (!path || !data || access(path, F_OK) != 0)
+		return 0;
+	db = get_db(data, TRUE);
+	if (!db)
+		return -1;
+
+	dprint(1, (debugfile, "nm: record message: %s\n", path));
+	trans = db_trans_begin(data);
+	if (trans < 0)
+		goto done;
+
+	st = notmuch_database_add_message(db, path, &msg);
+
+	if (st != NOTMUCH_STATUS_SUCCESS &&
+	    st != NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID) {
+		dprint(1, (debugfile, "nm: failed to add '%s' [st=%d]\n", path, (int) st));
+		goto done;
+	}
+
+	if (st == NOTMUCH_STATUS_SUCCESS && msg) {
+		notmuch_message_maildir_flags_to_tags(msg);
+		if (h)
+			update_tags(msg, nm_header_get_tags(h));
+		if (NotmuchRecordTags)
+			update_tags(msg, NotmuchRecordTags);
+	}
+
+	rc = 0;
+done:
+	if (msg)
+		notmuch_message_destroy(msg);
+	if (trans == 1)
+		db_trans_end(data);
+	if (!is_longrun(data))
+		release_db(data);
+	return rc;
+}
+
+/*
+ * Fill a list with all notmuch tags.
+ *
+ * If tag_list is NULL, just count the tags.
+ */
+int nm_get_all_tags(CONTEXT *ctx, char **tag_list, int *tag_count)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	notmuch_database_t *db = NULL;
+	notmuch_tags_t *tags = NULL;
+	int rc = -1;
+
+	if (!data)
+		return -1;
+
+	if (!(db = get_db(data, FALSE)) ||
+			!(tags = notmuch_database_get_all_tags(db)))
+		goto done;
+
+	*tag_count = 0;
+	dprint(1, (debugfile, "nm: get all tags\n"));
+
+	while (notmuch_tags_valid(tags)) {
+		if (tag_list != NULL) {
+			tag_list[*tag_count] = safe_strdup(notmuch_tags_get(tags));
+		}
+		(*tag_count)++;
+		notmuch_tags_move_to_next(tags);
+	}
+
+	rc = 0;
+done:
+	if (tags)
+		notmuch_tags_destroy(tags);
+
+	if (!is_longrun(data))
+		release_db(data);
+
+	dprint(1, (debugfile, "nm: get all tags done [rc=%d tag_count=%u]\n", rc,
+						 *tag_count));
+	return rc;
+}
+
+static int nm_open_message (CONTEXT *ctx, MESSAGE *msg, int msgno)
+{
+	if (!ctx || !msg)
+		return 1;
+	HEADER *cur = ctx->hdrs[msgno];
+	char *folder = ctx->path;
+	char path[_POSIX_PATH_MAX];
+	folder = nm_header_get_folder(cur);
+
+	snprintf (path, sizeof (path), "%s/%s", folder, cur->path);
+
+	msg->fp = fopen (path, "r");
+	if ((msg->fp == NULL) && (errno == ENOENT) && ((ctx->magic == MUTT_MAILDIR) || (ctx->magic == MUTT_NOTMUCH)))
+		msg->fp = maildir_open_find_message (folder, cur->path, NULL);
+
+	dprint(1, (debugfile, "%s\n", __func__));
+	return 0;
+}
+
+static int nm_close_message (CONTEXT *ctx, MESSAGE *msg)
+{
+	if (!msg)
+		return 1;
+	safe_fclose (&(msg->fp));
+	return 0;
+}
+
+static int nm_commit_message (CONTEXT *ctx, MESSAGE *msg)
+{
+	mutt_perror _("Can't write to virtual folder.");
+	return 1;
+}
+
+struct mx_ops mx_notmuch_ops = {
+	.open         = nm_read_query,	/* calls init_context() */
+        .open_append  = NULL,
+	.close        = deinit_context,
+	.check        = nm_check_database,
+	.open_msg     = nm_open_message,
+	.close_msg    = nm_close_message,
+	.commit_msg   = nm_commit_message,
+        .open_new_msg = NULL
+};
+
diff --git a/mutt_notmuch.h b/mutt_notmuch.h
new file mode 100644
index 0000000..8267b1f
--- /dev/null
+++ b/mutt_notmuch.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2011 Karel Zak <kzak@redhat.com>
+ */
+#ifndef _MUTT_NOTMUCH_H_
+#define _MUTT_NOTMUCH_H_ 1
+
+int nm_read_query(CONTEXT *ctx);
+int nm_read_entire_thread(CONTEXT *ctx, HEADER *h);
+
+int nm_sync(CONTEXT * ctx, int *index_hint);
+char *nm_header_get_folder(HEADER *h);
+int nm_header_get_magic(HEADER *h);
+char *nm_header_get_fullpath(HEADER *h, char *buf, size_t bufsz);
+int nm_update_filename(CONTEXT *ctx, const char *o, const char *n, HEADER *h);
+char *nm_uri_from_query(CONTEXT *ctx, char *buf, size_t bufsz);
+int nm_modify_message_tags(CONTEXT *ctx, HEADER *hdr, char *tags);
+
+void nm_longrun_init(CONTEXT *cxt, int writable);
+void nm_longrun_done(CONTEXT *cxt);
+
+char *nm_get_description(CONTEXT *ctx);
+int nm_description_to_path(const char *desc, char *buf, size_t bufsz);
+
+int nm_record_message(CONTEXT *ctx, char *path, HEADER *h);
+
+void nm_debug_check(CONTEXT *ctx);
+int nm_get_all_tags(CONTEXT *ctx, char **tag_list, int *tag_count);
+
+/*
+ * functions usable outside notmuch CONTEXT
+ */
+int nm_nonctx_get_count(char *path, int *all, int *new);
+
+char *nm_header_get_tag_transformed(char *tag, HEADER *h);
+char *nm_header_get_tags_transformed(HEADER *h);
+char *nm_header_get_tags(HEADER *h);
+
+extern struct mx_ops mx_notmuch_ops;
+
+#endif /* _MUTT_NOTMUCH_H_ */
diff --git a/mutt_sasl.c b/mutt_sasl.c
index d99ba72..39aa8bd 100644
--- a/mutt_sasl.c
+++ b/mutt_sasl.c
@@ -192,6 +192,11 @@ int mutt_sasl_client_new (CONNECTION* conn, sasl_conn_t** saslconn)
     case MUTT_ACCT_TYPE_SMTP:
       service = "smtp";
       break;
+#ifdef USE_NNTP
+    case MUTT_ACCT_TYPE_NNTP:
+      service = "nntp";
+      break;
+#endif
     default:
       mutt_error (_("Unknown SASL profile"));
       return -1;
diff --git a/mutt_ssl.c b/mutt_ssl.c
index bf67972..2a9266f 100644
--- a/mutt_ssl.c
+++ b/mutt_ssl.c
@@ -412,6 +412,18 @@ static int ssl_negotiate (CONNECTION *conn, sslsockdata* ssldata)
   SSL_set_mode (ssldata->ssl, SSL_MODE_AUTO_RETRY);
 #endif
 
+#if (OPENSSL_VERSION_NUMBER >= 0x0090806fL) && !defined(OPENSSL_NO_TLSEXT)
+  /* TLS Virtual-hosting requires that the server present the correct
+   * certificate; to do this, the ServerNameIndication TLS extension is used.
+   * If TLS is negotiated, and OpenSSL is recent enough that it might have
+   * support, and support was enabled when OpenSSL was built, mutt supports
+   * sending the hostname we think we're connecting to, so a server can send
+   * back the correct certificate.
+   * This has been tested over SMTP against Exim 4.80.
+   * Not yet found an IMAP server which supports this. */
+  SSL_set_tlsext_host_name (ssldata->ssl, conn->account.host);
+#endif
+
   if ((err = SSL_connect (ssldata->ssl)) != 1)
   {
     switch (SSL_get_error (ssldata->ssl, err))
@@ -443,14 +455,6 @@ static int ssl_negotiate (CONNECTION *conn, sslsockdata* ssldata)
   if (!ssl_check_certificate (conn, ssldata))
     return -1;
 
-  /* L10N:
-     %1$s is version (e.g. "TLSv1.2")
-     %2$s is cipher_version (e.g. "TLSv1/SSLv3")
-     %3$s is cipher_name (e.g. "ECDHE-RSA-AES128-GCM-SHA256") */
-  mutt_message (_("%s connection using %s (%s)"),
-    SSL_get_version(ssldata->ssl), SSL_get_cipher_version (ssldata->ssl), SSL_get_cipher_name (ssldata->ssl));
-  mutt_sleep (0);
-
   return 0;
 }
 
diff --git a/muttbug b/muttbug
deleted file mode 100755
index e94d8cd..0000000
--- a/muttbug
+++ /dev/null
@@ -1,3 +0,0 @@
-#!/bin/sh
-
-exec flea "$@"
diff --git a/muttbug.sh.in b/muttbug.sh.in
deleted file mode 100644
index b429fae..0000000
--- a/muttbug.sh.in
+++ /dev/null
@@ -1,332 +0,0 @@
-#!/bin/sh
-
-#
-#     File a bug against the Mutt mail user agent.
-#
-
-# 
-#     $Id$
-#
-
-#
-#     Copyright (c) 2000 Thomas Roessler <roessler@does-not-exist.org>
-#
-#
-#     This program is free software; you can redistribute it and/or modify
-#     it under the terms of the GNU General Public License as published by
-#     the Free Software Foundation; either version 2 of the License, or
-#     (at your option) any later version.
-# 
-#     This program is distributed in the hope that it will be useful,
-#     but WITHOUT ANY WARRANTY; without even the implied warranty of
-#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#     GNU General Public License for more details.
-# 
-#     You should have received a copy of the GNU General Public License
-#     along with this program; if not, write to the Free Software
-#     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
-#
-
-SUBMIT="fleas@mutt.org"
-DEBIAN_SUBMIT="submit@bugs.debian.org"
-
-prefix=@prefix@
-
-DEBUGGER=@DEBUGGER@
-SENDMAIL=@SENDMAIL@
-sysconfdir=@sysconfdir@
-pkgdatadir=@pkgdatadir@
-
-include_file ()
-{
-	echo
-	echo "--- Begin $1"
-	sed -e '/^[	 ]*#/d; /^[	 ]*$/d; s/^-/- -/' $1
-	echo "--- End $1"
-	echo
-}
-
-debug_gdb ()
-{
-	cat << EOF > $SCRATCH/gdb.rc
-bt
-list
-quit
-EOF
-	$DEBUGGER -n -x $SCRATCH/gdb.rc -c $CORE mutt
-}
-
-debug_dbx ()
-{
-	cat << EOF > $SCRATCH/dbx.rc
-where
-list
-quit
-EOF
-	$DEBUGGER -s $SCRATCH/dbx.rc mutt $CORE
-}
-
-debug_sdb ()
-{
-	cat << EOF > $SCRATCH/sdb.rc
-t
-w
-q
-EOF
-	$DEBUGGER mutt $CORE < $SCRATCH/sdb.rc
-}
-
-case `echo -n` in
-"") n=-n; c=   ;;
- *) n=; c='\c' ;;
-esac
- 
-
-exec > /dev/tty
-exec < /dev/tty
-
-SCRATCH=${TMPDIR-/tmp}/`basename $0`.`hostname`.$$
-
-mkdir ${SCRATCH} || \
-{ 
-	echo "`basename $0`: Can't create temporary directory." >& 2 ; 
-	exit 1 ; 
-}
-
-trap "rm -r -f ${SCRATCH} ; trap '' 0 ; exit" 0 1 2
-
-TEMPLATE=${SCRATCH}/template.txt
-
-if test -z "$EMAIL" ; then
-	EMAIL="`mutt -Q from 2> /dev/null | sed -e 's/^from=.\(.*\).$/\1/'`"
-fi
-
-EMAILTMP=''
-while test -z "$EMAILTMP"
-do
-  echo "Please enter your e-mail address [$EMAIL]:"
-  echo $n "> $c"
-  read EMAILTMP
-
-  if test -z "$EMAILTMP"; then EMAILTMP="$EMAIL"; fi
-
-  if ! echo "$EMAILTMP" | grep -q @
-  then
-    echo "$EMAILTMP does not appear to be a valid email address"
-    EMAILTMP=''
-    continue
-  fi
-
-  EMAIL="$EMAILTMP"
-done
-
-echo "Please enter a one-line description of the problem you experience:"
-echo $n "> $c"
-read SUBJECT
-
-cat <<EOF  
-What should the severity for this bug report be?
-
-       0) Feature request, or maybe a bug which is very difficult to
-       fix due to major design considerations.
-
-       1) The package fails to perform correctly in some conditions,
-       or on some systems, or fails to comply with current policy
-       documents. Most bugs are in this category.
-
-       2) This bug makes this version of the package unsuitable for
-       a stable release.
-
-       3) Dangerous bug. Makes the package in question unusable by
-       anyone or mostly so, or causes data loss, or introduces a
-       security hole allowing access to the accounts of users who
-       use the package.
-
-       4) Critical bug. Makes unrelated software on the system (or
-       the whole system) break, or causes serious data loss, or
-       introduces a security hole on systems where you install the
-       package.
-
-EOF
-echo $n "Severity? [01234] $c"
-read severity
-case "$severity" in
-0|[Ww]) severity=wishlist  ;;
-2|[Ii]) severity=important ;;
-3|[Gg]) severity=grave     ;;
-4|[Cc]) severity=critical  ;;
-     *) severity=normal    ;;
-esac
-
-if test -x $DEBUGGER ; then
-	test -f core && CORE=core
-	echo "If mutt has crashed, it may have saved some program state in"
-	echo "a file named core.  We can include this information with the bug"
-	echo "report if you wish so."
-	echo "Do you want to include information gathered from a core file?"
-	echo "If yes, please enter the path - otherwise just say no: [$CORE]"
-	echo $n "> $c"
-	read _CORE
-	test "$_CORE" && CORE="$_CORE"
-fi
-
-echo $n "Do you want to include your personal mutt configuration files? [Y|n] $c"
-read personal
-case "$personal" in
-[nN]*)  personal=no  ;;
-    *)  personal=yes ;;
-esac
-
-echo $n "Do you want to include your system's global mutt configuration file? [Y|n] $c"
-read global
-case "$global" in
-[nN]*)  global=no  ;;
-    *)	global=yes ;;
-esac
-
-if test -f /etc/debian_version ; then
-	DEBIAN=yes
-	echo $n "Checking whether mutt has been installed as a package... $c"
-	DEBIANVERSION="`dpkg -l mutt | grep '^[ih]' | awk '{print $3}'`" 2> /dev/null
-	if test "$DEBIANVERSION" ; then
-		DPKG=yes
-	else
-		DPKG=no
-		unset DEBIANVERSION
-	fi
-	echo "$DPKG"
-	echo $n "File this bug with Debian? [Y|n] $c"
-	read DPKG
-	case "$DPKG" in
-	[nN])	DPKG=no ;;
-	*)	DPKG=yes ;;
-	esac
-else
-	DEBIAN=no
-	DPKG=no
-fi
-
-if rpm -q mutt > /dev/null 2> /dev/null ; then
-	echo "Mutt seems to come from an RPM package."
-	RPMVERSION="`rpm -q mutt`"
-	RPMPACKAGER="`rpm -q -i mutt | sed -n -e 's/^Packager *: *//p'`"
-fi
-
-MUTTVERSION="`mutt -v | awk '{print $2; exit; }'`"
-test "$DPKG" = "yes" && SUBMIT="$SUBMIT, $DEBIAN_SUBMIT"
-
-exec > ${TEMPLATE}
-
-test "$EMAIL"        && echo "From: $EMAIL"
-test "$REPLYTO"      && echo "Reply-To: $REPLYTO"
-test "$ORGANIZATION" && echo "Organization: $ORGANIZATION"
-
-echo "Subject: mutt-$MUTTVERSION: $SUBJECT"
-echo "To: $SUBMIT"
-test "$EMAIL" 	     && echo "Bcc: ${EMAIL}"
-echo
-echo "Package: mutt"
-echo "Version: ${DEBIANVERSION-${RPMVERSION-$MUTTVERSION}}"
-echo "Severity: $severity"
-echo 
-echo "-- Please type your report below this line"
-echo
-echo
-echo
-
-if test "$DEBIAN" = "yes" ; then
-	echo "Obtaining Debian-specific information..." > /dev/tty
-	bug -p -s dummy mutt < /dev/null 2> /dev/null |        \
-		sed -n -e "/^-- System Information/,/^---/p" | \
-		grep -v '^---'
-else
-	echo "-- System Information"
-	echo "System Version: `uname -a`"
-	test -z "$RPMPACKAGER" || echo "RPM Packager: $RPMPACKAGER";
-	test -f /etc/redhat-release && echo "RedHat Release: `cat /etc/redhat-release`"
-	test -f /etc/SuSE-release && echo "SuSE Release: `sed 1q /etc/SuSE-release`"
-	# Please provide more of these if you have any.
-fi
-
-echo
-echo "-- Mutt Version Information"
-echo
-LC_ALL=C mutt -v
-
-if test "$CORE" && test -f "$CORE" ; then
-	echo 
-	echo "-- Core Dump Analysis Output"
-	echo
-
-	case "$DEBUGGER" in
-		*sdb) debug_sdb $CORE ;;
-		*dbx) debug_dbx $CORE ;;
-		*gdb) debug_gdb $CORE ;;
-	esac
-	
-	echo
-fi
-
-if test "$personal" = "yes" ; then
-	CANDIDATES=".muttrc-${MUTTVERSION} .muttrc .mutt/muttrc-${MUTTVERSION} .mutt/muttrc"
-	MATCHED="none"
-	for f in $CANDIDATES; do
-		if test -f "${HOME}/$f" ; then
-			MATCHED="${HOME}/$f"
-			break
-	        fi
-	done
-	
-	if test "$MATCHED" = "none" ; then
-		echo "Warning: Can't find your personal .muttrc." >&2
-	else
-		include_file $MATCHED
-	fi
-fi
-
-
-if test "$global" = "yes" ; then
-	CANDIDATES="Muttrc-${MUTTVERSION} Muttrc"
-	DIRECTORIES="$sysconfdir $pkgdatadir"
-	MATCHED="none"
-	for d in $DIRECTORIES ; do
-		for f in $CANDIDATES; do
-			if test -f $d/$f ; then
-				MATCHED="$d/$f"
-				break
-			fi
-		done
-		test "$MATCHED" = "none" || break
-	done
-	
-	if test "$MATCHED" = "none" ; then
-		echo "Warning: Can't find global Muttrc." >&2
-	else
-		include_file $MATCHED
-	fi
-fi
-
-exec > /dev/tty
-
-cp $TEMPLATE $SCRATCH/mutt-bug.txt
-
-input="e"
-while : ; do
-	if test "$input" = "e" ; then
-		${VISUAL-${EDITOR-vi}} $SCRATCH/mutt-bug.txt
-		if cmp $SCRATCH/mutt-bug.txt ${TEMPLATE} > /dev/null ; then
-			echo "Warning: Bug report was not modified!"
-		fi
-	fi
-	
-	echo $n "Submit, Edit, View, Quit? [S|e|v|q] $c"
-	read _input
-	input="`echo $_input | tr EVSQ evsq`"
-	case $input in
-	e*)	;;
-	v*)	${PAGER-more} $SCRATCH/mutt-bug.txt ;;
-	s*|"")	$SENDMAIL -t < $SCRATCH/mutt-bug.txt ; exit ;;
-	q*)	exit
-	esac
-done
-
diff --git a/muttlib.c b/muttlib.c
index 209c7ab..41de638 100644
--- a/muttlib.c
+++ b/muttlib.c
@@ -32,11 +32,18 @@
 #include "imap.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include "mutt_crypt.h"
 
 #include <string.h>
 #include <ctype.h>
 #include <unistd.h>
+#ifdef HAVE_SYS_SYSCALL_H
+#include <sys/syscall.h>
+#endif
 #include <stdlib.h>
 #include <sys/wait.h>
 #include <errno.h>
@@ -46,6 +53,18 @@
 #include <sys/types.h>
 #include <utime.h>
 
+static const char *xdg_env_vars[] =
+{
+  [kXDGConfigHome] = "XDG_CONFIG_HOME",
+  [kXDGConfigDirs] = "XDG_CONFIG_DIRS",
+};
+
+static const char *xdg_defaults[] =
+{
+  [kXDGConfigHome] = "~/.config",
+  [kXDGConfigDirs] = "/etc/xdg",
+};
+
 BODY *mutt_new_body (void)
 {
   BODY *p = (BODY *) safe_calloc (1, sizeof (BODY));
@@ -331,7 +350,9 @@ void mutt_free_header (HEADER **h)
 #ifdef MIXMASTER
   mutt_free_list (&(*h)->chain);
 #endif
-#if defined USE_POP || defined USE_IMAP
+#if defined USE_POP || defined USE_IMAP || defined USE_NNTP || defined USE_NOTMUCH
+  if ((*h)->free_cb)
+    (*h)->free_cb(*h);
   FREE (&(*h)->data);
 #endif
   FREE (h);		/* __FREE_CHECKED__ */
@@ -442,6 +463,11 @@ char *_mutt_expand_path (char *s, size_t slen, int rx)
 	  strfcpy (p, NONULL (Maildir), sizeof (p));
 	else
 #endif
+#ifdef USE_NOTMUCH
+	if (mx_is_notmuch (NONULL (Maildir)))
+	  strfcpy (p, NONULL (Maildir), sizeof (p));
+	else
+#endif
 	if (Maildir && *Maildir && Maildir[strlen (Maildir) - 1] == '/')
 	  strfcpy (p, NONULL (Maildir), sizeof (p));
 	else
@@ -716,12 +742,21 @@ void mutt_free_envelope (ENVELOPE **p)
   FREE (&(*p)->supersedes);
   FREE (&(*p)->date);
   FREE (&(*p)->x_label);
+  FREE (&(*p)->organization);
+#ifdef USE_NNTP
+  FREE (&(*p)->newsgroups);
+  FREE (&(*p)->xref);
+  FREE (&(*p)->followup_to);
+  FREE (&(*p)->x_comment_to);
+#endif
 
   mutt_buffer_free (&(*p)->spam);
 
   mutt_free_list (&(*p)->references);
   mutt_free_list (&(*p)->in_reply_to);
   mutt_free_list (&(*p)->userhdrs);
+  mutt_label_ref_dec ((*p));
+  mutt_free_list (&(*p)->labels);
   FREE (p);		/* __FREE_CHECKED__ */
 }
 
@@ -744,7 +779,7 @@ void mutt_merge_envelopes(ENVELOPE* base, ENVELOPE** extra)
   MOVE_ELEM(message_id);
   MOVE_ELEM(supersedes);
   MOVE_ELEM(date);
-  MOVE_ELEM(x_label);
+  MOVE_ELEM(labels);
   if (!base->refs_changed)
   {
     MOVE_ELEM(references);
@@ -773,12 +808,73 @@ void mutt_merge_envelopes(ENVELOPE* base, ENVELOPE** extra)
   mutt_free_envelope(extra);
 }
 
+static FILE *frandom;
+
+void mutt_randbuf(void *out, size_t len)
+{
+  if (len > 1048576) {
+    mutt_error (_("mutt_randbuf len=%zu"), len);
+    exit(1);
+  }
+  /* XXX switch to HAVE_GETRANDOM and getrandom() in about 2017 */
+#if defined(SYS_getrandom) && defined(__linux__)
+  long ret;
+  do {
+    ret = syscall(SYS_getrandom, out, len, 0, 0, 0, 0);
+  } while ((ret == -1) && (errno == EINTR));
+  if (ret == len) return;
+  /* let's try urandom in case we're on an old kernel, or the user has
+   * configured selinux, seccomp or something to not allow getrandom */
+#endif
+  if (frandom == NULL) {
+    frandom = fopen("/dev/urandom", "rb");
+    if (frandom == NULL) {
+      mutt_error (_("open /dev/urandom: %s"), strerror(errno));
+      exit(1);
+    }
+    setbuf(frandom, NULL);
+  }
+  if (fread(out, 1, len, frandom) != len) {
+    mutt_error (_("read /dev/urandom: %s"), strerror(errno));
+    exit(1);
+  }
+}
+
+static const unsigned char base32[] = "abcdefghijklmnopqrstuvwxyz234567";
+
+void mutt_rand_base32(void *out, size_t len)
+{
+  size_t pos;
+  uint8_t *p = out;
+
+  mutt_randbuf(p, len);
+  for (pos = 0; pos < len; pos++)
+    p[pos] = base32[p[pos] % 32];
+}
+
+uint32_t mutt_rand32(void)
+{
+  uint32_t ret;
+
+  mutt_randbuf(&ret, sizeof(ret));
+  return ret;
+}
+
+uint64_t mutt_rand64(void)
+{
+  uint64_t ret;
+
+  mutt_randbuf(&ret, sizeof(ret));
+  return ret;
+}
+
+
 void _mutt_mktemp (char *s, size_t slen, const char *prefix, const char *suffix,
                    const char *src, int line)
 {
-  size_t n = snprintf (s, slen, "%s/%s-%s-%d-%d-%ld%ld%s%s",
+  size_t n = snprintf (s, slen, "%s/%s-%s-%d-%d-%" PRIu64 "%s%s",
       NONULL (Tempdir), NONULL (prefix), NONULL (Hostname),
-      (int) getuid (), (int) getpid (), random (), random (),
+      (int) getuid (), (int) getpid (), mutt_rand64(),
       suffix ? "." : "", NONULL (suffix));
   if (n >= slen)
     dprint (1, (debugfile, "%s:%d: ERROR: insufficient buffer space to hold temporary filename! slen=%zu but need %zu\n",
@@ -821,6 +917,11 @@ void mutt_pretty_mailbox (char *s, size_t buflen)
   }
 #endif
 
+#ifdef USE_NOTMUCH
+  if (scheme == U_NOTMUCH)
+    return;
+#endif
+
   /* if s is an url, only collapse path component */
   if (scheme != U_UNKNOWN)
   {
@@ -1216,8 +1317,34 @@ void mutt_FormatString (char *dest,		/* output buffer */
 
       if (*src == '?')
       {
+	/* change original %? to new %< notation */
+	/* %?x?y&z? to %<x?y&z> where y and z are nestable */
+	char *p = (char *) src;
+	*p = '<';
+	for ( ; *p && *p != '?'; p++);
+	  /* nothing */
+	if (*p == '?') {
+	  p++;
+	}
+	for ( ; *p && *p != '?'; p++);
+	  /* nothing */
+	if (*p == '?') {
+	  *p = '>';
+	}
+      }
+
+      if (*src == '<')
+      {
 	flags |= MUTT_FORMAT_OPTIONAL;
+	ch = *(++src); /* save the character to switch on */
 	src++;
+	cp = prefix;
+	count = 0;
+	while ((count < sizeof (prefix)) && (*src != '?')) {
+	  *cp++ = *src++;
+	  count++;
+	}
+	*cp = 0;
       }
       else
       {
@@ -1233,15 +1360,17 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	  count++;
 	}
 	*cp = 0;
-      }
 
-      if (!*src)
-	break; /* bad format */
+	if (!*src)
+	  break; /* bad format */
 
-      ch = *src++; /* save the character to switch on */
+	ch = *src++; /* save the character to switch on */
+      }
 
       if (flags & MUTT_FORMAT_OPTIONAL)
       {
+	int lrbalance;
+
         if (*src != '?')
           break; /* bad format */
         src++;
@@ -1249,8 +1378,20 @@ void mutt_FormatString (char *dest,		/* output buffer */
         /* eat the `if' part of the string */
         cp = ifstring;
 	count = 0;
-        while (count < sizeof (ifstring) && *src && *src != '?' && *src != '&')
-	{
+	lrbalance = 1;
+        while ((lrbalance > 0) && (count < sizeof (ifstring)) && *src) {
+	  if (*src == '\\') {
+	    src++;
+	    *cp++ = *src++;
+	  } else if ((src[0] == '%') && (src[1] == '<')) {
+	    lrbalance++;
+	  } else if (src[0] == '>') {
+	    lrbalance--;
+	  }
+	  if (lrbalance == 0)
+	    break;
+	  if ((lrbalance == 1) && (src[0] == '&'))
+	    break;
           *cp++ = *src++;
 	  count++;
 	}
@@ -1261,9 +1402,20 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	  src++; /* skip the & */
 	cp = elsestring;
 	count = 0;
-	while (count < sizeof (elsestring) && *src && *src != '?')
-	{
-	  *cp++ = *src++;
+	while ((lrbalance > 0) && (count < sizeof (elsestring)) && *src) {
+	  if (*src == '\\') {
+	    src++;
+	    *cp++ = *src++;
+	  } else if ((src[0] == '%') && (src[1] == '<')) {
+	    lrbalance++;
+	  } else if (src[0] == '>') {
+	    lrbalance--;
+	  }
+	  if (lrbalance == 0)
+	    break;
+	  if ((lrbalance == 1) && (src[0] == '&'))
+	    break;
+          *cp++ = *src++;
 	  count++;
 	}
 	*cp = 0;
@@ -1271,7 +1423,7 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	if (!*src)
 	  break; /* bad format */
 
-        src++; /* move past the trailing `?' */
+        src++; /* move past the trailing `>' (formerly '?') */
       }
 
       /* handle generic cases first */
@@ -1545,6 +1697,14 @@ int mutt_save_confirm (const char *s, struct stat *st)
     }
   }
 
+#ifdef USE_NNTP
+  if (magic == MUTT_NNTP)
+  {
+    mutt_error _("Can't save message to news server.");
+    return 0;
+  }
+#endif
+
   if (stat (s, st) != -1)
   {
     if (magic == -1)
@@ -1827,8 +1987,8 @@ void mutt_set_mtime (const char* from, const char* to)
 const char *mutt_make_version (void)
 {
   static char vstring[STRING];
-  snprintf (vstring, sizeof (vstring), "Mutt %s (%s)",
-	    MUTT_VERSION, ReleaseDate);
+  snprintf (vstring, sizeof (vstring), "NeoMutt %s (%s)",
+	    PACKAGE_VERSION, OldMuttVer);
   return vstring;
 }
 
@@ -1979,3 +2139,31 @@ void mutt_encode_path (char *dest, size_t dlen, const char *src)
   strfcpy (dest, (rc == 0) ? NONULL(p) : NONULL(src), dlen);
   FREE (&p);
 }
+
+/*
+ * Process an XDG environment variable or its fallback.
+ *
+ * Return 1 if an entry was found that actually exists on disk and 0 otherwise.
+ */
+int mutt_set_xdg_path(const XDGType type, char *buf, size_t bufsize)
+{
+  char *xdg_env = getenv (xdg_env_vars[type]);
+  char *xdg     = (xdg_env && *xdg_env) ? safe_strdup (xdg_env) : safe_strdup (xdg_defaults[type]);
+  char *x       = xdg;  /* strsep() changes xdg, so free x instead later */
+  char *token   = NULL;
+
+  while ((token = strsep (&xdg, ":")))
+  {
+    if (snprintf (buf, bufsize, "%s/neomutt/config", token) < 0)
+      continue;
+    mutt_expand_path (buf, bufsize);
+    if (access (buf, F_OK) == 0)
+    {
+      FREE (&x);
+      return 1;
+    }
+  }
+
+  FREE (&x);
+  return 0;
+}
diff --git a/mx.c b/mx.c
index fbe82e4..414602a 100644
--- a/mx.c
+++ b/mx.c
@@ -33,6 +33,10 @@
 #include "sidebar.h"
 #endif
 
+#ifdef USE_COMPRESSED
+#include "compress.h"
+#endif
+
 #ifdef USE_IMAP
 #include "imap.h"
 #endif
@@ -41,6 +45,14 @@
 #include "pop.h"
 #endif
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
+
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include "buffy.h"
 
 #ifdef USE_DOTLOCK
@@ -60,7 +72,7 @@
 #include <ctype.h>
 #include <utime.h>
 
-static struct mx_ops* mx_get_ops (int magic)
+struct mx_ops* mx_get_ops (int magic)
 {
   switch (magic)
   {
@@ -80,6 +92,18 @@ static struct mx_ops* mx_get_ops (int magic)
     case MUTT_POP:
       return &mx_pop_ops;
 #endif
+#ifdef USE_COMPRESSED
+    case MUTT_COMPRESSED:
+      return &mx_comp_ops;
+#endif
+#ifdef USE_NNTP
+    case MUTT_NNTP:
+      return &mx_nntp_ops;
+#endif
+#ifdef USE_NOTMUCH
+    case MUTT_NOTMUCH:
+      return &mx_notmuch_ops;
+#endif
     default:
       return NULL;
   }
@@ -328,7 +352,7 @@ static void mx_unlink_empty (const char *path)
 /* try to figure out what type of mailbox ``path'' is
  *
  * return values:
- *	M_*	mailbox type
+ *	MUTT_*	mailbox type
  *	0	not a mailbox
  *	-1	error
  */
@@ -370,6 +394,40 @@ int mx_is_pop (const char *p)
 }
 #endif
 
+#ifdef USE_NNTP
+int mx_is_nntp (const char *p)
+{
+  url_scheme_t scheme;
+
+  if (!p)
+    return 0;
+
+  scheme = url_check_scheme (p);
+  if (scheme == U_NNTP || scheme == U_NNTPS)
+    return 1;
+
+  return 0;
+}
+#endif
+
+#ifdef USE_NOTMUCH
+
+int mx_is_notmuch(const char *p)
+{
+  url_scheme_t scheme;
+
+  if (!p)
+    return 0;
+
+  scheme = url_check_scheme (p);
+  if (scheme == U_NOTMUCH)
+    return 1;
+
+  return 0;
+}
+
+#endif
+
 int mx_get_magic (const char *path)
 {
   struct stat st;
@@ -387,6 +445,16 @@ int mx_get_magic (const char *path)
     return MUTT_POP;
 #endif /* USE_POP */
 
+#ifdef USE_NNTP
+  if (mx_is_nntp (path))
+    return MUTT_NNTP;
+#endif /* USE_NNTP */
+
+#ifdef USE_NOTMUCH
+  if (mx_is_notmuch(path))
+    return MUTT_NOTMUCH;
+#endif
+
   if (stat (path, &st) == -1)
   {
     dprint (1, (debugfile, "mx_get_magic(): unable to stat %s: %s (errno %d).\n",
@@ -441,6 +509,12 @@ int mx_get_magic (const char *path)
     return (-1);
   }
 
+#ifdef USE_COMPRESSED
+  /* If there are no other matches, see if there are any
+   * compress hooks that match */
+  if ((magic == 0) && comp_can_read (path))
+    return MUTT_COMPRESSED;
+#endif
   return (magic);
 }
 
@@ -507,6 +581,11 @@ static int mx_open_mailbox_append (CONTEXT *ctx, int flags)
       return -1;
   }
 
+#ifdef USE_COMPRESSED
+  if (comp_can_append (ctx))
+    ctx->mx_ops = &mx_comp_ops;
+  else
+#endif
   ctx->mx_ops = mx_get_ops (ctx->magic);
   if (!ctx->mx_ops || !ctx->mx_ops->open_append)
     return -1;
@@ -700,6 +779,19 @@ static int sync_mailbox (CONTEXT *ctx, int *index_hint)
       rc = pop_sync_mailbox (ctx, index_hint);
       break;
 #endif /* USE_POP */
+
+#ifdef USE_NNTP
+    case MUTT_NNTP:
+      rc = nntp_sync_mailbox (ctx);
+      break;
+#endif /* USE_NNTP */
+
+#ifdef USE_NOTMUCH
+    case MUTT_NOTMUCH:
+      rc = nm_sync (ctx, index_hint);
+      break;
+#endif /* USE_NOTMUCH */
+
   }
 
 #if 0
@@ -709,6 +801,14 @@ static int sync_mailbox (CONTEXT *ctx, int *index_hint)
   
   if (tmp && tmp->new == 0)
     mutt_update_mailbox (tmp);
+
+#ifdef USE_COMPRESSED
+  /* If everything went well, the mbox handler saved the changes to our
+   * temporary file.  Next, comp_sync() will compress the temporary file. */
+  if ((rc == 0) && ctx->compress_info)
+    return comp_sync (ctx);
+#endif
+
   return rc;
 }
 
@@ -810,6 +910,25 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
     return 0;
   }
 
+#ifdef USE_NNTP
+  if (ctx->unread && ctx->magic == MUTT_NNTP)
+  {
+    NNTP_DATA *nntp_data = ctx->data;
+
+    if (nntp_data && nntp_data->nserv && nntp_data->group)
+    {
+      int rc = query_quadoption (OPT_CATCHUP, _("Mark all articles read?"));
+      if (rc < 0)
+      {
+	ctx->closing = 0;
+	return -1;
+      }
+      else if (rc == MUTT_YES)
+	mutt_newsgroup_catchup (nntp_data->nserv, nntp_data->group);
+    }
+  }
+#endif
+
   for (i = 0; i < ctx->msgcount; i++)
   {
     if (!ctx->hdrs[i]->deleted && ctx->hdrs[i]->read 
@@ -823,6 +942,12 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
 #endif
   }
 
+#ifdef USE_NNTP
+  /* don't need to move articles from newsgroup */
+  if (ctx->magic == MUTT_NNTP)
+    read_msgs = 0;
+#endif
+
   if (read_msgs && quadoption (OPT_MOVE) != MUTT_NO)
   {
     char *p;
@@ -1014,6 +1139,10 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
   return 0;
 }
 
+#if USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 
 /* update a Context structure's internal tables. */
 
@@ -1033,9 +1162,10 @@ void mx_update_tables(CONTEXT *ctx, int committing)
 #define this_body ctx->hdrs[j]->content
   for (i = 0, j = 0; i < ctx->msgcount; i++)
   {
-    if ((committing && (!ctx->hdrs[i]->deleted || 
+    if (!ctx->hdrs[i]->quasi_deleted &&
+	((committing && (!ctx->hdrs[i]->deleted ||
 			(ctx->magic == MUTT_MAILDIR && option (OPTMAILDIRTRASH)))) ||
-	(!committing && ctx->hdrs[i]->active))
+	(!committing && ctx->hdrs[i]->active)))
     {
       if (i != j)
       {
@@ -1353,6 +1483,7 @@ int mx_close_message (CONTEXT *ctx, MESSAGE **msg)
     FREE (&(*msg)->path);
   }
 
+  FREE (&(*msg)->commited_path);
   FREE (msg);		/* __FREE_CHECKED__ */
   return (r);
 }
diff --git a/mx.h b/mx.h
index ba9a78f..2f62abf 100644
--- a/mx.h
+++ b/mx.h
@@ -35,8 +35,15 @@ enum
   MUTT_MMDF,
   MUTT_MH,
   MUTT_MAILDIR,
+#ifdef USE_NNTP
+  MUTT_NNTP,
+#endif
   MUTT_IMAP,
+  MUTT_NOTMUCH,
   MUTT_POP
+#ifdef USE_COMPRESSED
+  , MUTT_COMPRESSED
+#endif
 };
 
 WHERE short DefaultMagic INITVAL (MUTT_MBOX);
@@ -57,7 +64,24 @@ int mh_check_empty (const char *);
 
 int maildir_check_empty (const char *);
 
-FILE *maildir_open_find_message (const char *, const char *);
+HEADER *maildir_parse_message (int magic, const char *fname, int is_old, HEADER * _h);
+HEADER *maildir_parse_stream (int magic, FILE *f, const char *fname, int is_old, HEADER * _h);
+void maildir_parse_flags (HEADER * h, const char *path);
+void maildir_update_flags (CONTEXT *ctx, HEADER *o, HEADER *n);
+void maildir_flags(char *dest, size_t destlen, HEADER * hdr);
+
+#if USE_HCACHE
+#include <hcache.h>
+int mh_sync_mailbox_message (CONTEXT * ctx, int msgno, header_cache_t *hc);
+#else
+int mh_sync_mailbox_message (CONTEXT * ctx, int msgno);
+#endif
+
+#ifdef USE_NOTMUCH
+int mx_is_notmuch(const char *p);
+#endif
+
+FILE *maildir_open_find_message (const char *, const char *, char **);
 
 int mbox_strict_cmp_headers (const HEADER *, const HEADER *);
 int mutt_reopen_mailbox (CONTEXT *, int *);
@@ -70,6 +94,7 @@ void mx_update_tables (CONTEXT *, int);
 int mx_lock_file (const char *, int, int, int, int);
 int mx_unlock_file (const char *path, int fd, int dot);
 
+struct mx_ops* mx_get_ops (int magic);
 extern struct mx_ops mx_maildir_ops;
 extern struct mx_ops mx_mbox_ops;
 extern struct mx_ops mx_mh_ops;
diff --git a/newsrc.c b/newsrc.c
new file mode 100644
index 0000000..6f7eff0
--- /dev/null
+++ b/newsrc.c
@@ -0,0 +1,1263 @@
+/*
+ * Copyright (C) 1998 Brandon Long <blong@fiction.net>
+ * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>
+ * Copyright (C) 2000-2012 Vsevolod Volkov <vvv@mutt.org.ua>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mutt_curses.h"
+#include "sort.h"
+#include "mx.h"
+#include "mime.h"
+#include "mailbox.h"
+#include "nntp.h"
+#include "rfc822.h"
+#include "rfc1524.h"
+#include "rfc2047.h"
+#include "bcache.h"
+
+#if USE_HCACHE
+#include "hcache.h"
+#endif
+
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <errno.h>
+
+/* Find NNTP_DATA for given newsgroup or add it */
+static NNTP_DATA *nntp_data_find (NNTP_SERVER *nserv, const char *group)
+{
+  NNTP_DATA *nntp_data = hash_find (nserv->groups_hash, group);
+
+  if (!nntp_data)
+  {
+    int len = strlen (group) + 1;
+    /* create NNTP_DATA structure and add it to hash */
+    nntp_data = safe_calloc (1, sizeof (NNTP_DATA) + len);
+    nntp_data->group = (char *)nntp_data + sizeof (NNTP_DATA);
+    strfcpy (nntp_data->group, group, len);
+    nntp_data->nserv = nserv;
+    nntp_data->deleted = 1;
+    if (nserv->groups_hash->nelem < nserv->groups_hash->curnelem * 2)
+      nserv->groups_hash = hash_resize (nserv->groups_hash,
+			   nserv->groups_hash->nelem * 2, 0);
+    hash_insert (nserv->groups_hash, nntp_data->group, nntp_data, 0);
+
+    /* add NNTP_DATA to list */
+    if (nserv->groups_num >= nserv->groups_max)
+    {
+      nserv->groups_max *= 2;
+      safe_realloc (&nserv->groups_list,
+		    nserv->groups_max * sizeof (nntp_data));
+    }
+    nserv->groups_list[nserv->groups_num++] = nntp_data;
+  }
+  return nntp_data;
+}
+
+/* Remove all temporarily cache files */
+void nntp_acache_free (NNTP_DATA *nntp_data)
+{
+  int i;
+
+  for (i = 0; i < NNTP_ACACHE_LEN; i++)
+  {
+    if (nntp_data->acache[i].path)
+    {
+      unlink (nntp_data->acache[i].path);
+      FREE (&nntp_data->acache[i].path);
+    }
+  }
+}
+
+/* Free NNTP_DATA, used to destroy hash elements */
+void nntp_data_free (void *data)
+{
+  NNTP_DATA *nntp_data = data;
+
+  if (!nntp_data)
+    return;
+  nntp_acache_free (nntp_data);
+  mutt_bcache_close (&nntp_data->bcache);
+  FREE (&nntp_data->newsrc_ent);
+  FREE (&nntp_data->desc);
+  FREE (&data);
+}
+
+/* Unlock and close .newsrc file */
+void nntp_newsrc_close (NNTP_SERVER *nserv)
+{
+  if (!nserv->newsrc_fp)
+    return;
+
+  dprint (1, (debugfile, "Unlocking %s\n", nserv->newsrc_file));
+  mx_unlock_file (nserv->newsrc_file, fileno (nserv->newsrc_fp), 0);
+  safe_fclose (&nserv->newsrc_fp);
+}
+
+/* Parse .newsrc file:
+ *  0 - not changed
+ *  1 - parsed
+ * -1 - error */
+int nntp_newsrc_parse (NNTP_SERVER *nserv)
+{
+  unsigned int i;
+  char *line;
+  struct stat sb;
+
+  /* if file doesn't exist, create it */
+  nserv->newsrc_fp = safe_fopen (nserv->newsrc_file, "a");
+  safe_fclose (&nserv->newsrc_fp);
+
+  /* open .newsrc */
+  nserv->newsrc_fp = safe_fopen (nserv->newsrc_file, "r");
+  if (!nserv->newsrc_fp)
+  {
+    mutt_perror (nserv->newsrc_file);
+    mutt_sleep (2);
+    return -1;
+  }
+
+  /* lock it */
+  dprint (1, (debugfile, "Locking %s\n", nserv->newsrc_file));
+  if (mx_lock_file (nserv->newsrc_file, fileno (nserv->newsrc_fp), 0, 0, 1))
+  {
+    safe_fclose (&nserv->newsrc_fp);
+    return -1;
+  }
+
+  if (stat (nserv->newsrc_file, &sb))
+  {
+    mutt_perror (nserv->newsrc_file);
+    nntp_newsrc_close (nserv);
+    mutt_sleep (2);
+    return -1;
+  }
+
+  if (nserv->size == sb.st_size && nserv->mtime == sb.st_mtime)
+    return 0;
+
+  nserv->size = sb.st_size;
+  nserv->mtime = sb.st_mtime;
+  nserv->newsrc_modified = 1;
+  dprint (1, (debugfile, "Parsing %s\n", nserv->newsrc_file));
+
+  /* .newsrc has been externally modified or hasn't been loaded yet */
+  for (i = 0; i < nserv->groups_num; i++)
+  {
+    NNTP_DATA *nntp_data = nserv->groups_list[i];
+
+    if (!nntp_data)
+      continue;
+
+    nntp_data->subscribed = 0;
+    nntp_data->newsrc_len = 0;
+    FREE (&nntp_data->newsrc_ent);
+  }
+
+  line = safe_malloc (sb.st_size + 1);
+  while (sb.st_size && fgets (line, sb.st_size + 1, nserv->newsrc_fp))
+  {
+    char *b, *h, *p;
+    unsigned int subs = 0, i = 1;
+    NNTP_DATA *nntp_data;
+
+    /* find end of newsgroup name */
+    p = strpbrk (line, ":!");
+    if (!p)
+      continue;
+
+    /* ":" - subscribed, "!" - unsubscribed */
+    if (*p == ':')
+      subs++;
+    *p++ = '\0';
+
+    /* get newsgroup data */
+    nntp_data = nntp_data_find (nserv, line);
+    FREE (&nntp_data->newsrc_ent);
+
+    /* count number of entries */
+    b = p;
+    while (*b)
+      if (*b++ == ',')
+	i++;
+    nntp_data->newsrc_ent = safe_calloc (i, sizeof (NEWSRC_ENTRY));
+    nntp_data->subscribed = subs;
+
+    /* parse entries */
+    i = 0;
+    while (p)
+    {
+      b = p;
+
+      /* find end of entry */
+      p = strchr (p, ',');
+      if (p)
+	*p++ = '\0';
+
+      /* first-last or single number */
+      h = strchr (b, '-');
+      if (h)
+	*h++ = '\0';
+      else
+	h = b;
+
+      if (sscanf (b, ANUM, &nntp_data->newsrc_ent[i].first) == 1 &&
+	  sscanf (h, ANUM, &nntp_data->newsrc_ent[i].last) == 1)
+	i++;
+    }
+    if (i == 0)
+    {
+	nntp_data->newsrc_ent[i].first = 1;
+	nntp_data->newsrc_ent[i].last = 0;
+	i++;
+    }
+    if (nntp_data->lastMessage == 0)
+      nntp_data->lastMessage = nntp_data->newsrc_ent[i - 1].last;
+    nntp_data->newsrc_len = i;
+    safe_realloc (&nntp_data->newsrc_ent, i * sizeof (NEWSRC_ENTRY));
+    nntp_group_unread_stat (nntp_data);
+    dprint (2, (debugfile, "nntp_newsrc_parse: %s\n", nntp_data->group));
+  }
+  FREE (&line);
+  return 1;
+}
+
+/* Generate array of .newsrc entries */
+void nntp_newsrc_gen_entries (CONTEXT *ctx)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  anum_t last = 0, first = 1;
+  int series, i;
+  int save_sort = SORT_ORDER;
+  unsigned int entries;
+
+  if (Sort != SORT_ORDER)
+  {
+    save_sort = Sort;
+    Sort = SORT_ORDER;
+    mutt_sort_headers (ctx, 0);
+  }
+
+  entries = nntp_data->newsrc_len;
+  if (!entries)
+  {
+    entries = 5;
+    nntp_data->newsrc_ent = safe_calloc (entries, sizeof (NEWSRC_ENTRY));
+  }
+
+  /* Set up to fake initial sequence from 1 to the article before the
+   * first article in our list */
+  nntp_data->newsrc_len = 0;
+  series = 1;
+  for (i = 0; i < ctx->msgcount; i++)
+  {
+    /* search for first unread */
+    if (series)
+    {
+      /* We don't actually check sequential order, since we mark
+       * "missing" entries as read/deleted */
+      last = NHDR (ctx->hdrs[i])->article_num;
+      if (last >= nntp_data->firstMessage && !ctx->hdrs[i]->deleted &&
+	  !ctx->hdrs[i]->read)
+      {
+	if (nntp_data->newsrc_len >= entries)
+	{
+	  entries *= 2;
+	  safe_realloc (&nntp_data->newsrc_ent, entries * sizeof (NEWSRC_ENTRY));
+	}
+	nntp_data->newsrc_ent[nntp_data->newsrc_len].first = first;
+	nntp_data->newsrc_ent[nntp_data->newsrc_len].last = last - 1;
+	nntp_data->newsrc_len++;
+	series = 0;
+      }
+    }
+
+    /* search for first read */
+    else
+    {
+      if (ctx->hdrs[i]->deleted || ctx->hdrs[i]->read)
+      {
+	first = last + 1;
+	series = 1;
+      }
+      last = NHDR (ctx->hdrs[i])->article_num;
+    }
+  }
+
+  if (series && first <= nntp_data->lastLoaded)
+  {
+    if (nntp_data->newsrc_len >= entries)
+    {
+      entries++;
+      safe_realloc (&nntp_data->newsrc_ent, entries * sizeof (NEWSRC_ENTRY));
+    }
+    nntp_data->newsrc_ent[nntp_data->newsrc_len].first = first;
+    nntp_data->newsrc_ent[nntp_data->newsrc_len].last = nntp_data->lastLoaded;
+    nntp_data->newsrc_len++;
+  }
+  safe_realloc (&nntp_data->newsrc_ent,
+		nntp_data->newsrc_len * sizeof (NEWSRC_ENTRY));
+
+  if (save_sort != Sort)
+  {
+    Sort = save_sort;
+    mutt_sort_headers (ctx, 0);
+  }
+}
+
+/* Update file with new contents */
+static int update_file (char *filename, char *buf)
+{
+  FILE *fp;
+  char tmpfile[_POSIX_PATH_MAX];
+  int rc = -1;
+
+  while (1)
+  {
+    snprintf (tmpfile, sizeof (tmpfile), "%s.tmp", filename);
+    fp = safe_fopen (tmpfile, "w");
+    if (!fp)
+    {
+      mutt_perror (tmpfile);
+      *tmpfile = '\0';
+      break;
+    }
+    if (fputs (buf, fp) == EOF)
+    {
+      mutt_perror (tmpfile);
+      break;
+    }
+    if (fclose (fp) == EOF)
+    {
+      mutt_perror (tmpfile);
+      fp = NULL;
+      break;
+    }
+    fp = NULL;
+    if (rename (tmpfile, filename) < 0)
+    {
+      mutt_perror (filename);
+      break;
+    }
+    *tmpfile = '\0';
+    rc = 0;
+    break;
+  }
+  if (fp)
+    fclose (fp);
+  if (*tmpfile)
+    unlink (tmpfile);
+  if (rc)
+    mutt_sleep (2);
+  return rc;
+}
+
+/* Update .newsrc file */
+int nntp_newsrc_update (NNTP_SERVER *nserv)
+{
+  char *buf;
+  size_t buflen, off;
+  unsigned int i;
+  int rc = -1;
+
+  if (!nserv)
+    return -1;
+
+  buflen = 10 * LONG_STRING;
+  buf = safe_calloc (1, buflen);
+  off = 0;
+
+  /* we will generate full newsrc here */
+  for (i = 0; i < nserv->groups_num; i++)
+  {
+    NNTP_DATA *nntp_data = nserv->groups_list[i];
+    unsigned int n;
+
+    if (!nntp_data || !nntp_data->newsrc_ent)
+      continue;
+
+    /* write newsgroup name */
+    if (off + strlen (nntp_data->group) + 3 > buflen)
+    {
+      buflen *= 2;
+      safe_realloc (&buf, buflen);
+    }
+    snprintf (buf + off, buflen - off, "%s%c ", nntp_data->group,
+	      nntp_data->subscribed ? ':' : '!');
+    off += strlen (buf + off);
+
+    /* write entries */
+    for (n = 0; n < nntp_data->newsrc_len; n++)
+    {
+      if (off + LONG_STRING > buflen)
+      {
+	buflen *= 2;
+	safe_realloc (&buf, buflen);
+      }
+      if (n)
+	buf[off++] = ',';
+      if (nntp_data->newsrc_ent[n].first == nntp_data->newsrc_ent[n].last)
+	snprintf (buf + off, buflen - off, "%d", nntp_data->newsrc_ent[n].first);
+      else if (nntp_data->newsrc_ent[n].first < nntp_data->newsrc_ent[n].last)
+	snprintf (buf + off, buflen - off, "%d-%d",
+		  nntp_data->newsrc_ent[n].first, nntp_data->newsrc_ent[n].last);
+      off += strlen (buf + off);
+    }
+    buf[off++] = '\n';
+  }
+  buf[off] = '\0';
+
+  /* newrc being fully rewritten */
+  dprint (1, (debugfile, "Updating %s\n", nserv->newsrc_file));
+  if (nserv->newsrc_file && update_file (nserv->newsrc_file, buf) == 0)
+  {
+    struct stat sb;
+
+    rc = stat (nserv->newsrc_file, &sb);
+    if (rc == 0)
+    {
+      nserv->size = sb.st_size;
+      nserv->mtime = sb.st_mtime;
+    }
+    else
+    {
+      mutt_perror (nserv->newsrc_file);
+      mutt_sleep (2);
+    }
+  }
+  FREE (&buf);
+  return rc;
+}
+
+/* Make fully qualified cache file name */
+static void cache_expand (char *dst, size_t dstlen, ACCOUNT *acct, char *src)
+{
+  char *c;
+  char file[_POSIX_PATH_MAX];
+
+  /* server subdirectory */
+  if (acct)
+  {
+    ciss_url_t url;
+
+    mutt_account_tourl (acct, &url);
+    url.path = src;
+    url_ciss_tostring (&url, file, sizeof (file), U_PATH);
+  }
+  else
+    strfcpy (file, src ? src : "", sizeof (file));
+
+  snprintf (dst, dstlen, "%s/%s", NewsCacheDir, file);
+
+  /* remove trailing slash */
+  c = dst + strlen (dst) - 1;
+  if (*c == '/')
+    *c = '\0';
+  mutt_expand_path (dst, dstlen);
+}
+
+/* Make fully qualified url from newsgroup name */
+void nntp_expand_path (char *line, size_t len, ACCOUNT *acct)
+{
+  ciss_url_t url;
+
+  url.path = safe_strdup (line);
+  mutt_account_tourl (acct, &url);
+  url_ciss_tostring (&url, line, len, 0);
+  FREE (&url.path);
+}
+
+/* Parse newsgroup */
+int nntp_add_group (char *line, void *data)
+{
+  NNTP_SERVER *nserv = data;
+  NNTP_DATA *nntp_data;
+  char group[LONG_STRING];
+  char desc[HUGE_STRING] = "";
+  char mod;
+  anum_t first, last;
+
+  if (!nserv || !line)
+    return 0;
+
+  if (sscanf (line, "%s " ANUM " " ANUM " %c %[^\n]", group,
+	      &last, &first, &mod, desc) < 4)
+    return 0;
+
+  nntp_data = nntp_data_find (nserv, group);
+  nntp_data->deleted = 0;
+  nntp_data->firstMessage = first;
+  nntp_data->lastMessage = last;
+  nntp_data->allowed = mod == 'y' || mod == 'm' ? 1 : 0;
+  mutt_str_replace (&nntp_data->desc, desc);
+  if (nntp_data->newsrc_ent || nntp_data->lastCached)
+    nntp_group_unread_stat (nntp_data);
+  else if (nntp_data->lastMessage &&
+	   nntp_data->firstMessage <= nntp_data->lastMessage)
+    nntp_data->unread = nntp_data->lastMessage - nntp_data->firstMessage + 1;
+  else
+    nntp_data->unread = 0;
+  return 0;
+}
+
+/* Load list of all newsgroups from cache */
+static int active_get_cache (NNTP_SERVER *nserv)
+{
+  char buf[HUGE_STRING];
+  char file[_POSIX_PATH_MAX];
+  time_t t;
+  FILE *fp;
+
+  cache_expand (file, sizeof (file), &nserv->conn->account, ".active");
+  dprint (1, (debugfile, "Parsing %s\n", file));
+  fp = safe_fopen (file, "r");
+  if (!fp)
+    return -1;
+
+  if (fgets (buf, sizeof (buf), fp) == NULL ||
+      sscanf (buf, "%ld%s", &t, file) != 1 || t == 0)
+  {
+    fclose (fp);
+    return -1;
+  }
+  nserv->newgroups_time = t;
+
+  mutt_message _("Loading list of groups from cache...");
+  while (fgets (buf, sizeof (buf), fp))
+    nntp_add_group (buf, nserv);
+  nntp_add_group (NULL, NULL);
+  fclose (fp);
+  mutt_clear_error ();
+  return 0;
+}
+
+/* Save list of all newsgroups to cache */
+int nntp_active_save_cache (NNTP_SERVER *nserv)
+{
+  char file[_POSIX_PATH_MAX];
+  char *buf;
+  size_t buflen, off;
+  unsigned int i;
+  int rc;
+
+  if (!nserv->cacheable)
+    return 0;
+
+  buflen = 10 * LONG_STRING;
+  buf = safe_calloc (1, buflen);
+  snprintf (buf, buflen, "%lu\n", (unsigned long)nserv->newgroups_time);
+  off = strlen (buf);
+
+  for (i = 0; i < nserv->groups_num; i++)
+  {
+    NNTP_DATA *nntp_data = nserv->groups_list[i];
+
+    if (!nntp_data || nntp_data->deleted)
+      continue;
+
+    if (off + strlen (nntp_data->group) +
+	(nntp_data->desc ? strlen (nntp_data->desc) : 0) + 50 > buflen)
+    {
+      buflen *= 2;
+      safe_realloc (&buf, buflen);
+    }
+    snprintf (buf + off, buflen - off, "%s %d %d %c%s%s\n", nntp_data->group,
+	      nntp_data->lastMessage, nntp_data->firstMessage,
+	      nntp_data->allowed ? 'y' : 'n', nntp_data->desc ? " " : "",
+	      nntp_data->desc ? nntp_data->desc : "");
+    off += strlen (buf + off);
+  }
+
+  cache_expand (file, sizeof (file), &nserv->conn->account, ".active");
+  dprint (1, (debugfile, "Updating %s\n", file));
+  rc = update_file (file, buf);
+  FREE (&buf);
+  return rc;
+}
+
+#ifdef USE_HCACHE
+/* Used by mutt_hcache_open() to compose hcache file name */
+static int nntp_hcache_namer (const char *path, char *dest, size_t destlen)
+{
+  return snprintf (dest, destlen, "%s.hcache", path);
+}
+
+/* Open newsgroup hcache */
+header_cache_t *nntp_hcache_open (NNTP_DATA *nntp_data)
+{
+  ciss_url_t url;
+  char file[_POSIX_PATH_MAX];
+
+  if (!nntp_data->nserv || !nntp_data->nserv->cacheable ||
+      !nntp_data->nserv->conn || !nntp_data->group ||
+      !(nntp_data->newsrc_ent || nntp_data->subscribed ||
+      option (OPTSAVEUNSUB)))
+    return NULL;
+
+  mutt_account_tourl (&nntp_data->nserv->conn->account, &url);
+  url.path = nntp_data->group;
+  url_ciss_tostring (&url, file, sizeof (file), U_PATH);
+  return mutt_hcache_open (NewsCacheDir, file, nntp_hcache_namer);
+}
+
+/* Remove stale cached headers */
+void nntp_hcache_update (NNTP_DATA *nntp_data, header_cache_t *hc)
+{
+  char buf[16];
+  int old = 0;
+  void *hdata;
+  anum_t first, last, current;
+
+  if (!hc)
+    return;
+
+  /* fetch previous values of first and last */
+  hdata = mutt_hcache_fetch_raw (hc, "index", strlen);
+  if (hdata)
+  {
+    dprint (2, (debugfile,
+		"nntp_hcache_update: mutt_hcache_fetch index: %s\n", hdata));
+    if (sscanf (hdata, ANUM " " ANUM, &first, &last) == 2)
+    {
+      old = 1;
+      nntp_data->lastCached = last;
+
+      /* clean removed headers from cache */
+      for (current = first; current <= last; current++)
+      {
+	if (current >= nntp_data->firstMessage &&
+	    current <= nntp_data->lastMessage)
+	  continue;
+
+	snprintf (buf, sizeof (buf), "%d", current);
+	dprint (2, (debugfile,
+		    "nntp_hcache_update: mutt_hcache_delete %s\n", buf));
+	mutt_hcache_delete (hc, buf, strlen);
+      }
+    }
+    FREE (&hdata);
+  }
+
+  /* store current values of first and last */
+  if (!old || nntp_data->firstMessage != first ||
+	      nntp_data->lastMessage != last)
+  {
+    snprintf (buf, sizeof (buf), "%u %u", nntp_data->firstMessage,
+					  nntp_data->lastMessage);
+    dprint (2, (debugfile,
+		"nntp_hcache_update: mutt_hcache_store index: %s\n", buf));
+    mutt_hcache_store_raw (hc, "index", buf, strlen (buf) + 1, strlen);
+  }
+}
+#endif
+
+/* Remove bcache file */
+static int nntp_bcache_delete (const char *id, body_cache_t *bcache, void *data)
+{
+  NNTP_DATA *nntp_data = data;
+  anum_t anum;
+  char c;
+
+  if (!nntp_data || sscanf (id, ANUM "%c", &anum, &c) != 1 ||
+      anum < nntp_data->firstMessage || anum > nntp_data->lastMessage)
+  {
+    if (nntp_data)
+      dprint (2, (debugfile, "nntp_bcache_delete: mutt_bcache_del %s\n", id));
+    mutt_bcache_del (bcache, id);
+  }
+  return 0;
+}
+
+/* Remove stale cached messages */
+void nntp_bcache_update (NNTP_DATA *nntp_data)
+{
+  mutt_bcache_list (nntp_data->bcache, nntp_bcache_delete, nntp_data);
+}
+
+/* Remove hcache and bcache of newsgroup */
+void nntp_delete_group_cache (NNTP_DATA *nntp_data)
+{
+  char file[_POSIX_PATH_MAX];
+
+  if (!nntp_data || !nntp_data->nserv || !nntp_data->nserv->cacheable)
+    return;
+
+#ifdef USE_HCACHE
+  nntp_hcache_namer (nntp_data->group, file, sizeof (file));
+  cache_expand (file, sizeof (file), &nntp_data->nserv->conn->account, file);
+  unlink (file);
+  nntp_data->lastCached = 0;
+  dprint (2, (debugfile, "nntp_delete_group_cache: %s\n", file));
+#endif
+
+  if (!nntp_data->bcache)
+    nntp_data->bcache = mutt_bcache_open (&nntp_data->nserv->conn->account,
+			nntp_data->group);
+  if (nntp_data->bcache)
+  {
+    dprint (2, (debugfile, "nntp_delete_group_cache: %s/*\n", nntp_data->group));
+    mutt_bcache_list (nntp_data->bcache, nntp_bcache_delete, NULL);
+    mutt_bcache_close (&nntp_data->bcache);
+  }
+}
+
+/* Remove hcache and bcache of all unexistent and unsubscribed newsgroups */
+void nntp_clear_cache (NNTP_SERVER *nserv)
+{
+  char file[_POSIX_PATH_MAX];
+  char *fp;
+  struct dirent *entry;
+  DIR *dp;
+
+  if (!nserv || !nserv->cacheable)
+    return;
+
+  cache_expand (file, sizeof (file), &nserv->conn->account, NULL);
+  dp = opendir (file);
+  if (dp)
+  {
+    safe_strncat (file, sizeof (file), "/", 1);
+    fp = file + strlen (file);
+    while ((entry = readdir (dp)))
+    {
+      char *group = entry->d_name;
+      struct stat sb;
+      NNTP_DATA *nntp_data;
+      NNTP_DATA nntp_tmp;
+
+      if (mutt_strcmp (group, ".") == 0 ||
+	  mutt_strcmp (group, "..") == 0)
+	continue;
+      *fp = '\0';
+      safe_strncat (file, sizeof (file), group, strlen (group));
+      if (stat (file, &sb))
+	continue;
+
+#ifdef USE_HCACHE
+      if (S_ISREG (sb.st_mode))
+      {
+	char *ext = group + strlen (group) - 7;
+	if (strlen (group) < 8 || mutt_strcmp (ext, ".hcache"))
+	  continue;
+	*ext = '\0';
+      }
+      else
+#endif
+      if (!S_ISDIR (sb.st_mode))
+	continue;
+
+      nntp_data = hash_find (nserv->groups_hash, group);
+      if (!nntp_data)
+      {
+	nntp_data = &nntp_tmp;
+	nntp_data->nserv = nserv;
+	nntp_data->group = group;
+	nntp_data->bcache = NULL;
+      }
+      else if (nntp_data->newsrc_ent || nntp_data->subscribed ||
+	       option (OPTSAVEUNSUB))
+	continue;
+
+      nntp_delete_group_cache (nntp_data);
+      if (S_ISDIR (sb.st_mode))
+      {
+	rmdir (file);
+	dprint (2, (debugfile, "nntp_clear_cache: %s\n", file));
+      }
+    }
+    closedir (dp);
+  }
+  return;
+}
+
+/* %a = account url
+ * %p = port
+ * %P = port if specified
+ * %s = news server name
+ * %S = url schema
+ * %u = username */
+const char *
+nntp_format_str (char *dest, size_t destlen, size_t col, int cols, char op, const char *src,
+		const char *fmt, const char *ifstring, const char *elsestring,
+		unsigned long data, format_flag flags)
+{
+  NNTP_SERVER *nserv = (NNTP_SERVER *)data;
+  ACCOUNT *acct = &nserv->conn->account;
+  ciss_url_t url;
+  char fn[SHORT_STRING], tmp[SHORT_STRING], *p;
+
+  switch (op)
+  {
+    case 'a':
+      mutt_account_tourl (acct, &url);
+      url_ciss_tostring (&url, fn, sizeof (fn), U_PATH);
+      p = strchr (fn, '/');
+      if (p)
+	*p = '\0';
+      snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+      snprintf (dest, destlen, tmp, fn);
+      break;
+    case 'p':
+      snprintf (tmp, sizeof (tmp), "%%%su", fmt);
+      snprintf (dest, destlen, tmp, acct->port);
+      break;
+    case 'P':
+      *dest = '\0';
+      if (acct->flags & MUTT_ACCT_PORT)
+      {
+	snprintf (tmp, sizeof (tmp), "%%%su", fmt);
+	snprintf (dest, destlen, tmp, acct->port);
+      }
+      break;
+    case 's':
+      strncpy (fn, acct->host, sizeof (fn) - 1);
+      mutt_strlower (fn);
+      snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+      snprintf (dest, destlen, tmp, fn);
+      break;
+    case 'S':
+      mutt_account_tourl (acct, &url);
+      url_ciss_tostring (&url, fn, sizeof (fn), U_PATH);
+      p = strchr (fn, ':');
+      if (p)
+	*p = '\0';
+      snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+      snprintf (dest, destlen, tmp, fn);
+      break;
+    case 'u':
+      snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+      snprintf (dest, destlen, tmp, acct->user);
+      break;
+  }
+  return (src);
+}
+
+/* Automatically loads a newsrc into memory, if necessary.
+ * Checks the size/mtime of a newsrc file, if it doesn't match, load
+ * again.  Hmm, if a system has broken mtimes, this might mean the file
+ * is reloaded every time, which we'd have to fix. */
+NNTP_SERVER *nntp_select_server (char *server, int leave_lock)
+{
+  char file[_POSIX_PATH_MAX];
+  char *p;
+  int rc;
+  struct stat sb;
+  ACCOUNT acct;
+  NNTP_SERVER *nserv;
+  NNTP_DATA *nntp_data;
+  CONNECTION *conn;
+  ciss_url_t url;
+
+  if (!server || !*server)
+  {
+    mutt_error _("No news server defined!");
+    mutt_sleep (2);
+    return NULL;
+  }
+
+  /* create account from news server url */
+  acct.flags = 0;
+  acct.port = NNTP_PORT;
+  acct.type = MUTT_ACCT_TYPE_NNTP;
+  snprintf (file, sizeof (file), "%s%s",
+	    strstr (server, "://") ? "" : "news://", server);
+  if (url_parse_ciss (&url, file) < 0 ||
+      (url.path && *url.path) ||
+      !(url.scheme == U_NNTP || url.scheme == U_NNTPS) ||
+      mutt_account_fromurl (&acct, &url) < 0)
+  {
+    mutt_error (_("%s is an invalid news server specification!"), server);
+    mutt_sleep (2);
+    return NULL;
+  }
+  if (url.scheme == U_NNTPS)
+  {
+    acct.flags |= MUTT_ACCT_SSL;
+    acct.port = NNTP_SSL_PORT;
+  }
+
+  /* find connection by account */
+  conn = mutt_conn_find (NULL, &acct);
+  if (!conn)
+    return NULL;
+  if (!(conn->account.flags & MUTT_ACCT_USER) && acct.flags & MUTT_ACCT_USER)
+  {
+    conn->account.flags |= MUTT_ACCT_USER;
+    conn->account.user[0] = '\0';
+  }
+
+  /* news server already exists */
+  nserv = conn->data;
+  if (nserv)
+  {
+    if (nserv->status == NNTP_BYE)
+      nserv->status = NNTP_NONE;
+    if (nntp_open_connection (nserv) < 0)
+      return NULL;
+
+    rc = nntp_newsrc_parse (nserv);
+    if (rc < 0)
+      return NULL;
+
+    /* check for new newsgroups */
+    if (!leave_lock && nntp_check_new_groups (nserv) < 0)
+      rc = -1;
+
+    /* .newsrc has been externally modified */
+    if (rc > 0)
+      nntp_clear_cache (nserv);
+    if (rc < 0 || !leave_lock)
+      nntp_newsrc_close (nserv);
+    return rc < 0 ? NULL : nserv;
+  }
+
+  /* new news server */
+  nserv = safe_calloc (1, sizeof (NNTP_SERVER));
+  nserv->conn = conn;
+  nserv->groups_hash = hash_create (1009, 0);
+  nserv->groups_max = 16;
+  nserv->groups_list = safe_malloc (nserv->groups_max * sizeof (nntp_data));
+
+  rc = nntp_open_connection (nserv);
+
+  /* try to create cache directory and enable caching */
+  nserv->cacheable = 0;
+  if (rc >= 0 && NewsCacheDir && *NewsCacheDir)
+  {
+    cache_expand (file, sizeof (file), &conn->account, NULL);
+    p = *file == '/' ? file + 1 : file;
+    while (1)
+    {
+      p = strchr (p, '/');
+      if (p)
+	*p = '\0';
+      if ((stat (file, &sb) || (sb.st_mode & S_IFDIR) == 0) &&
+	  mkdir (file, 0700))
+      {
+	mutt_error (_("Can't create %s: %s."), file, strerror (errno));
+	mutt_sleep (2);
+	break;
+      }
+      if (!p)
+      {
+	nserv->cacheable = 1;
+	break;
+      }
+      *p++ = '/';
+    }
+  }
+
+  /* load .newsrc */
+  if (rc >= 0)
+  {
+    mutt_FormatString (file, sizeof (file), 0, MuttIndexWindow->cols, NONULL (NewsRc),
+		       nntp_format_str, (unsigned long)nserv, 0);
+    mutt_expand_path (file, sizeof (file));
+    nserv->newsrc_file = safe_strdup (file);
+    rc = nntp_newsrc_parse (nserv);
+  }
+  if (rc >= 0)
+  {
+    /* try to load list of newsgroups from cache */
+    if (nserv->cacheable && active_get_cache (nserv) == 0)
+      rc = nntp_check_new_groups (nserv);
+
+    /* load list of newsgroups from server */
+    else
+      rc = nntp_active_fetch (nserv);
+  }
+
+  if (rc >= 0)
+    nntp_clear_cache (nserv);
+
+#ifdef USE_HCACHE
+  /* check cache files */
+  if (rc >= 0 && nserv->cacheable)
+  {
+    struct dirent *entry;
+    DIR *dp = opendir (file);
+
+    if (dp)
+    {
+      while ((entry = readdir (dp)))
+      {
+	header_cache_t *hc;
+	void *hdata;
+	char *group = entry->d_name;
+
+	p = group + strlen (group) - 7;
+	if (strlen (group) < 8 || strcmp (p, ".hcache"))
+	  continue;
+	*p = '\0';
+	nntp_data = hash_find (nserv->groups_hash, group);
+	if (!nntp_data)
+	  continue;
+
+	hc = nntp_hcache_open (nntp_data);
+	if (!hc)
+	  continue;
+
+	/* fetch previous values of first and last */
+	hdata = mutt_hcache_fetch_raw (hc, "index", strlen);
+	if (hdata)
+	{
+	  anum_t first, last;
+
+	  if (sscanf (hdata, ANUM " " ANUM, &first, &last) == 2)
+	  {
+	    if (nntp_data->deleted)
+	    {
+	      nntp_data->firstMessage = first;
+	      nntp_data->lastMessage = last;
+	    }
+	    if (last >= nntp_data->firstMessage &&
+		last <= nntp_data->lastMessage)
+	    {
+	      nntp_data->lastCached = last;
+	      dprint (2, (debugfile, "nntp_select_server: %s lastCached=%u\n",
+			  nntp_data->group, last));
+	    }
+	  }
+	  FREE (&hdata);
+	}
+	mutt_hcache_close (hc);
+      }
+      closedir (dp);
+    }
+  }
+#endif
+
+  if (rc < 0 || !leave_lock)
+    nntp_newsrc_close (nserv);
+
+  if (rc < 0)
+  {
+    hash_destroy (&nserv->groups_hash, nntp_data_free);
+    FREE (&nserv->groups_list);
+    FREE (&nserv->newsrc_file);
+    FREE (&nserv->authenticators);
+    FREE (&nserv);
+    mutt_socket_close (conn);
+    mutt_socket_free (conn);
+    return NULL;
+  }
+
+  conn->data = nserv;
+  return nserv;
+}
+
+/* Full status flags are not supported by nntp, but we can fake some of them:
+ * Read = a read message number is in the .newsrc
+ * New = not read and not cached
+ * Old = not read but cached */
+void nntp_article_status (CONTEXT *ctx, HEADER *hdr, char *group, anum_t anum)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  unsigned int i;
+
+  if (group)
+    nntp_data = hash_find (nntp_data->nserv->groups_hash, group);
+
+  if (!nntp_data)
+    return;
+
+  for (i = 0; i < nntp_data->newsrc_len; i++)
+  {
+    if ((anum >= nntp_data->newsrc_ent[i].first) &&
+	(anum <= nntp_data->newsrc_ent[i].last))
+    {
+      /* can't use mutt_set_flag() because mx_update_context()
+	 didn't called yet */
+      hdr->read = 1;
+      return;
+    }
+  }
+
+  /* article was not cached yet, it's new */
+  if (anum > nntp_data->lastCached)
+    return;
+
+  /* article isn't read but cached, it's old */
+  if (option (OPTMARKOLD))
+    hdr->old = 1;
+}
+
+/* calculate number of unread articles using .newsrc data */
+void nntp_group_unread_stat (NNTP_DATA *nntp_data)
+{
+  unsigned int i;
+  anum_t first, last;
+
+  nntp_data->unread = 0;
+  if (nntp_data->lastMessage == 0 ||
+      nntp_data->firstMessage > nntp_data->lastMessage)
+    return;
+
+  nntp_data->unread = nntp_data->lastMessage - nntp_data->firstMessage + 1;
+  for (i = 0; i < nntp_data->newsrc_len; i++)
+  {
+    first = nntp_data->newsrc_ent[i].first;
+    if (first < nntp_data->firstMessage)
+      first = nntp_data->firstMessage;
+    last = nntp_data->newsrc_ent[i].last;
+    if (last > nntp_data->lastMessage)
+      last = nntp_data->lastMessage;
+    if (first <= last)
+      nntp_data->unread -= last - first + 1;
+  }
+}
+
+/* Subscribe newsgroup */
+NNTP_DATA *mutt_newsgroup_subscribe (NNTP_SERVER *nserv, char *group)
+{
+  NNTP_DATA *nntp_data;
+
+  if (!nserv || !nserv->groups_hash || !group || !*group)
+    return NULL;
+
+  nntp_data = nntp_data_find (nserv, group);
+  nntp_data->subscribed = 1;
+  if (!nntp_data->newsrc_ent)
+  {
+    nntp_data->newsrc_ent = safe_calloc (1, sizeof (NEWSRC_ENTRY));
+    nntp_data->newsrc_len = 1;
+    nntp_data->newsrc_ent[0].first = 1;
+    nntp_data->newsrc_ent[0].last = 0;
+  }
+  return nntp_data;
+}
+
+/* Unsubscribe newsgroup */
+NNTP_DATA *mutt_newsgroup_unsubscribe (NNTP_SERVER *nserv, char *group)
+{
+  NNTP_DATA *nntp_data;
+
+  if (!nserv || !nserv->groups_hash || !group || !*group)
+    return NULL;
+
+  nntp_data = hash_find (nserv->groups_hash, group);
+  if (!nntp_data)
+    return NULL;
+
+  nntp_data->subscribed = 0;
+  if (!option (OPTSAVEUNSUB))
+  {
+    nntp_data->newsrc_len = 0;
+    FREE (&nntp_data->newsrc_ent);
+  }
+  return nntp_data;
+}
+
+/* Catchup newsgroup */
+NNTP_DATA *mutt_newsgroup_catchup (NNTP_SERVER *nserv, char *group)
+{
+  NNTP_DATA *nntp_data;
+
+  if (!nserv || !nserv->groups_hash || !group || !*group)
+    return NULL;
+
+  nntp_data = hash_find (nserv->groups_hash, group);
+  if (!nntp_data)
+    return NULL;
+
+  if (nntp_data->newsrc_ent)
+  {
+    safe_realloc (&nntp_data->newsrc_ent, sizeof (NEWSRC_ENTRY));
+    nntp_data->newsrc_len = 1;
+    nntp_data->newsrc_ent[0].first = 1;
+    nntp_data->newsrc_ent[0].last = nntp_data->lastMessage;
+  }
+  nntp_data->unread = 0;
+  if (Context && Context->data == nntp_data)
+  {
+    unsigned int i;
+
+    for (i = 0; i < Context->msgcount; i++)
+      mutt_set_flag (Context, Context->hdrs[i], MUTT_READ, 1);
+  }
+  return nntp_data;
+}
+
+/* Uncatchup newsgroup */
+NNTP_DATA *mutt_newsgroup_uncatchup (NNTP_SERVER *nserv, char *group)
+{
+  NNTP_DATA *nntp_data;
+
+  if (!nserv || !nserv->groups_hash || !group || !*group)
+    return NULL;
+
+  nntp_data = hash_find (nserv->groups_hash, group);
+  if (!nntp_data)
+    return NULL;
+
+  if (nntp_data->newsrc_ent)
+  {
+    safe_realloc (&nntp_data->newsrc_ent, sizeof (NEWSRC_ENTRY));
+    nntp_data->newsrc_len = 1;
+    nntp_data->newsrc_ent[0].first = 1;
+    nntp_data->newsrc_ent[0].last = nntp_data->firstMessage - 1;
+  }
+  if (Context && Context->data == nntp_data)
+  {
+    unsigned int i;
+
+    nntp_data->unread = Context->msgcount;
+    for (i = 0; i < Context->msgcount; i++)
+      mutt_set_flag (Context, Context->hdrs[i], MUTT_READ, 0);
+  }
+  else
+    nntp_data->unread = nntp_data->lastMessage - nntp_data->newsrc_ent[0].last;
+  return nntp_data;
+}
+
+/* Get first newsgroup with new messages */
+void nntp_buffy (char *buf, size_t len)
+{
+  unsigned int i;
+
+  for (i = 0; i < CurrentNewsSrv->groups_num; i++)
+  {
+    NNTP_DATA *nntp_data = CurrentNewsSrv->groups_list[i];
+
+    if (!nntp_data || !nntp_data->subscribed || !nntp_data->unread)
+      continue;
+
+    if (Context && Context->magic == MUTT_NNTP &&
+	!mutt_strcmp (nntp_data->group, ((NNTP_DATA *)Context->data)->group))
+    {
+      unsigned int i, unread = 0;
+
+      for (i = 0; i < Context->msgcount; i++)
+	if (!Context->hdrs[i]->read && !Context->hdrs[i]->deleted)
+	  unread++;
+      if (!unread)
+	continue;
+    }
+    strfcpy (buf, nntp_data->group, len);
+    break;
+  }
+}
diff --git a/nntp.c b/nntp.c
new file mode 100644
index 0000000..397bd24
--- /dev/null
+++ b/nntp.c
@@ -0,0 +1,2449 @@
+/*
+ * Copyright (C) 1998 Brandon Long <blong@fiction.net>
+ * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>
+ * Copyright (C) 2000-2012 Vsevolod Volkov <vvv@mutt.org.ua>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mutt_curses.h"
+#include "sort.h"
+#include "mx.h"
+#include "mime.h"
+#include "rfc1524.h"
+#include "rfc2047.h"
+#include "mailbox.h"
+#include "mutt_crypt.h"
+#include "nntp.h"
+
+#if defined(USE_SSL)
+#include "mutt_ssl.h"
+#endif
+
+#ifdef HAVE_PGP
+#include "pgp.h"
+#endif
+
+#ifdef HAVE_SMIME
+#include "smime.h"
+#endif
+
+#if USE_HCACHE
+#include "hcache.h"
+#endif
+
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+
+#ifdef USE_SASL
+#include <sasl/sasl.h>
+#include <sasl/saslutil.h>
+
+#include "mutt_sasl.h"
+#endif
+
+static int nntp_connect_error (NNTP_SERVER *nserv)
+{
+  nserv->status = NNTP_NONE;
+  mutt_error _("Server closed connection!");
+  mutt_sleep (2);
+  return -1;
+}
+
+/* Get capabilities:
+ * -1 - error, connection is closed
+ *  0 - mode is reader, capabilities setted up
+ *  1 - need to switch to reader mode */
+static int nntp_capabilities (NNTP_SERVER *nserv)
+{
+  CONNECTION *conn = nserv->conn;
+  unsigned int mode_reader = 0;
+  char buf[LONG_STRING];
+  char authinfo[LONG_STRING] = "";
+
+  nserv->hasCAPABILITIES = 0;
+  nserv->hasSTARTTLS = 0;
+  nserv->hasDATE = 0;
+  nserv->hasLIST_NEWSGROUPS = 0;
+  nserv->hasLISTGROUP = 0;
+  nserv->hasLISTGROUPrange = 0;
+  nserv->hasOVER = 0;
+  FREE (&nserv->authenticators);
+
+  if (mutt_socket_write (conn, "CAPABILITIES\r\n") < 0 ||
+      mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+    return nntp_connect_error (nserv);
+
+  /* no capabilities */
+  if (mutt_strncmp ("101", buf, 3))
+    return 1;
+  nserv->hasCAPABILITIES = 1;
+
+  /* parse capabilities */
+  do
+  {
+    if (mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+    if (!mutt_strcmp ("STARTTLS", buf))
+      nserv->hasSTARTTLS = 1;
+    else if (!mutt_strcmp ("MODE-READER", buf))
+      mode_reader = 1;
+    else if (!mutt_strcmp ("READER", buf))
+    {
+      nserv->hasDATE = 1;
+      nserv->hasLISTGROUP = 1;
+      nserv->hasLISTGROUPrange = 1;
+    }
+    else if (!mutt_strncmp ("AUTHINFO ", buf, 9))
+    {
+      safe_strcat (buf, sizeof (buf), " ");
+      strfcpy (authinfo, buf + 8, sizeof (authinfo));
+    }
+#ifdef USE_SASL
+    else if (!mutt_strncmp ("SASL ", buf, 5))
+    {
+      char *p = buf + 5;
+      while (*p == ' ')
+	p++;
+      nserv->authenticators = safe_strdup (p);
+    }
+#endif
+    else if (!mutt_strcmp ("OVER", buf))
+      nserv->hasOVER = 1;
+    else if (!mutt_strncmp ("LIST ", buf, 5))
+    {
+      char *p = strstr (buf, " NEWSGROUPS");
+      if (p)
+      {
+	p += 11;
+	if (*p == '\0' || *p == ' ')
+	  nserv->hasLIST_NEWSGROUPS = 1;
+      }
+    }
+  } while (mutt_strcmp (".", buf));
+  *buf = '\0';
+#ifdef USE_SASL
+  if (nserv->authenticators && strcasestr (authinfo, " SASL "))
+    strfcpy (buf, nserv->authenticators, sizeof (buf));
+#endif
+  if (strcasestr (authinfo, " USER "))
+  {
+    if (*buf)
+      safe_strcat (buf, sizeof (buf), " ");
+    safe_strcat (buf, sizeof (buf), "USER");
+  }
+  mutt_str_replace (&nserv->authenticators, buf);
+
+  /* current mode is reader */
+  if (nserv->hasDATE)
+    return 0;
+
+  /* server is mode-switching, need to switch to reader mode */
+  if (mode_reader)
+    return 1;
+
+  mutt_socket_close (conn);
+  nserv->status = NNTP_BYE;
+  mutt_error _("Server doesn't support reader mode.");
+  mutt_sleep (2);
+  return -1;
+}
+
+char *OverviewFmt =
+	"Subject:\0"
+	"From:\0"
+	"Date:\0"
+	"Message-ID:\0"
+	"References:\0"
+	"Content-Length:\0"
+	"Lines:\0"
+	"\0";
+
+/* Detect supported commands */
+static int nntp_attempt_features (NNTP_SERVER *nserv)
+{
+  CONNECTION *conn = nserv->conn;
+  char buf[LONG_STRING];
+
+  /* no CAPABILITIES, trying DATE, LISTGROUP, LIST NEWSGROUPS */
+  if (!nserv->hasCAPABILITIES)
+  {
+    if (mutt_socket_write (conn, "DATE\r\n") < 0 ||
+	mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+    if (mutt_strncmp ("500", buf, 3))
+      nserv->hasDATE = 1;
+
+    if (mutt_socket_write (conn, "LISTGROUP\r\n") < 0 ||
+	mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+    if (mutt_strncmp ("500", buf, 3))
+      nserv->hasLISTGROUP = 1;
+
+    if (mutt_socket_write (conn, "LIST NEWSGROUPS +\r\n") < 0 ||
+	mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+    if (mutt_strncmp ("500", buf, 3))
+      nserv->hasLIST_NEWSGROUPS = 1;
+    if (!mutt_strncmp ("215", buf, 3))
+    {
+      do
+      {
+	if (mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+	  return nntp_connect_error (nserv);
+      } while (mutt_strcmp (".", buf));
+    }
+  }
+
+  /* no LIST NEWSGROUPS, trying XGTITLE */
+  if (!nserv->hasLIST_NEWSGROUPS)
+  {
+    if (mutt_socket_write (conn, "XGTITLE\r\n") < 0 ||
+	mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+    if (mutt_strncmp ("500", buf, 3))
+      nserv->hasXGTITLE = 1;
+  }
+
+  /* no OVER, trying XOVER */
+  if (!nserv->hasOVER)
+  {
+    if (mutt_socket_write (conn, "XOVER\r\n") < 0 ||
+	mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+    if (mutt_strncmp ("500", buf, 3))
+      nserv->hasXOVER = 1;
+  }
+
+  /* trying LIST OVERVIEW.FMT */
+  if (nserv->hasOVER || nserv->hasXOVER)
+  {
+    if (mutt_socket_write (conn, "LIST OVERVIEW.FMT\r\n") < 0 ||
+	mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+    if (mutt_strncmp ("215", buf, 3))
+      nserv->overview_fmt = OverviewFmt;
+    else
+    {
+      int chunk, cont = 0;
+      size_t buflen = 2 * LONG_STRING, off = 0, b = 0;
+
+      if (nserv->overview_fmt)
+	FREE (&nserv->overview_fmt);
+      nserv->overview_fmt = safe_malloc (buflen);
+
+      while (1)
+      {
+	if (buflen - off < LONG_STRING)
+	{
+	  buflen *= 2;
+	  safe_realloc (&nserv->overview_fmt, buflen);
+	}
+
+	chunk = mutt_socket_readln (nserv->overview_fmt + off,
+				    buflen - off, conn);
+	if (chunk < 0)
+	{
+	  FREE (&nserv->overview_fmt);
+	  return nntp_connect_error (nserv);
+	}
+
+	if (!cont && !mutt_strcmp (".", nserv->overview_fmt + off))
+	  break;
+
+	cont = chunk >= buflen - off ? 1 : 0;
+	off += strlen (nserv->overview_fmt + off);
+	if (!cont)
+	{
+	  char *colon;
+
+	  if (nserv->overview_fmt[b] == ':')
+	  {
+	    memmove (nserv->overview_fmt + b,
+		     nserv->overview_fmt + b + 1, off - b - 1);
+	    nserv->overview_fmt[off - 1] = ':';
+	  }
+	  colon = strchr (nserv->overview_fmt + b, ':');
+	  if (!colon)
+	    nserv->overview_fmt[off++] = ':';
+	  else if (strcmp (colon + 1, "full"))
+	    off = colon + 1 - nserv->overview_fmt;
+	  if (!strcasecmp (nserv->overview_fmt + b, "Bytes:"))
+	  {
+            int len = strlen (nserv->overview_fmt + b);
+	    strfcpy (nserv->overview_fmt + b, "Content-Length:", len + 1);
+	    off = b + len;
+	  }
+	  nserv->overview_fmt[off++] = '\0';
+	  b = off;
+	}
+      }
+      nserv->overview_fmt[off++] = '\0';
+      safe_realloc (&nserv->overview_fmt, off);
+    }
+  }
+  return 0;
+}
+
+/* Get login, password and authenticate */
+static int nntp_auth (NNTP_SERVER *nserv)
+{
+  CONNECTION *conn = nserv->conn;
+  char buf[LONG_STRING];
+  char authenticators[LONG_STRING] = "USER";
+  char *method, *a, *p;
+  unsigned char flags = conn->account.flags;
+
+  while (1)
+  {
+    /* get login and password */
+    if (mutt_account_getuser (&conn->account) || !conn->account.user[0] ||
+	mutt_account_getpass (&conn->account) || !conn->account.pass[0])
+      break;
+
+    /* get list of authenticators */
+    if (NntpAuthenticators && *NntpAuthenticators)
+      strfcpy (authenticators, NntpAuthenticators, sizeof (authenticators));
+    else if (nserv->hasCAPABILITIES)
+    {
+      strfcpy (authenticators, NONULL (nserv->authenticators),
+	       sizeof (authenticators));
+      p = authenticators;
+      while (*p)
+      {
+	if (*p == ' ')
+	  *p = ':';
+	p++;
+      }
+    }
+    p = authenticators;
+    while (*p)
+    {
+      *p = ascii_toupper (*p);
+      p++;
+    }
+
+    dprint (1, (debugfile,
+		"nntp_auth: available methods: %s\n", nserv->authenticators));
+    a = authenticators;
+    while (1)
+    {
+      if (!a)
+      {
+	mutt_error _("No authenticators available");
+	mutt_sleep (2);
+	break;
+      }
+
+      method = a;
+      a = strchr (a, ':');
+      if (a)
+	*a++ = '\0';
+
+      /* check authenticator */
+      if (nserv->hasCAPABILITIES)
+      {
+	char *m;
+
+	if (!nserv->authenticators)
+	  continue;
+	m = strcasestr (nserv->authenticators, method);
+	if (!m)
+	  continue;
+	if (m > nserv->authenticators && *(m - 1) != ' ')
+	  continue;
+	m += strlen (method);
+	if (*m != '\0' && *m != ' ')
+	  continue;
+      }
+      dprint (1, (debugfile, "nntp_auth: trying method %s\n", method));
+
+      /* AUTHINFO USER authentication */
+      if (!strcmp (method, "USER"))
+      {
+	mutt_message (_("Authenticating (%s)..."), method);
+	snprintf (buf, sizeof (buf), "AUTHINFO USER %s\r\n", conn->account.user);
+	if (mutt_socket_write (conn, buf) < 0 ||
+	    mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+	  break;
+
+	/* authenticated, password is not required */
+	if (!mutt_strncmp ("281", buf, 3))
+	  return 0;
+
+	/* username accepted, sending password */
+	if (!mutt_strncmp ("381", buf, 3))
+	{
+#ifdef DEBUG
+	  if (debuglevel < MUTT_SOCK_LOG_FULL)
+	    dprint (MUTT_SOCK_LOG_CMD, (debugfile,
+		    "%d> AUTHINFO PASS *\n", conn->fd));
+#endif
+	  snprintf (buf, sizeof (buf), "AUTHINFO PASS %s\r\n",
+		    conn->account.pass);
+	  if (mutt_socket_write_d (conn, buf, -1, MUTT_SOCK_LOG_FULL) < 0 ||
+	      mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+	  break;
+
+	  /* authenticated */
+	  if (!mutt_strncmp ("281", buf, 3))
+	    return 0;
+	}
+
+	/* server doesn't support AUTHINFO USER, trying next method */
+	if (*buf == '5')
+	  continue;
+      }
+
+      else
+      {
+#ifdef USE_SASL
+	sasl_conn_t *saslconn;
+	sasl_interact_t *interaction = NULL;
+	int rc;
+	char inbuf[LONG_STRING] = "";
+	const char *mech;
+	const char *client_out = NULL;
+	unsigned int client_len, len;
+
+	if (mutt_sasl_client_new (conn, &saslconn) < 0)
+	{
+	  dprint (1, (debugfile,
+		  "nntp_auth: error allocating SASL connection.\n"));
+	  continue;
+	}
+
+	while (1)
+	{
+	  rc = sasl_client_start (saslconn, method, &interaction,
+				  &client_out, &client_len, &mech);
+	  if (rc != SASL_INTERACT)
+	    break;
+	  mutt_sasl_interact (interaction);
+	}
+	if (rc != SASL_OK && rc != SASL_CONTINUE)
+	{
+	  sasl_dispose (&saslconn);
+	  dprint (1, (debugfile,
+		  "nntp_auth: error starting SASL authentication exchange.\n"));
+	  continue;
+	}
+
+	mutt_message (_("Authenticating (%s)..."), method);
+	snprintf (buf, sizeof (buf), "AUTHINFO SASL %s", method);
+
+	/* looping protocol */
+	while (rc == SASL_CONTINUE || (rc == SASL_OK && client_len))
+	{
+	  /* send out client response */
+	  if (client_len)
+	  {
+#ifdef DEBUG
+	    if (debuglevel >= MUTT_SOCK_LOG_FULL)
+	    {
+	      char tmp[LONG_STRING];
+	      memcpy (tmp, client_out, client_len);
+	      for (p = tmp; p < tmp + client_len; p++)
+	      {
+		if (*p == '\0')
+		  *p = '.';
+	      }
+	      *p = '\0';
+	      dprint (1, (debugfile, "SASL> %s\n", tmp));
+	    }
+#endif
+
+	    if (*buf)
+	      safe_strcat (buf, sizeof (buf), " ");
+	    len = strlen (buf);
+	    if (sasl_encode64 (client_out, client_len,
+		buf + len, sizeof (buf) - len, &len) != SASL_OK)
+	    {
+	      dprint (1, (debugfile,
+		      "nntp_auth: error base64-encoding client response.\n"));
+	      break;
+	    }
+	  }
+
+	  safe_strcat (buf, sizeof (buf), "\r\n");
+#ifdef DEBUG
+	  if (debuglevel < MUTT_SOCK_LOG_FULL)
+	  {
+	    if (strchr (buf, ' '))
+	      dprint (MUTT_SOCK_LOG_CMD, (debugfile, "%d> AUTHINFO SASL %s%s\n",
+		      conn->fd, method, client_len ? " sasl_data" : ""));
+	    else
+	      dprint (MUTT_SOCK_LOG_CMD, (debugfile, "%d> sasl_data\n", conn->fd));
+	  }
+#endif
+	  client_len = 0;
+	  if (mutt_socket_write_d (conn, buf, -1, MUTT_SOCK_LOG_FULL) < 0 ||
+	      mutt_socket_readln_d (inbuf, sizeof (inbuf), conn, MUTT_SOCK_LOG_FULL) < 0)
+	    break;
+	  if (mutt_strncmp (inbuf, "283 ", 4) &&
+	      mutt_strncmp (inbuf, "383 ", 4))
+	  {
+#ifdef DEBUG
+	    if (debuglevel < MUTT_SOCK_LOG_FULL)
+	      dprint (MUTT_SOCK_LOG_CMD, (debugfile, "%d< %s\n", conn->fd, inbuf));
+#endif
+	    break;
+	  }
+#ifdef DEBUG
+	  if (debuglevel < MUTT_SOCK_LOG_FULL)
+	  {
+	    inbuf[3] = '\0';
+	    dprint (MUTT_SOCK_LOG_CMD, (debugfile,
+		    "%d< %s sasl_data\n", conn->fd, inbuf));
+	  }
+#endif
+
+	  if (!strcmp ("=", inbuf + 4))
+	    len = 0;
+	  else if (sasl_decode64 (inbuf + 4, strlen (inbuf + 4),
+		   buf, sizeof (buf) - 1, &len) != SASL_OK)
+	  {
+	    dprint (1, (debugfile,
+		    "nntp_auth: error base64-decoding server response.\n"));
+	    break;
+	  }
+#ifdef DEBUG
+	  else if (debuglevel >= MUTT_SOCK_LOG_FULL)
+	  {
+	    char tmp[LONG_STRING];
+	    memcpy (tmp, buf, len);
+	    for (p = tmp; p < tmp + len; p++)
+	    {
+	      if (*p == '\0')
+		*p = '.';
+	    }
+	    *p = '\0';
+	    dprint (1, (debugfile, "SASL< %s\n", tmp));
+	  }
+#endif
+
+	  while (1)
+	  {
+	    rc = sasl_client_step (saslconn, buf, len,
+				   &interaction, &client_out, &client_len);
+	    if (rc != SASL_INTERACT)
+	      break;
+	    mutt_sasl_interact (interaction);
+	  }
+	  if (*inbuf != '3')
+	    break;
+
+	  *buf = '\0';
+	} /* looping protocol */
+
+	if (rc == SASL_OK && client_len == 0 && *inbuf == '2')
+	{
+	  mutt_sasl_setup_conn (conn, saslconn);
+	  return 0;
+	}
+
+	/* terminate SASL sessoin */
+	sasl_dispose (&saslconn);
+	if (conn->fd < 0)
+	  break;
+	if (!mutt_strncmp (inbuf, "383 ", 4))
+	{
+	  if (mutt_socket_write (conn, "*\r\n") < 0 ||
+	      mutt_socket_readln (inbuf, sizeof (inbuf), conn) < 0)
+	    break;
+	}
+
+	/* server doesn't support AUTHINFO SASL, trying next method */
+	if (*inbuf == '5')
+	  continue;
+#else
+	continue;
+#endif /* USE_SASL */
+      }
+
+      mutt_error (_("%s authentication failed."), method);
+      mutt_sleep (2);
+      break;
+    }
+    break;
+  }
+
+  /* error */
+  nserv->status = NNTP_BYE;
+  conn->account.flags = flags;
+  if (conn->fd < 0)
+  {
+    mutt_error _("Server closed connection!");
+    mutt_sleep (2);
+  }
+  else
+    mutt_socket_close (conn);
+  return -1;
+}
+
+/* Connect to server, authenticate and get capabilities */
+int nntp_open_connection (NNTP_SERVER *nserv)
+{
+  CONNECTION *conn = nserv->conn;
+  char buf[STRING];
+  int cap;
+  unsigned int posting = 0, auth = 1;
+
+  if (nserv->status == NNTP_OK)
+    return 0;
+  if (nserv->status == NNTP_BYE)
+    return -1;
+  nserv->status = NNTP_NONE;
+
+  if (mutt_socket_open (conn) < 0)
+    return -1;
+
+  if (mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+    return nntp_connect_error (nserv);
+
+  if (!mutt_strncmp ("200", buf, 3))
+    posting = 1;
+  else if (mutt_strncmp ("201", buf, 3))
+  {
+    mutt_socket_close (conn);
+    mutt_remove_trailing_ws (buf);
+    mutt_error ("%s", buf);
+    mutt_sleep (2);
+    return -1;
+  }
+
+  /* get initial capabilities */
+  cap = nntp_capabilities (nserv);
+  if (cap < 0)
+    return -1;
+
+  /* tell news server to switch to mode reader if it isn't so */
+  if (cap > 0)
+  {
+    if (mutt_socket_write (conn, "MODE READER\r\n") < 0 ||
+	mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+
+    if (!mutt_strncmp ("200", buf, 3))
+      posting = 1;
+    else if (!mutt_strncmp ("201", buf, 3))
+      posting = 0;
+    /* error if has capabilities, ignore result if no capabilities */
+    else if (nserv->hasCAPABILITIES)
+    {
+      mutt_socket_close (conn);
+      mutt_error _("Could not switch to reader mode.");
+      mutt_sleep (2);
+      return -1;
+    }
+
+    /* recheck capabilities after MODE READER */
+    if (nserv->hasCAPABILITIES)
+    {
+      cap = nntp_capabilities (nserv);
+      if (cap < 0)
+	return -1;
+    }
+  }
+
+  mutt_message (_("Connected to %s. %s"), conn->account.host,
+		posting ? _("Posting is ok.") : _("Posting is NOT ok."));
+  mutt_sleep (1);
+
+#if defined(USE_SSL)
+  /* Attempt STARTTLS if available and desired. */
+  if (nserv->use_tls != 1 && (nserv->hasSTARTTLS || option (OPTSSLFORCETLS)))
+  {
+    if (nserv->use_tls == 0)
+      nserv->use_tls = option (OPTSSLFORCETLS) ||
+			query_quadoption (OPT_SSLSTARTTLS,
+			_("Secure connection with TLS?")) == MUTT_YES ? 2 : 1;
+    if (nserv->use_tls == 2)
+    {
+      if (mutt_socket_write (conn, "STARTTLS\r\n") < 0 ||
+	  mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+	return nntp_connect_error (nserv);
+      if (mutt_strncmp ("382", buf, 3))
+      {
+	nserv->use_tls = 0;
+	mutt_error ("STARTTLS: %s", buf);
+	mutt_sleep (2);
+      }
+      else if (mutt_ssl_starttls (conn))
+      {
+	nserv->use_tls = 0;
+	nserv->status = NNTP_NONE;
+	mutt_socket_close (nserv->conn);
+	mutt_error _("Could not negotiate TLS connection");
+	mutt_sleep (2);
+	return -1;
+      }
+      else
+      {
+	/* recheck capabilities after STARTTLS */
+	cap = nntp_capabilities (nserv);
+	if (cap < 0)
+	  return -1;
+      }
+    }
+  }
+#endif
+
+  /* authentication required? */
+  if (conn->account.flags & MUTT_ACCT_USER)
+  {
+    if (!conn->account.user[0])
+      auth = 0;
+  }
+  else
+  {
+    if (mutt_socket_write (conn, "STAT\r\n") < 0 ||
+	mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+    if (mutt_strncmp ("480", buf, 3))
+      auth = 0;
+  }
+
+  /* authenticate */
+  if (auth && nntp_auth (nserv) < 0)
+      return -1;
+
+  /* get final capabilities after authentication */
+  if (nserv->hasCAPABILITIES && (auth || cap > 0))
+  {
+    cap = nntp_capabilities (nserv);
+    if (cap < 0)
+      return -1;
+    if (cap > 0)
+    {
+      mutt_socket_close (conn);
+      mutt_error _("Could not switch to reader mode.");
+      mutt_sleep (2);
+      return -1;
+    }
+  }
+
+  /* attempt features */
+  if (nntp_attempt_features (nserv) < 0)
+    return -1;
+
+  nserv->status = NNTP_OK;
+  return 0;
+}
+
+/* Send data from buffer and receive answer to same buffer */
+static int nntp_query (NNTP_DATA *nntp_data, char *line, size_t linelen)
+{
+  NNTP_SERVER *nserv = nntp_data->nserv;
+  char buf[LONG_STRING];
+
+  if (nserv->status == NNTP_BYE)
+    return -1;
+
+  while (1)
+  {
+    if (nserv->status == NNTP_OK)
+    {
+      int rc = 0;
+
+      if (*line)
+	rc = mutt_socket_write (nserv->conn, line);
+      else if (nntp_data->group)
+      {
+	snprintf (buf, sizeof (buf), "GROUP %s\r\n", nntp_data->group);
+	rc = mutt_socket_write (nserv->conn, buf);
+      }
+      if (rc >= 0)
+	rc = mutt_socket_readln (buf, sizeof (buf), nserv->conn);
+      if (rc >= 0)
+	break;
+    }
+
+    /* reconnect */
+    while (1)
+    {
+      nserv->status = NNTP_NONE;
+      if (nntp_open_connection (nserv) == 0)
+	break;
+
+      snprintf (buf, sizeof (buf), _("Connection to %s lost. Reconnect?"),
+		nserv->conn->account.host);
+      if (mutt_yesorno (buf, MUTT_YES) != MUTT_YES)
+      {
+	nserv->status = NNTP_BYE;
+	return -1;
+      }
+    }
+
+    /* select newsgroup after reconnection */
+    if (nntp_data->group)
+    {
+      snprintf (buf, sizeof (buf), "GROUP %s\r\n", nntp_data->group);
+      if (mutt_socket_write (nserv->conn, buf) < 0 ||
+	  mutt_socket_readln (buf, sizeof (buf), nserv->conn) < 0)
+	return nntp_connect_error (nserv);
+    }
+    if (!*line)
+      break;
+  }
+
+  strfcpy (line, buf, linelen);
+  return 0;
+}
+
+/* This function calls funct(*line, *data) for each received line,
+ * funct(NULL, *data) if rewind(*data) needs, exits when fail or done:
+ *  0 - success
+ *  1 - bad response (answer in query buffer)
+ * -1 - conection lost
+ * -2 - error in funct(*line, *data) */
+static int nntp_fetch_lines (NNTP_DATA *nntp_data, char *query, size_t qlen,
+			char *msg, int (*funct) (char *, void *), void *data)
+{
+  int done = FALSE;
+  int rc;
+
+  while (!done)
+  {
+    char buf[LONG_STRING];
+    char *line;
+    unsigned int lines = 0;
+    size_t off = 0;
+    progress_t progress;
+
+    if (msg)
+      mutt_progress_init (&progress, msg, MUTT_PROGRESS_MSG, ReadInc, -1);
+
+    strfcpy (buf, query, sizeof (buf));
+    if (nntp_query (nntp_data, buf, sizeof (buf)) < 0)
+      return -1;
+    if (buf[0] != '2')
+    {
+      strfcpy (query, buf, qlen);
+      return 1;
+    }
+
+    line = safe_malloc (sizeof (buf));
+    rc = 0;
+
+    while (1)
+    {
+      char *p;
+      int chunk = mutt_socket_readln_d (buf, sizeof (buf),
+		  nntp_data->nserv->conn, MUTT_SOCK_LOG_HDR);
+      if (chunk < 0)
+      {
+	nntp_data->nserv->status = NNTP_NONE;
+	break;
+      }
+
+      p = buf;
+      if (!off && buf[0] == '.')
+      {
+	if (buf[1] == '\0')
+	{
+	  done = TRUE;
+	  break;
+	}
+	if (buf[1] == '.')
+	  p++;
+      }
+
+      strfcpy (line + off, p, sizeof (buf));
+
+      if (chunk >= sizeof (buf))
+	off += strlen (p);
+      else
+      {
+	if (msg)
+	  mutt_progress_update (&progress, ++lines, -1);
+
+	if (rc == 0 && funct (line, data) < 0)
+	  rc = -2;
+	off = 0;
+      }
+
+      safe_realloc (&line, off + sizeof (buf));
+    }
+    FREE (&line);
+    funct (NULL, data);
+  }
+  return rc;
+}
+
+/* Parse newsgroup description */
+static int fetch_description (char *line, void *data)
+{
+  NNTP_SERVER *nserv = data;
+  NNTP_DATA *nntp_data;
+  char *desc;
+
+  if (!line)
+    return 0;
+
+  desc = strpbrk (line, " \t");
+  if (desc)
+  {
+    *desc++ = '\0';
+    desc += strspn (desc, " \t");
+  }
+  else
+    desc = strchr (line, '\0');
+
+  nntp_data = hash_find (nserv->groups_hash, line);
+  if (nntp_data && mutt_strcmp (desc, nntp_data->desc))
+  {
+    mutt_str_replace (&nntp_data->desc, desc);
+    dprint (2, (debugfile, "group: %s, desc: %s\n", line, desc));
+  }
+  return 0;
+}
+
+/* Fetch newsgroups descriptions.
+ * Returns the same code as nntp_fetch_lines() */
+static int get_description (NNTP_DATA *nntp_data, char *wildmat, char *msg)
+{
+  NNTP_SERVER *nserv;
+  char buf[STRING];
+  char *cmd;
+  int rc;
+
+  /* get newsgroup description, if possible */
+  nserv = nntp_data->nserv;
+  if (!wildmat)
+    wildmat = nntp_data->group;
+  if (nserv->hasLIST_NEWSGROUPS)
+    cmd = "LIST NEWSGROUPS";
+  else if (nserv->hasXGTITLE)
+    cmd = "XGTITLE";
+  else
+    return 0;
+
+  snprintf (buf, sizeof (buf), "%s %s\r\n", cmd, wildmat);
+  rc = nntp_fetch_lines (nntp_data, buf, sizeof (buf), msg,
+			 fetch_description, nserv);
+  if (rc > 0)
+  {
+    mutt_error ("%s: %s", cmd, buf);
+    mutt_sleep (2);
+  }
+  return rc;
+}
+
+/* Update read flag and set article number if empty */
+static void nntp_parse_xref (CONTEXT *ctx, HEADER *hdr)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  char *buf, *p;
+
+  buf = p = safe_strdup (hdr->env->xref);
+  while (p)
+  {
+    char *grp, *colon;
+    anum_t anum;
+
+    /* skip to next word */
+    p += strspn (p, " \t");
+    grp = p;
+
+    /* skip to end of word */
+    p = strpbrk (p, " \t");
+    if (p)
+      *p++ = '\0';
+
+    /* find colon */
+    colon = strchr (grp, ':');
+    if (!colon)
+      continue;
+    *colon++ = '\0';
+    if (sscanf (colon, ANUM, &anum) != 1)
+      continue;
+
+    nntp_article_status (ctx, hdr, grp, anum);
+    if (hdr && !NHDR (hdr)->article_num && !mutt_strcmp (nntp_data->group, grp))
+      NHDR (hdr)->article_num = anum;
+  }
+  FREE (&buf);
+}
+
+/* Write line to temporarily file */
+static int fetch_tempfile (char *line, void *data)
+{
+  FILE *fp = data;
+
+  if (!line)
+    rewind (fp);
+  else if (fputs (line, fp) == EOF || fputc ('\n', fp) == EOF)
+    return -1;
+  return 0;
+}
+
+typedef struct
+{
+  CONTEXT *ctx;
+  anum_t first;
+  anum_t last;
+  int restore;
+  unsigned char *messages;
+  progress_t progress;
+#ifdef USE_HCACHE
+  header_cache_t *hc;
+#endif
+} FETCH_CTX;
+
+/* Parse article number */
+static int fetch_numbers (char *line, void *data)
+{
+  FETCH_CTX *fc = data;
+  anum_t anum;
+
+  if (!line)
+    return 0;
+  if (sscanf (line, ANUM, &anum) != 1)
+    return 0;
+  if (anum < fc->first || anum > fc->last)
+    return 0;
+  fc->messages[anum - fc->first] = 1;
+  return 0;
+}
+
+/* Parse overview line */
+static int parse_overview_line (char *line, void *data)
+{
+  FETCH_CTX *fc = data;
+  CONTEXT *ctx = fc->ctx;
+  NNTP_DATA *nntp_data = ctx->data;
+  HEADER *hdr;
+  FILE *fp;
+  char tempfile[_POSIX_PATH_MAX];
+  char *header, *field;
+  int save = 1;
+  anum_t anum;
+
+  if (!line)
+    return 0;
+
+  /* parse article number */
+  field = strchr (line, '\t');
+  if (field)
+    *field++ = '\0';
+  if (sscanf (line, ANUM, &anum) != 1)
+    return 0;
+  dprint (2, (debugfile, "parse_overview_line: " ANUM "\n", anum));
+
+  /* out of bounds */
+  if (anum < fc->first || anum > fc->last)
+    return 0;
+
+  /* not in LISTGROUP */
+  if (!fc->messages[anum - fc->first])
+  {
+    /* progress */
+    if (!ctx->quiet)
+      mutt_progress_update (&fc->progress, anum - fc->first + 1, -1);
+    return 0;
+  }
+
+  /* convert overview line to header */
+  mutt_mktemp (tempfile, sizeof (tempfile));
+  fp = safe_fopen (tempfile, "w+");
+  if (!fp)
+    return -1;
+
+  header = nntp_data->nserv->overview_fmt;
+  while (field)
+  {
+    char *b = field;
+
+    if (*header)
+    {
+      if (strstr (header, ":full") == NULL && fputs (header, fp) == EOF)
+      {
+	fclose (fp);
+	unlink (tempfile);
+	return -1;
+      }
+      header = strchr (header, '\0') + 1;
+    }
+
+    field = strchr (field, '\t');
+    if (field)
+      *field++ = '\0';
+    if (fputs (b, fp) == EOF || fputc ('\n', fp) == EOF)
+    {
+      fclose (fp);
+      unlink (tempfile);
+      return -1;
+    }
+  }
+  rewind (fp);
+
+  /* allocate memory for headers */
+  if (ctx->msgcount >= ctx->hdrmax)
+    mx_alloc_memory (ctx);
+
+  /* parse header */
+  hdr = ctx->hdrs[ctx->msgcount] = mutt_new_header ();
+  hdr->env = mutt_read_rfc822_header (fp, hdr, 0, 0);
+  hdr->env->newsgroups = safe_strdup (nntp_data->group);
+  hdr->received = hdr->date_sent;
+  fclose (fp);
+  unlink (tempfile);
+
+#ifdef USE_HCACHE
+  if (fc->hc)
+  {
+    void *hdata;
+    char buf[16];
+
+    /* try to replace with header from cache */
+    snprintf (buf, sizeof (buf), "%d", anum);
+    hdata = mutt_hcache_fetch (fc->hc, buf, strlen);
+    if (hdata)
+    {
+      dprint (2, (debugfile,
+		  "parse_overview_line: mutt_hcache_fetch %s\n", buf));
+      mutt_free_header (&hdr);
+      ctx->hdrs[ctx->msgcount] =
+      hdr = mutt_hcache_restore (hdata, NULL);
+      FREE (&hdata);
+      hdr->data = 0;
+      hdr->read = 0;
+      hdr->old = 0;
+
+      /* skip header marked as deleted in cache */
+      if (hdr->deleted && !fc->restore)
+      {
+	if (nntp_data->bcache)
+	{
+	  dprint (2, (debugfile,
+		      "parse_overview_line: mutt_bcache_del %s\n", buf));
+	  mutt_bcache_del (nntp_data->bcache, buf);
+	}
+	save = 0;
+      }
+    }
+
+    /* not chached yet, store header */
+    else
+    {
+      dprint (2, (debugfile,
+		  "parse_overview_line: mutt_hcache_store %s\n", buf));
+      mutt_hcache_store (fc->hc, buf, hdr, 0, strlen, MUTT_GENERATE_UIDVALIDITY);
+    }
+  }
+#endif
+
+  if (save)
+  {
+    hdr->index = ctx->msgcount++;
+    hdr->read = 0;
+    hdr->old = 0;
+    hdr->deleted = 0;
+    hdr->data = safe_calloc (1, sizeof (NNTP_HEADER_DATA));
+    NHDR (hdr)->article_num = anum;
+    if (fc->restore)
+      hdr->changed = 1;
+    else
+    {
+      nntp_article_status (ctx, hdr, NULL, anum);
+      if (!hdr->read)
+	nntp_parse_xref (ctx, hdr);
+    }
+    if (anum > nntp_data->lastLoaded)
+      nntp_data->lastLoaded = anum;
+  }
+  else
+    mutt_free_header (&hdr);
+
+  /* progress */
+  if (!ctx->quiet)
+    mutt_progress_update (&fc->progress, anum - fc->first + 1, -1);
+  return 0;
+}
+
+/* Fetch headers */
+static int nntp_fetch_headers (CONTEXT *ctx, void *hc,
+			       anum_t first, anum_t last, int restore)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  FETCH_CTX fc;
+  HEADER *hdr;
+  char buf[HUGE_STRING];
+  int rc = 0;
+  int oldmsgcount = ctx->msgcount;
+  anum_t current;
+  anum_t first_over = first;
+#ifdef USE_HCACHE
+  void *hdata;
+#endif
+
+  /* if empty group or nothing to do */
+  if (!last || first > last)
+    return 0;
+
+  /* init fetch context */
+  fc.ctx = ctx;
+  fc.first = first;
+  fc.last = last;
+  fc.restore = restore;
+  fc.messages = safe_calloc (last - first + 1, sizeof (unsigned char));
+#ifdef USE_HCACHE
+  fc.hc = hc;
+#endif
+
+  /* fetch list of articles */
+  if (option (OPTLISTGROUP) && nntp_data->nserv->hasLISTGROUP &&
+      !nntp_data->deleted)
+  {
+    if (!ctx->quiet)
+      mutt_message _("Fetching list of articles...");
+    if (nntp_data->nserv->hasLISTGROUPrange)
+      snprintf (buf, sizeof (buf), "LISTGROUP %s %d-%d\r\n", nntp_data->group,
+		first, last);
+    else
+      snprintf (buf, sizeof (buf), "LISTGROUP %s\r\n", nntp_data->group);
+    rc = nntp_fetch_lines (nntp_data, buf, sizeof (buf), NULL,
+			   fetch_numbers, &fc);
+    if (rc > 0)
+    {
+      mutt_error ("LISTGROUP: %s", buf);
+      mutt_sleep (2);
+    }
+    if (rc == 0)
+    {
+      for (current = first; current <= last && rc == 0; current++)
+      {
+	if (fc.messages[current - first])
+	  continue;
+
+	snprintf (buf, sizeof (buf), "%d", current);
+	if (nntp_data->bcache)
+	{
+	  dprint (2, (debugfile,
+		      "nntp_fetch_headers: mutt_bcache_del %s\n", buf));
+	  mutt_bcache_del (nntp_data->bcache, buf);
+	}
+
+#ifdef USE_HCACHE
+	if (fc.hc)
+	{
+	  dprint (2, (debugfile,
+		      "nntp_fetch_headers: mutt_hcache_delete %s\n", buf));
+	  mutt_hcache_delete (fc.hc, buf, strlen);
+	}
+#endif
+      }
+    }
+  }
+  else
+    for (current = first; current <= last; current++)
+      fc.messages[current - first] = 1;
+
+  /* fetching header from cache or server, or fallback to fetch overview */
+  if (!ctx->quiet)
+    mutt_progress_init (&fc.progress, _("Fetching message headers..."),
+			MUTT_PROGRESS_MSG, ReadInc, last - first + 1);
+  for (current = first; current <= last && rc == 0; current++)
+  {
+    if (!ctx->quiet)
+      mutt_progress_update (&fc.progress, current - first + 1, -1);
+
+#ifdef USE_HCACHE
+    snprintf (buf, sizeof (buf), "%d", current);
+#endif
+
+    /* delete header from cache that does not exist on server */
+    if (!fc.messages[current - first])
+      continue;
+
+    /* allocate memory for headers */
+    if (ctx->msgcount >= ctx->hdrmax)
+      mx_alloc_memory (ctx);
+
+#ifdef USE_HCACHE
+    /* try to fetch header from cache */
+    hdata = mutt_hcache_fetch (fc.hc, buf, strlen);
+    if (hdata)
+    {
+      dprint (2, (debugfile,
+		  "nntp_fetch_headers: mutt_hcache_fetch %s\n", buf));
+      ctx->hdrs[ctx->msgcount] =
+      hdr = mutt_hcache_restore (hdata, NULL);
+      FREE (&hdata);
+      hdr->data = 0;
+
+      /* skip header marked as deleted in cache */
+      if (hdr->deleted && !restore)
+      {
+	mutt_free_header (&hdr);
+	if (nntp_data->bcache)
+	{
+	  dprint (2, (debugfile,
+		      "nntp_fetch_headers: mutt_bcache_del %s\n", buf));
+	  mutt_bcache_del (nntp_data->bcache, buf);
+	}
+	continue;
+      }
+
+      hdr->read = 0;
+      hdr->old = 0;
+    }
+    else
+#endif
+
+    /* don't try to fetch header from removed newsgroup */
+    if (nntp_data->deleted)
+      continue;
+
+    /* fallback to fetch overview */
+    else if (nntp_data->nserv->hasOVER || nntp_data->nserv->hasXOVER)
+      if (option (OPTLISTGROUP) && nntp_data->nserv->hasLISTGROUP)
+	break;
+      else
+	continue;
+
+    /* fetch header from server */
+    else
+    {
+      FILE *fp;
+      char tempfile[_POSIX_PATH_MAX];
+
+      mutt_mktemp (tempfile, sizeof (tempfile));
+      fp = safe_fopen (tempfile, "w+");
+      if (!fp)
+      {
+	mutt_perror (tempfile);
+	mutt_sleep (2);
+	unlink (tempfile);
+	rc = -1;
+	break;
+      }
+
+      snprintf (buf, sizeof (buf), "HEAD %d\r\n", current);
+      rc = nntp_fetch_lines (nntp_data, buf, sizeof (buf), NULL,
+			     fetch_tempfile, fp);
+      if (rc)
+      {
+	fclose (fp);
+	unlink (tempfile);
+	if (rc < 0)
+	  break;
+
+	/* invalid response */
+	if (mutt_strncmp ("423", buf, 3))
+	{
+	  mutt_error ("HEAD: %s", buf);
+	  mutt_sleep (2);
+	  break;
+	}
+
+	/* no such article */
+	if (nntp_data->bcache)
+	{
+	  snprintf (buf, sizeof (buf), "%d", current);
+	  dprint (2, (debugfile,
+		      "nntp_fetch_headers: mutt_bcache_del %s\n", buf));
+	  mutt_bcache_del (nntp_data->bcache, buf);
+	}
+	rc = 0;
+	continue;
+      }
+
+      /* parse header */
+      hdr = ctx->hdrs[ctx->msgcount] = mutt_new_header ();
+      hdr->env = mutt_read_rfc822_header (fp, hdr, 0, 0);
+      hdr->received = hdr->date_sent;
+      fclose (fp);
+      unlink (tempfile);
+    }
+
+    /* save header in context */
+    hdr->index = ctx->msgcount++;
+    hdr->read = 0;
+    hdr->old = 0;
+    hdr->deleted = 0;
+    hdr->data = safe_calloc (1, sizeof (NNTP_HEADER_DATA));
+    NHDR (hdr)->article_num = current;
+    if (restore)
+      hdr->changed = 1;
+    else
+    {
+      nntp_article_status (ctx, hdr, NULL, NHDR (hdr)->article_num);
+      if (!hdr->read)
+	nntp_parse_xref (ctx, hdr);
+    }
+    if (current > nntp_data->lastLoaded)
+      nntp_data->lastLoaded = current;
+    first_over = current + 1;
+  }
+
+  if (!option (OPTLISTGROUP) || !nntp_data->nserv->hasLISTGROUP)
+    current = first_over;
+
+  /* fetch overview information */
+  if (current <= last && rc == 0 && !nntp_data->deleted) {
+    char *cmd = nntp_data->nserv->hasOVER ? "OVER" : "XOVER";
+    snprintf (buf, sizeof (buf), "%s %d-%d\r\n", cmd, current, last);
+    rc = nntp_fetch_lines (nntp_data, buf, sizeof (buf), NULL,
+	 parse_overview_line, &fc);
+    if (rc > 0)
+    {
+      mutt_error ("%s: %s", cmd, buf);
+      mutt_sleep (2);
+    }
+  }
+
+  if (ctx->msgcount > oldmsgcount)
+    mx_update_context (ctx, ctx->msgcount - oldmsgcount);
+
+  FREE (&fc.messages);
+  if (rc != 0)
+    return -1;
+  mutt_clear_error ();
+  return 0;
+}
+
+/* Open newsgroup */
+int nntp_open_mailbox (CONTEXT *ctx)
+{
+  NNTP_SERVER *nserv;
+  NNTP_DATA *nntp_data;
+  char buf[HUGE_STRING];
+  char server[LONG_STRING];
+  char *group;
+  int rc;
+  void *hc = NULL;
+  anum_t first, last, count = 0;
+  ciss_url_t url;
+
+  strfcpy (buf, ctx->path, sizeof (buf));
+  if (url_parse_ciss (&url, buf) < 0 || !url.path ||
+     !(url.scheme == U_NNTP || url.scheme == U_NNTPS))
+  {
+    mutt_error (_("%s is an invalid newsgroup specification!"), ctx->path);
+    mutt_sleep (2);
+    return -1;
+  }
+
+  group = url.path;
+  url.path = strchr (url.path, '\0');
+  url_ciss_tostring (&url, server, sizeof (server), 0);
+  nserv = nntp_select_server (server, 1);
+  if (!nserv)
+    return -1;
+  CurrentNewsSrv = nserv;
+
+  /* find news group data structure */
+  nntp_data = hash_find (nserv->groups_hash, group);
+  if (!nntp_data)
+  {
+    nntp_newsrc_close (nserv);
+    mutt_error (_("Newsgroup %s not found on the server."), group);
+    mutt_sleep (2);
+    return -1;
+  }
+
+  mutt_bit_unset (ctx->rights, MUTT_ACL_INSERT);
+  if (!nntp_data->newsrc_ent && !nntp_data->subscribed &&
+      !option (OPTSAVEUNSUB))
+    ctx->readonly = 1;
+
+  /* select newsgroup */
+  mutt_message (_("Selecting %s..."), group);
+  buf[0] = '\0';
+  if (nntp_query (nntp_data, buf, sizeof (buf)) < 0)
+  {
+    nntp_newsrc_close (nserv);
+    return -1;
+  }
+
+  /* newsgroup not found, remove it */
+  if (!mutt_strncmp ("411", buf, 3))
+  {
+    mutt_error (_("Newsgroup %s has been removed from the server."),
+		nntp_data->group);
+    if (!nntp_data->deleted)
+    {
+      nntp_data->deleted = 1;
+      nntp_active_save_cache (nserv);
+    }
+    if (nntp_data->newsrc_ent && !nntp_data->subscribed &&
+	!option (OPTSAVEUNSUB))
+    {
+      FREE (&nntp_data->newsrc_ent);
+      nntp_data->newsrc_len = 0;
+      nntp_delete_group_cache (nntp_data);
+      nntp_newsrc_update (nserv);
+    }
+    mutt_sleep (2);
+  }
+
+  /* parse newsgroup info */
+  else {
+    if (sscanf (buf, "211 " ANUM " " ANUM " " ANUM, &count, &first, &last) != 3)
+    {
+      nntp_newsrc_close (nserv);
+      mutt_error ("GROUP: %s", buf);
+      mutt_sleep (2);
+      return -1;
+    }
+    nntp_data->firstMessage = first;
+    nntp_data->lastMessage = last;
+    nntp_data->deleted = 0;
+
+    /* get description if empty */
+    if (option (OPTLOADDESC) && !nntp_data->desc)
+    {
+      if (get_description (nntp_data, NULL, NULL) < 0)
+      {
+	nntp_newsrc_close (nserv);
+	return -1;
+      }
+      if (nntp_data->desc)
+	nntp_active_save_cache (nserv);
+    }
+  }
+
+  time (&nserv->check_time);
+  ctx->data = nntp_data;
+  // QWQ
+  // ctx->mx_close = nntp_fastclose_mailbox;
+  if (!nntp_data->bcache && (nntp_data->newsrc_ent ||
+      nntp_data->subscribed || option (OPTSAVEUNSUB)))
+    nntp_data->bcache = mutt_bcache_open (&nserv->conn->account,
+			nntp_data->group);
+
+  /* strip off extra articles if adding context is greater than $nntp_context */
+  first = nntp_data->firstMessage;
+  if (NntpContext && nntp_data->lastMessage - first + 1 > NntpContext)
+    first = nntp_data->lastMessage - NntpContext + 1;
+  nntp_data->lastLoaded = first ? first - 1 : 0;
+  count = nntp_data->firstMessage;
+  nntp_data->firstMessage = first;
+  nntp_bcache_update (nntp_data);
+  nntp_data->firstMessage = count;
+#ifdef USE_HCACHE
+  hc = nntp_hcache_open (nntp_data);
+  nntp_hcache_update (nntp_data, hc);
+#endif
+  if (!hc)
+  {
+    mutt_bit_unset (ctx->rights, MUTT_ACL_WRITE);
+    mutt_bit_unset (ctx->rights, MUTT_ACL_DELETE);
+  }
+  nntp_newsrc_close (nserv);
+  rc = nntp_fetch_headers (ctx, hc, first, nntp_data->lastMessage, 0);
+#ifdef USE_HCACHE
+  mutt_hcache_close (hc);
+#endif
+  if (rc < 0)
+    return -1;
+  nntp_data->lastLoaded = nntp_data->lastMessage;
+  nserv->newsrc_modified = 0;
+  return 0;
+}
+
+/* Fetch message */
+int nntp_fetch_message (CONTEXT *ctx, MESSAGE *msg, int msgno)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  NNTP_ACACHE *acache;
+  HEADER *hdr = ctx->hdrs[msgno];
+  char buf[_POSIX_PATH_MAX];
+  char article[16];
+  char *fetch_msg = _("Fetching message...");
+  int rc;
+
+  /* try to get article from cache */
+  acache = &nntp_data->acache[hdr->index % NNTP_ACACHE_LEN];
+  if (acache->path)
+  {
+    if (acache->index == hdr->index)
+    {
+      msg->fp = fopen (acache->path, "r");
+      if (msg->fp)
+	return 0;
+    }
+    /* clear previous entry */
+    else
+    {
+      unlink (acache->path);
+      FREE (&acache->path);
+    }
+  }
+  snprintf (article, sizeof (article), "%d", NHDR (hdr)->article_num);
+  msg->fp = mutt_bcache_get (nntp_data->bcache, article);
+  if (msg->fp)
+  {
+    if (NHDR (hdr)->parsed)
+      return 0;
+  }
+  else
+  {
+    /* don't try to fetch article from removed newsgroup */
+    if (nntp_data->deleted)
+      return -1;
+
+    /* create new cache file */
+    mutt_message (fetch_msg);
+    msg->fp = mutt_bcache_put (nntp_data->bcache, article, 1);
+    if (!msg->fp)
+    {
+      mutt_mktemp (buf, sizeof (buf));
+      acache->path = safe_strdup (buf);
+      acache->index = hdr->index;
+      msg->fp = safe_fopen (acache->path, "w+");
+      if (!msg->fp)
+      {
+	mutt_perror (acache->path);
+	unlink (acache->path);
+	FREE (&acache->path);
+	return -1;
+      }
+    }
+
+    /* fetch message to cache file */
+    snprintf (buf, sizeof (buf), "ARTICLE %s\r\n",
+	      NHDR (hdr)->article_num ? article : hdr->env->message_id);
+    rc = nntp_fetch_lines (nntp_data, buf, sizeof (buf), fetch_msg,
+			   fetch_tempfile, msg->fp);
+    if (rc)
+    {
+      safe_fclose (&msg->fp);
+      if (acache->path)
+      {
+	unlink (acache->path);
+	FREE (&acache->path);
+      }
+      if (rc > 0)
+      {
+	if (!mutt_strncmp (NHDR (hdr)->article_num ? "423" : "430", buf, 3))
+	  mutt_error (_("Article %d not found on the server."),
+		      NHDR (hdr)->article_num ? article : hdr->env->message_id);
+	else
+	  mutt_error ("ARTICLE: %s", buf);
+      }
+      return -1;
+    }
+
+    if (!acache->path)
+      mutt_bcache_commit (nntp_data->bcache, article);
+  }
+
+  /* replace envelope with new one
+   * hash elements must be updated because pointers will be changed */
+  if (ctx->id_hash && hdr->env->message_id)
+    hash_delete (ctx->id_hash, hdr->env->message_id, hdr, NULL);
+  if (ctx->subj_hash && hdr->env->real_subj)
+    hash_delete (ctx->subj_hash, hdr->env->real_subj, hdr, NULL);
+
+  mutt_free_envelope (&hdr->env);
+  hdr->env = mutt_read_rfc822_header (msg->fp, hdr, 0, 0);
+
+  if (ctx->id_hash && hdr->env->message_id)
+    hash_insert (ctx->id_hash, hdr->env->message_id, hdr, 0);
+  if (ctx->subj_hash && hdr->env->real_subj)
+    hash_insert (ctx->subj_hash, hdr->env->real_subj, hdr, 1);
+
+  /* fix content length */
+  fseek (msg->fp, 0, SEEK_END);
+  hdr->content->length = ftell (msg->fp) - hdr->content->offset;
+
+  /* this is called in mutt before the open which fetches the message,
+   * which is probably wrong, but we just call it again here to handle
+   * the problem instead of fixing it */
+  NHDR (hdr)->parsed = 1;
+  mutt_parse_mime_message (ctx, hdr);
+
+  /* these would normally be updated in mx_update_context(), but the
+   * full headers aren't parsed with overview, so the information wasn't
+   * available then */
+  if (WithCrypto)
+    hdr->security = crypt_query (hdr->content);
+
+  rewind (msg->fp);
+  mutt_clear_error();
+  return 0;
+}
+
+/* Post article */
+int nntp_post (const char *msg) {
+  NNTP_DATA *nntp_data, nntp_tmp;
+  FILE *fp;
+  char buf[LONG_STRING];
+  size_t len;
+
+  if (Context && Context->magic == MUTT_NNTP)
+    nntp_data = Context->data;
+  else
+  {
+    CurrentNewsSrv = nntp_select_server (NewsServer, 0);
+    if (!CurrentNewsSrv)
+      return -1;
+
+    nntp_data = &nntp_tmp;
+    nntp_data->nserv = CurrentNewsSrv;
+    nntp_data->group = NULL;
+  }
+
+  fp = safe_fopen (msg, "r");
+  if (!fp)
+  {
+    mutt_perror (msg);
+    return -1;
+  }
+
+  strfcpy (buf, "POST\r\n", sizeof (buf));
+  if (nntp_query (nntp_data, buf, sizeof (buf)) < 0)
+    return -1;
+  if (buf[0] != '3')
+  {
+    mutt_error (_("Can't post article: %s"), buf);
+    return -1;
+  }
+
+  buf[0] = '.';
+  buf[1] = '\0';
+  while (fgets (buf + 1, sizeof (buf) - 2, fp))
+  {
+    len = strlen (buf);
+    if (buf[len - 1] == '\n')
+    {
+      buf[len - 1] = '\r';
+      buf[len] = '\n';
+      len++;
+      buf[len] = '\0';
+    }
+    if (mutt_socket_write_d (nntp_data->nserv->conn,
+	buf[1] == '.' ? buf : buf + 1, -1, MUTT_SOCK_LOG_HDR) < 0)
+      return nntp_connect_error (nntp_data->nserv);
+  }
+  fclose (fp);
+
+  if ((buf[strlen (buf) - 1] != '\n' &&
+      mutt_socket_write_d (nntp_data->nserv->conn, "\r\n", -1, MUTT_SOCK_LOG_HDR) < 0) ||
+      mutt_socket_write_d (nntp_data->nserv->conn, ".\r\n", -1, MUTT_SOCK_LOG_HDR) < 0 ||
+      mutt_socket_readln (buf, sizeof (buf), nntp_data->nserv->conn) < 0)
+    return nntp_connect_error (nntp_data->nserv);
+  if (buf[0] != '2')
+  {
+    mutt_error (_("Can't post article: %s"), buf);
+    return -1;
+  }
+  return 0;
+}
+
+/* Save changes to .newsrc and cache */
+int nntp_sync_mailbox (CONTEXT *ctx)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  int rc, i;
+#ifdef USE_HCACHE
+  header_cache_t *hc;
+#endif
+
+  /* check for new articles */
+  nntp_data->nserv->check_time = 0;
+  rc = nntp_check_mailbox (ctx, NULL);
+  if (rc)
+    return rc;
+
+#ifdef USE_HCACHE
+  nntp_data->lastCached = 0;
+  hc = nntp_hcache_open (nntp_data);
+#endif
+
+  nntp_data->unread = ctx->unread;
+  for (i = 0; i < ctx->msgcount; i++)
+  {
+    HEADER *hdr = ctx->hdrs[i];
+    char buf[16];
+
+    snprintf (buf, sizeof (buf), "%d", NHDR (hdr)->article_num);
+    if (nntp_data->bcache && hdr->deleted)
+    {
+      dprint (2, (debugfile, "nntp_sync_mailbox: mutt_bcache_del %s\n", buf));
+      mutt_bcache_del (nntp_data->bcache, buf);
+    }
+
+#ifdef USE_HCACHE
+    if (hc && (hdr->changed || hdr->deleted))
+    {
+      if (hdr->deleted && !hdr->read)
+	nntp_data->unread--;
+      dprint (2, (debugfile, "nntp_sync_mailbox: mutt_hcache_store %s\n", buf));
+      mutt_hcache_store (hc, buf, hdr, 0, strlen, MUTT_GENERATE_UIDVALIDITY);
+    }
+#endif
+  }
+
+#ifdef USE_HCACHE
+  if (hc)
+  {
+    mutt_hcache_close (hc);
+    nntp_data->lastCached = nntp_data->lastLoaded;
+  }
+#endif
+
+  /* save .newsrc entries */
+  nntp_newsrc_gen_entries (ctx);
+  nntp_newsrc_update (nntp_data->nserv);
+  nntp_newsrc_close (nntp_data->nserv);
+  return 0;
+}
+
+/* Free up memory associated with the newsgroup context */
+int nntp_fastclose_mailbox (CONTEXT *ctx)
+{
+  NNTP_DATA *nntp_data = ctx->data, *nntp_tmp;
+
+  if (!nntp_data)
+    return 0;
+
+  nntp_acache_free (nntp_data);
+  if (!nntp_data->nserv || !nntp_data->nserv->groups_hash || !nntp_data->group)
+    return 0;
+
+  nntp_tmp = hash_find (nntp_data->nserv->groups_hash, nntp_data->group);
+  if (nntp_tmp == NULL || nntp_tmp != nntp_data)
+    nntp_data_free (nntp_data);
+  return 0;
+}
+
+/* Get date and time from server */
+int nntp_date (NNTP_SERVER *nserv, time_t *now)
+{
+  if (nserv->hasDATE)
+  {
+    NNTP_DATA nntp_data;
+    char buf[LONG_STRING];
+    struct tm tm;
+
+    nntp_data.nserv = nserv;
+    nntp_data.group = NULL;
+    strfcpy (buf, "DATE\r\n", sizeof (buf));
+    if (nntp_query (&nntp_data, buf, sizeof (buf)) < 0)
+      return -1;
+
+    if (sscanf (buf, "111 %4d%2d%2d%2d%2d%2d%*s", &tm.tm_year, &tm.tm_mon,
+		&tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec) == 6)
+    {
+      tm.tm_year -= 1900;
+      tm.tm_mon--;
+      *now = timegm (&tm);
+      if (*now >= 0)
+      {
+	dprint (1, (debugfile, "nntp_date: server time is %d\n", *now));
+	return 0;
+      }
+    }
+  }
+  time (now);
+  return 0;
+}
+
+/* Fetch list of all newsgroups from server */
+int nntp_active_fetch (NNTP_SERVER *nserv)
+{
+  NNTP_DATA nntp_data;
+  char msg[SHORT_STRING];
+  char buf[LONG_STRING];
+  unsigned int i;
+  int rc;
+
+  snprintf (msg, sizeof (msg), _("Loading list of groups from server %s..."),
+	    nserv->conn->account.host);
+  mutt_message (msg);
+  if (nntp_date (nserv, &nserv->newgroups_time) < 0)
+    return -1;
+
+  nntp_data.nserv = nserv;
+  nntp_data.group = NULL;
+  strfcpy (buf, "LIST\r\n", sizeof (buf));
+  rc = nntp_fetch_lines (&nntp_data, buf, sizeof (buf), msg,
+			 nntp_add_group, nserv);
+  if (rc)
+  {
+    if (rc > 0)
+    {
+      mutt_error ("LIST: %s", buf);
+      mutt_sleep (2);
+    }
+    return -1;
+  }
+
+  if (option (OPTLOADDESC) &&
+      get_description (&nntp_data, "*", _("Loading descriptions...")) < 0)
+    return -1;
+
+  for (i = 0; i < nserv->groups_num; i++)
+  {
+    NNTP_DATA *nntp_data = nserv->groups_list[i];
+
+    if (nntp_data && nntp_data->deleted && !nntp_data->newsrc_ent)
+    {
+      nntp_delete_group_cache (nntp_data);
+      hash_delete (nserv->groups_hash, nntp_data->group, NULL, nntp_data_free);
+      nserv->groups_list[i] = NULL;
+    }
+  }
+  nntp_active_save_cache (nserv);
+  mutt_clear_error ();
+  return 0;
+}
+
+/* Check newsgroup for new articles:
+ *  1 - new articles found
+ *  0 - no change
+ * -1 - lost connection */
+static int nntp_group_poll (NNTP_DATA *nntp_data, int update_stat)
+{
+  char buf[LONG_STRING] = "";
+  anum_t count, first, last;
+
+  /* use GROUP command to poll newsgroup */
+  if (nntp_query (nntp_data, buf, sizeof (buf)) < 0)
+    return -1;
+  if (sscanf (buf, "211 " ANUM " " ANUM " " ANUM, &count, &first, &last) != 3)
+    return 0;
+  if (first == nntp_data->firstMessage && last == nntp_data->lastMessage)
+    return 0;
+
+  /* articles have been renumbered */
+  if (last < nntp_data->lastMessage)
+  {
+    nntp_data->lastCached = 0;
+    if (nntp_data->newsrc_len)
+    {
+      safe_realloc (&nntp_data->newsrc_ent, sizeof (NEWSRC_ENTRY));
+      nntp_data->newsrc_len = 1;
+      nntp_data->newsrc_ent[0].first = 1;
+      nntp_data->newsrc_ent[0].last = 0;
+    }
+  }
+  nntp_data->firstMessage = first;
+  nntp_data->lastMessage = last;
+  if (!update_stat)
+    return 1;
+
+  /* update counters */
+  else if (!last || (!nntp_data->newsrc_ent && !nntp_data->lastCached))
+    nntp_data->unread = count;
+  else
+    nntp_group_unread_stat (nntp_data);
+  return 1;
+}
+
+/* Check current newsgroup for new articles:
+ *  MUTT_REOPENED	- articles have been renumbered or removed from server
+ *  MUTT_NEW_MAIL	- new articles found
+ *  0		- no change
+ * -1		- lost connection */
+int nntp_check_mailbox (CONTEXT *ctx, int *index_hint)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  NNTP_SERVER *nserv = nntp_data->nserv;
+  time_t now = time (NULL);
+  int i, j;
+  int rc, ret = 0;
+  void *hc = NULL;
+
+  if (nserv->check_time + NewsPollTimeout > now)
+    return 0;
+
+  mutt_message _("Checking for new messages...");
+  if (nntp_newsrc_parse (nserv) < 0)
+    return -1;
+
+  nserv->check_time = now;
+  rc = nntp_group_poll (nntp_data, 0);
+  if (rc < 0)
+  {
+    nntp_newsrc_close (nserv);
+    return -1;
+  }
+  if (rc)
+    nntp_active_save_cache (nserv);
+
+  /* articles have been renumbered, remove all headers */
+  if (nntp_data->lastMessage < nntp_data->lastLoaded)
+  {
+    for (i = 0; i < ctx->msgcount; i++)
+      mutt_free_header (&ctx->hdrs[i]);
+    ctx->msgcount = 0;
+    ctx->tagged = 0;
+
+    if (nntp_data->lastMessage < nntp_data->lastLoaded)
+    {
+      nntp_data->lastLoaded = nntp_data->firstMessage - 1;
+      if (NntpContext && nntp_data->lastMessage - nntp_data->lastLoaded >
+	  NntpContext)
+	nntp_data->lastLoaded = nntp_data->lastMessage - NntpContext;
+    }
+    ret = MUTT_REOPENED;
+  }
+
+  /* .newsrc has been externally modified */
+  if (nserv->newsrc_modified)
+  {
+    anum_t anum;
+#ifdef USE_HCACHE
+    unsigned char *messages;
+    char buf[16];
+    void *hdata;
+    HEADER *hdr;
+    anum_t first = nntp_data->firstMessage;
+
+    if (NntpContext && nntp_data->lastMessage - first + 1 > NntpContext)
+      first = nntp_data->lastMessage - NntpContext + 1;
+    messages = safe_calloc (nntp_data->lastLoaded - first + 1,
+			    sizeof (unsigned char));
+    hc = nntp_hcache_open (nntp_data);
+    nntp_hcache_update (nntp_data, hc);
+#endif
+
+    /* update flags according to .newsrc */
+    for (i = j = 0; i < ctx->msgcount; i++)
+    {
+      int flagged = 0;
+      anum = NHDR (ctx->hdrs[i])->article_num;
+
+#ifdef USE_HCACHE
+      /* check hcache for flagged and deleted flags */
+      if (hc)
+      {
+	if (anum >= first && anum <= nntp_data->lastLoaded)
+	  messages[anum - first] = 1;
+
+	snprintf (buf, sizeof (buf), "%d", anum);
+	hdata = mutt_hcache_fetch (hc, buf, strlen);
+	if (hdata)
+	{
+	  int deleted;
+
+	  dprint (2, (debugfile,
+		      "nntp_check_mailbox: mutt_hcache_fetch %s\n", buf));
+	  hdr = mutt_hcache_restore (hdata, NULL);
+	  FREE (&hdata);
+	  hdr->data = 0;
+	  deleted = hdr->deleted;
+	  flagged = hdr->flagged;
+	  mutt_free_header (&hdr);
+
+	  /* header marked as deleted, removing from context */
+	  if (deleted)
+	  {
+	    mutt_set_flag (ctx, ctx->hdrs[i], MUTT_TAG, 0);
+	    mutt_free_header (&ctx->hdrs[i]);
+	    continue;
+	  }
+	}
+      }
+#endif
+
+      if (!ctx->hdrs[i]->changed)
+      {
+	ctx->hdrs[i]->flagged = flagged;
+	ctx->hdrs[i]->read = 0;
+	ctx->hdrs[i]->old = 0;
+	nntp_article_status (ctx, ctx->hdrs[i], NULL, anum);
+	if (!ctx->hdrs[i]->read)
+	  nntp_parse_xref (ctx, ctx->hdrs[i]);
+      }
+      ctx->hdrs[j++] = ctx->hdrs[i];
+    }
+
+#ifdef USE_HCACHE
+    ctx->msgcount = j;
+
+    /* restore headers without "deleted" flag */
+    for (anum = first; anum <= nntp_data->lastLoaded; anum++)
+    {
+      if (messages[anum - first])
+	continue;
+
+      snprintf (buf, sizeof (buf), "%d", anum);
+      hdata = mutt_hcache_fetch (hc, buf, strlen);
+      if (hdata)
+      {
+	dprint (2, (debugfile,
+		    "nntp_check_mailbox: mutt_hcache_fetch %s\n", buf));
+	if (ctx->msgcount >= ctx->hdrmax)
+	  mx_alloc_memory (ctx);
+
+	ctx->hdrs[ctx->msgcount] =
+	hdr = mutt_hcache_restore (hdata, NULL);
+	FREE (&hdata);
+	hdr->data = 0;
+	if (hdr->deleted)
+	{
+	  mutt_free_header (&hdr);
+	  if (nntp_data->bcache)
+	  {
+	    dprint (2, (debugfile,
+			"nntp_check_mailbox: mutt_bcache_del %s\n", buf));
+	    mutt_bcache_del (nntp_data->bcache, buf);
+	  }
+	  continue;
+	}
+
+	ctx->msgcount++;
+	hdr->read = 0;
+	hdr->old = 0;
+	hdr->data = safe_calloc (1, sizeof (NNTP_HEADER_DATA));
+	NHDR (hdr)->article_num = anum;
+	nntp_article_status (ctx, hdr, NULL, anum);
+	if (!hdr->read)
+	  nntp_parse_xref (ctx, hdr);
+      }
+    }
+    FREE (&messages);
+#endif
+
+    nserv->newsrc_modified = 0;
+    ret = MUTT_REOPENED;
+  }
+
+  /* some headers were removed, context must be updated */
+  if (ret == MUTT_REOPENED)
+  {
+    if (ctx->subj_hash)
+      hash_destroy (&ctx->subj_hash, NULL);
+    if (ctx->id_hash)
+      hash_destroy (&ctx->id_hash, NULL);
+    mutt_clear_threads (ctx);
+
+    ctx->vcount = 0;
+    ctx->deleted = 0;
+    ctx->new = 0;
+    ctx->unread = 0;
+    ctx->flagged = 0;
+    ctx->changed = 0;
+    ctx->id_hash = NULL;
+    ctx->subj_hash = NULL;
+    mx_update_context (ctx, ctx->msgcount);
+  }
+
+  /* fetch headers of new articles */
+  if (nntp_data->lastMessage > nntp_data->lastLoaded)
+  {
+    int oldmsgcount = ctx->msgcount;
+    int quiet = ctx->quiet;
+    ctx->quiet = 1;
+#ifdef USE_HCACHE
+    if (!hc)
+    {
+      hc = nntp_hcache_open (nntp_data);
+      nntp_hcache_update (nntp_data, hc);
+    }
+#endif
+    rc = nntp_fetch_headers (ctx, hc, nntp_data->lastLoaded + 1,
+			     nntp_data->lastMessage, 0);
+    ctx->quiet = quiet;
+    if (rc >= 0)
+      nntp_data->lastLoaded = nntp_data->lastMessage;
+    if (ret == 0 && ctx->msgcount > oldmsgcount)
+      ret = MUTT_NEW_MAIL;
+  }
+
+#ifdef USE_HCACHE
+  mutt_hcache_close (hc);
+#endif
+  /* If there's an error, or we've been called from nntp_sync_mailbox() */
+  if (ret || !index_hint)
+    nntp_newsrc_close (nserv);
+  mutt_clear_error ();
+  return ret;
+}
+
+/* Check for new groups and new articles in subscribed groups:
+ *  1 - new groups found
+ *  0 - no new groups
+ * -1 - error */
+int nntp_check_new_groups (NNTP_SERVER *nserv)
+{
+  NNTP_DATA nntp_data;
+  time_t now;
+  struct tm *tm;
+  char buf[LONG_STRING];
+  char *msg = _("Checking for new newsgroups...");
+  unsigned int i;
+  int rc, update_active = FALSE;
+
+  if (!nserv || !nserv->newgroups_time)
+    return -1;
+
+  /* check subscribed newsgroups for new articles */
+  if (option (OPTSHOWNEWNEWS))
+  {
+    mutt_message _("Checking for new messages...");
+    for (i = 0; i < nserv->groups_num; i++)
+    {
+      NNTP_DATA *nntp_data = nserv->groups_list[i];
+
+      if (nntp_data && nntp_data->subscribed)
+      {
+	rc = nntp_group_poll (nntp_data, 1);
+	if (rc < 0)
+	  return -1;
+	if (rc > 0)
+	  update_active = TRUE;
+      }
+    }
+    /* select current newsgroup */
+    if (Context && Context->magic == MUTT_NNTP)
+    {
+      buf[0] = '\0';
+      if (nntp_query ((NNTP_DATA *)Context->data, buf, sizeof (buf)) < 0)
+	return -1;
+    }
+  }
+  else if (nserv->newgroups_time)
+    return 0;
+
+  /* get list of new groups */
+  mutt_message (msg);
+  if (nntp_date (nserv, &now) < 0)
+    return -1;
+  nntp_data.nserv = nserv;
+  if (Context && Context->magic == MUTT_NNTP)
+    nntp_data.group = ((NNTP_DATA *)Context->data)->group;
+  else
+    nntp_data.group = NULL;
+  i = nserv->groups_num;
+  tm = gmtime (&nserv->newgroups_time);
+  snprintf (buf, sizeof (buf), "NEWGROUPS %02d%02d%02d %02d%02d%02d GMT\r\n",
+	    tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday,
+	    tm->tm_hour, tm->tm_min, tm->tm_sec);
+  rc = nntp_fetch_lines (&nntp_data, buf, sizeof (buf), msg,
+			 nntp_add_group, nserv);
+  if (rc)
+  {
+    if (rc > 0)
+    {
+      mutt_error ("NEWGROUPS: %s", buf);
+      mutt_sleep (2);
+    }
+    return -1;
+  }
+
+  /* new groups found */
+  rc = 0;
+  if (nserv->groups_num != i)
+  {
+    nserv->newgroups_time = now;
+
+    /* loading descriptions */
+    if (option (OPTLOADDESC))
+    {
+      unsigned int count = 0;
+      progress_t progress;
+
+      mutt_progress_init (&progress, _("Loading descriptions..."),
+			  MUTT_PROGRESS_MSG, ReadInc, nserv->groups_num - i);
+      for (; i < nserv->groups_num; i++)
+      {
+	NNTP_DATA *nntp_data = nserv->groups_list[i];
+
+	if (get_description (nntp_data, NULL, NULL) < 0)
+	  return -1;
+	mutt_progress_update (&progress, ++count, -1);
+      }
+    }
+    update_active = TRUE;
+    rc = 1;
+  }
+  if (update_active)
+    nntp_active_save_cache (nserv);
+  mutt_clear_error ();
+  return rc;
+}
+
+/* Fetch article by Message-ID:
+ *  0 - success
+ *  1 - no such article
+ * -1 - error */
+int nntp_check_msgid (CONTEXT *ctx, const char *msgid)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  HEADER *hdr;
+  FILE *fp;
+  char tempfile[_POSIX_PATH_MAX];
+  char buf[LONG_STRING];
+  int rc;
+
+  mutt_mktemp (tempfile, sizeof (tempfile));
+  fp = safe_fopen (tempfile, "w+");
+  if (!fp)
+  {
+    mutt_perror (tempfile);
+    unlink (tempfile);
+    return -1;
+  }
+
+  snprintf (buf, sizeof (buf), "HEAD %s\r\n", msgid);
+  rc = nntp_fetch_lines (nntp_data, buf, sizeof (buf), NULL,
+			 fetch_tempfile, fp);
+  if (rc)
+  {
+    fclose (fp);
+    unlink (tempfile);
+    if (rc < 0)
+      return -1;
+    if (!mutt_strncmp ("430", buf, 3))
+      return 1;
+    mutt_error ("HEAD: %s", buf);
+    return -1;
+  }
+
+  /* parse header */
+  if (ctx->msgcount == ctx->hdrmax)
+    mx_alloc_memory (ctx);
+  hdr = ctx->hdrs[ctx->msgcount] = mutt_new_header ();
+  hdr->data = safe_calloc (1, sizeof (NNTP_HEADER_DATA));
+  hdr->env = mutt_read_rfc822_header (fp, hdr, 0, 0);
+  fclose (fp);
+  unlink (tempfile);
+
+  /* get article number */
+  if (hdr->env->xref)
+    nntp_parse_xref (ctx, hdr);
+  else
+  {
+    snprintf (buf, sizeof (buf), "STAT %s\r\n", msgid);
+    if (nntp_query (nntp_data, buf, sizeof (buf)) < 0)
+    {
+      mutt_free_header (&hdr);
+      return -1;
+    }
+    sscanf (buf + 4, ANUM, &NHDR (hdr)->article_num);
+  }
+
+  /* reset flags */
+  hdr->read = 0;
+  hdr->old = 0;
+  hdr->deleted = 0;
+  hdr->changed = 1;
+  hdr->received = hdr->date_sent;
+  hdr->index = ctx->msgcount++;
+  mx_update_context (ctx, 1);
+  return 0;
+}
+
+typedef struct
+{
+  CONTEXT *ctx;
+  unsigned int num;
+  unsigned int max;
+  anum_t *child;
+} CHILD_CTX;
+
+/* Parse XPAT line */
+static int fetch_children (char *line, void *data)
+{
+  CHILD_CTX *cc = data;
+  anum_t anum;
+  unsigned int i;
+
+  if (!line || sscanf (line, ANUM, &anum) != 1)
+    return 0;
+  for (i = 0; i < cc->ctx->msgcount; i++)
+    if (NHDR (cc->ctx->hdrs[i])->article_num == anum)
+      return 0;
+  if (cc->num >= cc->max)
+  {
+    cc->max *= 2;
+    safe_realloc (&cc->child, sizeof (anum_t) * cc->max);
+  }
+  cc->child[cc->num++] = anum;
+  return 0;
+}
+
+/* Fetch children of article with the Message-ID */
+int nntp_check_children (CONTEXT *ctx, const char *msgid)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  CHILD_CTX cc;
+  char buf[STRING];
+  int i, rc, quiet;
+  void *hc = NULL;
+
+  if (!nntp_data || !nntp_data->nserv)
+    return -1;
+  if (nntp_data->firstMessage > nntp_data->lastLoaded)
+    return 0;
+
+  /* init context */
+  cc.ctx = ctx;
+  cc.num = 0;
+  cc.max = 10;
+  cc.child = safe_malloc (sizeof (anum_t) * cc.max);
+
+  /* fetch numbers of child messages */
+  snprintf (buf, sizeof (buf), "XPAT References %d-%d *%s*\r\n",
+	    nntp_data->firstMessage, nntp_data->lastLoaded, msgid);
+  rc = nntp_fetch_lines (nntp_data, buf, sizeof (buf), NULL,
+			 fetch_children, &cc);
+  if (rc)
+  {
+    FREE (&cc.child);
+    if (rc > 0) {
+      if (mutt_strncmp ("500", buf, 3))
+	mutt_error ("XPAT: %s", buf);
+      else
+	mutt_error _("Unable to find child articles because server does not support XPAT command.");
+    }
+    return -1;
+  }
+
+  /* fetch all found messages */
+  quiet = ctx->quiet;
+  ctx->quiet = 1;
+#ifdef USE_HCACHE
+  hc = nntp_hcache_open (nntp_data);
+#endif
+  for (i = 0; i < cc.num; i++)
+  {
+    rc = nntp_fetch_headers (ctx, hc, cc.child[i], cc.child[i], 1);
+    if (rc < 0)
+      break;
+  }
+#ifdef USE_HCACHE
+  mutt_hcache_close (hc);
+#endif
+  ctx->quiet = quiet;
+  FREE (&cc.child);
+  return rc < 0 ? -1 : 0;
+}
+
+struct mx_ops mx_nntp_ops = {
+  .open         = nntp_open_mailbox,
+  .open_append  = NULL,
+  .close        = nntp_fastclose_mailbox,
+  .check        = nntp_check_mailbox,
+  .open_msg     = nntp_fetch_message,
+  .close_msg    = NULL,
+  .commit_msg   = NULL,
+  .open_new_msg = NULL
+};
+
diff --git a/nntp.h b/nntp.h
new file mode 100644
index 0000000..9db9ef5
--- /dev/null
+++ b/nntp.h
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 1998 Brandon Long <blong@fiction.net>
+ * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>
+ * Copyright (C) 2000-2012 Vsevolod Volkov <vvv@mutt.org.ua>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _NNTP_H_
+#define _NNTP_H_ 1
+
+#include "mutt_socket.h"
+#include "mailbox.h"
+#include "bcache.h"
+
+#if USE_HCACHE
+#include "hcache.h"
+#endif
+
+#include <time.h>
+#include <sys/types.h>
+#include <stdint.h>
+
+#define NNTP_PORT 119
+#define NNTP_SSL_PORT 563
+
+/* number of entries in article cache */
+#define NNTP_ACACHE_LEN 10
+
+/* article number type and format */
+#define anum_t uint32_t
+#define ANUM "%u"
+
+enum
+{
+  NNTP_NONE = 0,
+  NNTP_OK,
+  NNTP_BYE
+};
+
+typedef struct
+{
+  unsigned int hasCAPABILITIES : 1;
+  unsigned int hasSTARTTLS : 1;
+  unsigned int hasDATE : 1;
+  unsigned int hasLIST_NEWSGROUPS : 1;
+  unsigned int hasXGTITLE : 1;
+  unsigned int hasLISTGROUP : 1;
+  unsigned int hasLISTGROUPrange : 1;
+  unsigned int hasOVER : 1;
+  unsigned int hasXOVER : 1;
+  unsigned int use_tls : 3;
+  unsigned int status : 3;
+  unsigned int cacheable : 1;
+  unsigned int newsrc_modified : 1;
+  FILE *newsrc_fp;
+  char *newsrc_file;
+  char *authenticators;
+  char *overview_fmt;
+  off_t size;
+  time_t mtime;
+  time_t newgroups_time;
+  time_t check_time;
+  unsigned int groups_num;
+  unsigned int groups_max;
+  void **groups_list;
+  HASH *groups_hash;
+  CONNECTION *conn;
+} NNTP_SERVER;
+
+typedef struct
+{
+  anum_t first;
+  anum_t last;
+} NEWSRC_ENTRY;
+
+typedef struct
+{
+  unsigned int index;
+  char *path;
+} NNTP_ACACHE;
+
+typedef struct
+{
+  char *group;
+  char *desc;
+  anum_t firstMessage;
+  anum_t lastMessage;
+  anum_t lastLoaded;
+  anum_t lastCached;
+  anum_t unread;
+  unsigned int subscribed : 1;
+  unsigned int new : 1;
+  unsigned int allowed : 1;
+  unsigned int deleted : 1;
+  unsigned int newsrc_len;
+  NEWSRC_ENTRY *newsrc_ent;
+  NNTP_SERVER *nserv;
+  NNTP_ACACHE acache[NNTP_ACACHE_LEN];
+  body_cache_t *bcache;
+} NNTP_DATA;
+
+typedef struct
+{
+  anum_t article_num;
+  unsigned int parsed : 1;
+} NNTP_HEADER_DATA;
+
+#define NHDR(hdr) ((NNTP_HEADER_DATA*)((hdr)->data))
+
+/* internal functions */
+int nntp_add_group (char *, void *);
+int nntp_active_save_cache (NNTP_SERVER *);
+int nntp_check_new_groups (NNTP_SERVER *);
+int nntp_fastclose_mailbox (CONTEXT *);
+int nntp_open_connection (NNTP_SERVER *);
+void nntp_newsrc_gen_entries (CONTEXT *);
+void nntp_bcache_update (NNTP_DATA *);
+void nntp_article_status (CONTEXT *, HEADER *, char *, anum_t);
+void nntp_group_unread_stat (NNTP_DATA *);
+void nntp_data_free (void *);
+void nntp_acache_free (NNTP_DATA *);
+void nntp_delete_group_cache (NNTP_DATA *);
+
+/* exposed interface */
+NNTP_SERVER *nntp_select_server (char *, int);
+NNTP_DATA *mutt_newsgroup_subscribe (NNTP_SERVER *, char *);
+NNTP_DATA *mutt_newsgroup_unsubscribe (NNTP_SERVER *, char *);
+NNTP_DATA *mutt_newsgroup_catchup (NNTP_SERVER *, char *);
+NNTP_DATA *mutt_newsgroup_uncatchup (NNTP_SERVER *, char *);
+int nntp_active_fetch (NNTP_SERVER *);
+int nntp_newsrc_update (NNTP_SERVER *);
+int nntp_open_mailbox (CONTEXT *);
+int nntp_sync_mailbox (CONTEXT *);
+int nntp_check_mailbox (CONTEXT *, int*);
+int nntp_fetch_message (CONTEXT *, MESSAGE *, int);
+int nntp_post (const char *);
+int nntp_check_msgid (CONTEXT *, const char *);
+int nntp_check_children (CONTEXT *, const char *);
+int nntp_newsrc_parse (NNTP_SERVER *);
+void nntp_newsrc_close (NNTP_SERVER *);
+void nntp_buffy (char *, size_t);
+void nntp_expand_path (char *, size_t, ACCOUNT *);
+void nntp_clear_cache (NNTP_SERVER *);
+const char *nntp_format_str (char *, size_t, size_t, int, char, const char *,
+			     const char *, const char *, const char *,
+			     unsigned long, format_flag);
+
+NNTP_SERVER *CurrentNewsSrv INITVAL (NULL);
+
+#ifdef USE_HCACHE
+header_cache_t *nntp_hcache_open (NNTP_DATA *);
+void nntp_hcache_update (NNTP_DATA *, header_cache_t *);
+#endif
+
+extern struct mx_ops mx_nntp_ops;
+
+#endif /* _NNTP_H_ */
diff --git a/pager.c b/pager.c
index d7674eb..850d4b6 100644
--- a/pager.c
+++ b/pager.c
@@ -1092,6 +1092,11 @@ fill_buffer (FILE *f, LOFF_T *last_pos, LOFF_T offset, unsigned char **buf,
   return b_read;
 }
 
+#ifdef USE_NNTP
+#include "mx.h"
+#include "nntp.h"
+#endif
+
 
 static int format_line (struct line_t **lineInfo, int n, unsigned char *buf,
 			int flags, ansi_attr *pa, int cnt,
@@ -1563,6 +1568,16 @@ static const struct mapping_t PagerHelpExtra[] = {
   { NULL,	0 }
 };
 
+#ifdef USE_NNTP
+static struct mapping_t PagerNewsHelpExtra[] = {
+  { N_("Post"),     OP_POST },
+  { N_("Followup"), OP_FOLLOWUP },
+  { N_("Del"),      OP_DELETE },
+  { N_("Next"),     OP_MAIN_NEXT_UNDELETED },
+  { NULL,           0 }
+};
+#endif
+
 void mutt_clear_pager_position (void)
 {
   TopLine = 0;
@@ -1608,6 +1623,10 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
   int old_PagerIndexLines;		/* some people want to resize it
   					 * while inside the pager... */
 
+#ifdef USE_NNTP
+  char *followup_to;
+#endif
+
   if (!(flags & MUTT_SHOWCOLOR))
     flags |= MUTT_SHOWFLAT;
 
@@ -1647,7 +1666,11 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
   if (IsHeader (extra))
   {
     strfcpy (tmphelp, helpstr, sizeof (tmphelp));
-    mutt_compile_help (buffer, sizeof (buffer), MENU_PAGER, PagerHelpExtra);
+    mutt_compile_help (buffer, sizeof (buffer), MENU_PAGER,
+#ifdef USE_NNTP
+	(Context && (Context->magic == MUTT_NNTP)) ? PagerNewsHelpExtra :
+#endif
+	PagerHelpExtra);
     snprintf (helpstr, sizeof (helpstr), "%s %s", tmphelp, buffer);
   }
   if (!InHelp)
@@ -1860,13 +1883,13 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 	size_t l2 = sizeof (buffer);
 	hfi.hdr = (IsHeader (extra)) ? extra->hdr : extra->bdy->hdr;
 	mutt_make_string_info (buffer, l1 < l2 ? l1 : l2, pager_status_window->cols, NONULL (PagerFmt), &hfi, MUTT_FORMAT_MAKEPRINT);
-	mutt_paddstr (pager_status_window->cols, buffer);
+	mutt_draw_statusline (pager_status_window->cols, buffer, l2);
       }
       else
       {
 	char bn[STRING];
 	snprintf (bn, sizeof (bn), "%s (%s)", banner, pager_progress_str);
-	mutt_paddstr (pager_status_window->cols, bn);
+	mutt_draw_statusline (pager_status_window->cols, bn, sizeof (bn));
       }
       NORMAL_COLOR;
       if (option(OPTTSENABLED) && TSSupported)
@@ -2307,11 +2330,11 @@ search_next:
 	  int dretval = 0;
 	  int new_topline = topline;
 
-	  while ((new_topline < lastLine ||
+	  while (((new_topline + SkipQuotedOffset) < lastLine ||
 		  (0 == (dretval = display_line (fp, &last_pos, &lineInfo,
 			 new_topline, &lastLine, &maxLine, MUTT_TYPES | (flags & MUTT_PAGER_NOWRAP),
                          &QuoteList, &q_level, &force_redraw, &SearchRE, pager_window))))
-		 && lineInfo[new_topline].type != MT_COLOR_QUOTED)
+		 && lineInfo[new_topline + SkipQuotedOffset].type != MT_COLOR_QUOTED)
 	    new_topline++;
 
 	  if (dretval < 0)
@@ -2320,11 +2343,11 @@ search_next:
 	    break;
 	  }
 
-	  while ((new_topline < lastLine ||
+	  while (((new_topline + SkipQuotedOffset) < lastLine ||
 		  (0 == (dretval = display_line (fp, &last_pos, &lineInfo,
 			 new_topline, &lastLine, &maxLine, MUTT_TYPES | (flags & MUTT_PAGER_NOWRAP),
                          &QuoteList, &q_level, &force_redraw, &SearchRE, pager_window))))
-		 && lineInfo[new_topline].type == MT_COLOR_QUOTED)
+		 && lineInfo[new_topline + SkipQuotedOffset].type == MT_COLOR_QUOTED)
 	    new_topline++;
 
 	  if (dretval < 0)
@@ -2603,6 +2626,60 @@ search_next:
 	redraw = REDRAW_FULL;
 	break;
 
+#ifdef USE_NNTP
+      case OP_POST:
+	CHECK_MODE(IsHeader (extra) && !IsAttach (extra));
+	CHECK_ATTACH;
+	if (extra->ctx && extra->ctx->magic == MUTT_NNTP &&
+	    !((NNTP_DATA *)extra->ctx->data)->allowed &&
+	    query_quadoption (OPT_TOMODERATED,_("Posting to this group not allowed, may be moderated. Continue?")) != MUTT_YES)
+	  break;
+	ci_send_message (SENDNEWS, NULL, NULL, extra->ctx, NULL);
+	redraw = REDRAW_FULL;
+	break;
+
+      case OP_FORWARD_TO_GROUP:
+	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra));
+	CHECK_ATTACH;
+	if (extra->ctx && extra->ctx->magic == MUTT_NNTP &&
+	    !((NNTP_DATA *)extra->ctx->data)->allowed &&
+	    query_quadoption (OPT_TOMODERATED,_("Posting to this group not allowed, may be moderated. Continue?")) != MUTT_YES)
+	  break;
+	if (IsMsgAttach (extra))
+	  mutt_attach_forward (extra->fp, extra->hdr, extra->idx,
+			       extra->idxlen, extra->bdy, SENDNEWS);
+	else
+	  ci_send_message (SENDNEWS|SENDFORWARD, NULL, NULL, extra->ctx, extra->hdr);
+	redraw = REDRAW_FULL;
+	break;
+
+      case OP_FOLLOWUP:
+	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra));
+	CHECK_ATTACH;
+
+	if (IsMsgAttach (extra))
+	  followup_to = extra->bdy->hdr->env->followup_to;
+	else
+	  followup_to = extra->hdr->env->followup_to;
+
+	if (!followup_to || mutt_strcasecmp (followup_to, "poster") ||
+	    query_quadoption (OPT_FOLLOWUPTOPOSTER,_("Reply by mail as poster prefers?")) != MUTT_YES)
+	{
+	  if (extra->ctx && extra->ctx->magic == MUTT_NNTP &&
+	      !((NNTP_DATA *)extra->ctx->data)->allowed &&
+	      query_quadoption (OPT_TOMODERATED,_("Posting to this group not allowed, may be moderated. Continue?")) != MUTT_YES)
+	    break;
+	  if (IsMsgAttach (extra))
+	    mutt_attach_reply (extra->fp, extra->hdr, extra->idx,
+			       extra->idxlen, extra->bdy, SENDNEWS|SENDREPLY);
+	  else
+	    ci_send_message (SENDNEWS|SENDREPLY, NULL, NULL,
+			     extra->ctx, extra->hdr);
+	  redraw = REDRAW_FULL;
+	  break;
+	}
+#endif
+
       case OP_REPLY:
 	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra));
         CHECK_ATTACH;      
@@ -2649,7 +2726,7 @@ search_next:
         CHECK_ATTACH;
         if (IsMsgAttach (extra))
 	  mutt_attach_forward (extra->fp, extra->hdr, extra->idx,
-			       extra->idxlen, extra->bdy);
+			       extra->idxlen, extra->bdy, 0);
         else
 	  ci_send_message (SENDFORWARD, NULL, NULL, extra->ctx, extra->hdr);
 	redraw = REDRAW_FULL;
@@ -2807,6 +2884,18 @@ search_next:
 	redraw = REDRAW_FULL;
 	break;
 
+     case OP_EDIT_LABEL:
+        CHECK_MODE(IsHeader (extra));
+        rc = mutt_label_message(extra->hdr);
+        if (rc > 0) {
+          Context->changed = 1;
+          redraw = REDRAW_FULL;
+          mutt_message ("%d label%s changed.", rc, rc == 1 ? "" : "s");
+        }
+        else {
+          mutt_message _("No labels changed.");
+        }
+        break;
 
       case OP_MAIL_KEY:
         if (!(WithCrypto & APPLICATION_PGP))
diff --git a/parse.c b/parse.c
index 92cfeb0..2d5d8b9 100644
--- a/parse.c
+++ b/parse.c
@@ -94,7 +94,7 @@ char *mutt_read_rfc822_line (FILE *f, char *line, size_t *linelen)
   /* not reached */
 }
 
-static LIST *mutt_parse_references (char *s, int in_reply_to)
+LIST *mutt_parse_references (char *s, int in_reply_to)
 {
   LIST *t, *lst = NULL;
   char *m;
@@ -981,6 +981,7 @@ int mutt_parse_rfc822_line (ENVELOPE *e, HEADER *hdr, char *line, char *p, short
 {
   int matched = 0;
   LIST *last = NULL;
+  int kwtype = 0;
   
   if (lastp)
     last = *lastp;
@@ -1077,6 +1078,17 @@ int mutt_parse_rfc822_line (ENVELOPE *e, HEADER *hdr, char *line, char *p, short
       e->from = rfc822_parse_adrlist (e->from, p);
       matched = 1;
     }
+#ifdef USE_NNTP
+    else if (!mutt_strcasecmp (line+1, "ollowup-to"))
+    {
+      if (!e->followup_to)
+      {
+	mutt_remove_trailing_ws (p);
+	e->followup_to = safe_strdup (mutt_skip_whitespace (p));
+      }
+      matched = 1;
+    }
+#endif
     break;
     
     case 'i':
@@ -1087,7 +1099,14 @@ int mutt_parse_rfc822_line (ENVELOPE *e, HEADER *hdr, char *line, char *p, short
       matched = 1;
     }
     break;
-    
+
+    case 'k':
+    if (!ascii_strcasecmp (line+1, "eywords"))
+    {
+      kwtype = MUTT_KEYWORDS;
+    }
+    break;
+
     case 'l':
     if (!ascii_strcasecmp (line + 1, "ines"))
     {
@@ -1159,6 +1178,27 @@ int mutt_parse_rfc822_line (ENVELOPE *e, HEADER *hdr, char *line, char *p, short
     }
     break;
     
+#ifdef USE_NNTP
+    case 'n':
+    if (!mutt_strcasecmp (line + 1, "ewsgroups"))
+    {
+      FREE (&e->newsgroups);
+      mutt_remove_trailing_ws (p);
+      e->newsgroups = safe_strdup (mutt_skip_whitespace (p));
+      matched = 1;
+    }
+    break;
+#endif
+
+    case 'o':
+    /* field `Organization:' saves only for pager! */
+    if (!mutt_strcasecmp (line + 1, "rganization"))
+    {
+      if (!e->organization && mutt_strcasecmp (p, "unknown"))
+	e->organization = safe_strdup (p);
+    }
+    break;
+
     case 'r':
     if (!ascii_strcasecmp (line + 1, "eferences"))
     {
@@ -1267,15 +1307,35 @@ int mutt_parse_rfc822_line (ENVELOPE *e, HEADER *hdr, char *line, char *p, short
     }
     else if (ascii_strcasecmp (line+1, "-label") == 0)
     {
-      FREE(&e->x_label);
-      e->x_label = safe_strdup(p);
+      kwtype = MUTT_X_LABEL;
+    }
+    else if (!ascii_strcasecmp (line+1, "-keywords"))
+    {
+      kwtype = MUTT_X_KEYWORDS;
+    }
+    else if (!ascii_strcasecmp (line+1, "-mozilla-keys"))
+    {
+      kwtype = MUTT_X_MOZILLA_KEYS;
+    }
+#ifdef USE_NNTP
+    else if (!mutt_strcasecmp (line + 1, "-comment-to"))
+    {
+      if (!e->x_comment_to)
+	e->x_comment_to = safe_strdup (p);
       matched = 1;
     }
-    
+    else if (!mutt_strcasecmp (line + 1, "ref"))
+    {
+      if (!e->xref)
+	e->xref = safe_strdup (p);
+      matched = 1;
+    }
+#endif
+
     default:
     break;
   }
-  
+
   /* Keep track of the user-defined headers */
   if (!matched && user_hdrs)
   {
@@ -1298,12 +1358,59 @@ int mutt_parse_rfc822_line (ENVELOPE *e, HEADER *hdr, char *line, char *p, short
       rfc2047_decode (&last->data);
   }
 
+  if (kwtype)
+  {
+    char *last, *label;
+    char *text = safe_strdup(p);
+    char *sep;
+
+    if (kwtype == MUTT_KEYWORDS)
+      sep = ",";
+    else if (kwtype == MUTT_X_LABEL)
+      sep = XlabelDelim;
+    else
+      sep = " ";
+
+    rfc2047_decode(&text);
+    if (sep == NULL || *sep == '\0')
+    {
+      SKIPWS(text);
+      if (!mutt_find_list(e->labels, text))
+      {
+        if (e->labels)
+          mutt_add_list(e->labels, text);
+        else
+        {
+          e->labels = mutt_new_list();
+          e->labels->data = safe_strdup(text);
+        }
+      }
+    }
+    else for (label = strtok_r(text, sep, &last); label;
+              label = strtok_r(NULL, sep, &last))
+    {
+      SKIPWS(label);
+      if (mutt_find_list(e->labels, label))
+        continue;
+      if (e->labels)
+        mutt_add_list(e->labels, label);
+      else
+      {
+        e->labels = mutt_new_list();
+        e->labels->data = safe_strdup(label);
+      }
+    }
+    e->kwtypes |= kwtype;
+    kwtype = 0;
+    matched = 1;
+  }
+
   done:
   
   *lastp = last;
   return matched;
 }
-  
+
   
 /* mutt_read_rfc822_header() -- parses a RFC822 header
  *
@@ -1441,7 +1548,6 @@ ENVELOPE *mutt_read_rfc822_header (FILE *f, HEADER *hdr, short user_hdrs,
     rfc2047_decode_adrlist (e->mail_followup_to);
     rfc2047_decode_adrlist (e->return_path);
     rfc2047_decode_adrlist (e->sender);
-    rfc2047_decode (&e->x_label);
 
     if (e->subject)
     {
diff --git a/patchlist.sh b/patchlist.sh
index 2914b87..d2dab1f 100755
--- a/patchlist.sh
+++ b/patchlist.sh
@@ -29,7 +29,7 @@ void mutt_print_patchlist (void)
 {
 EOF
 
-list_patches | while read patch ; do
+cat - | while read patch ; do
 	echo "  puts (\"${patch}\");"
 done
 
diff --git a/pattern.c b/pattern.c
index 85d38b5..0a3315c 100644
--- a/pattern.c
+++ b/pattern.c
@@ -42,6 +42,10 @@
 #include "imap/imap.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 static int eat_regexp (pattern_t *pat, BUFFER *, BUFFER *);
 static int eat_date (pattern_t *pat, BUFFER *, BUFFER *);
 static int eat_range (pattern_t *pat, BUFFER *, BUFFER *);
@@ -92,9 +96,15 @@ Flags[] =
   { 'U', MUTT_UNREAD,		0,		NULL },
   { 'v', MUTT_COLLAPSED,		0,		NULL },
   { 'V', MUTT_CRYPT_VERIFIED,	0,		NULL },
+#ifdef USE_NNTP
+  { 'w', MUTT_NEWSGROUPS,		0,		eat_regexp },
+#endif
   { 'x', MUTT_REFERENCE,		0,		eat_regexp },
   { 'X', MUTT_MIMEATTACH,		0,		eat_range },
   { 'y', MUTT_XLABEL,		0,		eat_regexp },
+#ifdef USE_NOTMUCH
+  { 'Y', MUTT_NOTMUCH_LABEL,	0,		eat_regexp },
+#endif
   { 'z', MUTT_SIZE,		0,		eat_range },
   { '=', MUTT_DUPLICATED,		0,		NULL },
   { '$', MUTT_UNREFERENCED,	0,		NULL },
@@ -144,16 +154,21 @@ int mutt_which_case (const char *s)
 static int
 msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
 {
-  char tempfile[_POSIX_PATH_MAX];
   MESSAGE *msg = NULL;
   STATE s;
-  struct stat st;
   FILE *fp = NULL;
   long lng = 0;
   int match = 0;
   HEADER *h = ctx->hdrs[msgno];
   char *buf;
   size_t blen;
+#ifdef USE_FMEMOPEN
+  char *temp;
+  size_t tempsize;
+#else
+  char tempfile[_POSIX_PATH_MAX];
+  struct stat st;
+#endif
 
   if ((msg = mx_open_message (ctx, msgno)) != NULL)
   {
@@ -163,12 +178,20 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
       memset (&s, 0, sizeof (s));
       s.fpin = msg->fp;
       s.flags = MUTT_CHARCONV;
+#ifdef USE_FMEMOPEN
+      s.fpout = open_memstream (&temp, &tempsize);
+      if (!s.fpout) {
+	mutt_perror ("Error opening memstream");
+	return 0;
+      }
+#else
       mutt_mktemp (tempfile, sizeof (tempfile));
       if ((s.fpout = safe_fopen (tempfile, "w+")) == NULL)
       {
 	mutt_perror (tempfile);
 	return (0);
       }
+#endif
 
       if (pat->op != MUTT_BODY)
 	mutt_copy_header (msg->fp, h, s.fpout, CH_FROM | CH_DECODE, NULL);
@@ -184,7 +207,11 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
 	  if (s.fpout)
 	  {
 	    safe_fclose (&s.fpout);
+#ifdef USE_FMEMOPEN
+            FREE(&temp);
+#else
 	    unlink (tempfile);
+#endif
 	  }
 	  return (0);
 	}
@@ -193,11 +220,30 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
 	mutt_body_handler (h->content, &s);
       }
 
+#ifdef USE_FMEMOPEN
+      fclose (s.fpout);
+      lng = tempsize;
+
+      if (tempsize) {
+        fp = fmemopen (temp, tempsize, "r");
+        if (!fp) {
+          mutt_perror ("Error re-opening memstream");
+          return 0;
+        }
+      } else { /* fmemopen cannot handle empty buffers */
+        fp = safe_fopen ("/dev/null", "r");
+        if (!fp) {
+          mutt_perror ("Error opening /dev/null");
+          return 0;
+        }
+      }
+#else
       fp = s.fpout;
       fflush (fp);
       fseek (fp, 0, 0);
       fstat (fileno (fp), &st);
       lng = (long) st.st_size;
+#endif
     }
     else
     {
@@ -244,7 +290,12 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
     if (option (OPTTHOROUGHSRC))
     {
       safe_fclose (&fp);
+#ifdef USE_FMEMOPEN
+      if (tempsize)
+        FREE(&temp);
+#else
       unlink (tempfile);
+#endif
     }
   }
 
@@ -1209,7 +1260,27 @@ mutt_pattern_exec (struct pattern_t *pat, pattern_exec_flag flags, CONTEXT *ctx,
        break;
      return (pat->not ^ ((h->security & APPLICATION_PGP) && (h->security & PGPKEY)));
     case MUTT_XLABEL:
+      {
+        LIST *label;
+        int result = 0;
+        for (label = h->env->labels; label; label = label->next)
+        {
+          if (label->data == NULL)
+            continue;
+          result = patmatch (pat, label->data) == 0;
+          if (result)
+            break;
+        }
+        return pat->not ^ result;
+      }
       return (pat->not ^ (h->env->x_label && patmatch (pat, h->env->x_label) == 0));
+#ifdef USE_NOTMUCH
+    case MUTT_NOTMUCH_LABEL:
+      {
+      char *tags = nm_header_get_tags(h);
+      return (pat->not ^ (tags && patmatch (pat, tags) == 0));
+      }
+#endif
     case MUTT_HORMEL:
       return (pat->not ^ (h->env->spam && h->env->spam->data && patmatch (pat, h->env->spam->data) == 0));
     case MUTT_DUPLICATED:
@@ -1222,6 +1293,10 @@ mutt_pattern_exec (struct pattern_t *pat, pattern_exec_flag flags, CONTEXT *ctx,
       }
     case MUTT_UNREFERENCED:
       return (pat->not ^ (h->thread && !h->thread->child));
+#ifdef USE_NNTP
+    case MUTT_NEWSGROUPS:
+      return (pat->not ^ (h->env->newsgroups && patmatch (pat, h->env->newsgroups) == 0));
+#endif
   }
   mutt_error (_("error: unknown op %d (report this error)."), pat->op);
   return (-1);
@@ -1294,6 +1369,76 @@ void mutt_check_simple (char *s, size_t len, const char *simple)
   }
 }
 
+/**
+ * top_of_thread - Find the first email in the current thread
+ * @h: Header of current email
+ *
+ * Returns:
+ *  THREAD*: success, email found
+ *  NULL:    on error
+ */
+static THREAD *
+top_of_thread (HEADER *h)
+{
+  THREAD *t;
+
+  if (!h)
+    return NULL;
+
+  t = h->thread;
+
+  while (t && t->parent)
+    t = t->parent;
+
+  return t;
+}
+
+/**
+ * mutt_limit_current_thread - Limit the email view to the current thread
+ * @h: Header of current email
+ *
+ * Returns:
+ *  1: Success
+ *  0: Failure
+ */
+int
+mutt_limit_current_thread (HEADER *h)
+{
+  int i;
+  THREAD *me;
+
+  if (!h)
+    return 0;
+
+  me = top_of_thread (h);
+  if (!me)
+    return 0;
+
+  Context->vcount    = 0;
+  Context->vsize     = 0;
+  Context->collapsed = 0;
+
+  for (i = 0; i < Context->msgcount; i++)
+  {
+    Context->hdrs[i]->virtual    = -1;
+    Context->hdrs[i]->limited    = 0;
+    Context->hdrs[i]->collapsed  = 0;
+    Context->hdrs[i]->num_hidden = 0;
+
+    if (top_of_thread (Context->hdrs[i]) == me)
+    {
+      BODY *body = Context->hdrs[i]->content;
+
+      Context->hdrs[i]->virtual = Context->vcount;
+      Context->hdrs[i]->limited = 1;
+      Context->v2r[Context->vcount] = i;
+      Context->vcount++;
+      Context->vsize += (body->length + body->offset - body->hdr_offset);
+    }
+  }
+  return 1;
+}
+
 int mutt_pattern_func (int op, char *prompt)
 {
   pattern_t *pat;
@@ -1303,6 +1448,7 @@ int mutt_pattern_func (int op, char *prompt)
   progress_t progress;
 
   strfcpy (buf, NONULL (Context->pattern), sizeof (buf));
+  if (prompt || op != MUTT_LIMIT)
   if (mutt_get_field (prompt, buf, sizeof (buf), MUTT_PATTERN | MUTT_CLEAR) != 0 || !buf[0])
     return (-1);
 
diff --git a/po/POTFILES.in b/po/POTFILES.in
index 2d01add..1e499ec 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -8,6 +8,7 @@ charset.c
 color.c
 commands.c
 compose.c
+compress.c
 crypt-gpgme.c
 crypt.c
 cryptglue.c
@@ -46,6 +47,8 @@ mutt_ssl_gnutls.c
 mutt_tunnel.c
 muttlib.c
 mx.c
+newsrc.c
+nntp.c
 pager.c
 parse.c
 pattern.c
diff --git a/po/de.po b/po/de.po
index f0d7589..f60217f 100644
--- a/po/de.po
+++ b/po/de.po
@@ -2,7 +2,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: 1.5.20\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2016-08-17 20:11-0700\n"
+"POT-Creation-Date: 2016-07-06 10:39-0700\n"
 "PO-Revision-Date: 2008-05-18 10:28+0200\n"
 "Last-Translator: Rocco Rutte <pdmef@gmx.net>\n"
 "Language-Team: German <mutt-po@mutt.org>\n"
@@ -21,16 +21,16 @@ msgstr "Username bei %s: "
 msgid "Password for %s@%s: "
 msgstr "Passwort fr %s@%s: "
 
-#: addrbook.c:37 browser.c:46 pager.c:1553 postpone.c:41 query.c:48
+#: addrbook.c:37 browser.c:46 pager.c:1532 postpone.c:41 query.c:48
 #: recvattach.c:53
 msgid "Exit"
 msgstr "Verlassen"
 
-#: addrbook.c:38 curs_main.c:487 pager.c:1560 postpone.c:42
+#: addrbook.c:38 curs_main.c:482 pager.c:1539 postpone.c:42
 msgid "Del"
 msgstr "Lsch."
 
-#: addrbook.c:39 curs_main.c:488 postpone.c:43
+#: addrbook.c:39 curs_main.c:483 postpone.c:43
 msgid "Undel"
 msgstr "Behalten"
 
@@ -38,9 +38,9 @@ msgstr "Behalten"
 msgid "Select"
 msgstr "Auswhlen"
 
-#: addrbook.c:41 browser.c:49 compose.c:96 crypt-gpgme.c:4023 curs_main.c:493
-#: mutt_ssl.c:1084 mutt_ssl_gnutls.c:1003 pager.c:1656 pgpkey.c:523
-#: postpone.c:44 query.c:53 recvattach.c:57 smime.c:440
+#: addrbook.c:41 browser.c:49 compose.c:96 crypt-gpgme.c:4022 curs_main.c:488
+#: mutt_ssl.c:1049 mutt_ssl_gnutls.c:1003 pager.c:1631 pgpkey.c:522
+#: postpone.c:44 query.c:53 recvattach.c:57 smime.c:439
 msgid "Help"
 msgstr "Hilfe"
 
@@ -84,8 +84,8 @@ msgstr "Name: "
 msgid "[%s = %s] Accept?"
 msgstr "[%s = %s] Eintragen?"
 
-#: alias.c:347 recvattach.c:441 recvattach.c:467 recvattach.c:480
-#: recvattach.c:493 recvattach.c:523
+#: alias.c:347 recvattach.c:440 recvattach.c:466 recvattach.c:479
+#: recvattach.c:492 recvattach.c:522
 msgid "Save to file: "
 msgstr "Speichern in Datei: "
 
@@ -110,8 +110,8 @@ msgstr "Namensschema kann nicht erf
 msgid "Mailcap compose entry requires %%s"
 msgstr "\"compose\"-Eintrag in der Mailcap-Datei erfordert %%s."
 
-#: attach.c:134 attach.c:266 commands.c:223 compose.c:1208 curs_lib.c:204
-#: curs_lib.c:723
+#: attach.c:134 attach.c:266 commands.c:223 compose.c:1207 curs_lib.c:196
+#: curs_lib.c:569
 #, c-format
 msgid "Error running \"%s\"!"
 msgstr "Fehler beim Ausfhren von \"%s\"!"
@@ -176,8 +176,8 @@ msgstr "---Anhang: %s: %s"
 msgid "---Attachment: %s"
 msgstr "---Anhang: %s"
 
-#: attach.c:631 attach.c:663 attach.c:958 attach.c:1016 handler.c:1363
-#: pgpkey.c:572 pgpkey.c:761
+#: attach.c:631 attach.c:663 attach.c:958 attach.c:1016 handler.c:1362
+#: pgpkey.c:571 pgpkey.c:760
 msgid "Can't create filter"
 msgstr "Kann Filter nicht erzeugen"
 
@@ -197,155 +197,155 @@ msgstr "Verzeichnis"
 msgid "Mask"
 msgstr "Maske"
 
-#: browser.c:425 browser.c:1091
+#: browser.c:400 browser.c:1055
 #, c-format
 msgid "%s is not a directory."
 msgstr "%s ist kein Verzeichnis."
 
-#: browser.c:573
+#: browser.c:539
 #, c-format
 msgid "Mailboxes [%d]"
 msgstr "Mailbox-Dateien [%d]"
 
-#: browser.c:580
+#: browser.c:546
 #, c-format
 msgid "Subscribed [%s], File mask: %s"
 msgstr "Abonniert [%s], Dateimaske: %s"
 
-#: browser.c:584
+#: browser.c:550
 #, c-format
 msgid "Directory [%s], File mask: %s"
 msgstr "Verzeichnis [%s], Dateimaske: %s"
 
-#: browser.c:596
+#: browser.c:562
 msgid "Can't attach a directory!"
 msgstr "Verzeichnisse knnen nicht angehngt werden!"
 
-#: browser.c:735 browser.c:1159 browser.c:1257
+#: browser.c:701 browser.c:1123 browser.c:1221
 msgid "No files match the file mask"
 msgstr "Es gibt keine zur Maske passenden Dateien"
 
-#: browser.c:939
+#: browser.c:905
 msgid "Create is only supported for IMAP mailboxes"
 msgstr "Es knnen nur IMAP Mailboxen erzeugt werden"
 
-#: browser.c:963
+#: browser.c:929
 msgid "Rename is only supported for IMAP mailboxes"
 msgstr "Es knnen nur IMAP Mailboxen umbenannt werden"
 
-#: browser.c:986
+#: browser.c:952
 msgid "Delete is only supported for IMAP mailboxes"
 msgstr "Es knnen nur IMAP Mailboxen gelscht werden"
 
-#: browser.c:996
+#: browser.c:962
 msgid "Cannot delete root folder"
 msgstr "Kann Wurzel-Mailbox nicht lschen"
 
-#: browser.c:999
+#: browser.c:965
 #, c-format
 msgid "Really delete mailbox \"%s\"?"
 msgstr "Mailbox \"%s\" wirklich lschen?"
 
-#: browser.c:1015
+#: browser.c:979
 msgid "Mailbox deleted."
 msgstr "Mailbox gelscht."
 
-#: browser.c:1021
+#: browser.c:985
 msgid "Mailbox not deleted."
 msgstr "Mailbox nicht gelscht."
 
-#: browser.c:1040
+#: browser.c:1004
 msgid "Chdir to: "
 msgstr "Verzeichnis wechseln nach: "
 
-#: browser.c:1079 browser.c:1152
+#: browser.c:1043 browser.c:1116
 msgid "Error scanning directory."
 msgstr "Fehler beim Einlesen des Verzeichnisses."
 
-#: browser.c:1103
+#: browser.c:1067
 msgid "File Mask: "
 msgstr "Dateimaske: "
 
-#: browser.c:1175
+#: browser.c:1139
 msgid "Reverse sort by (d)ate, (a)lpha, si(z)e or do(n)'t sort? "
 msgstr ""
 "Sortiere umgekehrt nach (D)atum, (a)lphabetisch, (G)re, oder (n)icht? "
 
-#: browser.c:1176
+#: browser.c:1140
 msgid "Sort by (d)ate, (a)lpha, si(z)e or do(n)'t sort? "
 msgstr "Sortiere nach (D)atum, (a)lphabetisch, (G)re oder (n)icht?"
 
-#: browser.c:1177
+#: browser.c:1141
 msgid "dazn"
 msgstr "dagn"
 
-#: browser.c:1244
+#: browser.c:1208
 msgid "New file name: "
 msgstr "Neuer Dateiname: "
 
-#: browser.c:1275
+#: browser.c:1239
 msgid "Can't view a directory"
 msgstr "Verzeichnisse knnen nicht angezeigt werden."
 
-#: browser.c:1292
+#: browser.c:1256
 msgid "Error trying to view file"
 msgstr "Fehler bei der Anzeige einer Datei"
 
-#: buffy.c:607
+#: buffy.c:504
 msgid "New mail in "
 msgstr "Neue Nachrichten in "
 
-#: color.c:339
+#: color.c:328
 #, c-format
 msgid "%s: color not supported by term"
 msgstr "%s: color wird nicht vom Terminal untersttzt."
 
-#: color.c:345
+#: color.c:334
 #, c-format
 msgid "%s: no such color"
 msgstr "%s: Farbe unbekannt."
 
-#: color.c:409 color.c:615 color.c:626
+#: color.c:398 color.c:604 color.c:615
 #, c-format
 msgid "%s: no such object"
 msgstr "%s: Objekt unbekannt."
 
-#: color.c:422
+#: color.c:411
 #, c-format
 msgid "%s: command valid only for index, body, header objects"
 msgstr "%s: Kommando ist nur fr Index-/Body-/Header-Objekt gltig."
 
-#: color.c:430
+#: color.c:419
 #, c-format
 msgid "%s: too few arguments"
 msgstr "%s: Zu wenige Parameter."
 
-#: color.c:603
+#: color.c:592
 msgid "Missing arguments."
 msgstr "Fehlende Parameter."
 
-#: color.c:642 color.c:653
+#: color.c:631 color.c:642
 msgid "color: too few arguments"
 msgstr "color: Zu wenige Parameter."
 
-#: color.c:676
+#: color.c:665
 msgid "mono: too few arguments"
 msgstr "mono: Zu wenige Parameter."
 
-#: color.c:696
+#: color.c:685
 #, c-format
 msgid "%s: no such attribute"
 msgstr "%s: Attribut unbekannt."
 
-#: color.c:736 hook.c:69 hook.c:77 keymap.c:921
+#: color.c:725 hook.c:69 hook.c:77 keymap.c:921
 msgid "too few arguments"
 msgstr "Zu wenige Parameter."
 
-#: color.c:745 hook.c:83
+#: color.c:734 hook.c:83
 msgid "too many arguments"
 msgstr "Zu viele Parameter."
 
-#: color.c:761
+#: color.c:750
 msgid "default colors not supported"
 msgstr "Standard-Farben werden nicht untersttzt."
 
@@ -353,7 +353,7 @@ msgstr "Standard-Farben werden nicht unterst
 msgid "Verify PGP signature?"
 msgstr "PGP-Signatur berprfen?"
 
-#: commands.c:115 mbox.c:864
+#: commands.c:115 mbox.c:786
 msgid "Could not create temporary file!"
 msgstr "Konnte keine Temporrdatei erzeugen!"
 
@@ -500,65 +500,65 @@ msgstr "danbefugwp"
 msgid "Shell command: "
 msgstr "Shell-Kommando: "
 
-#: commands.c:742
+#: commands.c:741
 #, c-format
 msgid "Decode-save%s to mailbox"
 msgstr "Speichere%s dekodiert in Mailbox"
 
-#: commands.c:743
+#: commands.c:742
 #, c-format
 msgid "Decode-copy%s to mailbox"
 msgstr "Kopiere%s dekodiert in Mailbox"
 
-#: commands.c:744
+#: commands.c:743
 #, c-format
 msgid "Decrypt-save%s to mailbox"
 msgstr "Speichere%s entschlsselt in Mailbox"
 
-#: commands.c:745
+#: commands.c:744
 #, c-format
 msgid "Decrypt-copy%s to mailbox"
 msgstr "Kopiere%s entschlsselt in Mailbox"
 
-#: commands.c:746
+#: commands.c:745
 #, c-format
 msgid "Save%s to mailbox"
 msgstr "Speichere%s in Mailbox"
 
-#: commands.c:746
+#: commands.c:745
 #, c-format
 msgid "Copy%s to mailbox"
 msgstr "Kopiere%s in Mailbox"
 
-#: commands.c:747
+#: commands.c:746
 msgid " tagged"
 msgstr " ausgewhlte"
 
-#: commands.c:820
+#: commands.c:819
 #, c-format
 msgid "Copying to %s..."
 msgstr "Kopiere nach %s..."
 
-#: commands.c:936
+#: commands.c:935
 #, c-format
 msgid "Convert to %s upon sending?"
 msgstr "Konvertiere beim Senden nach %s?"
 
-#: commands.c:946
+#: commands.c:945
 #, c-format
 msgid "Content-Type changed to %s."
 msgstr "Content-Type in %s abgendert."
 
-#: commands.c:951
+#: commands.c:950
 #, c-format
 msgid "Character set changed to %s; %s."
 msgstr "Zeichensatz in %s abgendert; %s."
 
-#: commands.c:953
+#: commands.c:952
 msgid "not converting"
 msgstr "nicht konvertiert"
 
-#: commands.c:953
+#: commands.c:952
 msgid "converting"
 msgstr "konvertiert"
 
@@ -570,11 +570,11 @@ msgstr "Es sind keine Anh
 msgid "Send"
 msgstr "Absenden"
 
-#: compose.c:90 remailer.c:484
+#: compose.c:90 remailer.c:481
 msgid "Abort"
 msgstr "Verwerfen"
 
-#: compose.c:94 compose.c:686
+#: compose.c:94 compose.c:685
 msgid "Attach file"
 msgstr "Datei anhngen"
 
@@ -622,8 +622,7 @@ msgid " (OppEnc mode)"
 msgstr ""
 
 #: compose.c:153 compose.c:157
-#, fuzzy
-msgid "sign as: "
+msgid " sign as: "
 msgstr " signiere als: "
 
 #: compose.c:153 compose.c:157
@@ -634,144 +633,139 @@ msgstr "<Voreinstellung>"
 msgid "Encrypt with: "
 msgstr "Verschlsseln mit: "
 
-#. L10N: "Mix" refers to the MixMaster chain for anonymous email
-#: compose.c:179
-msgid "Mix: "
-msgstr ""
-
-#: compose.c:219
+#: compose.c:218
 #, c-format
 msgid "%s [#%d] no longer exists!"
 msgstr "%s [#%d] existiert nicht mehr!"
 
-#: compose.c:227
+#: compose.c:226
 #, c-format
 msgid "%s [#%d] modified. Update encoding?"
 msgstr "%s [#%d] wurde verndert. Kodierung neu bestimmen?"
 
-#: compose.c:270
+#: compose.c:269
 msgid "-- Attachments"
 msgstr "-- Anhnge"
 
-#: compose.c:298
+#: compose.c:297
 #, c-format
 msgid "Warning: '%s' is a bad IDN."
 msgstr "Warnung: '%s' ist eine ungltige IDN."
 
-#: compose.c:321
+#: compose.c:320
 msgid "You may not delete the only attachment."
 msgstr "Der einzige Nachrichtenteil kann nicht gelscht werden."
 
-#: compose.c:614 send.c:1681
+#: compose.c:613 send.c:1681
 #, c-format
 msgid "Bad IDN in \"%s\": '%s'"
 msgstr "Ungltige IDN in \"%s\": '%s'"
 
-#: compose.c:702
+#: compose.c:701
 msgid "Attaching selected files..."
 msgstr "Hnge ausgewhlte Dateien an..."
 
-#: compose.c:714
+#: compose.c:713
 #, c-format
 msgid "Unable to attach %s!"
 msgstr "Kann %s nicht anhngen!"
 
-#: compose.c:733
+#: compose.c:732
 msgid "Open mailbox to attach message from"
 msgstr "Mailbox, aus der angehngt werden soll"
 
-#: compose.c:763
+#: compose.c:762
 #, fuzzy, c-format
 msgid "Unable to open mailbox %s"
 msgstr "Kann Mailbox nicht fr exklusiven Zugriff sperren!"
 
-#: compose.c:771
+#: compose.c:770
 msgid "No messages in that folder."
 msgstr "Keine Nachrichten in diesem Ordner."
 
-#: compose.c:780
+#: compose.c:779
 msgid "Tag the messages you want to attach!"
 msgstr "Bitte markieren Sie die Nachrichten, die Sie anhngen wollen!"
 
-#: compose.c:812
+#: compose.c:811
 msgid "Unable to attach!"
 msgstr "Kann nicht anhngen!"
 
-#: compose.c:863
+#: compose.c:862
 msgid "Recoding only affects text attachments."
 msgstr "ndern der Kodierung betrifft nur Textanhnge."
 
-#: compose.c:868
+#: compose.c:867
 msgid "The current attachment won't be converted."
 msgstr "Der aktuelle Anhang wird nicht konvertiert werden."
 
-#: compose.c:870
+#: compose.c:869
 msgid "The current attachment will be converted."
 msgstr "Der aktuelle Anhang wird konvertiert werden."
 
-#: compose.c:945
+#: compose.c:944
 msgid "Invalid encoding."
 msgstr "Ungltige Kodierung."
 
-#: compose.c:971
+#: compose.c:970
 msgid "Save a copy of this message?"
 msgstr "Soll eine Kopie dieser Nachricht gespeichert werden?"
 
-#: compose.c:1027
+#: compose.c:1026
 msgid "Rename to: "
 msgstr "Umbenennen in: "
 
 #. L10N:
 #. "stat" is a system call. Do "man 2 stat" for more information.
-#: compose.c:1034 editmsg.c:96 editmsg.c:121 sendlib.c:872
+#: compose.c:1033 editmsg.c:96 editmsg.c:121 sendlib.c:872
 #, c-format
 msgid "Can't stat %s: %s"
 msgstr "Kann Verzeichniseintrag fr Datei %s nicht lesen: %s"
 
-#: compose.c:1061
+#: compose.c:1060
 msgid "New file: "
 msgstr "Neue Datei: "
 
-#: compose.c:1074
+#: compose.c:1073
 msgid "Content-Type is of the form base/sub"
 msgstr "Content-Type ist von der Form Basis/Untertyp."
 
-#: compose.c:1080
+#: compose.c:1079
 #, c-format
 msgid "Unknown Content-Type %s"
 msgstr "Unbekannter Content-Type %s."
 
-#: compose.c:1093
+#: compose.c:1092
 #, c-format
 msgid "Can't create file %s"
 msgstr "Kann Datei %s nicht anlegen."
 
-#: compose.c:1101
+#: compose.c:1100
 msgid "What we have here is a failure to make an attachment"
 msgstr "Anhang kann nicht erzeugt werden."
 
-#: compose.c:1162
+#: compose.c:1161
 msgid "Postpone this message?"
 msgstr "Nachricht zurckstellen?"
 
-#: compose.c:1226
+#: compose.c:1225
 msgid "Write message to mailbox"
 msgstr "Schreibe Nachricht in Mailbox"
 
-#: compose.c:1229
+#: compose.c:1228
 #, c-format
 msgid "Writing message to %s ..."
 msgstr "Schreibe Nachricht nach %s ..."
 
-#: compose.c:1238
+#: compose.c:1237
 msgid "Message written."
 msgstr "Nachricht geschrieben."
 
-#: compose.c:1252
+#: compose.c:1251
 msgid "S/MIME already selected. Clear & continue ? "
 msgstr "S/MIME bereits ausgewhlt. Lschen und weiter?"
 
-#: compose.c:1285
+#: compose.c:1284
 msgid "PGP already selected. Clear & continue ? "
 msgstr "PGP bereits ausgewhlt. Lschen und weiter?"
 
@@ -805,7 +799,7 @@ msgstr "Fehler beim Zur
 msgid "error reading data object: %s\n"
 msgstr "Fehler beim Lesen des Datenobjekts: %s\n"
 
-#: crypt-gpgme.c:573 crypt-gpgme.c:3637 pgpkey.c:560 pgpkey.c:741
+#: crypt-gpgme.c:573 crypt-gpgme.c:3636 pgpkey.c:559 pgpkey.c:740
 msgid "Can't create temporary file"
 msgstr "Kann temporre Datei nicht erzeugen"
 
@@ -893,7 +887,7 @@ msgid "PKA verified signer's address is: "
 msgstr "Die PKA geprfte Adresse des Unterzeichners lautet: "
 
 #. L10N: DOTFILL
-#: crypt-gpgme.c:1264 crypt-gpgme.c:3468
+#: crypt-gpgme.c:1264 crypt-gpgme.c:3467
 msgid "Fingerprint: "
 msgstr "Fingerabdruck: "
 
@@ -1101,15 +1095,15 @@ msgstr "[-- Ende der S/MIME signierten Daten --]\n"
 msgid "[-- End of S/MIME encrypted data --]\n"
 msgstr "[-- Ende der S/MIME-verschlsselten Daten --]\n"
 
-#: crypt-gpgme.c:3299
+#: crypt-gpgme.c:3298
 msgid "[Can't display this user ID (unknown encoding)]"
 msgstr "[Kann Benutzer-ID nicht darstellen (unbekannte Kodierung)]"
 
-#: crypt-gpgme.c:3301
+#: crypt-gpgme.c:3300
 msgid "[Can't display this user ID (invalid encoding)]"
 msgstr "[Kann Benutzer-ID nicht darstellen (unzulssige Kodierung)]"
 
-#: crypt-gpgme.c:3306
+#: crypt-gpgme.c:3305
 msgid "[Can't display this user ID (invalid DN)]"
 msgstr "[Kann Benutzer-ID nicht darstellen (unzulssiger DN)]"
 
@@ -1117,153 +1111,153 @@ msgstr "[Kann Benutzer-ID nicht darstellen (unzul
 #. Fill dots to make the DOTFILL entries the same length.
 #. In English, msgid "Fingerprint: " is the longest entry for this menu.
 #. Your language may vary.
-#: crypt-gpgme.c:3389
+#: crypt-gpgme.c:3388
 msgid " aka ......: "
 msgstr " aka ......: "
 
-#: crypt-gpgme.c:3389
+#: crypt-gpgme.c:3388
 msgid "Name ......: "
 msgstr "Name ......: "
 
-#: crypt-gpgme.c:3392 crypt-gpgme.c:3539
+#: crypt-gpgme.c:3391 crypt-gpgme.c:3538
 msgid "[Invalid]"
 msgstr "[Ungltig]"
 
 #. L10N: DOTFILL
-#: crypt-gpgme.c:3413 crypt-gpgme.c:3564
+#: crypt-gpgme.c:3412 crypt-gpgme.c:3563
 #, c-format
 msgid "Valid From : %s\n"
 msgstr "Gltig ab: %s\n"
 
 #. L10N: DOTFILL
-#: crypt-gpgme.c:3427 crypt-gpgme.c:3578
+#: crypt-gpgme.c:3426 crypt-gpgme.c:3577
 #, c-format
 msgid "Valid To ..: %s\n"
 msgstr "Gltig bis: %s\n"
 
 #. L10N: DOTFILL
-#: crypt-gpgme.c:3441 crypt-gpgme.c:3592
+#: crypt-gpgme.c:3440 crypt-gpgme.c:3591
 #, c-format
 msgid "Key Type ..: %s, %lu bit %s\n"
 msgstr "Schlssel Typ ..: %s, %lu Bit %s\n"
 
 #. L10N: DOTFILL
-#: crypt-gpgme.c:3444 crypt-gpgme.c:3595
+#: crypt-gpgme.c:3443 crypt-gpgme.c:3594
 #, c-format
 msgid "Key Usage .: "
 msgstr "Schlssel Gebrauch .: "
 
-#: crypt-gpgme.c:3449 crypt-gpgme.c:3600
+#: crypt-gpgme.c:3448 crypt-gpgme.c:3599
 msgid "encryption"
 msgstr "Verschlsselung"
 
-#: crypt-gpgme.c:3450 crypt-gpgme.c:3455 crypt-gpgme.c:3460 crypt-gpgme.c:3601
-#: crypt-gpgme.c:3606 crypt-gpgme.c:3611
+#: crypt-gpgme.c:3449 crypt-gpgme.c:3454 crypt-gpgme.c:3459 crypt-gpgme.c:3600
+#: crypt-gpgme.c:3605 crypt-gpgme.c:3610
 msgid ", "
 msgstr ", "
 
-#: crypt-gpgme.c:3454 crypt-gpgme.c:3605
+#: crypt-gpgme.c:3453 crypt-gpgme.c:3604
 msgid "signing"
 msgstr "Signieren"
 
-#: crypt-gpgme.c:3459 crypt-gpgme.c:3610
+#: crypt-gpgme.c:3458 crypt-gpgme.c:3609
 msgid "certification"
 msgstr "Zertifikat"
 
 #. L10N: DOTFILL
-#: crypt-gpgme.c:3501
+#: crypt-gpgme.c:3500
 #, c-format
 msgid "Serial-No .: 0x%s\n"
 msgstr "Seriennr. .: 0x%s\n"
 
 #. L10N: DOTFILL
-#: crypt-gpgme.c:3510
+#: crypt-gpgme.c:3509
 #, c-format
 msgid "Issued By .: "
 msgstr "Herausgegeben von .: "
 
 #. L10N: DOTFILL
-#: crypt-gpgme.c:3530
+#: crypt-gpgme.c:3529
 #, c-format
 msgid "Subkey ....: 0x%s"
 msgstr "Unter-Schlssel: 0x%s"
 
-#: crypt-gpgme.c:3534
+#: crypt-gpgme.c:3533
 msgid "[Revoked]"
 msgstr "[Zurckgez.]"
 
-#: crypt-gpgme.c:3544
+#: crypt-gpgme.c:3543
 msgid "[Expired]"
 msgstr "[Abgelaufen]"
 
-#: crypt-gpgme.c:3549
+#: crypt-gpgme.c:3548
 msgid "[Disabled]"
 msgstr "[Deaktiviert]"
 
-#: crypt-gpgme.c:3640
+#: crypt-gpgme.c:3639
 msgid "Collecting data..."
 msgstr "Sammle Informtionen..."
 
-#: crypt-gpgme.c:3666
+#: crypt-gpgme.c:3665
 #, c-format
 msgid "Error finding issuer key: %s\n"
 msgstr "Fehler bei der Suche nach dem Schlssel des Herausgebers: %s\n"
 
-#: crypt-gpgme.c:3676
+#: crypt-gpgme.c:3675
 #, fuzzy
 msgid "Error: certification chain too long - stopping here\n"
 msgstr "Fehler: Zertifikatskette zu lang - Stoppe hier\n"
 
-#: crypt-gpgme.c:3687 pgpkey.c:582
+#: crypt-gpgme.c:3686 pgpkey.c:581
 #, c-format
 msgid "Key ID: 0x%s"
 msgstr "Schlssel ID: 0x%s"
 
-#: crypt-gpgme.c:3770
+#: crypt-gpgme.c:3769
 #, c-format
 msgid "gpgme_new failed: %s"
 msgstr "gpgme_new fehlgeschlagen: %s"
 
-#: crypt-gpgme.c:3809 crypt-gpgme.c:3884
+#: crypt-gpgme.c:3808 crypt-gpgme.c:3883
 #, c-format
 msgid "gpgme_op_keylist_start failed: %s"
 msgstr "gpgme_op_keylist_start fehlgeschlagen: %s"
 
-#: crypt-gpgme.c:3871 crypt-gpgme.c:3915
+#: crypt-gpgme.c:3870 crypt-gpgme.c:3914
 #, c-format
 msgid "gpgme_op_keylist_next failed: %s"
 msgstr "gpgme_op_keylist_next fehlgeschlagen: %s"
 
-#: crypt-gpgme.c:3986
+#: crypt-gpgme.c:3985
 msgid "All matching keys are marked expired/revoked."
 msgstr "Alles passenden Schlssel sind abgelaufen/zurckgezogen."
 
-#: crypt-gpgme.c:4015 mutt_ssl.c:1082 mutt_ssl_gnutls.c:1001 pgpkey.c:516
-#: smime.c:435
+#: crypt-gpgme.c:4014 mutt_ssl.c:1047 mutt_ssl_gnutls.c:1001 pgpkey.c:515
+#: smime.c:434
 msgid "Exit  "
 msgstr "Ende  "
 
-#: crypt-gpgme.c:4017 pgpkey.c:518 smime.c:437
+#: crypt-gpgme.c:4016 pgpkey.c:517 smime.c:436
 msgid "Select  "
 msgstr "Auswahl  "
 
-#: crypt-gpgme.c:4020 pgpkey.c:521
+#: crypt-gpgme.c:4019 pgpkey.c:520
 msgid "Check key  "
 msgstr "Schlssel prfen  "
 
-#: crypt-gpgme.c:4036
+#: crypt-gpgme.c:4035
 msgid "PGP and S/MIME keys matching"
 msgstr "Passende PGP und S/MIME Schlssel"
 
-#: crypt-gpgme.c:4038
+#: crypt-gpgme.c:4037
 msgid "PGP keys matching"
 msgstr "Passende PGP Schlssel"
 
-#: crypt-gpgme.c:4040
+#: crypt-gpgme.c:4039
 msgid "S/MIME keys matching"
 msgstr "Passende S/MIME Schlssel"
 
-#: crypt-gpgme.c:4042
+#: crypt-gpgme.c:4041
 msgid "keys matching"
 msgstr "Passende Schlssel"
 
@@ -1271,64 +1265,64 @@ msgstr "Passende Schl
 #. %1$s is one of the previous four entries.
 #. %2$s is an address.
 #. e.g. "S/MIME keys matching <me@mutt.org>."
-#: crypt-gpgme.c:4049
+#: crypt-gpgme.c:4048
 #, c-format
 msgid "%s <%s>."
 msgstr "%s <%s>."
 
 #. L10N:
 #. e.g. 'S/MIME keys matching "Michael Elkins".'
-#: crypt-gpgme.c:4053
+#: crypt-gpgme.c:4052
 #, c-format
 msgid "%s \"%s\"."
 msgstr "%s \"%s\"."
 
-#: crypt-gpgme.c:4080 pgpkey.c:602
+#: crypt-gpgme.c:4079 pgpkey.c:601
 msgid "This key can't be used: expired/disabled/revoked."
 msgstr ""
 "Dieser Schlssel ist nicht verwendbar: veraltet/deaktiviert/zurckgezogen."
 
-#: crypt-gpgme.c:4094 pgpkey.c:614 smime.c:467
+#: crypt-gpgme.c:4093 pgpkey.c:613 smime.c:466
 msgid "ID is expired/disabled/revoked."
 msgstr "Diese ID ist veraltet/deaktiviert/zurckgezogen."
 
-#: crypt-gpgme.c:4102 pgpkey.c:618 smime.c:470
+#: crypt-gpgme.c:4101 pgpkey.c:617 smime.c:469
 msgid "ID has undefined validity."
 msgstr "Die Gltigkeit dieser ID ist undefiniert."
 
-#: crypt-gpgme.c:4105 pgpkey.c:621
+#: crypt-gpgme.c:4104 pgpkey.c:620
 msgid "ID is not valid."
 msgstr "Diese ID ist ungltig."
 
-#: crypt-gpgme.c:4108 pgpkey.c:624
+#: crypt-gpgme.c:4107 pgpkey.c:623
 msgid "ID is only marginally valid."
 msgstr "Diese Gltigkeit dieser ID ist begrenzt."
 
-#: crypt-gpgme.c:4117 pgpkey.c:628 smime.c:477
+#: crypt-gpgme.c:4116 pgpkey.c:627 smime.c:476
 #, c-format
 msgid "%s Do you really want to use the key?"
 msgstr "%s Wollen Sie den Schlssel wirklich benutzen?"
 
-#: crypt-gpgme.c:4178 crypt-gpgme.c:4312 pgpkey.c:839 pgpkey.c:966
+#: crypt-gpgme.c:4177 crypt-gpgme.c:4311 pgpkey.c:838 pgpkey.c:965
 #, c-format
 msgid "Looking for keys matching \"%s\"..."
 msgstr "Suche nach Schlsseln, die auf \"%s\" passen..."
 
-#: crypt-gpgme.c:4467 pgp.c:1304
+#: crypt-gpgme.c:4466 pgp.c:1304
 #, c-format
 msgid "Use keyID = \"%s\" for %s?"
 msgstr "Benutze KeyID = \"%s\" fr %s?"
 
-#: crypt-gpgme.c:4525 pgp.c:1353 smime.c:796 smime.c:902
+#: crypt-gpgme.c:4524 pgp.c:1353 smime.c:795 smime.c:901
 #, c-format
 msgid "Enter keyID for %s: "
 msgstr "KeyID fr %s: "
 
-#: crypt-gpgme.c:4602 pgpkey.c:726
+#: crypt-gpgme.c:4601 pgpkey.c:725
 msgid "Please enter the key ID: "
 msgstr "Bitte Schlsselidentifikation eingeben: "
 
-#: crypt-gpgme.c:4615
+#: crypt-gpgme.c:4614
 #, fuzzy, c-format
 msgid "Error exporting key: %s\n"
 msgstr "Fehler beim Auslesen der Schlsselinformation!\n"
@@ -1337,20 +1331,20 @@ msgstr "Fehler beim Auslesen der Schl
 #. MIME description for exported (attached) keys.
 #. You can translate this entry to a non-ASCII string (it will be encoded),
 #. but it may be safer to keep it untranslated.
-#: crypt-gpgme.c:4635
+#: crypt-gpgme.c:4634
 #, fuzzy, c-format
 msgid "PGP Key 0x%s."
 msgstr "PGP Schlssel %s."
 
-#: crypt-gpgme.c:4677
+#: crypt-gpgme.c:4676
 msgid "GPGME: OpenPGP protocol not available"
 msgstr ""
 
-#: crypt-gpgme.c:4685
+#: crypt-gpgme.c:4684
 msgid "GPGME: CMS protocol not available"
 msgstr ""
 
-#: crypt-gpgme.c:4722
+#: crypt-gpgme.c:4721
 #, fuzzy
 msgid "S/MIME (s)ign, sign (a)s, (p)gp, (c)lear, or (o)ppenc mode off? "
 msgstr ""
@@ -1360,21 +1354,21 @@ msgstr ""
 #. 'clear'.  Please use a corresponding letter in your language.
 #. Alternatively, you may duplicate the letter 'c' is translated to.
 #. This comment also applies to the five following letter sequences.
-#: crypt-gpgme.c:4727
+#: crypt-gpgme.c:4726
 msgid "sapfco"
 msgstr ""
 
-#: crypt-gpgme.c:4732
+#: crypt-gpgme.c:4731
 #, fuzzy
 msgid "PGP (s)ign, sign (a)s, s/(m)ime, (c)lear, or (o)ppenc mode off? "
 msgstr ""
 "PGP (v)erschl., (s)ign., sign. (a)ls, (b)eides, s/(m)ime, (u)nverschl.?"
 
-#: crypt-gpgme.c:4733
+#: crypt-gpgme.c:4732
 msgid "samfco"
 msgstr ""
 
-#: crypt-gpgme.c:4745
+#: crypt-gpgme.c:4744
 #, fuzzy
 msgid ""
 "S/MIME (e)ncrypt, (s)ign, sign (a)s, (b)oth, (p)gp, (c)lear, or (o)ppenc "
@@ -1382,12 +1376,12 @@ msgid ""
 msgstr ""
 "S/MIME (v)erschl., (s)ign., sign. (a)ls, (b)eides, (p)gp, (u)nverschl.?"
 
-#: crypt-gpgme.c:4746
+#: crypt-gpgme.c:4745
 #, fuzzy
 msgid "esabpfco"
 msgstr "vsabpku"
 
-#: crypt-gpgme.c:4751
+#: crypt-gpgme.c:4750
 #, fuzzy
 msgid ""
 "PGP (e)ncrypt, (s)ign, sign (a)s, (b)oth, s/(m)ime, (c)lear, or (o)ppenc "
@@ -1395,40 +1389,40 @@ msgid ""
 msgstr ""
 "PGP (v)erschl., (s)ign., sign. (a)ls, (b)eides, s/(m)ime, (u)nverschl.?"
 
-#: crypt-gpgme.c:4752
+#: crypt-gpgme.c:4751
 #, fuzzy
 msgid "esabmfco"
 msgstr "vsabmku"
 
-#: crypt-gpgme.c:4763
+#: crypt-gpgme.c:4762
 #, fuzzy
 msgid "S/MIME (e)ncrypt, (s)ign, sign (a)s, (b)oth, (p)gp or (c)lear? "
 msgstr ""
 "S/MIME (v)erschl., (s)ign., sign. (a)ls, (b)eides, (p)gp, (u)nverschl.?"
 
-#: crypt-gpgme.c:4764
+#: crypt-gpgme.c:4763
 msgid "esabpfc"
 msgstr "vsabpku"
 
-#: crypt-gpgme.c:4769
+#: crypt-gpgme.c:4768
 #, fuzzy
 msgid "PGP (e)ncrypt, (s)ign, sign (a)s, (b)oth, s/(m)ime or (c)lear? "
 msgstr ""
 "PGP (v)erschl., (s)ign., sign. (a)ls, (b)eides, s/(m)ime, (u)nverschl.?"
 
-#: crypt-gpgme.c:4770
+#: crypt-gpgme.c:4769
 msgid "esabmfc"
 msgstr "vsabmku"
 
-#: crypt-gpgme.c:4795 pgp.c:1818 smime.c:2222 smime.c:2237
+#: crypt-gpgme.c:4794 pgp.c:1818 smime.c:2221 smime.c:2236
 msgid "Sign as: "
 msgstr "Signiere als: "
 
-#: crypt-gpgme.c:4930
+#: crypt-gpgme.c:4929
 msgid "Failed to verify sender"
 msgstr "Prfung des Absenders fehlgeschlagen"
 
-#: crypt-gpgme.c:4933
+#: crypt-gpgme.c:4932
 msgid "Failed to figure out sender"
 msgstr "Kann Absender nicht ermitteln"
 
@@ -1455,7 +1449,7 @@ msgstr "Nachricht kann nicht inline verschickt werden. PGP/MIME verwenden?"
 msgid "Mail not sent: inline PGP can't be used with attachments."
 msgstr ""
 
-#: crypt.c:161 cryptglue.c:110 pgpkey.c:564 pgpkey.c:754
+#: crypt.c:161 cryptglue.c:110 pgpkey.c:563 pgpkey.c:753
 msgid "Invoking PGP..."
 msgstr "Rufe PGP auf..."
 
@@ -1539,318 +1533,318 @@ msgstr ""
 msgid "Invoking S/MIME..."
 msgstr "Rufe S/MIME auf..."
 
-#: curs_lib.c:218
+#: curs_lib.c:210
 msgid "yes"
 msgstr "ja"
 
-#: curs_lib.c:219
+#: curs_lib.c:211
 msgid "no"
 msgstr "nein"
 
-#: curs_lib.c:326
+#: curs_lib.c:318
 msgid "Exit Mutt?"
 msgstr "Mutt verlassen?"
 
-#: curs_lib.c:675 mutt_socket.c:577 mutt_ssl.c:426
+#: curs_lib.c:521 mutt_socket.c:577 mutt_ssl.c:415
 msgid "unknown error"
 msgstr "unbekannter Fehler"
 
-#: curs_lib.c:695
+#: curs_lib.c:541
 msgid "Press any key to continue..."
 msgstr "Bitte drcken Sie eine Taste..."
 
-#: curs_lib.c:740
+#: curs_lib.c:586
 msgid " ('?' for list): "
 msgstr " (fr eine Liste '?' eingeben): "
 
-#: curs_main.c:57 curs_main.c:709 curs_main.c:739
+#: curs_main.c:52 curs_main.c:694 curs_main.c:724
 msgid "No mailbox is open."
 msgstr "Keine Mailbox ist geffnet."
 
-#: curs_main.c:58
+#: curs_main.c:53
 msgid "There are no messages."
 msgstr "Es sind keine Nachrichten vorhanden."
 
-#: curs_main.c:59 mx.c:1130 pager.c:54 recvattach.c:43
+#: curs_main.c:54 mx.c:1102 pager.c:51 recvattach.c:43
 msgid "Mailbox is read-only."
 msgstr "Mailbox kann nur gelesen, nicht geschrieben werden."
 
-#: curs_main.c:60 pager.c:55 recvattach.c:925
+#: curs_main.c:55 pager.c:52 recvattach.c:924
 msgid "Function not permitted in attach-message mode."
 msgstr "Funktion steht beim Anhngen von Nachrichten nicht zur Verfgung."
 
-#: curs_main.c:61
+#: curs_main.c:56
 msgid "No visible messages."
 msgstr "Keine sichtbaren Nachrichten."
 
 #. L10N: %s is one of the CHECK_ACL entries below.
-#: curs_main.c:102 pager.c:86
+#: curs_main.c:97 pager.c:83
 #, fuzzy, c-format
 msgid "%s: Operation not permitted by ACL"
 msgstr "Operation \"%s\" gem ACL nicht zulssig"
 
-#: curs_main.c:332
+#: curs_main.c:327
 msgid "Cannot toggle write on a readonly mailbox!"
 msgstr "Kann Mailbox im Nur-Lese-Modus nicht schreibbar machen!"
 
-#: curs_main.c:339
+#: curs_main.c:334
 msgid "Changes to folder will be written on folder exit."
 msgstr "nderungen an dieser Mailbox werden beim Verlassen geschrieben."
 
-#: curs_main.c:344
+#: curs_main.c:339
 msgid "Changes to folder will not be written."
 msgstr "nderungen an dieser Mailbox werden nicht geschrieben."
 
-#: curs_main.c:486
+#: curs_main.c:481
 msgid "Quit"
 msgstr "Ende"
 
-#: curs_main.c:489 recvattach.c:54
+#: curs_main.c:484 recvattach.c:54
 msgid "Save"
 msgstr "Speichern"
 
-#: curs_main.c:490 query.c:49
+#: curs_main.c:485 query.c:49
 msgid "Mail"
 msgstr "Senden"
 
-#: curs_main.c:491 pager.c:1561
+#: curs_main.c:486 pager.c:1540
 msgid "Reply"
 msgstr "Antw."
 
-#: curs_main.c:492
+#: curs_main.c:487
 msgid "Group"
 msgstr "Antw.alle"
 
-#: curs_main.c:574
+#: curs_main.c:571
 msgid "Mailbox was externally modified.  Flags may be wrong."
 msgstr "Mailbox wurde verndert. Markierungen knnen veraltet sein."
 
-#: curs_main.c:577
+#: curs_main.c:574
 msgid "New mail in this mailbox."
 msgstr "Neue Nachrichten in dieser Mailbox."
 
-#: curs_main.c:581
+#: curs_main.c:578
 msgid "Mailbox was externally modified."
 msgstr "Mailbox wurde von auen verndert."
 
-#: curs_main.c:715
+#: curs_main.c:700
 msgid "No tagged messages."
 msgstr "Keine markierten Nachrichten."
 
-#: curs_main.c:746 menu.c:928
+#: curs_main.c:731 menu.c:907
 msgid "Nothing to do."
 msgstr "Nichts zu erledigen."
 
-#: curs_main.c:832
+#: curs_main.c:817
 msgid "Jump to message: "
 msgstr "Springe zu Nachricht: "
 
-#: curs_main.c:838
+#: curs_main.c:823
 msgid "Argument must be a message number."
 msgstr "Argument muss eine Nachrichtennummer sein."
 
-#: curs_main.c:870
+#: curs_main.c:855
 msgid "That message is not visible."
 msgstr "Diese Nachricht ist nicht sichtbar."
 
-#: curs_main.c:873
+#: curs_main.c:858
 msgid "Invalid message number."
 msgstr "Ungltige Nachrichtennummer."
 
 #. L10N: CHECK_ACL
-#: curs_main.c:887 curs_main.c:2004 pager.c:2450
+#: curs_main.c:872 curs_main.c:1970 pager.c:2390
 #, fuzzy
 msgid "Cannot delete message(s)"
 msgstr "Lschmarkierung von Nachricht(en) entfernen"
 
-#: curs_main.c:890
+#: curs_main.c:875
 msgid "Delete messages matching: "
 msgstr "Lsche Nachrichten nach Muster: "
 
-#: curs_main.c:912
+#: curs_main.c:897
 msgid "No limit pattern is in effect."
 msgstr "Zur Zeit ist kein Muster aktiv."
 
 #. L10N: ask for a limit to apply
-#: curs_main.c:917
+#: curs_main.c:902
 #, c-format
 msgid "Limit: %s"
 msgstr "Begrenze: %s"
 
-#: curs_main.c:927
+#: curs_main.c:912
 msgid "Limit to messages matching: "
 msgstr "Begrenze auf Nachrichten nach Muster: "
 
-#: curs_main.c:949
+#: curs_main.c:934
 msgid "To view all messages, limit to \"all\"."
 msgstr "Um alle Nachrichten zu sehen, begrenze auf \"all\"."
 
-#: curs_main.c:961 pager.c:1997
+#: curs_main.c:946 pager.c:1939
 msgid "Quit Mutt?"
 msgstr "Mutt beenden?"
 
-#: curs_main.c:1051
+#: curs_main.c:1036
 msgid "Tag messages matching: "
 msgstr "Markiere Nachrichten nach Muster: "
 
 #. L10N: CHECK_ACL
-#: curs_main.c:1061 curs_main.c:2304 pager.c:2765
+#: curs_main.c:1046 curs_main.c:2268 pager.c:2704
 #, fuzzy
 msgid "Cannot undelete message(s)"
 msgstr "Lschmarkierung von Nachricht(en) entfernen"
 
-#: curs_main.c:1063
+#: curs_main.c:1048
 msgid "Undelete messages matching: "
 msgstr "Entferne Lschmarkierung nach Muster: "
 
-#: curs_main.c:1071
+#: curs_main.c:1056
 msgid "Untag messages matching: "
 msgstr "Entferne Markierung nach Muster: "
 
-#: curs_main.c:1097
+#: curs_main.c:1082
 msgid "Logged out of IMAP servers."
 msgstr ""
 
-#: curs_main.c:1182
+#: curs_main.c:1164
 msgid "Open mailbox in read-only mode"
 msgstr "ffne Mailbox im nur-Lesen-Modus"
 
-#: curs_main.c:1184
+#: curs_main.c:1166
 msgid "Open mailbox"
 msgstr "ffne Mailbox"
 
-#: curs_main.c:1194
+#: curs_main.c:1176
 msgid "No mailboxes have new mail"
 msgstr "Keine Mailbox mit neuen Nachrichten"
 
-#: curs_main.c:1231 mx.c:487 mx.c:580
+#: curs_main.c:1204 mx.c:472 mx.c:621
 #, c-format
 msgid "%s is not a mailbox."
 msgstr "%s ist keine Mailbox."
 
-#: curs_main.c:1334
+#: curs_main.c:1303
 msgid "Exit Mutt without saving?"
 msgstr "Mutt verlassen, ohne nderungen zu speichern?"
 
-#: curs_main.c:1352 curs_main.c:1388 curs_main.c:1846 curs_main.c:1878
-#: flags.c:301 thread.c:1028 thread.c:1083 thread.c:1138
+#: curs_main.c:1321 curs_main.c:1357 curs_main.c:1815 curs_main.c:1847
+#: flags.c:282 thread.c:1028 thread.c:1083 thread.c:1138
 msgid "Threading is not enabled."
 msgstr "Darstellung von Diskussionsfden ist nicht eingeschaltet."
 
-#: curs_main.c:1364
+#: curs_main.c:1333
 msgid "Thread broken"
 msgstr "Diskussionsfaden unterbrochen"
 
-#: curs_main.c:1375
+#: curs_main.c:1344
 msgid "Thread cannot be broken, message is not part of a thread"
 msgstr "Nachricht ist nicht Teil eines Diskussionsfadens"
 
 #. L10N: CHECK_ACL
-#: curs_main.c:1385
+#: curs_main.c:1354
 #, fuzzy
 msgid "Cannot link threads"
 msgstr "Diskussionsfden verlinken"
 
-#: curs_main.c:1390
+#: curs_main.c:1359
 msgid "No Message-ID: header available to link thread"
 msgstr "Keine Message-ID verfgbar, um Diskussionsfaden aufzubauen"
 
-#: curs_main.c:1392
+#: curs_main.c:1361
 msgid "First, please tag a message to be linked here"
 msgstr "Bitte erst eine Nachricht zur Verlinkung markieren"
 
-#: curs_main.c:1404
+#: curs_main.c:1373
 msgid "Threads linked"
 msgstr "Diskussionfden verbunden"
 
-#: curs_main.c:1407
+#: curs_main.c:1376
 msgid "No thread linked"
 msgstr "Kein Diskussionsfaden verbunden"
 
-#: curs_main.c:1443 curs_main.c:1468
+#: curs_main.c:1412 curs_main.c:1437
 msgid "You are on the last message."
 msgstr "Sie sind bereits auf der letzten Nachricht."
 
-#: curs_main.c:1450 curs_main.c:1494
+#: curs_main.c:1419 curs_main.c:1463
 msgid "No undeleted messages."
 msgstr "Keine ungelschten Nachrichten."
 
-#: curs_main.c:1487 curs_main.c:1511
+#: curs_main.c:1456 curs_main.c:1480
 msgid "You are on the first message."
 msgstr "Sie sind bereits auf der ersten Nachricht."
 
-#: curs_main.c:1586 menu.c:773 pager.c:2115 pattern.c:1491
+#: curs_main.c:1555 menu.c:757 pager.c:2057 pattern.c:1489
 msgid "Search wrapped to top."
 msgstr "Suche von vorne begonnen."
 
-#: curs_main.c:1595 pager.c:2137 pattern.c:1502
+#: curs_main.c:1564 pager.c:2079 pattern.c:1500
 msgid "Search wrapped to bottom."
 msgstr "Suche von hinten begonnen."
 
-#: curs_main.c:1639
+#: curs_main.c:1608
 #, fuzzy
 msgid "No new messages in this limited view."
 msgstr "Bezugsnachricht ist in dieser begrenzten Sicht nicht sichtbar."
 
-#: curs_main.c:1641
+#: curs_main.c:1610
 #, fuzzy
 msgid "No new messages."
 msgstr "Keine neuen Nachrichten"
 
-#: curs_main.c:1646
+#: curs_main.c:1615
 #, fuzzy
 msgid "No unread messages in this limited view."
 msgstr "Bezugsnachricht ist in dieser begrenzten Sicht nicht sichtbar."
 
-#: curs_main.c:1648
+#: curs_main.c:1617
 #, fuzzy
 msgid "No unread messages."
 msgstr "Keine ungelesenen Nachrichten"
 
 #. L10N: CHECK_ACL
-#: curs_main.c:1666
+#: curs_main.c:1635
 #, fuzzy
 msgid "Cannot flag message"
 msgstr "Indikator setzen"
 
 #. L10N: CHECK_ACL
-#: curs_main.c:1704 pager.c:2728
+#: curs_main.c:1673 pager.c:2668
 #, fuzzy
 msgid "Cannot toggle new"
 msgstr "Umschalten zwischen neu/nicht neu"
 
-#: curs_main.c:1781
+#: curs_main.c:1750
 msgid "No more threads."
 msgstr "Keine weiteren Diskussionsfden."
 
-#: curs_main.c:1783
+#: curs_main.c:1752
 msgid "You are on the first thread."
 msgstr "Sie haben bereits den ersten Diskussionsfaden ausgewhlt."
 
-#: curs_main.c:1864
+#: curs_main.c:1833
 msgid "Thread contains unread messages."
 msgstr "Diskussionsfaden enthlt ungelesene Nachrichten."
 
 #. L10N: CHECK_ACL
-#: curs_main.c:1960 pager.c:2417
+#: curs_main.c:1928 pager.c:2358
 #, fuzzy
 msgid "Cannot delete message"
 msgstr "Lschmarkierung entfernen"
 
 #. L10N: CHECK_ACL
-#: curs_main.c:2046
+#: curs_main.c:2012
 #, fuzzy
 msgid "Cannot edit message"
 msgstr "Kann Nachricht nicht schreiben"
 
 #. L10N: CHECK_ACL
-#: curs_main.c:2178
+#: curs_main.c:2144
 #, fuzzy
 msgid "Cannot mark message(s) as read"
 msgstr "Nachricht(en) als gelesen markieren"
 
 #. L10N: CHECK_ACL
-#: curs_main.c:2274 pager.c:2748
+#: curs_main.c:2240 pager.c:2688
 #, fuzzy
 msgid "Cannot undelete message"
 msgstr "Lschmarkierung entfernen"
@@ -1979,93 +1973,93 @@ msgstr "Kann Nachrichten-Datei nicht 
 msgid "Can't append to folder: %s"
 msgstr "Kann an Mailbox nicht anhngen: %s"
 
-#: editmsg.c:210
+#: editmsg.c:209
 #, c-format
 msgid "Error. Preserving temporary file: %s"
 msgstr "Fehler. Speichere temporre Datei als %s ab."
 
-#: flags.c:345
+#: flags.c:325
 msgid "Set flag"
 msgstr "Setze Indikator"
 
-#: flags.c:345
+#: flags.c:325
 msgid "Clear flag"
 msgstr "Entferne Indikator"
 
-#: handler.c:1139
+#: handler.c:1138
 msgid "[-- Error:  Could not display any parts of Multipart/Alternative! --]\n"
 msgstr ""
 "[-- Fehler: Konnte keinen der multipart/alternative-Teile anzeigen! --]\n"
 
-#: handler.c:1254
+#: handler.c:1253
 #, c-format
 msgid "[-- Attachment #%d"
 msgstr "[-- Anhang #%d"
 
-#: handler.c:1266
+#: handler.c:1265
 #, c-format
 msgid "[-- Type: %s/%s, Encoding: %s, Size: %s --]\n"
 msgstr "[-- Typ: %s/%s, Kodierung: %s, Gre: %s --]\n"
 
-#: handler.c:1282
+#: handler.c:1281
 msgid "One or more parts of this message could not be displayed"
 msgstr "Warnung: Mind. ein Teil dieser Nachricht konnte nicht angezeigt werden"
 
-#: handler.c:1334
+#: handler.c:1333
 #, c-format
 msgid "[-- Autoview using %s --]\n"
 msgstr "[-- Automatische Anzeige mittels %s --]\n"
 
-#: handler.c:1335
+#: handler.c:1334
 #, c-format
 msgid "Invoking autoview command: %s"
 msgstr "Automatische Anzeige mittels: %s"
 
-#: handler.c:1367
+#: handler.c:1366
 #, c-format
 msgid "[-- Can't run %s. --]\n"
 msgstr "[-- Kann %s nicht ausfhren. --]\n"
 
-#: handler.c:1386 handler.c:1407
+#: handler.c:1385 handler.c:1406
 #, c-format
 msgid "[-- Autoview stderr of %s --]\n"
 msgstr "[-- Fehlerausgabe von %s --]\n"
 
-#: handler.c:1446
+#: handler.c:1445
 msgid "[-- Error: message/external-body has no access-type parameter --]\n"
 msgstr ""
 "[-- Fehler: message/external-body hat keinen access-type Parameter --]\n"
 
-#: handler.c:1467
+#: handler.c:1466
 #, c-format
 msgid "[-- This %s/%s attachment "
 msgstr "[-- Dieser %s/%s-Anhang "
 
-#: handler.c:1474
+#: handler.c:1473
 #, c-format
 msgid "(size %s bytes) "
 msgstr "(Gre %s Byte) "
 
-#: handler.c:1476
+#: handler.c:1475
 msgid "has been deleted --]\n"
 msgstr "wurde gelscht --]\n"
 
-#: handler.c:1481
+#: handler.c:1480
 #, c-format
 msgid "[-- on %s --]\n"
 msgstr "[-- am %s --]\n"
 
-#: handler.c:1486
+#: handler.c:1485
 #, c-format
 msgid "[-- name: %s --]\n"
 msgstr "[-- Name: %s --]\n"
 
-#: handler.c:1499 handler.c:1515
+#: handler.c:1498 handler.c:1514
 #, c-format
 msgid "[-- This %s/%s attachment is not included, --]\n"
 msgstr "[-- Dieser %s/%s-Anhang ist nicht in der Nachricht enthalten, --]\n"
 
-#: handler.c:1501
+#: handler.c:1500
 msgid ""
 "[-- and the indicated external source has --]\n"
 "[-- expired. --]\n"
@@ -2073,34 +2067,34 @@ msgstr ""
 "[-- und die zugehrige externe Quelle --]\n"
 "[-- existiert nicht mehr. --]\n"
 
-#: handler.c:1519
+#: handler.c:1518
 #, c-format
 msgid "[-- and the indicated access-type %s is unsupported --]\n"
 msgstr "[-- und die angegebene Zugangsmethode %s wird nicht untersttzt --]\n"
 
-#: handler.c:1625
+#: handler.c:1624
 msgid "Unable to open temporary file!"
 msgstr "Konnte temporre Datei nicht ffnen!"
 
-#: handler.c:1771
+#: handler.c:1770
 msgid "Error: multipart/signed has no protocol."
 msgstr "Fehler: multipart/signed ohne \"protocol\"-Parameter."
 
-#: handler.c:1822
+#: handler.c:1821
 msgid "[-- This is an attachment "
 msgstr "[-- Dies ist ein Anhang "
 
-#: handler.c:1824
+#: handler.c:1823
 #, c-format
 msgid "[-- %s/%s is unsupported "
 msgstr "[-- %s/%s wird nicht untersttzt "
 
-#: handler.c:1831
+#: handler.c:1830
 #, c-format
 msgid "(use '%s' to view this part)"
 msgstr "(benutzen Sie '%s', um diesen Teil anzuzeigen)"
 
-#: handler.c:1833
+#: handler.c:1832
 msgid "(need 'view-attachments' bound to key!)"
 msgstr "(Tastaturbindung fr 'view-attachments' bentigt!)"
 
@@ -2109,15 +2103,15 @@ msgstr "(Tastaturbindung f
 msgid "%s: unable to attach file"
 msgstr "%s: Kann Datei nicht anhngen."
 
-#: help.c:310
+#: help.c:306
 msgid "ERROR: please report this bug"
 msgstr "ERROR: Bitte melden sie diesen Fehler"
 
-#: help.c:352
+#: help.c:348
 msgid "<UNKNOWN>"
 msgstr "<unbekannt>"
 
-#: help.c:364
+#: help.c:360
 msgid ""
 "\n"
 "Generic bindings:\n"
@@ -2127,7 +2121,7 @@ msgstr ""
 "Allgemeine Tastenbelegungen:\n"
 "\n"
 
-#: help.c:368
+#: help.c:364
 msgid ""
 "\n"
 "Unbound functions:\n"
@@ -2137,7 +2131,7 @@ msgstr ""
 "Funktionen ohne Bindung an Taste:\n"
 "\n"
 
-#: help.c:376
+#: help.c:372
 #, c-format
 msgid "Help for %s"
 msgstr "Hilfe fr %s"
@@ -2147,6 +2141,10 @@ msgstr "Hilfe f
 msgid "Bad history file format (line %d)"
 msgstr "Falsches Format der Datei frherer Eingaben (Zeile %d)"
 
+#: hook.c:96
+msgid "badly formatted command string"
+msgstr "Hook enthlt nicht die Muster %f und %t"
+
 #: hook.c:93
 msgid "current mailbox shortcut '^' is unset"
 msgstr ""
@@ -2219,47 +2217,42 @@ msgstr "Authentifiziere (%s)..."
 msgid "SASL authentication failed."
 msgstr "SASL Authentifizierung fehlgeschlagen."
 
-#: imap/browse.c:59 imap/imap.c:569
+#: imap/browse.c:58 imap/imap.c:569
 #, c-format
 msgid "%s is an invalid IMAP path"
 msgstr "%s ist ein ungltiger IMAP Pfad"
 
-#: imap/browse.c:70
+#: imap/browse.c:69
 msgid "Getting folder list..."
 msgstr "Hole Liste der Ordner..."
 
-#: imap/browse.c:190
+#: imap/browse.c:189
 msgid "No such folder"
 msgstr "Ordner existiert nicht"
 
-#: imap/browse.c:243
+#: imap/browse.c:278
 msgid "Create mailbox: "
 msgstr "Erzeuge Mailbox: "
 
-#: imap/browse.c:248 imap/browse.c:301
+#: imap/browse.c:283 imap/browse.c:338
 msgid "Mailbox must have a name."
 msgstr "Mailbox muss einen Namen haben."
 
-#: imap/browse.c:256
+#: imap/browse.c:291
 msgid "Mailbox created."
 msgstr "Mailbox erzeugt."
 
-#: imap/browse.c:289
-#, fuzzy
-msgid "Cannot rename root folder"
-msgstr "Kann Wurzel-Mailbox nicht lschen"
-
-#: imap/browse.c:293
+#: imap/browse.c:330
 #, c-format
 msgid "Rename mailbox %s to: "
 msgstr "Benenne Mailbox %s um in: "
 
-#: imap/browse.c:309
+#: imap/browse.c:346
 #, c-format
 msgid "Rename failed: %s"
 msgstr "Umbenennung fehlgeschlagen: %s"
 
-#: imap/browse.c:314
+#: imap/browse.c:351
 msgid "Mailbox renamed."
 msgstr "Mailbox umbenannt."
 
@@ -2293,84 +2286,79 @@ msgstr "Konnte keine TLS-Verbindung realisieren"
 msgid "Encrypted connection unavailable"
 msgstr "Verschlsselte Verbindung nicht verfgbar"
 
-#: imap/imap.c:602
+#: imap/imap.c:601
 #, c-format
 msgid "Selecting %s..."
 msgstr "Whle %s aus..."
 
-#: imap/imap.c:757
+#: imap/imap.c:756
 msgid "Error opening mailbox"
 msgstr "Fehler beim ffnen der Mailbox"
 
-#: imap/imap.c:808 imap/imap.c:2147 imap/message.c:877 muttlib.c:1565
+#: imap/imap.c:808 imap/message.c:861 muttlib.c:1541
 #, c-format
 msgid "Create %s?"
 msgstr "%s erstellen?"
 
-#: imap/imap.c:1201
+#: imap/imap.c:1183
 msgid "Expunge failed"
 msgstr "Lschen fehlgeschlagen"
 
-#: imap/imap.c:1213
+#: imap/imap.c:1195
 #, c-format
 msgid "Marking %d messages deleted..."
 msgstr "Markiere %d Nachrichten zum Lschen..."
 
-#: imap/imap.c:1245
+#: imap/imap.c:1227
 #, c-format
 msgid "Saving changed messages... [%d/%d]"
 msgstr "Speichere vernderte Nachrichten... [%d/%d]"
 
-#: imap/imap.c:1300
+#: imap/imap.c:1282
 msgid "Error saving flags. Close anyway?"
 msgstr "Fehler beim Speichern der Markierungen. Trotzdem Schlieen?"
 
-#: imap/imap.c:1308
+#: imap/imap.c:1290
 msgid "Error saving flags"
 msgstr "Fehler beim Speichern der Markierungen"
 
-#: imap/imap.c:1331
+#: imap/imap.c:1313
 msgid "Expunging messages from server..."
 msgstr "Lsche Nachrichten auf dem Server..."
 
-#: imap/imap.c:1336
+#: imap/imap.c:1318
 msgid "imap_sync_mailbox: EXPUNGE failed"
 msgstr "imap_sync_mailbox: EXPUNGE fehlgeschlagen"
 
-#: imap/imap.c:1805
+#: imap/imap.c:1768
 #, c-format
 msgid "Header search without header name: %s"
 msgstr "Suche im Nachrichtenkopf ohne Angabe des Feldes: %s"
 
-#: imap/imap.c:1876
+#: imap/imap.c:1839
 msgid "Bad mailbox name"
 msgstr "Unzulssiger Mailbox Name"
 
-#: imap/imap.c:1900
+#: imap/imap.c:1863
 #, c-format
 msgid "Subscribing to %s..."
 msgstr "Abonniere %s..."
 
-#: imap/imap.c:1902
+#: imap/imap.c:1865
 #, c-format
 msgid "Unsubscribing from %s..."
 msgstr "Beende Abonnement von %s..."
 
-#: imap/imap.c:1912
+#: imap/imap.c:1875
 #, c-format
 msgid "Subscribed to %s"
 msgstr "Abonniere %s"
 
-#: imap/imap.c:1914
+#: imap/imap.c:1877
 #, c-format
 msgid "Unsubscribed from %s"
 msgstr "Abonnement von %s beendet"
 
-#: imap/imap.c:2132 imap/message.c:841
-#, c-format
-msgid "Copying %d messages to %s..."
-msgstr "Kopiere %d Nachrichten nach %s..."
-
 #: imap/message.c:98
 msgid "Unable to fetch headers from this IMAP server version."
 msgstr ""
@@ -2391,20 +2379,25 @@ msgstr "Werte Cache aus..."
 msgid "Fetching message headers..."
 msgstr "Hole Nachrichten-Kpfe..."
 
-#: imap/message.c:444 imap/message.c:501 pop.c:573
+#: imap/message.c:443 imap/message.c:500 pop.c:572
 msgid "Fetching message..."
 msgstr "Hole Nachricht..."
 
-#: imap/message.c:490 pop.c:568
+#: imap/message.c:489 pop.c:567
 msgid "The message index is incorrect. Try reopening the mailbox."
 msgstr ""
 "Der Nachrichtenindex ist fehlerhaft. Versuche die Mailbox neu zu ffnen."
 
-#: imap/message.c:660
+#: imap/message.c:644
 msgid "Uploading message..."
 msgstr "Lade Nachricht auf den Server..."
 
-#: imap/message.c:845
+#: imap/message.c:825
+#, c-format
+msgid "Copying %d messages to %s..."
+msgstr "Kopiere %d Nachrichten nach %s..."
+
+#: imap/message.c:829
 #, c-format
 msgid "Copying message %d to %s..."
 msgstr "Kopiere Nachricht %d nach %s..."
@@ -2413,7 +2406,7 @@ msgstr "Kopiere Nachricht %d nach %s..."
 msgid "Continue?"
 msgstr "Weiter?"
 
-#: init.c:60 init.c:1768 pager.c:53
+#: init.c:60 init.c:1762 pager.c:50
 #, c-format
 msgid "Not available in this menu."
 msgstr "Funktion ist in diesem Men nicht verfgbar."
@@ -2485,126 +2478,126 @@ msgstr "%s: Unbekannte Sortiermethode"
 msgid "mutt_restore_default(%s): error in regexp: %s\n"
 msgstr "mutt_restore_default(%s): Fehler in regulrem Ausdruck: %s\n"
 
-#: init.c:1745 init.c:1858
+#: init.c:1739 init.c:1852
 #, c-format
 msgid "%s: unknown variable"
 msgstr "%s: Unbekannte Variable."
 
-#: init.c:1754
+#: init.c:1748
 #, c-format
 msgid "prefix is illegal with reset"
 msgstr "Prfix ist bei \"reset\" nicht zulssig."
 
-#: init.c:1760
+#: init.c:1754
 #, c-format
 msgid "value is illegal with reset"
 msgstr "Wertzuweisung ist bei \"reset\" nicht zulssig."
 
-#: init.c:1796 init.c:1808
+#: init.c:1790 init.c:1802
 #, c-format
 msgid "Usage: set variable=yes|no"
 msgstr "Benutzung: set variable=yes|no"
 
-#: init.c:1816
+#: init.c:1810
 #, c-format
 msgid "%s is set"
 msgstr "%s ist gesetzt."
 
-#: init.c:1816
+#: init.c:1810
 #, c-format
 msgid "%s is unset"
 msgstr "%s ist nicht gesetzt."
 
-#: init.c:1919
+#: init.c:1913
 #, c-format
 msgid "Invalid value for option %s: \"%s\""
 msgstr "Ungltiger Wert fr Variable %s: \"%s\""
 
-#: init.c:2056
+#: init.c:2050
 #, c-format
 msgid "%s: invalid mailbox type"
 msgstr "%s: Ungltiger Mailbox-Typ"
 
-#: init.c:2087
+#: init.c:2081
 #, c-format
 msgid "%s: invalid value (%s)"
 msgstr "%s: ungltiger Wert (%s)"
 
-#: init.c:2088
+#: init.c:2082
 msgid "format error"
 msgstr "Format-Fehler"
 
-#: init.c:2088
+#: init.c:2082
 msgid "number overflow"
 msgstr "Zahlenberlauf"
 
-#: init.c:2148
+#: init.c:2142
 #, c-format
 msgid "%s: invalid value"
 msgstr "%s: Ungltiger Wert"
 
-#: init.c:2192
+#: init.c:2183
 #, c-format
 msgid "%s: Unknown type."
 msgstr "%s: Unbekannter Typ."
 
-#: init.c:2219
+#: init.c:2210
 #, c-format
 msgid "%s: unknown type"
 msgstr "%s: Unbekannter Typ"
 
-#: init.c:2287
+#: init.c:2272
 #, c-format
 msgid "Error in %s, line %d: %s"
 msgstr "Fehler in %s, Zeile %d: %s"
 
-#: init.c:2310
+#: init.c:2295
 #, c-format
 msgid "source: errors in %s"
 msgstr "source: Fehler in %s"
 
-#: init.c:2311
+#: init.c:2296
 #, fuzzy, c-format
 msgid "source: reading aborted due to too many errors in %s"
 msgstr "source: Lesevorgang abgebrochen, zu viele Fehler in %s"
 
-#: init.c:2325
+#: init.c:2310
 #, c-format
 msgid "source: error at %s"
 msgstr "source: Fehler bei %s"
 
-#: init.c:2330
+#: init.c:2315
 msgid "source: too many arguments"
 msgstr "source: Zu viele Argumente"
 
-#: init.c:2384
+#: init.c:2369
 #, c-format
 msgid "%s: unknown command"
 msgstr "%s: Unbekanntes Kommando"
 
-#: init.c:2872
+#: init.c:2857
 #, c-format
 msgid "Error in command line: %s\n"
 msgstr "Fehler in Kommandozeile: %s\n"
 
-#: init.c:2951
+#: init.c:2936
 msgid "unable to determine home directory"
 msgstr "Kann Home-Verzeichnis nicht bestimmen."
 
-#: init.c:2959
+#: init.c:2944
 msgid "unable to determine username"
 msgstr "Kann Nutzernamen nicht bestimmen."
 
-#: init.c:2985
+#: init.c:2970
 #, fuzzy
 msgid "unable to determine nodename via uname()"
 msgstr "Kann Nutzernamen nicht bestimmen."
 
-#: init.c:3229
+#: init.c:3214
 msgid "-group: no group name"
 msgstr "-group: Kein Gruppen Name"
 
-#: init.c:3239
+#: init.c:3224
 msgid "out of arguments"
 msgstr "Zu wenige Parameter"
 
@@ -2681,7 +2674,7 @@ msgstr "Integer 
 msgid "Out of memory!"
 msgstr "Kein Speicher verfgbar!"
 
-#: main.c:68
+#: main.c:65
 msgid ""
 "To contact the developers, please mail to <mutt-dev@mutt.org>.\n"
 "To report a bug, please visit http://bugs.mutt.org/.\n"
@@ -2690,7 +2683,7 @@ msgstr ""
 "eine Nachricht (in englisch) an <mutt-dev@mutt.org>.\n"
 "Um einen Bug zu melden, besuchen Sie bitte http://bugs.mutt.org/.\n"
 
-#: main.c:72
+#: main.c:69
 #, fuzzy
 msgid ""
 "Copyright (C) 1996-2016 Michael R. Elkins and others.\n"
@@ -2704,10 +2697,10 @@ msgstr ""
 "Sie knnen es unter bestimmten Bedingungen weitergeben; starten Sie\n"
 "`mutt -vv' fr weitere Details.\n"
 
-#: main.c:78
+#: main.c:75
 #, fuzzy
 msgid ""
-"Copyright (C) 1996-2016 Michael R. Elkins <me@mutt.org>\n"
+"Copyright (C) 1996-2014 Michael R. Elkins <me@mutt.org>\n"
 "Copyright (C) 1996-2002 Brandon Long <blong@fiction.net>\n"
 "Copyright (C) 1997-2009 Thomas Roessler <roessler@does-not-exist.org>\n"
 "Copyright (C) 1998-2005 Werner Koch <wk@isil.d.shuttle.de>\n"
@@ -2715,7 +2708,7 @@ msgid ""
 "Copyright (C) 1999-2002 Tommi Komulainen <Tommi.Komulainen@iki.fi>\n"
 "Copyright (C) 2000-2004 Edmund Grimley Evans <edmundo@rano.org>\n"
 "Copyright (C) 2006-2009 Rocco Rutte <pdmef@gmx.net>\n"
-"Copyright (C) 2014-2016 Kevin J. McCarthy <kevin@8t8.us>\n"
+"Copyright (C) 2014-2015 Kevin J. McCarthy <kevin@8t8.us>\n"
 "\n"
 "Many others not mentioned here contributed code, fixes,\n"
 "and suggestions.\n"
@@ -2732,7 +2725,7 @@ msgstr ""
 "Unzhlige hier nicht einzeln aufgefhrte Helfer haben Code,\n"
 "Fehlerkorrekturen und hilfreiche Hinweise beigesteuert.\n"
 
-#: main.c:92
+#: main.c:89
 msgid ""
 "    This program is free software; you can redistribute it and/or modify\n"
 "    it under the terms of the GNU General Public License as published by\n"
@@ -2756,7 +2749,7 @@ msgstr ""
 "    BESTIMMTEN ZWECK. Entnehmen Sie alle weiteren Details der\n"
 "    GNU General Public License.\n"
 
-#: main.c:102
+#: main.c:99
 msgid ""
 "    You should have received a copy of the GNU General Public License\n"
 "    along with this program; if not, write to the Free Software\n"
@@ -2768,7 +2761,7 @@ msgstr ""
 "    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n"
 "    Boston, MA 02110-1301, USA.\n"
 
-#: main.c:119
+#: main.c:116
 #, fuzzy
 msgid ""
 "usage: mutt [<options>] [-z] [-f <file> | -yZ]\n"
@@ -2793,7 +2786,7 @@ msgstr ""
 "       mutt [<options>] -D\n"
 "       mutt -v[v]\n"
 
-#: main.c:128
+#: main.c:125
 #, fuzzy
 msgid ""
 "options:\n"
@@ -2811,11 +2804,11 @@ msgstr ""
 "  -c <address>\tEmpfnger einer Kopie (Cc:)\n"
 "  -D\t\tGib die Werte aller Variablen aus"
 
-#: main.c:137
+#: main.c:134
 msgid "  -d <level>\tlog debugging output to ~/.muttdebug0"
 msgstr "  -d <level>\tSschreibe Debug-Informationen nach ~/.muttdebug0"
 
-#: main.c:140
+#: main.c:137
 #, fuzzy
 msgid ""
 "  -E\t\tedit the draft (-H) or include (-i) file\n"
@@ -2837,7 +2830,7 @@ msgstr ""
 "  -n\t\tDas Muttrc des Systems ignorieren\n"
 "  -p\t\tEine zurckgestellte Nachricht zurckholen"
 
-#: main.c:150
+#: main.c:147
 msgid ""
 "  -Q <variable>\tquery a configuration variable\n"
 "  -R\t\topen mailbox in read-only mode\n"
@@ -2859,7 +2852,7 @@ msgstr ""
 "  -Z\t\tffne erste Mailbox mit neuen Nachrichten oder beenden\n"
 "  -h\t\tDiese Hilfe"
 
-#: main.c:231
+#: main.c:228
 msgid ""
 "\n"
 "Compile options:"
@@ -2867,216 +2860,206 @@ msgstr ""
 "\n"
 "Einstellungen bei der Compilierung:"
 
-#: main.c:541
+#: main.c:532
 msgid "Error initializing terminal."
 msgstr "Kann Terminal nicht initialisieren."
 
-#: main.c:679
+#: main.c:669
 #, c-format
 msgid "Error: value '%s' is invalid for -d.\n"
 msgstr "Fehler: Wert '%s' ist ungltig fr -d.\n"
 
-#: main.c:682
+#: main.c:672
 #, c-format
 msgid "Debugging at level %d.\n"
 msgstr "Debugging auf Ebene %d.\n"
 
-#: main.c:684
+#: main.c:674
 msgid "DEBUG was not defined during compilation.  Ignored.\n"
 msgstr "DEBUG war beim Kompilieren nicht definiert.  Ignoriert.\n"
 
-#: main.c:862
+#: main.c:848
 #, c-format
 msgid "%s does not exist. Create it?"
 msgstr "%s existiert nicht. Neu anlegen?"
 
-#: main.c:866
+#: main.c:852
 #, c-format
 msgid "Can't create %s: %s."
 msgstr "Kann %s nicht anlegen: %s."
 
-#: main.c:906
+#: main.c:891
 msgid "Failed to parse mailto: link\n"
 msgstr "Fehler beim Parsen von mailto: Link\n"
 
-#: main.c:918
+#: main.c:903
 msgid "No recipients specified.\n"
 msgstr "Keine Empfnger angegeben.\n"
 
-#: main.c:944
+#: main.c:929
 msgid "Cannot use -E flag with stdin\n"
 msgstr ""
 
-#: main.c:1097
+#: main.c:1082
 #, c-format
 msgid "%s: unable to attach file.\n"
 msgstr "%s: Kann Datei nicht anhngen.\n"
 
-#: main.c:1178
+#: main.c:1162
 msgid "No mailbox with new mail."
 msgstr "Keine Mailbox mit neuen Nachrichten."
 
-#: main.c:1187
+#: main.c:1171
 msgid "No incoming mailboxes defined."
 msgstr "Keine Eingangs-Mailboxen definiert."
 
-#: main.c:1215
+#: main.c:1199
 msgid "Mailbox is empty."
 msgstr "Mailbox ist leer."
 
-#: mbox.c:120 mbox.c:271 mh.c:1255 mx.c:598
+#: mbox.c:119 mbox.c:269 mh.c:1205 mx.c:642
 #, c-format
 msgid "Reading %s..."
 msgstr "Lese %s..."
 
-#: mbox.c:158 mbox.c:215
+#: mbox.c:157 mbox.c:214
 msgid "Mailbox is corrupt!"
 msgstr "Mailbox fehlerhaft!"
 
-#: mbox.c:456
-#, c-format
-msgid "Couldn't lock %s\n"
-msgstr "Kann %s nicht locken.\n"
-
-#: mbox.c:493 mbox.c:508
-msgid "Can't write message"
-msgstr "Kann Nachricht nicht schreiben"
-
-#: mbox.c:748
+#: compress.c:203 mbox.c:661
 msgid "Mailbox was corrupted!"
 msgstr "Mailbox wurde zerstrt!"
 
-#: mbox.c:829 mbox.c:1089
+#: mbox.c:751 mbox.c:1011
 msgid "Fatal error!  Could not reopen mailbox!"
 msgstr "Fataler Fehler, konnte Mailbox nicht erneut ffnen!"
 
-#: mbox.c:838
+#: compress.c:246 compress.c:367 compress.c:443 mbox.c:706
 msgid "Unable to lock mailbox!"
 msgstr "Kann Mailbox nicht fr exklusiven Zugriff sperren!"
 
-#: mbox.c:881
+#: mbox.c:803
 msgid "sync: mbox modified, but no modified messages! (report this bug)"
 msgstr ""
 "sync: Mailbox verndert, aber Nachrichten unverndert! (bitte Bug melden)"
 
-#: mbox.c:905 mh.c:1889 mx.c:675
+#: mbox.c:827 mh.c:1711 mx.c:739
 #, c-format
 msgid "Writing %s..."
 msgstr "Schreibe %s..."
 
-#: mbox.c:1040
+#: mbox.c:962
 msgid "Committing changes..."
 msgstr "Speichere nderungen..."
 
-#: mbox.c:1075
+#: mbox.c:997
 #, c-format
 msgid "Write failed!  Saved partial mailbox to %s"
 msgstr "Konnte nicht schreiben! Speichere Teil-Mailbox in %s"
 
-#: mbox.c:1137
+#: mbox.c:1059
 msgid "Could not reopen mailbox!"
 msgstr "Konnte Mailbox nicht erneut ffnen!"
 
-#: mbox.c:1164
+#: mbox.c:1095
 msgid "Reopening mailbox..."
 msgstr "ffne Mailbox erneut..."
 
-#: menu.c:430
+#: menu.c:418
 msgid "Jump to: "
 msgstr "Springe zu: "
 
-#: menu.c:439
+#: menu.c:427
 msgid "Invalid index number."
 msgstr "Ungltige Indexnummer."
 
-#: menu.c:443 menu.c:464 menu.c:529 menu.c:572 menu.c:588 menu.c:599 menu.c:610
-#: menu.c:621 menu.c:634 menu.c:647 menu.c:1065
+#: menu.c:431 menu.c:452 menu.c:517 menu.c:560 menu.c:576 menu.c:587 menu.c:598
+#: menu.c:609 menu.c:622 menu.c:635 menu.c:1044
 msgid "No entries."
 msgstr "Keine Eintrge"
 
-#: menu.c:461
+#: menu.c:449
 msgid "You cannot scroll down farther."
 msgstr "Sie knnen nicht weiter nach unten gehen."
 
-#: menu.c:479
+#: menu.c:467
 msgid "You cannot scroll up farther."
 msgstr "Sie knnen nicht weiter nach oben gehen."
 
-#: menu.c:522
+#: menu.c:510
 msgid "You are on the first page."
 msgstr "Sie sind auf der ersten Seite."
 
-#: menu.c:523
+#: menu.c:511
 msgid "You are on the last page."
 msgstr "Sie sind auf der letzten Seite."
 
-#: menu.c:658
+#: menu.c:646
 msgid "You are on the last entry."
 msgstr "Sie sind auf dem letzten Eintrag."
 
-#: menu.c:669
+#: menu.c:657
 msgid "You are on the first entry."
 msgstr "Sie sind auf dem ersten Eintrag"
 
-#: menu.c:747 pager.c:2159 pattern.c:1430
+#: menu.c:731 pager.c:2101 pattern.c:1428
 msgid "Search for: "
 msgstr "Suche nach: "
 
-#: menu.c:747 pager.c:2159 pattern.c:1430
+#: menu.c:731 pager.c:2101 pattern.c:1428
 msgid "Reverse search for: "
 msgstr "Suche rckwrts nach: "
 
-#: menu.c:791 pager.c:2112 pager.c:2134 pager.c:2254 pattern.c:1545
+#: menu.c:775 pager.c:2054 pager.c:2076 pager.c:2196 pattern.c:1543
 msgid "Not found."
 msgstr "Nicht gefunden."
 
-#: menu.c:922
+#: menu.c:901
 msgid "No tagged entries."
 msgstr "Keine markierten Eintrge."
 
-#: menu.c:1022
+#: menu.c:1001
 msgid "Search is not implemented for this menu."
 msgstr "In diesem Men kann nicht gesucht werden."
 
-#: menu.c:1027
+#: menu.c:1006
 msgid "Jumping is not implemented for dialogs."
 msgstr "Springen in Dialogen ist nicht mglich."
 
-#: menu.c:1068
+#: menu.c:1047
 msgid "Tagging is not supported."
 msgstr "Markieren wird nicht untersttzt."
 
-#: mh.c:1235
+#: mh.c:1184
 #, c-format
 msgid "Scanning %s..."
 msgstr "Durchsuche %s..."
 
-#: mh.c:1558 mh.c:1641
+#: mh.c:1385 mh.c:1463
 msgid "Could not flush message to disk"
 msgstr "Konnte Nachricht nicht auf Festplatte speichern"
 
-#: mh.c:1603
-#, fuzzy
-msgid "_maildir_commit_message(): unable to set time on file"
+#: mh.c:1430
+msgid "maildir_commit_message(): unable to set time on file"
 msgstr "maildir_commit_message(): kann Zeitstempel der Datei nicht setzen"
 
-#: mutt_sasl.c:196
+#: mutt_sasl.c:194
 msgid "Unknown SASL profile"
 msgstr "Unbekanntes SASL Profil"
 
-#: mutt_sasl.c:230
+#: mutt_sasl.c:228
 msgid "Error allocating SASL connection"
 msgstr "Fehler beim Aufbau der SASL Verbindung"
 
-#: mutt_sasl.c:241
+#: mutt_sasl.c:239
 msgid "Error setting SASL security properties"
 msgstr "Fehler beim Setzen der SASL Sicherheitsparameter"
 
-#: mutt_sasl.c:251
+#: mutt_sasl.c:249
 msgid "Error setting SASL external security strength"
 msgstr "Fehler beim Setzen der externen SASL Sicherheitstrke"
 
-#: mutt_sasl.c:260
+#: mutt_sasl.c:258
 msgid "Error setting SASL external user name"
 msgstr "Fehler beim Setzen des externen SASL Benutzernamens"
 
@@ -3123,44 +3106,35 @@ msgstr "Verbinde zu %s..."
 msgid "Could not connect to %s (%s)."
 msgstr "Kann keine Verbindung zu %s aufbauen (%s)."
 
-#: mutt_ssl.c:226
+#: mutt_ssl.c:225
 msgid "Failed to find enough entropy on your system"
 msgstr "Nicht gengend Entropie auf diesem System gefunden"
 
-#: mutt_ssl.c:250
+#: mutt_ssl.c:249
 #, c-format
 msgid "Filling entropy pool: %s...\n"
 msgstr "Sammle Entropie fr Zufallsgenerator: %s...\n"
 
-#: mutt_ssl.c:258
+#: mutt_ssl.c:257
 #, c-format
 msgid "%s has insecure permissions!"
 msgstr "%s hat unsichere Zugriffsrechte!"
 
-#: mutt_ssl.c:277
+#: mutt_ssl.c:276
 #, fuzzy
 msgid "SSL disabled due to the lack of entropy"
 msgstr "SSL deaktiviert, weil nicht gengend Entropie zur Verfgung steht"
 
-#. L10N: an SSL context is a data structure returned by the OpenSSL
-#. *       function SSL_CTX_new().  In this case it returned NULL: an
-#. *       error condition.
-#.
-#: mutt_ssl.c:344
-#, fuzzy
-msgid "Unable to create SSL context"
-msgstr "Fehler: Kann keinen OpenSSL Prozess erzeugen!"
-
-#: mutt_ssl.c:420
+#: mutt_ssl.c:409
 msgid "I/O error"
 msgstr "Ein-/Ausgabe Fehler"
 
-#: mutt_ssl.c:429
+#: mutt_ssl.c:418
 #, c-format
 msgid "SSL failed: %s"
 msgstr "SSL fehlgeschlagen: %s"
 
-#: mutt_ssl.c:438 mutt_ssl_gnutls.c:1079 mutt_ssl_gnutls.c:1114
+#: mutt_ssl.c:427 mutt_ssl_gnutls.c:1079 mutt_ssl_gnutls.c:1114
 #: mutt_ssl_gnutls.c:1124
 msgid "Unable to get certificate from peer"
 msgstr "Kann kein Zertifikat vom Server erhalten"
@@ -3169,104 +3143,104 @@ msgstr "Kann kein Zertifikat vom Server erhalten"
 #. %1$s is version (e.g. "TLSv1.2")
 #. %2$s is cipher_version (e.g. "TLSv1/SSLv3")
 #. %3$s is cipher_name (e.g. "ECDHE-RSA-AES128-GCM-SHA256")
-#: mutt_ssl.c:450
+#: mutt_ssl.c:439
 #, fuzzy, c-format
 msgid "%s connection using %s (%s)"
 msgstr "SSL Verbindung unter Verwendung von %s (%s)"
 
-#: mutt_ssl.c:576
+#: mutt_ssl.c:541
 msgid "Unknown"
 msgstr "unbekannt"
 
-#: mutt_ssl.c:601 mutt_ssl_gnutls.c:598
+#: mutt_ssl.c:566 mutt_ssl_gnutls.c:598
 #, c-format
 msgid "[unable to calculate]"
 msgstr "[kann nicht berechnet werden]"
 
-#: mutt_ssl.c:619 mutt_ssl_gnutls.c:621
+#: mutt_ssl.c:584 mutt_ssl_gnutls.c:621
 msgid "[invalid date]"
 msgstr "[ungltiges Datum]"
 
-#: mutt_ssl.c:747
+#: mutt_ssl.c:712
 msgid "Server certificate is not yet valid"
 msgstr "Zertifikat des Servers ist noch nicht gltig"
 
-#: mutt_ssl.c:754
+#: mutt_ssl.c:719
 msgid "Server certificate has expired"
 msgstr "Zertifikat des Servers ist abgelaufen"
 
-#: mutt_ssl.c:876
+#: mutt_ssl.c:841
 msgid "cannot get certificate subject"
 msgstr "Kann Subject des Zertifikats nicht ermitteln"
 
-#: mutt_ssl.c:886 mutt_ssl.c:895
+#: mutt_ssl.c:851 mutt_ssl.c:860
 msgid "cannot get certificate common name"
 msgstr "Kann Common Name des Zertifikats nicht ermitteln"
 
-#: mutt_ssl.c:909
+#: mutt_ssl.c:874
 #, c-format
 msgid "certificate owner does not match hostname %s"
 msgstr "Zertifikat-Inhaber stimmt nicht mit Rechnername %s berein"
 
-#: mutt_ssl.c:950
+#: mutt_ssl.c:915
 #, c-format
 msgid "Certificate host check failed: %s"
 msgstr "Prfung des Rechnernames in Zertifikat gescheitert: %s"
 
-#: mutt_ssl.c:1028 mutt_ssl_gnutls.c:860
+#: mutt_ssl.c:993 mutt_ssl_gnutls.c:860
 msgid "This certificate belongs to:"
 msgstr "Dieses Zertifikat gehrt zu:"
 
-#: mutt_ssl.c:1041 mutt_ssl_gnutls.c:899
+#: mutt_ssl.c:1006 mutt_ssl_gnutls.c:899
 msgid "This certificate was issued by:"
 msgstr "Dieses Zertifikat wurde ausgegeben von:"
 
-#: mutt_ssl.c:1052 mutt_ssl_gnutls.c:938
+#: mutt_ssl.c:1017 mutt_ssl_gnutls.c:938
 #, c-format
 msgid "This certificate is valid"
 msgstr "Dieses Zertifikat ist gltig"
 
-#: mutt_ssl.c:1053 mutt_ssl_gnutls.c:941
+#: mutt_ssl.c:1018 mutt_ssl_gnutls.c:941
 #, c-format
 msgid "   from %s"
 msgstr "    von %s"
 
-#: mutt_ssl.c:1055 mutt_ssl_gnutls.c:945
+#: mutt_ssl.c:1020 mutt_ssl_gnutls.c:945
 #, c-format
 msgid "     to %s"
 msgstr "     an %s"
 
-#: mutt_ssl.c:1061
+#: mutt_ssl.c:1026
 #, c-format
 msgid "Fingerprint: %s"
 msgstr "Fingerabdruck: %s"
 
-#: mutt_ssl.c:1064 mutt_ssl_gnutls.c:982
+#: mutt_ssl.c:1029 mutt_ssl_gnutls.c:982
 #, c-format
 msgid "SSL Certificate check (certificate %d of %d in chain)"
 msgstr "SSL Zertifikatprfung (Zertifikat %d von %d in Kette)"
 
-#: mutt_ssl.c:1072 mutt_ssl_gnutls.c:991
+#: mutt_ssl.c:1037 mutt_ssl_gnutls.c:991
 msgid "(r)eject, accept (o)nce, (a)ccept always"
 msgstr "(z)urckweisen, (e)inmal akzeptieren, (i)mmer akzeptieren"
 
-#: mutt_ssl.c:1073 mutt_ssl_gnutls.c:992
+#: mutt_ssl.c:1038 mutt_ssl_gnutls.c:992
 msgid "roa"
 msgstr "zei"
 
-#: mutt_ssl.c:1077 mutt_ssl_gnutls.c:996
+#: mutt_ssl.c:1042 mutt_ssl_gnutls.c:996
 msgid "(r)eject, accept (o)nce"
 msgstr "(z)urckweisen, (e)inmal akzeptieren"
 
-#: mutt_ssl.c:1078 mutt_ssl_gnutls.c:997
+#: mutt_ssl.c:1043 mutt_ssl_gnutls.c:997
 msgid "ro"
 msgstr "ze"
 
-#: mutt_ssl.c:1109 mutt_ssl_gnutls.c:1046
+#: mutt_ssl.c:1074 mutt_ssl_gnutls.c:1046
 msgid "Warning: Couldn't save certificate"
 msgstr "Warnung: Konnte Zertifikat nicht speichern"
 
-#: mutt_ssl.c:1114 mutt_ssl_gnutls.c:1051
+#: mutt_ssl.c:1079 mutt_ssl_gnutls.c:1051
 msgid "Certificate saved"
 msgstr "Zertifikat gespeichert"
 
@@ -3356,179 +3330,178 @@ msgstr "Tunnel-Fehler bei Verbindung mit %s: %s"
 #. L10N:
 #. Means "The path you specified as the destination file is a directory."
 #. See the msgid "Save to file: " (alias.c, recvattach.c)
-#: muttlib.c:976
+#: muttlib.c:974
 msgid "File is a directory, save under it? [(y)es, (n)o, (a)ll]"
 msgstr "Datei ist ein Verzeichnis, darin abspeichern? [(j)a, (n)ein, (a)lle]"
 
-#: muttlib.c:976
+#: muttlib.c:974
 msgid "yna"
 msgstr "jna"
 
 #. L10N:
 #. Means "The path you specified as the destination file is a directory."
 #. See the msgid "Save to file: " (alias.c, recvattach.c)
-#: muttlib.c:995
+#: muttlib.c:993
 msgid "File is a directory, save under it?"
 msgstr "Datei ist ein Verzeichnis, darin abspeichern?"
 
-#: muttlib.c:999
+#: muttlib.c:997
 msgid "File under directory: "
 msgstr "Datei in diesem Verzeichnis: "
 
-#: muttlib.c:1008
+#: muttlib.c:1006
 msgid "File exists, (o)verwrite, (a)ppend, or (c)ancel?"
 msgstr "Datei existiert, (u)eberschreiben, (a)nhngen, a(b)brechen?"
 
-#: muttlib.c:1008
+#: muttlib.c:1006
 msgid "oac"
 msgstr "uab"
 
-#: muttlib.c:1531
+#: muttlib.c:1507
 msgid "Can't save message to POP mailbox."
 msgstr "Kann Nachricht nicht in POP Mailbox schreiben."
 
-#: muttlib.c:1540
+#: muttlib.c:1516
 #, c-format
 msgid "Append messages to %s?"
 msgstr "Nachricht an %s anhngen?"
 
-#: muttlib.c:1552
+#: muttlib.c:1528
 #, c-format
 msgid "%s is not a mailbox!"
 msgstr "%s ist keine Mailbox!"
 
-#: mx.c:143
+#: mx.c:116
 #, c-format
 msgid "Lock count exceeded, remove lock for %s?"
 msgstr "Lock-Datei fr %s entfernen?"
 
-#: mx.c:155
+#: mx.c:128
 #, c-format
 msgid "Can't dotlock %s.\n"
 msgstr "Kann %s nicht (dot-)locken.\n"
 
-#: mx.c:211
+#: mx.c:184
 msgid "Timeout exceeded while attempting fcntl lock!"
 msgstr "Konnte fcntl-Lock nicht innerhalb akzeptabler Zeit erhalten."
 
-#: mx.c:217
+#: mx.c:190
 #, c-format
 msgid "Waiting for fcntl lock... %d"
 msgstr "Warte auf fcntl-Lock... %d"
 
-#: mx.c:244
+#: mx.c:217
 msgid "Timeout exceeded while attempting flock lock!"
 msgstr "Konnte flock-Lock nicht innerhalb akzeptabler Zeit erhalten."
 
-#: mx.c:251
+#: mx.c:224
 #, c-format
 msgid "Waiting for flock attempt... %d"
 msgstr "Warte auf flock-Versuch... %d"
 
-#: mx.c:707
+#: mx.c:555
+#, c-format
+msgid "Couldn't lock %s\n"
+msgstr "Kann %s nicht locken.\n"
+
+#: mx.c:771
 #, c-format
 msgid "Could not synchronize mailbox %s!"
 msgstr "Kann Mailbox %s nicht synchronisieren!"
 
-#: mx.c:742
-#, fuzzy
-msgid "message(s) not deleted"
-msgstr "Markiere Nachrichten zum Lschen..."
-
-#: mx.c:775
-#, fuzzy
-msgid "Can't open trash folder"
-msgstr "Kann an Mailbox nicht anhngen: %s"
-
-#: mx.c:844
+#: mx.c:835
 #, c-format
 msgid "Move read messages to %s?"
 msgstr "Verschiebe gelesene Nachrichten nach %s?"
 
-#: mx.c:860 mx.c:1146
+#: mx.c:851 mx.c:1118
 #, c-format
 msgid "Purge %d deleted message?"
 msgstr "Entferne %d als gelscht markierte Nachrichten?"
 
-#: mx.c:860 mx.c:1146
+#: mx.c:851 mx.c:1118
 #, c-format
 msgid "Purge %d deleted messages?"
 msgstr "Entferne %d als gelscht markierte Nachrichten?"
 
-#: mx.c:881
+#: mx.c:872
 #, c-format
 msgid "Moving read messages to %s..."
 msgstr "Verschiebe gelesene Nachrichten nach %s..."
 
-#: mx.c:942 mx.c:1137
+#: mx.c:932 mx.c:1109
 msgid "Mailbox is unchanged."
 msgstr "Mailbox unverndert."
 
-#: mx.c:995
+#: mx.c:972
 #, c-format
 msgid "%d kept, %d moved, %d deleted."
 msgstr "%d behalten, %d verschoben, %d gelscht."
 
-#: mx.c:998 mx.c:1198
+#: mx.c:975 mx.c:1161
 #, c-format
 msgid "%d kept, %d deleted."
 msgstr "%d behalten, %d gelscht."
 
-#: mx.c:1121
+#: mx.c:1093
 #, c-format
 msgid " Press '%s' to toggle write"
 msgstr " Drcken Sie '%s', um Schreib-Modus ein-/auszuschalten"
 
-#: mx.c:1123
+#: mx.c:1095
 msgid "Use 'toggle-write' to re-enable write!"
 msgstr "Benutzen Sie 'toggle-write', um Schreib-Modus zu reaktivieren"
 
-#: mx.c:1125
+#: mx.c:1097
 #, c-format
 msgid "Mailbox is marked unwritable. %s"
 msgstr "Mailbox ist als unschreibbar markiert. %s"
 
-#: mx.c:1192
+#: mx.c:1155
 msgid "Mailbox checkpointed."
 msgstr "Checkpoint in der Mailbox gesetzt."
 
-#: mx.c:1367
+#: mx.c:1474
+msgid "Can't write message"
+msgstr "Kann Nachricht nicht schreiben"
+
+#: mx.c:1513
 msgid "Integer overflow -- can't allocate memory."
 msgstr "Integer berlauf -- kann keinen Speicher belegen."
 
-#: pager.c:1554
+#: pager.c:1533
 msgid "PrevPg"
 msgstr "S.zurck"
 
-#: pager.c:1555
+#: pager.c:1534
 msgid "NextPg"
 msgstr "S.vor"
 
-#: pager.c:1559
+#: pager.c:1538
 msgid "View Attachm."
 msgstr "Anhnge betr."
 
-#: pager.c:1562
+#: pager.c:1541
 msgid "Next"
 msgstr "Nchste Nachr."
 
-#: pager.c:2013 pager.c:2044 pager.c:2076 pager.c:2352
+#: pager.c:1955 pager.c:1986 pager.c:2018 pager.c:2294
 msgid "Bottom of message is shown."
 msgstr "Das Ende der Nachricht wird angezeigt."
 
-#: pager.c:2029 pager.c:2051 pager.c:2058 pager.c:2065
+#: pager.c:1971 pager.c:1993 pager.c:2000 pager.c:2007
 msgid "Top of message is shown."
 msgstr "Der Beginn der Nachricht wird angezeigt."
 
-#: pager.c:2290
+#: pager.c:2232
 msgid "Help is currently being shown."
 msgstr "Hilfe wird bereits angezeigt."
 
-#: pager.c:2319
+#: pager.c:2261
 msgid "No more quoted text."
 msgstr "Kein weiterer zitierter Text."
 
-#: pager.c:2332
+#: pager.c:2274
 msgid "No more unquoted text after quoted text."
 msgstr "Kein weiterer eigener Text nach zitiertem Text."
 
@@ -3605,7 +3578,7 @@ msgstr "Leeres Muster"
 msgid "error: unknown op %d (report this error)."
 msgstr "Fehler: Unbekannter Muster-Operator %d (Bitte Bug melden)."
 
-#: pattern.c:1309 pattern.c:1451
+#: pattern.c:1309 pattern.c:1449
 msgid "Compiling search pattern..."
 msgstr "Compiliere Suchmuster..."
 
@@ -3613,23 +3586,23 @@ msgstr "Compiliere Suchmuster..."
 msgid "Executing command on matching messages..."
 msgstr "Fhre Kommando aus..."
 
-#: pattern.c:1399
+#: pattern.c:1397
 msgid "No messages matched criteria."
 msgstr "Keine Nachrichten haben Kriterium erfllt."
 
-#: pattern.c:1481
+#: pattern.c:1479
 msgid "Searching..."
 msgstr "Suche..."
 
-#: pattern.c:1494
+#: pattern.c:1492
 msgid "Search hit bottom without finding match"
 msgstr "Suche hat Ende erreicht, ohne Treffer zu erzielen."
 
-#: pattern.c:1505
+#: pattern.c:1503
 msgid "Search hit top without finding match"
 msgstr "Suche hat Anfang erreicht, ohne Treffer zu erzielen."
 
-#: pattern.c:1537
+#: pattern.c:1535
 msgid "Search interrupted."
 msgstr "Suche unterbrochen."
 
@@ -3749,30 +3722,30 @@ msgstr "PGP (v)erschl., (s)ign., sign. (a)ls, (b)eides, %s, (k)ein PGP? "
 msgid "esabfc"
 msgstr "vsabpku"
 
-#: pgpinvoke.c:310
+#: pgpinvoke.c:309
 msgid "Fetching PGP key..."
 msgstr "Hole PGP Schlssel..."
 
-#: pgpkey.c:492
+#: pgpkey.c:491
 msgid "All matching keys are expired, revoked, or disabled."
 msgstr ""
 "Alle passenden Schlssel sind veraltet, zurckgezogen oder deaktiviert."
 
-#: pgpkey.c:533
+#: pgpkey.c:532
 #, c-format
 msgid "PGP keys matching <%s>."
 msgstr "PGP-Schlssel, die zu <%s> passen."
 
-#: pgpkey.c:535
+#: pgpkey.c:534
 #, c-format
 msgid "PGP keys matching \"%s\"."
 msgstr "PGP-Schlssel, die zu \"%s\" passen."
 
-#: pgpkey.c:554 pgpkey.c:747
+#: pgpkey.c:553 pgpkey.c:746
 msgid "Can't open /dev/null"
 msgstr "Kann /dev/null nicht ffnen"
 
-#: pgpkey.c:779
+#: pgpkey.c:778
 #, c-format
 msgid "PGP Key %s."
 msgstr "PGP Schlssel %s."
@@ -3797,54 +3770,54 @@ msgid "%d messages have been lost. Try reopening the mailbox."
 msgstr ""
 "%d Nachrichten verloren gegangen. Versuche Sie die Mailbox neu zu ffnen."
 
-#: pop.c:411 pop.c:807
+#: pop.c:411 pop.c:801
 #, c-format
 msgid "%s is an invalid POP path"
 msgstr "%s ist ein ungltiger POP Pfad"
 
-#: pop.c:455
+#: pop.c:454
 msgid "Fetching list of messages..."
 msgstr "Hole Liste der Nachrichten..."
 
-#: pop.c:613
+#: pop.c:612
 msgid "Can't write message to temporary file!"
 msgstr "Kann Nachricht nicht in temporre Datei schreiben!"
 
-#: pop.c:684
+#: pop.c:678
 msgid "Marking messages deleted..."
 msgstr "Markiere Nachrichten zum Lschen..."
 
-#: pop.c:762 pop.c:827
+#: pop.c:756 pop.c:821
 msgid "Checking for new messages..."
 msgstr "Prfe auf neue Nachrichten..."
 
-#: pop.c:791
+#: pop.c:785
 msgid "POP host is not defined."
 msgstr "Es wurde kein POP-Server definiert."
 
-#: pop.c:855
+#: pop.c:849
 msgid "No new mail in POP mailbox."
 msgstr "Keine neuen Nachrichten auf dem POP-Server."
 
-#: pop.c:862
+#: pop.c:856
 msgid "Delete messages from server?"
 msgstr "Lsche Nachrichten auf dem Server?"
 
-#: pop.c:864
+#: pop.c:858
 #, c-format
 msgid "Reading new messages (%d bytes)..."
 msgstr "Lese neue Nachrichten (%d Bytes)..."
 
-#: pop.c:906
+#: pop.c:900
 msgid "Error while writing mailbox!"
 msgstr "Fehler beim Versuch, die Mailbox zu schreiben!"
 
-#: pop.c:910
+#: pop.c:904
 #, c-format
 msgid "%s [%d of %d messages read]"
 msgstr "%s [%d von %d Nachrichten gelesen]"
 
-#: pop.c:933 pop_lib.c:378
+#: pop.c:927 pop_lib.c:378
 msgid "Server closed connection!"
 msgstr "Server hat Verbindung beendet!"
 
@@ -3899,23 +3872,23 @@ msgstr "Verbindung unterbrochen. Verbindung zum POP-Server wiederherstellen?"
 msgid "Postponed Messages"
 msgstr "Zurckgestelle Nachrichten"
 
-#: postpone.c:246 postpone.c:255
+#: postpone.c:245 postpone.c:254
 msgid "No postponed messages."
 msgstr "Keine zurckgestellten Nachrichten."
 
-#: postpone.c:457 postpone.c:478 postpone.c:512
+#: postpone.c:455 postpone.c:476 postpone.c:510
 msgid "Illegal crypto header"
 msgstr "Unzulssiger Crypto Header"
 
-#: postpone.c:498
+#: postpone.c:496
 msgid "Illegal S/MIME header"
 msgstr "Unzulssiger S/MIME Header"
 
-#: postpone.c:586
+#: postpone.c:584
 msgid "Decrypting message..."
 msgstr "Entschlssle Nachricht..."
 
-#: postpone.c:594
+#: postpone.c:592
 msgid "Decryption failed."
 msgstr "Entschlsselung gescheitert."
 
@@ -3961,71 +3934,71 @@ msgstr "Filtern"
 msgid "Print"
 msgstr "Drucke"
 
-#: recvattach.c:485
+#: recvattach.c:484
 msgid "Saving..."
 msgstr "Speichere..."
 
-#: recvattach.c:488 recvattach.c:579
+#: recvattach.c:487 recvattach.c:578
 msgid "Attachment saved."
 msgstr "Anhang gespeichert."
 
-#: recvattach.c:591
+#: recvattach.c:590
 #, c-format
 msgid "WARNING!  You are about to overwrite %s, continue?"
 msgstr "WARNUNG!  Datei %s existiert, berschreiben?"
 
-#: recvattach.c:609
+#: recvattach.c:608
 msgid "Attachment filtered."
 msgstr "Anhang gefiltert."
 
-#: recvattach.c:676
+#: recvattach.c:675
 msgid "Filter through: "
 msgstr "Filtere durch: "
 
-#: recvattach.c:676
+#: recvattach.c:675
 msgid "Pipe to: "
 msgstr "bergebe an (pipe): "
 
-#: recvattach.c:711
+#: recvattach.c:710
 #, fuzzy, c-format
 msgid "I don't know how to print %s attachments!"
 msgstr "Kann %s Anhnge nicht drucken!"
 
-#: recvattach.c:776
+#: recvattach.c:775
 msgid "Print tagged attachment(s)?"
 msgstr "Drucke markierte Anhnge?"
 
-#: recvattach.c:776
+#: recvattach.c:775
 msgid "Print attachment?"
 msgstr "Drucke Anhang?"
 
-#: recvattach.c:1010
+#: recvattach.c:1009
 msgid "Can't decrypt encrypted message!"
 msgstr "Kann verschlsselte Nachricht nicht entschlsseln!"
 
-#: recvattach.c:1022
+#: recvattach.c:1021
 msgid "Attachments"
 msgstr "Anhnge"
 
-#: recvattach.c:1058
+#: recvattach.c:1057
 msgid "There are no subparts to show!"
 msgstr "Es sind keine Teile zur Anzeige vorhanden!"
 
-#: recvattach.c:1119
+#: recvattach.c:1118
 msgid "Can't delete attachment from POP server."
 msgstr "Kann Dateianhang nicht vom POP-Server lschen."
 
-#: recvattach.c:1127
+#: recvattach.c:1126
 msgid "Deletion of attachments from encrypted messages is unsupported."
 msgstr "Kann Anhnge aus verschlsselten Nachrichten nicht lschen."
 
-#: recvattach.c:1133
+#: recvattach.c:1132
 #, fuzzy
 msgid ""
 "Deletion of attachments from signed messages may invalidate the signature."
 msgstr "Kann Anhnge aus verschlsselten Nachrichten nicht lschen."
 
-#: recvattach.c:1150 recvattach.c:1167
+#: recvattach.c:1149 recvattach.c:1166
 msgid "Only deletion of multipart attachments is supported."
 msgstr "Kann nur aus mehrteiligen Anhngen lschen."
 
@@ -4077,69 +4050,69 @@ msgid "Can't decode all tagged attachments.  MIME-encapsulate the others?"
 msgstr ""
 "Nicht alle markierten Anhnge dekodierbar. MIME fr den Rest verwenden?"
 
-#: remailer.c:481
+#: remailer.c:478
 msgid "Append"
 msgstr "Anhngen"
 
-#: remailer.c:482
+#: remailer.c:479
 msgid "Insert"
 msgstr "Einfgen"
 
-#: remailer.c:483
+#: remailer.c:480
 msgid "Delete"
 msgstr "Lschen"
 
-#: remailer.c:485
+#: remailer.c:482
 msgid "OK"
 msgstr "OK"
 
-#: remailer.c:512
+#: remailer.c:510
 msgid "Can't get mixmaster's type2.list!"
 msgstr "Kann die \"type2.list\" fr Mixmaster nicht holen!"
 
-#: remailer.c:537
+#: remailer.c:535
 msgid "Select a remailer chain."
 msgstr "Whle eine Remailer Kette aus."
 
-#: remailer.c:596
+#: remailer.c:595
 #, c-format
 msgid "Error: %s can't be used as the final remailer of a chain."
 msgstr ""
 "Fehler: %s kann nicht als letzter Remailer einer Kette verwendet werden."
 
-#: remailer.c:626
+#: remailer.c:625
 #, c-format
 msgid "Mixmaster chains are limited to %d elements."
 msgstr "Eine Mixmaster-Kette kann maximal %d Elemente enthalten."
 
-#: remailer.c:649
+#: remailer.c:648
 msgid "The remailer chain is already empty."
 msgstr "Die Remailer-Kette ist bereits leer."
 
-#: remailer.c:659
+#: remailer.c:658
 msgid "You already have the first chain element selected."
 msgstr "Sie haben bereits das erste Element der Kette ausgewhlt."
 
-#: remailer.c:669
+#: remailer.c:668
 msgid "You already have the last chain element selected."
 msgstr "Sie haben bereits das letzte Element der Kette ausgewhlt."
 
-#: remailer.c:708
+#: remailer.c:707
 msgid "Mixmaster doesn't accept Cc or Bcc headers."
 msgstr "Mixmaster untersttzt weder Cc: noch Bcc:"
 
-#: remailer.c:732
+#: remailer.c:731
 msgid ""
 "Please set the hostname variable to a proper value when using mixmaster!"
 msgstr ""
 "Setzen sie die Variable \"hostname\" richtig, wenn Sie Mixmaster verwenden!"
 
-#: remailer.c:766
+#: remailer.c:765
 #, c-format
 msgid "Error sending message, child exited %d.\n"
 msgstr "Fehler %d beim Versand der Nachricht.\n"
 
-#: remailer.c:770
+#: remailer.c:769
 msgid "Error sending message."
 msgstr "Fehler beim Versand der Nachricht."
 
@@ -4284,25 +4257,25 @@ msgstr "%s existiert nicht mehr!"
 msgid "%s isn't a regular file."
 msgstr "%s ist keine normale Datei."
 
-#: sendlib.c:1051
+#: sendlib.c:1050
 #, c-format
 msgid "Could not open %s"
 msgstr "Konnte %s nicht ffnen."
 
-#: sendlib.c:2360
+#: sendlib.c:2357
 msgid "$sendmail must be set in order to send mail."
 msgstr ""
 
-#: sendlib.c:2431
+#: sendlib.c:2428
 #, c-format
 msgid "Error sending message, child exited %d (%s)."
 msgstr "Fehler %d beim Versand der Nachricht (%s)."
 
-#: sendlib.c:2437
+#: sendlib.c:2434
 msgid "Output of the delivery process"
 msgstr "Ausgabe des Auslieferungs-Prozesses"
 
-#: sendlib.c:2611
+#: sendlib.c:2608
 #, c-format
 msgid "Bad IDN %s while preparing resent-from."
 msgstr "Ungltige IDN %s bei der Vorbereitung von Resent-From."
@@ -4326,79 +4299,79 @@ msgstr "Signal %d... Abbruch.\n"
 msgid "Enter S/MIME passphrase:"
 msgstr "S/MIME-Mantra eingeben:"
 
-#: smime.c:380
+#: smime.c:379
 msgid "Trusted   "
 msgstr "Vertr.wrd"
 
-#: smime.c:383
+#: smime.c:382
 msgid "Verified  "
 msgstr "Geprft   "
 
-#: smime.c:386
+#: smime.c:385
 msgid "Unverified"
 msgstr "Ungeprft "
 
-#: smime.c:389
+#: smime.c:388
 msgid "Expired   "
 msgstr "Veraltet  "
 
-#: smime.c:392
+#: smime.c:391
 msgid "Revoked   "
 msgstr "Zurckgez."
 
-#: smime.c:395
+#: smime.c:394
 msgid "Invalid   "
 msgstr "Ungltig  "
 
-#: smime.c:398
+#: smime.c:397
 msgid "Unknown   "
 msgstr "Unbekannt "
 
-#: smime.c:430
+#: smime.c:429
 #, c-format
 msgid "S/MIME certificates matching \"%s\"."
 msgstr "S/MIME Zertifikate, die zu \"%s\" passen."
 
-#: smime.c:473
+#: smime.c:472
 #, fuzzy
 msgid "ID is not trusted."
 msgstr "Diese ID ist ungltig."
 
-#: smime.c:762
+#: smime.c:761
 msgid "Enter keyID: "
 msgstr "KeyID eingeben: "
 
-#: smime.c:909
+#: smime.c:908
 #, c-format
 msgid "No (valid) certificate found for %s."
 msgstr "Kein (gltiges) Zertifikat fr %s gefunden."
 
-#: smime.c:962 smime.c:992 smime.c:1059 smime.c:1103 smime.c:1168 smime.c:1243
+#: smime.c:961 smime.c:991 smime.c:1058 smime.c:1102 smime.c:1167 smime.c:1242
 msgid "Error: unable to create OpenSSL subprocess!"
 msgstr "Fehler: Kann keinen OpenSSL Prozess erzeugen!"
 
-#: smime.c:1321
+#: smime.c:1320
 msgid "no certfile"
 msgstr "keine Zertifikat-Datei"
 
-#: smime.c:1324
+#: smime.c:1323
 msgid "no mbox"
 msgstr "keine Mailbox"
 
-#: smime.c:1467 smime.c:1624
+#: smime.c:1466 smime.c:1623
 msgid "No output from OpenSSL..."
 msgstr "Keine Ausgabe von OpenSSL..."
 
-#: smime.c:1534
+#: smime.c:1533
 msgid "Can't sign: No key specified. Use Sign As."
 msgstr ""
 "Kann nicht signieren: Kein Schlssel angegeben. Verwenden Sie \"sign. als\"."
 
-#: smime.c:1586
+#: smime.c:1585
 msgid "Can't open OpenSSL subprocess!"
 msgstr "Kann OpenSSL-Unterprozess nicht erzeugen!"
 
-#: smime.c:1792 smime.c:1915
+#: smime.c:1791 smime.c:1914
 msgid ""
 "[-- End of OpenSSL output --]\n"
 "\n"
@@ -4406,19 +4379,19 @@ msgstr ""
 "[-- Ende der OpenSSL-Ausgabe --]\n"
 "\n"
 
-#: smime.c:1874 smime.c:1885
+#: smime.c:1873 smime.c:1884
 msgid "[-- Error: unable to create OpenSSL subprocess! --]\n"
 msgstr "[-- Fehler: Kann keinen OpenSSL-Unterprozess erzeugen! --]\n"
 
-#: smime.c:1919
+#: smime.c:1918
 msgid "[-- The following data is S/MIME encrypted --]\n"
 msgstr "[-- Die folgenden Daten sind S/MIME-verschlsselt --]\n"
 
-#: smime.c:1922
+#: smime.c:1921
 msgid "[-- The following data is S/MIME signed --]\n"
 msgstr "[-- Die folgenden Daten sind S/MIME signiert --]\n"
 
-#: smime.c:1986
+#: smime.c:1985
 msgid ""
 "\n"
 "[-- End of S/MIME encrypted data. --]\n"
@@ -4426,7 +4399,7 @@ msgstr ""
 "\n"
 "[-- Ende der S/MIME-verschlsselten Daten --]\n"
 
-#: smime.c:1988
+#: smime.c:1987
 msgid ""
 "\n"
 "[-- End of S/MIME signed data. --]\n"
@@ -4434,7 +4407,7 @@ msgstr ""
 "\n"
 "[-- Ende der S/MIME signierten Daten --]\n"
 
-#: smime.c:2110
+#: smime.c:2109
 #, fuzzy
 msgid ""
 "S/MIME (s)ign, encrypt (w)ith, sign (a)s, (c)lear, or (o)ppenc mode off? "
@@ -4445,11 +4418,11 @@ msgstr ""
 #. 'clear'.  Please use a corresponding letter in your language.
 #. Alternatively, you may duplicate the letter 'c' is translated to.
 #. This comment also applies to the two following letter sequences.
-#: smime.c:2115
+#: smime.c:2114
 msgid "swafco"
 msgstr ""
 
-#: smime.c:2124
+#: smime.c:2123
 #, fuzzy
 msgid ""
 "S/MIME (e)ncrypt, (s)ign, encrypt (w)ith, sign (a)s, (b)oth, (c)lear, or "
@@ -4457,50 +4430,50 @@ msgid ""
 msgstr ""
 "S/MIME (v)erschl., (s)ign., verschl. (m)it, sign. (a)ls, (b)eides, (k)eins? "
 
-#: smime.c:2125
+#: smime.c:2124
 #, fuzzy
 msgid "eswabfco"
 msgstr "vsmabkc"
 
-#: smime.c:2133
+#: smime.c:2132
 msgid ""
 "S/MIME (e)ncrypt, (s)ign, encrypt (w)ith, sign (a)s, (b)oth, or (c)lear? "
 msgstr ""
 "S/MIME (v)erschl., (s)ign., verschl. (m)it, sign. (a)ls, (b)eides, (k)eins? "
 
-#: smime.c:2134
+#: smime.c:2133
 msgid "eswabfc"
 msgstr "vsmabkc"
 
-#: smime.c:2155
+#: smime.c:2154
 msgid "Choose algorithm family: 1: DES, 2: RC2, 3: AES, or (c)lear? "
 msgstr "Whle Algorithmus: 1: DES, 2: RC2, 3: AES, oder (u)nverschlsselt? "
 
-#: smime.c:2158
+#: smime.c:2157
 msgid "drac"
 msgstr "drau"
 
-#: smime.c:2161
+#: smime.c:2160
 msgid "1: DES, 2: Triple-DES "
 msgstr "1: DES, 2: Triple-DES "
 
-#: smime.c:2162
+#: smime.c:2161
 msgid "dt"
 msgstr "dt"
 
-#: smime.c:2174
+#: smime.c:2173
 msgid "1: RC2-40, 2: RC2-64, 3: RC2-128 "
 msgstr "1: RC2-40, 2: RC2-64, 3: RC2-128 "
 
-#: smime.c:2175
+#: smime.c:2174
 msgid "468"
 msgstr "468"
 
-#: smime.c:2190
+#: smime.c:2189
 msgid "1: AES128, 2: AES192, 3: AES256 "
 msgstr "1: AES128, 2: AES192, 3: AES256 "
 
-#: smime.c:2191
+#: smime.c:2190
 msgid "895"
 msgstr "895"
 
@@ -5149,270 +5122,222 @@ msgid "print the current entry"
 msgstr "Drucke aktuellen Eintrag"
 
 #: ../keymap_alldefs.h:149
-msgid "really delete the current entry, bypassing the trash folder"
-msgstr ""
-
-#: ../keymap_alldefs.h:150
 msgid "query external program for addresses"
 msgstr "Externe Adressenabfrage"
 
-#: ../keymap_alldefs.h:151
+#: ../keymap_alldefs.h:150
 msgid "append new query results to current results"
 msgstr "Hnge neue Abfrageergebnisse an"
 
-#: ../keymap_alldefs.h:152
+#: ../keymap_alldefs.h:151
 msgid "save changes to mailbox and quit"
 msgstr "Speichere nderungen in Mailbox und beende das Programm"
 
-#: ../keymap_alldefs.h:153
+#: ../keymap_alldefs.h:152
 msgid "recall a postponed message"
 msgstr "Bearbeite eine zurckgestellte Nachricht"
 
-#: ../keymap_alldefs.h:154
+#: ../keymap_alldefs.h:153
 msgid "clear and redraw the screen"
 msgstr "Erzeuge Bildschirmanzeige neu"
 
-#: ../keymap_alldefs.h:155
+#: ../keymap_alldefs.h:154
 msgid "{internal}"
 msgstr "{intern}"
 
-#: ../keymap_alldefs.h:156
+#: ../keymap_alldefs.h:155
 msgid "rename the current mailbox (IMAP only)"
 msgstr "benenne die aktuelle Mailbox um (nur fr IMAP)"
 
-#: ../keymap_alldefs.h:157
+#: ../keymap_alldefs.h:156
 msgid "reply to a message"
 msgstr "Beantworte Nachricht"
 
-#: ../keymap_alldefs.h:158
+#: ../keymap_alldefs.h:157
 msgid "use the current message as a template for a new one"
 msgstr "Verwende aktuelle Nachricht als Vorlage fr neue Nachricht"
 
-#: ../keymap_alldefs.h:159
+#: ../keymap_alldefs.h:158
 msgid "save message/attachment to a mailbox/file"
 msgstr "Speichere Nachricht/Anhang in Mailbox/Datei"
 
-#: ../keymap_alldefs.h:160
+#: ../keymap_alldefs.h:159
 msgid "search for a regular expression"
 msgstr "Suche nach regulrem Ausdruck"
 
-#: ../keymap_alldefs.h:161
+#: ../keymap_alldefs.h:160
 msgid "search backwards for a regular expression"
 msgstr "Suche rckwrts nach regulrem Ausdruck"
 
-#: ../keymap_alldefs.h:162
+#: ../keymap_alldefs.h:161
 msgid "search for next match"
 msgstr "Suche nchsten Treffer"
 
-#: ../keymap_alldefs.h:163
+#: ../keymap_alldefs.h:162
 msgid "search for next match in opposite direction"
 msgstr "Suche nchsten Treffer in umgekehrter Richtung"
 
-#: ../keymap_alldefs.h:164
+#: ../keymap_alldefs.h:163
 msgid "toggle search pattern coloring"
 msgstr "Schalte Suchtreffer-Hervorhebung ein/aus"
 
-#: ../keymap_alldefs.h:165
+#: ../keymap_alldefs.h:164
 msgid "invoke a command in a subshell"
 msgstr "Rufe Kommando in Shell auf"
 
-#: ../keymap_alldefs.h:166
+#: ../keymap_alldefs.h:165
 msgid "sort messages"
 msgstr "Sortiere Nachrichten"
 
-#: ../keymap_alldefs.h:167
+#: ../keymap_alldefs.h:166
 msgid "sort messages in reverse order"
 msgstr "Sortiere Nachrichten in umgekehrter Reihenfolge"
 
-#: ../keymap_alldefs.h:168
+#: ../keymap_alldefs.h:167
 msgid "tag the current entry"
 msgstr "Markiere aktuellen Eintrag"
 
-#: ../keymap_alldefs.h:169
+#: ../keymap_alldefs.h:168
 msgid "apply next function to tagged messages"
 msgstr "Wende nchste Funktion auf markierte Nachrichten an"
 
-#: ../keymap_alldefs.h:170
+#: ../keymap_alldefs.h:169
 msgid "apply next function ONLY to tagged messages"
 msgstr "Wende nchste Funktion NUR auf markierte Nachrichten an"
 
-#: ../keymap_alldefs.h:171
+#: ../keymap_alldefs.h:170
 msgid "tag the current subthread"
 msgstr "Markiere aktuellen Diskussionsfadenteil"
 
-#: ../keymap_alldefs.h:172
+#: ../keymap_alldefs.h:171
 msgid "tag the current thread"
 msgstr "Markiere aktuellen Diskussionsfaden"
 
-#: ../keymap_alldefs.h:173
+#: ../keymap_alldefs.h:172
 msgid "toggle a message's 'new' flag"
 msgstr "Setze/entferne den \"neu\"-Indikator einer Nachricht"
 
-#: ../keymap_alldefs.h:174
+#: ../keymap_alldefs.h:173
 msgid "toggle whether the mailbox will be rewritten"
 msgstr "Schalte Sichern von nderungen ein/aus"
 
-#: ../keymap_alldefs.h:175
+#: ../keymap_alldefs.h:174
 msgid "toggle whether to browse mailboxes or all files"
 msgstr "Schalte zwischen Mailboxen und allen Dateien um"
 
-#: ../keymap_alldefs.h:176
+#: ../keymap_alldefs.h:175
 msgid "move to the top of the page"
 msgstr "Springe zum Anfang der Seite"
 
-#: ../keymap_alldefs.h:177
+#: ../keymap_alldefs.h:176
 msgid "undelete the current entry"
 msgstr "Entferne Lschmarkierung vom aktuellen Eintrag"
 
-#: ../keymap_alldefs.h:178
+#: ../keymap_alldefs.h:177
 msgid "undelete all messages in thread"
 msgstr "Entferne Lschmarkierung von allen Nachrichten im Diskussionsfaden"
 
-#: ../keymap_alldefs.h:179
+#: ../keymap_alldefs.h:178
 msgid "undelete all messages in subthread"
 msgstr "Entferne Lschmarkierung von allen Nachrichten im Diskussionsfadenteil"
 
-#: ../keymap_alldefs.h:180
+#: ../keymap_alldefs.h:179
 msgid "show the Mutt version number and date"
 msgstr "Zeige Versionsnummer an"
 
-#: ../keymap_alldefs.h:181
+#: ../keymap_alldefs.h:180
 msgid "view attachment using mailcap entry if necessary"
 msgstr "Zeige Anhang, wenn ntig via Mailcap"
 
-#: ../keymap_alldefs.h:182
+#: ../keymap_alldefs.h:181
 msgid "show MIME attachments"
 msgstr "Zeige MIME-Anhnge"
 
-#: ../keymap_alldefs.h:183
+#: ../keymap_alldefs.h:182
 msgid "display the keycode for a key press"
 msgstr "Zeige Tastatur-Code einer Taste"
 
-#: ../keymap_alldefs.h:184
+#: ../keymap_alldefs.h:183
 msgid "show currently active limit pattern"
 msgstr "Zeige derzeit aktives Begrenzungsmuster"
 
-#: ../keymap_alldefs.h:185
+#: ../keymap_alldefs.h:184
 msgid "collapse/uncollapse current thread"
 msgstr "Kollabiere/expandiere aktuellen Diskussionsfaden"
 
-#: ../keymap_alldefs.h:186
+#: ../keymap_alldefs.h:185
 msgid "collapse/uncollapse all threads"
 msgstr "Kollabiere/expandiere alle Diskussionsfden"
 
-#: ../keymap_alldefs.h:187
-msgid "move the highlight to next mailbox"
-msgstr ""
-
-#: ../keymap_alldefs.h:188
-#, fuzzy
-msgid "move the highlight to next mailbox with new mail"
-msgstr "ffne nchste Mailbox mit neuen Nachrichten"
-
-#: ../keymap_alldefs.h:189
-#, fuzzy
-msgid "open highlighted mailbox"
-msgstr "ffne Mailbox erneut..."
-
-#: ../keymap_alldefs.h:190
-#, fuzzy
-msgid "scroll the sidebar down 1 page"
-msgstr "Gehe 1/2 Seite nach unten"
-
-#: ../keymap_alldefs.h:191
-#, fuzzy
-msgid "scroll the sidebar up 1 page"
-msgstr "Gehe 1/2 Seite nach oben"
-
-#: ../keymap_alldefs.h:192
-#, fuzzy
-msgid "move the highlight to previous mailbox"
-msgstr "Gehe zur vorigen Seite"
-
-#: ../keymap_alldefs.h:193
-#, fuzzy
-msgid "move the highlight to previous mailbox with new mail"
-msgstr "ffne nchste Mailbox mit neuen Nachrichten"
-
-#: ../keymap_alldefs.h:194
-msgid "make the sidebar (in)visible"
-msgstr ""
-
-#: ../keymap_alldefs.h:195
+#: ../keymap_alldefs.h:186
 msgid "attach a PGP public key"
 msgstr "Hnge ffentlichen PGP-Schlssel an"
 
-#: ../keymap_alldefs.h:196
+#: ../keymap_alldefs.h:187
 msgid "show PGP options"
 msgstr "Zeige PGP-Optionen"
 
-#: ../keymap_alldefs.h:197
+#: ../keymap_alldefs.h:188
 msgid "mail a PGP public key"
 msgstr "Verschicke ffentlichen PGP-Schlssel"
 
-#: ../keymap_alldefs.h:198
+#: ../keymap_alldefs.h:189
 msgid "verify a PGP public key"
 msgstr "Prfe ffentlichen PGP-Schlssel"
 
-#: ../keymap_alldefs.h:199
+#: ../keymap_alldefs.h:190
 msgid "view the key's user id"
 msgstr "Zeige Nutzer-ID zu Schlssel an"
 
-#: ../keymap_alldefs.h:200
+#: ../keymap_alldefs.h:191
 msgid "check for classic PGP"
 msgstr "Suche nach klassischem PGP"
 
-#: ../keymap_alldefs.h:201
-#, fuzzy
-msgid "accept the chain constructed"
+#: ../keymap_alldefs.h:192
+msgid "Accept the chain constructed"
 msgstr "Akzeptiere die erstellte Kette"
 
-#: ../keymap_alldefs.h:202
-#, fuzzy
-msgid "append a remailer to the chain"
+#: ../keymap_alldefs.h:193
+msgid "Append a remailer to the chain"
 msgstr "Hnge einen Remailer an die Kette an"
 
-#: ../keymap_alldefs.h:203
-#, fuzzy
-msgid "insert a remailer into the chain"
+#: ../keymap_alldefs.h:194
+msgid "Insert a remailer into the chain"
 msgstr "Fge einen Remailer in die Kette ein"
 
-#: ../keymap_alldefs.h:204
-#, fuzzy
-msgid "delete a remailer from the chain"
+#: ../keymap_alldefs.h:195
+msgid "Delete a remailer from the chain"
 msgstr "Lsche einen Remailer aus der Kette"
 
-#: ../keymap_alldefs.h:205
-#, fuzzy
-msgid "select the previous element of the chain"
+#: ../keymap_alldefs.h:196
+msgid "Select the previous element of the chain"
 msgstr "Whle das vorhergehende Element der Kette aus"
 
-#: ../keymap_alldefs.h:206
-#, fuzzy
-msgid "select the next element of the chain"
+#: ../keymap_alldefs.h:197
+msgid "Select the next element of the chain"
 msgstr "Whle das nchste Element der Kette aus"
 
-#: ../keymap_alldefs.h:207
+#: ../keymap_alldefs.h:198
 msgid "send the message through a mixmaster remailer chain"
 msgstr "Verschicke die Nachricht ber eine Mixmaster Remailer Kette"
 
-#: ../keymap_alldefs.h:208
+#: ../keymap_alldefs.h:199
 msgid "make decrypted copy and delete"
 msgstr "Erzeuge dechiffrierte Kopie und lsche"
 
-#: ../keymap_alldefs.h:209
+#: ../keymap_alldefs.h:200
 msgid "make decrypted copy"
 msgstr "Erzeuge dechiffrierte Kopie"
 
-#: ../keymap_alldefs.h:210
+#: ../keymap_alldefs.h:201
 msgid "wipe passphrase(s) from memory"
 msgstr "Entferne Mantra(s) aus Speicher"
 
-#: ../keymap_alldefs.h:211
+#: ../keymap_alldefs.h:202
 msgid "extract supported public keys"
 msgstr "Extrahiere untersttzte ffentliche Schlssel"
 
-#: ../keymap_alldefs.h:212
+#: ../keymap_alldefs.h:203
 msgid "show S/MIME options"
 msgstr "Zeige S/MIME Optionen"
 
@@ -5473,6 +5398,40 @@ msgstr "Zeige S/MIME Optionen"
 #~ msgid "Warning: Intermediate certificate not found."
 #~ msgstr "Warnung: Zwischenzertifikat nicht gefunden."
 
+#: compress.c:228 compress.c:253
+#, c-format
+msgid "Decompressing %s...\n"
+msgstr "Entpacke %s...\n"
+
+#: compress.c:264
+#, c-format
+msgid "Error executing: %s : unable to open the mailbox!\n"
+msgstr "Fehler beim Ausfhren von %s : Kann die Mailbox nicht ffnen!\n"
+
+#: compress.c:350 compress.c:377 compress.c:423 compress.c:454
+#, c-format
+msgid "Compressing %s...\n"
+msgstr "Komprimiere %s...\n"
+
+#: compress.c:381
+#, c-format
+msgid ""
+"%s: Error compressing mailbox! Original mailbox deleted, uncompressed one "
+"kept!\n"
+msgstr ""
+"%s: Fehler beim Komprimieren der Mailbox! Ursprngliche Mailbox gelscht, "
+"entpackte gespeichert!\n"
+
+#: compress.c:425 compress.c:456
+#, c-format
+msgid "Compressed-appending to %s...\n"
+msgstr "Hnge komprimiert an %s... an\n"
+
+#: compress.c:461
+#, c-format
+msgid " %s: Error compressing mailbox!  Uncompressed one kept!\n"
+msgstr " %s: Fehler beim packen der Mailbox! Entpackte Mailbox gespeichert!\n"
+
 #~ msgid "Clear"
 #~ msgstr "Klartext"
 
diff --git a/postpone.c b/postpone.c
index 525a72f..00a3e13 100644
--- a/postpone.c
+++ b/postpone.c
@@ -125,15 +125,26 @@ int mutt_num_postponed (int force)
 
   if (LastModify < st.st_mtime)
   {
+#ifdef USE_NNTP
+    int optnews = option (OPTNEWS);
+#endif
     LastModify = st.st_mtime;
 
     if (access (Postponed, R_OK | F_OK) != 0)
       return (PostCount = 0);
+#ifdef USE_NNTP
+    if (optnews)
+	unset_option (OPTNEWS);
+#endif
     if (mx_open_mailbox (Postponed, MUTT_NOSORT | MUTT_QUIET, &ctx) == NULL)
       PostCount = 0;
     else
       PostCount = ctx.msgcount;
     mx_fastclose_mailbox (&ctx);
+#ifdef USE_NNTP
+    if (optnews)
+	set_option (OPTNEWS);
+#endif
   }
 
   return (PostCount);
diff --git a/protos.h b/protos.h
index 19d6400..ec9c0a7 100644
--- a/protos.h
+++ b/protos.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 1996-2000,2007,2010,2013 Michael R. Elkins <me@mutt.org>
+ * Copyright (C) 2013 Karel Zak <kzak@redhat.com>
  * 
  *     This program is free software; you can redistribute it and/or modify
  *     it under the terms of the GNU General Public License as published by
@@ -36,6 +37,11 @@ struct hdr_format_info
   const char *pager_progress;
 };
 
+typedef enum {
+  kXDGConfigHome,  /* $XDG_CONFIG_HOME */
+  kXDGConfigDirs,  /* $XDG_CONFIG_DIRS */
+} XDGType;
+
 void mutt_make_string_info (char *, size_t, int, const char *, struct hdr_format_info *, format_flag);
 
 int mutt_extract_token (BUFFER *, BUFFER *, int);
@@ -79,6 +85,9 @@ void mutt_generate_boundary (PARAMETER **);
 void mutt_delete_parameter (const char *attribute, PARAMETER **p);
 void mutt_set_parameter (const char *, const char *, PARAMETER **);
 
+#ifdef USE_NOTMUCH
+int mutt_parse_virtual_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *err);
+#endif
 
 FILE *mutt_open_read (const char *, pid_t *);
 
@@ -111,6 +120,7 @@ HASH *mutt_make_id_hash (CONTEXT *);
 HASH *mutt_make_subj_hash (CONTEXT *);
 
 LIST *mutt_make_references(ENVELOPE *e);
+LIST *mutt_parse_references (char *, int);
 
 char *mutt_read_rfc822_line (FILE *, char *, size_t *);
 ENVELOPE *mutt_read_rfc822_header (FILE *, HEADER *, short, short);
@@ -149,6 +159,8 @@ const char *mutt_get_name (ADDRESS *);
 char *mutt_get_parameter (const char *, PARAMETER *);
 LIST *mutt_crypt_hook (ADDRESS *);
 char *mutt_make_date (char *, size_t);
+void mutt_timeout_hook (void);
+int mutt_set_xdg_path(const XDGType type, char *buf, size_t bufsize);
 
 const char *mutt_make_version (void);
 
@@ -182,10 +194,17 @@ void mutt_decode_base64 (STATE *s, long len, int istext, iconv_t cd);
 void mutt_default_save (char *, size_t, HEADER *);
 void mutt_display_address (ENVELOPE *);
 void mutt_display_sanitize (char *);
+void mutt_draw_statusline (int cols, const char *buf, int buflen);
 void mutt_edit_content_type (HEADER *, BODY *, FILE *);
 void mutt_edit_file (const char *, const char *);
 void mutt_edit_headers (const char *, const char *, HEADER *, char *, size_t);
 int mutt_filter_unprintable (char **);
+void mutt_label_ref_dec(ENVELOPE *);
+void mutt_label_ref_inc(ENVELOPE *);
+int mutt_label_message (HEADER *);
+void mutt_scan_labels (CONTEXT *);
+int mutt_label_complete (char *, size_t, int, int);
+char *mutt_labels(char *, int, ENVELOPE *, char *);
 void mutt_curses_error (const char *, ...);
 void mutt_curses_message (const char *, ...);
 void mutt_encode_descriptions (BODY *, short);
@@ -286,6 +305,10 @@ int mutt_check_overwrite (const char *, const char *, char *, size_t, int *, cha
 int mutt_check_traditional_pgp (HEADER *, int *);
 int mutt_command_complete (char *, size_t, int, int);
 int mutt_var_value_complete (char *, size_t, int);
+#if USE_NOTMUCH
+int mutt_nm_query_complete (char *buffer, size_t len, int pos, int numtabs);
+int mutt_nm_tag_complete (char *buffer, size_t len, int pos, int numtabs);
+#endif
 int mutt_complete (char *, size_t);
 int mutt_compose_attachment (BODY *a);
 int mutt_copy_body (FILE *, BODY **, BODY *);
@@ -301,8 +324,10 @@ int mutt_chscmp (const char *s, const char *chs);
 int mutt_parent_message (CONTEXT *, HEADER *);
 int mutt_prepare_template(FILE*, CONTEXT *, HEADER *, HEADER *, short);
 int mutt_resend_message (FILE *, CONTEXT *, HEADER *);
-#define mutt_enter_fname(A,B,C,D,E) _mutt_enter_fname(A,B,C,D,E,0,NULL,NULL)
-int _mutt_enter_fname (const char *, char *, size_t, int *, int, int, char ***, int *);
+#define mutt_enter_fname(A,B,C,D,E) _mutt_enter_fname(A,B,C,D,E,0,NULL,NULL,0)
+#define mutt_enter_vfolder(A,B,C,D,E) _mutt_enter_fname(A,B,C,D,E,0,NULL,NULL,MUTT_SEL_VFOLDER)
+
+int _mutt_enter_fname (const char *, char *, size_t, int *, int, int, char ***, int *, int);
 int  mutt_enter_string (char *buf, size_t buflen, int col, int flags);
 int _mutt_enter_string (char *, size_t, int, int, int, char ***, int *, ENTER_STATE *);
 #define mutt_get_field(A,B,C,D) _mutt_get_field(A,B,C,D,0,NULL,NULL)
@@ -367,7 +392,8 @@ int mutt_user_is_recipient (HEADER *);
 void mutt_update_num_postponed (void);
 int mutt_wait_filter (pid_t);
 int mutt_which_case (const char *);
-int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int, char *);
+int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int, char *, char **);
+int mutt_write_multiple_fcc (const char *path, HEADER *hdr, const char *msgid, int, char *, char **);
 int mutt_write_mime_body (BODY *, FILE *);
 int mutt_write_mime_header (BODY *, FILE *);
 int mutt_write_one_header (FILE *fp, const char *tag, const char *value, const char *pfx, int wraplen, int flags);
@@ -377,6 +403,11 @@ int mutt_yesorno (const char *, int);
 void mutt_set_header_color(CONTEXT *, HEADER *);
 void mutt_sleep (short);
 int mutt_save_confirm (const char  *, struct stat *);
+void mutt_randbuf(void *out, size_t len);
+#define MUTT_RANDTAG_LEN (16)
+void mutt_rand_base32(void *out, size_t len);
+uint32_t mutt_rand32(void);
+uint64_t mutt_rand64(void);
 
 int mh_valid_message (const char *);
 
@@ -424,16 +455,6 @@ void mutt_pattern_free (pattern_t **pat);
 #define LONGLONG long
 #endif
 
-#ifdef HAVE_SRAND48
-#define LRAND lrand48
-#define SRAND srand48
-#define DRAND drand48
-#else
-#define LRAND rand
-#define SRAND srand
-#define DRAND (double)rand
-#endif /* HAVE_SRAND48 */
-
 /* HP-UX, ConvexOS and UNIXware don't have this macro */
 #ifndef S_ISLNK
 #define S_ISLNK(x) (((x) & S_IFMT) == S_IFLNK ? 1 : 0)
@@ -567,3 +588,11 @@ char *strcasestr (const char *, const char *);
 #ifndef HAVE_MKDTEMP
 char *mkdtemp (char *tmpl);
 #endif
+
+#ifndef HAVE_STRNLEN
+size_t strnlen(const char *s, size_t maxlen);
+#endif
+
+#ifndef strndup
+char *strndup(const char *s, size_t n);
+#endif
diff --git a/recvattach.c b/recvattach.c
index fb31318..39a26c0 100644
--- a/recvattach.c
+++ b/recvattach.c
@@ -1121,6 +1121,15 @@ void mutt_view_attachments (HEADER *hdr)
 	}
 #endif
 
+#ifdef USE_NNTP
+	if (Context->magic == MUTT_NNTP)
+	{
+	  mutt_flushinp ();
+	  mutt_error _("Can't delete attachment from news server.");
+	  break;
+	}
+#endif
+
         if (WithCrypto && (hdr->security & ENCRYPT))
         {
           mutt_message _(
@@ -1215,10 +1224,33 @@ void mutt_view_attachments (HEADER *hdr)
       case OP_FORWARD_MESSAGE:
         CHECK_ATTACH;
         mutt_attach_forward (fp, hdr, idx, idxlen,
-			     menu->tagprefix ? NULL : idx[menu->current]->content);
+			     menu->tagprefix ? NULL : idx[menu->current]->content, 0);
         menu->redraw = REDRAW_FULL;
         break;
       
+#ifdef USE_NNTP
+      case OP_FORWARD_TO_GROUP:
+	CHECK_ATTACH;
+	mutt_attach_forward (fp, hdr, idx, idxlen,
+		menu->tagprefix ? NULL : idx[menu->current]->content, SENDNEWS);
+	menu->redraw = REDRAW_FULL;
+	break;
+
+      case OP_FOLLOWUP:
+	CHECK_ATTACH;
+
+	if (!idx[menu->current]->content->hdr->env->followup_to ||
+	    mutt_strcasecmp (idx[menu->current]->content->hdr->env->followup_to, "poster") ||
+	    query_quadoption (OPT_FOLLOWUPTOPOSTER,_("Reply by mail as poster prefers?")) != MUTT_YES)
+	{
+	  mutt_attach_reply (fp, hdr, idx, idxlen,
+		menu->tagprefix ? NULL : idx[menu->current]->content,
+		SENDNEWS|SENDREPLY);
+	  menu->redraw = REDRAW_FULL;
+	  break;
+	}
+#endif
+
       case OP_REPLY:
       case OP_GROUP_REPLY:
       case OP_LIST_REPLY:
diff --git a/recvcmd.c b/recvcmd.c
index cd19e9f..7f310be 100644
--- a/recvcmd.c
+++ b/recvcmd.c
@@ -401,7 +401,7 @@ static BODY ** copy_problematic_attachments (FILE *fp,
 static void attach_forward_bodies (FILE * fp, HEADER * hdr,
 				   ATTACHPTR ** idx, short idxlen,
 				   BODY * cur,
-				   short nattach)
+				   short nattach, int flags)
 {
   short i;
   short mime_fwd_all = 0;
@@ -547,7 +547,7 @@ _("Can't decode all tagged attachments.  MIME-forward the others?"))) == -1)
   tmpfp = NULL;
 
   /* now that we have the template, send it. */
-  ci_send_message (0, tmphdr, tmpbody, NULL, parent);
+  ci_send_message (flags, tmphdr, tmpbody, NULL, parent);
   return;
   
   bail:
@@ -574,7 +574,7 @@ _("Can't decode all tagged attachments.  MIME-forward the others?"))) == -1)
  */
 
 static void attach_forward_msgs (FILE * fp, HEADER * hdr, 
-	       ATTACHPTR ** idx, short idxlen, BODY * cur)
+	       ATTACHPTR ** idx, short idxlen, BODY * cur, int flags)
 {
   HEADER *curhdr = NULL;
   HEADER *tmphdr;
@@ -679,23 +679,23 @@ static void attach_forward_msgs (FILE * fp, HEADER * hdr,
   else
     mutt_free_header (&tmphdr);
 
-  ci_send_message (0, tmphdr, *tmpbody ? tmpbody : NULL, 
+  ci_send_message (flags, tmphdr, *tmpbody ? tmpbody : NULL, 
 		   NULL, curhdr);
 
 }
 
 void mutt_attach_forward (FILE * fp, HEADER * hdr, 
-			  ATTACHPTR ** idx, short idxlen, BODY * cur)
+			  ATTACHPTR ** idx, short idxlen, BODY * cur, int flags)
 {
   short nattach;
   
 
   if (check_all_msg (idx, idxlen, cur, 0) == 0)
-    attach_forward_msgs (fp, hdr, idx, idxlen, cur);
+    attach_forward_msgs (fp, hdr, idx, idxlen, cur, flags);
   else
   {
     nattach = count_tagged (idx, idxlen);
-    attach_forward_bodies (fp, hdr, idx, idxlen, cur, nattach);
+    attach_forward_bodies (fp, hdr, idx, idxlen, cur, nattach, flags);
   }
 }
 
@@ -753,28 +753,40 @@ attach_reply_envelope_defaults (ENVELOPE *env, ATTACHPTR **idx, short idxlen,
     return -1;
   }
 
-  if (parent)
+#ifdef USE_NNTP
+  if ((flags & SENDNEWS))
   {
-    if (mutt_fetch_recips (env, curenv, flags) == -1)
-      return -1;
+    /* in case followup set Newsgroups: with Followup-To: if it present */
+    if (!env->newsgroups && curenv &&
+	mutt_strcasecmp (curenv->followup_to, "poster"))
+      env->newsgroups = safe_strdup (curenv->followup_to);
   }
   else
+#endif
   {
-    for (i = 0; i < idxlen; i++)
+    if (parent)
     {
-      if (idx[i]->content->tagged
-	  && mutt_fetch_recips (env, idx[i]->content->hdr->env, flags) == -1)
+      if (mutt_fetch_recips (env, curenv, flags) == -1)
 	return -1;
     }
+    else
+    {
+      for (i = 0; i < idxlen; i++)
+      {
+	if (idx[i]->content->tagged
+	    && mutt_fetch_recips (env, idx[i]->content->hdr->env, flags) == -1)
+	  return -1;
+      }
+    }
+
+    if ((flags & SENDLISTREPLY) && !env->to)
+    {
+      mutt_error _("No mailing lists found!");
+      return (-1);
+    }
+
+    mutt_fix_reply_recipients (env);
   }
-  
-  if ((flags & SENDLISTREPLY) && !env->to)
-  {
-    mutt_error _("No mailing lists found!");
-    return (-1);
-  }
-  
-  mutt_fix_reply_recipients (env);
   mutt_make_misc_reply_headers (env, Context, curhdr, curenv);
 
   if (parent)
@@ -835,6 +847,13 @@ void mutt_attach_reply (FILE * fp, HEADER * hdr,
   char prefix[SHORT_STRING];
   int rc;
   
+#ifdef USE_NNTP
+  if (flags & SENDNEWS)
+    set_option (OPTNEWSSEND);
+  else
+    unset_option (OPTNEWSSEND);
+#endif
+
   if (check_all_msg (idx, idxlen, cur, 0) == -1)
   {
     nattach = count_tagged (idx, idxlen);
diff --git a/send.c b/send.c
index d54d495..007218f 100644
--- a/send.c
+++ b/send.c
@@ -44,10 +44,18 @@
 #include <sys/types.h>
 #include <utime.h>
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#include "mx.h"
+#endif
+
 #ifdef MIXMASTER
 #include "remailer.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
 
 static void append_signature (FILE *f)
 {
@@ -213,17 +221,51 @@ static int edit_address (ADDRESS **a, /* const */ char *field)
   return 0;
 }
 
-static int edit_envelope (ENVELOPE *en)
+static int edit_envelope (ENVELOPE *en, int flags)
 {
   char buf[HUGE_STRING];
   LIST *uh = UserHeader;
 
-  if (edit_address (&en->to, "To: ") == -1 || en->to == NULL)
-    return (-1);
-  if (option (OPTASKCC) && edit_address (&en->cc, "Cc: ") == -1)
-    return (-1);
-  if (option (OPTASKBCC) && edit_address (&en->bcc, "Bcc: ") == -1)
-    return (-1);
+#ifdef USE_NNTP
+  if (option (OPTNEWSSEND))
+  {
+    if (en->newsgroups)
+      strfcpy (buf, en->newsgroups, sizeof (buf));
+    else
+      buf[0] = 0;
+    if (mutt_get_field ("Newsgroups: ", buf, sizeof (buf), 0) != 0)
+      return (-1);
+    FREE (&en->newsgroups);
+    en->newsgroups = safe_strdup (buf);
+
+    if (en->followup_to)
+      strfcpy (buf, en->followup_to, sizeof (buf));
+    else
+      buf[0] = 0;
+    if (option (OPTASKFOLLOWUP) && mutt_get_field ("Followup-To: ", buf, sizeof (buf), 0) != 0)
+      return (-1);
+    FREE (&en->followup_to);
+    en->followup_to = safe_strdup (buf);
+
+    if (en->x_comment_to)
+      strfcpy (buf, en->x_comment_to, sizeof (buf));
+    else
+      buf[0] = 0;
+    if (option (OPTXCOMMENTTO) && option (OPTASKXCOMMENTTO) && mutt_get_field ("X-Comment-To: ", buf, sizeof (buf), 0) != 0)
+      return (-1);
+    FREE (&en->x_comment_to);
+    en->x_comment_to = safe_strdup (buf);
+  }
+  else
+#endif
+  {
+    if (edit_address (&en->to, "To: ") == -1 || en->to == NULL)
+      return (-1);
+    if (option (OPTASKCC) && edit_address (&en->cc, "Cc: ") == -1)
+      return (-1);
+    if (option (OPTASKBCC) && edit_address (&en->bcc, "Bcc: ") == -1)
+      return (-1);
+  }
 
   if (en->subject)
   {
@@ -258,6 +300,14 @@ static int edit_envelope (ENVELOPE *en)
   return 0;
 }
 
+#ifdef USE_NNTP
+char *nntp_get_header (const char *s)
+{
+  SKIPWS (s);
+  return safe_strdup (s);
+}
+#endif
+
 static void process_user_recips (ENVELOPE *env)
 {
   LIST *uh = UserHeader;
@@ -270,6 +320,14 @@ static void process_user_recips (ENVELOPE *env)
       env->cc = rfc822_parse_adrlist (env->cc, uh->data + 3);
     else if (ascii_strncasecmp ("bcc:", uh->data, 4) == 0)
       env->bcc = rfc822_parse_adrlist (env->bcc, uh->data + 4);
+#ifdef USE_NNTP
+    else if (ascii_strncasecmp ("newsgroups:", uh->data, 11) == 0)
+      env->newsgroups = nntp_get_header (uh->data + 11);
+    else if (ascii_strncasecmp ("followup-to:", uh->data, 12) == 0)
+      env->followup_to = nntp_get_header (uh->data + 12);
+    else if (ascii_strncasecmp ("x-comment-to:", uh->data, 13) == 0)
+      env->x_comment_to = nntp_get_header (uh->data + 13);
+#endif
   }
 }
 
@@ -308,6 +366,12 @@ static void process_user_header (ENVELOPE *env)
     else if (ascii_strncasecmp ("to:", uh->data, 3) != 0 &&
 	     ascii_strncasecmp ("cc:", uh->data, 3) != 0 &&
 	     ascii_strncasecmp ("bcc:", uh->data, 4) != 0 &&
+#ifdef USE_NNTP
+	     ascii_strncasecmp ("newsgroups:", uh->data, 11) != 0 &&
+	     ascii_strncasecmp ("followup-to:", uh->data, 12) != 0 &&
+	     ascii_strncasecmp ("x-comment-to:", uh->data, 13) != 0 &&
+#endif
+	     ascii_strncasecmp ("supersedes:", uh->data, 11) != 0 &&
 	     ascii_strncasecmp ("subject:", uh->data, 8) != 0 &&
 	     ascii_strncasecmp ("return-path:", uh->data, 12) != 0)
     {
@@ -659,6 +723,10 @@ void mutt_add_to_reference_headers (ENVELOPE *env, ENVELOPE *curenv, LIST ***pp,
   if (pp) *pp = p;
   if (qq) *qq = q;
   
+#ifdef USE_NNTP
+  if (option (OPTNEWSSEND) && option (OPTXCOMMENTTO) && curenv->from)
+    env->x_comment_to = safe_strdup (mutt_get_name (curenv->from));
+#endif
 }
 
 static void 
@@ -721,6 +789,16 @@ envelope_defaults (ENVELOPE *env, CONTEXT *ctx, HEADER *cur, int flags)
 
   if (flags & SENDREPLY)
   {
+#ifdef USE_NNTP
+    if ((flags & SENDNEWS))
+    {
+      /* in case followup set Newsgroups: with Followup-To: if it present */
+      if (!env->newsgroups && curenv &&
+	  mutt_strcasecmp (curenv->followup_to, "poster"))
+	env->newsgroups = safe_strdup (curenv->followup_to);
+    }
+    else
+#endif
     if (tag)
     {
       HEADER *h;
@@ -867,7 +945,18 @@ void mutt_set_followup_to (ENVELOPE *e)
    * it hasn't already been set
    */
 
-  if (option (OPTFOLLOWUPTO) && !e->mail_followup_to)
+  if (!option (OPTFOLLOWUPTO))
+    return;
+#ifdef USE_NNTP
+  if (option (OPTNEWSSEND))
+  {
+    if (!e->followup_to && e->newsgroups && (strrchr (e->newsgroups, ',')))
+      e->followup_to = safe_strdup (e->newsgroups);
+    return;
+  }
+#endif
+
+  if (!e->mail_followup_to)
   {
     if (mutt_is_list_cc (0, e->to, e->cc))
     {
@@ -1029,6 +1118,9 @@ static int send_message (HEADER *msg)
 #endif
 
 #if USE_SMTP
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
   if (SmtpUrl)
       return mutt_smtp_send (msg->env->from, msg->env->to, msg->env->cc,
                              msg->env->bcc, tempfile,
@@ -1164,9 +1256,17 @@ ci_send_message (int flags,		/* send mode */
   char *smime_default_key = NULL;
   char *tag = NULL, *err = NULL;
   char *ctype;
+  char *finalpath = NULL;
 
   int rv = -1;
   
+#ifdef USE_NNTP
+  if (flags & SENDNEWS)
+    set_option (OPTNEWSSEND);
+  else
+    unset_option (OPTNEWSSEND);
+#endif
+
   if (!flags && !msg && quadoption (OPT_RECALL) != MUTT_NO &&
       mutt_num_postponed (1))
   {
@@ -1202,6 +1302,22 @@ ci_send_message (int flags,		/* send mode */
     {
       if ((flags = mutt_get_postponed (ctx, msg, &cur, fcc, sizeof (fcc))) < 0)
 	goto cleanup;
+#ifdef USE_NNTP
+      /*
+       * If postponed message is a news article, it have
+       * a "Newsgroups:" header line, then set appropriate flag.
+       */
+      if (msg->env->newsgroups)
+      {
+	flags |= SENDNEWS;
+	set_option (OPTNEWSSEND);
+      }
+      else
+      {
+	flags &= ~SENDNEWS;
+	unset_option (OPTNEWSSEND);
+      }
+#endif
     }
 
     if (flags & (SENDPOSTPONED|SENDRESEND))
@@ -1303,11 +1419,16 @@ ci_send_message (int flags,		/* send mode */
     if (flags & SENDREPLY)
       mutt_fix_reply_recipients (msg->env);
 
+#ifdef USE_NNTP
+    if ((flags & SENDNEWS) && ctx && ctx->magic == MUTT_NNTP && !msg->env->newsgroups)
+      msg->env->newsgroups = safe_strdup (((NNTP_DATA *)ctx->data)->group);
+#endif
+
     if (! (flags & (SENDMAILX|SENDBATCH)) &&
 	! (option (OPTAUTOEDIT) && option (OPTEDITHDRS)) &&
 	! ((flags & SENDREPLY) && option (OPTFASTREPLY)))
     {
-      if (edit_envelope (msg->env) == -1)
+      if (edit_envelope (msg->env, flags) == -1)
 	goto cleanup;
     }
 
@@ -1606,6 +1727,11 @@ main_loop:
     if (i == -1)
     {
       /* abort */
+#ifdef USE_NNTP
+      if (flags & SENDNEWS)
+	mutt_message _("Article not posted.");
+      else
+#endif
       mutt_message _("Mail not sent.");
       goto cleanup;
     }
@@ -1647,7 +1773,9 @@ main_loop:
       mutt_prepare_envelope (msg->env, 0);
       mutt_env_to_intl (msg->env, NULL, NULL);	/* Handle bad IDNAs the next time. */
 
-      if (!Postponed || mutt_write_fcc (NONULL (Postponed), msg, (cur && (flags & SENDREPLY)) ? cur->env->message_id : NULL, 1, fcc) < 0)
+      if (!Postponed || mutt_write_fcc (NONULL (Postponed), msg,
+	                    (cur && (flags & SENDREPLY)) ?
+			             cur->env->message_id : NULL, 1, fcc, NULL) < 0)
       {
 	msg->content = mutt_remove_multipart (msg->content);
 	decode_descriptions (msg->content);
@@ -1661,6 +1789,9 @@ main_loop:
     }
   }
 
+#ifdef USE_NNTP
+  if (!(flags & SENDNEWS))
+#endif
   if (!has_recips (msg->env->to) && !has_recips (msg->env->cc) &&
       !has_recips (msg->env->bcc))
   {
@@ -1694,6 +1825,19 @@ main_loop:
       mutt_error _("No subject specified.");
     goto main_loop;
   }
+#ifdef USE_NNTP
+  if ((flags & SENDNEWS) && !msg->env->subject)
+  {
+    mutt_error _("No subject specified.");
+    goto main_loop;
+  }
+
+  if ((flags & SENDNEWS) && !msg->env->newsgroups)
+  {
+    mutt_error _("No newsgroup specified.");
+    goto main_loop;
+  }
+#endif
 
   if (msg->content->next)
     msg->content = mutt_make_multipart (msg->content);
@@ -1831,7 +1975,7 @@ full_fcc:
        * message was first postponed.
        */
       msg->received = time (NULL);
-      if (mutt_write_fcc (fcc, msg, NULL, 0, NULL) == -1)
+      if (mutt_write_multiple_fcc (fcc, msg, NULL, 0, NULL, &finalpath) == -1)
       {
 	/*
 	 * Error writing FCC, we should abort sending.
@@ -1892,6 +2036,7 @@ full_fcc:
       msg->content = mutt_remove_multipart (msg->content);
       decode_descriptions (msg->content);
       mutt_unprepare_envelope (msg->env);
+      FREE(&finalpath);
       goto main_loop;
     }
     else
@@ -1900,8 +2045,18 @@ full_fcc:
       goto cleanup;
     }
   }
-  else if (!option (OPTNOCURSES) && ! (flags & SENDMAILX))
-    mutt_message (i == 0 ? _("Mail sent.") : _("Sending in background."));
+  else if (!option (OPTNOCURSES) && ! (flags & SENDMAILX)) {
+    mutt_message (i != 0 ? _("Sending in background.") :
+#ifdef USE_NNTP
+		  (flags & SENDNEWS) ? _("Article posted.") : _("Mail sent."));
+#else
+		  _("Mail sent."));
+#endif
+#ifdef USE_NOTMUCH
+    if (option(OPTNOTMUCHRECORD))
+      nm_record_message(ctx, finalpath, cur);
+#endif
+  }
 
   if (WithCrypto && (msg->security & ENCRYPT))
     FREE (&pgpkeylist);
@@ -1946,7 +2101,8 @@ cleanup:
   safe_fclose (&tempfp);
   if (! (flags & SENDNOFREEHEADER))
     mutt_free_header (&msg);
-  
+
+  FREE(&finalpath);
   return rv;
 }
 
diff --git a/sendlib.c b/sendlib.c
index 771eae2..2ebf455 100644
--- a/sendlib.c
+++ b/sendlib.c
@@ -46,6 +46,10 @@
 #include <sys/wait.h>
 #include <fcntl.h>
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
+
 #ifdef HAVE_SYSEXITS_H
 #include <sysexits.h>
 #else /* Make sure EX_OK is defined <philiph@pobox.com> */
@@ -73,8 +77,6 @@ const char B64Chars[64] = {
   '8', '9', '+', '/'
 };
 
-static char MsgIdPfx = 'A';
-
 static void transform_to_7bit (BODY *a, FILE *fpin);
 
 static void encode_quoted (FGETCONV * fc, FILE *fout, int istext)
@@ -480,18 +482,12 @@ int mutt_write_mime_body (BODY *a, FILE *f)
 
 #undef write_as_text_part
 
-#define BOUNDARYLEN 16
 void mutt_generate_boundary (PARAMETER **parm)
 {
-  char rs[BOUNDARYLEN + 1];
-  char *p = rs;
-  int i;
-
-  rs[BOUNDARYLEN] = 0;
-  for (i=0;i<BOUNDARYLEN;i++)
-    *p++ = B64Chars[LRAND() % sizeof (B64Chars)];
-  *p = 0;
+  char rs[MUTT_RANDTAG_LEN + 1];
 
+  mutt_rand_base32(rs, sizeof(rs) - 1);
+  rs[MUTT_RANDTAG_LEN] = 0;
   mutt_set_parameter ("boundary", rs, parm);
 }
 
@@ -1546,6 +1542,14 @@ void mutt_write_references (LIST *r, FILE *f, int trim)
 {
   LIST **ref = NULL;
   int refcnt = 0, refmax = 0;
+  int multiline = 1;
+  int space = 0;
+
+  if (trim < 0)
+  {
+    trim = -trim;
+    multiline = 0;
+  }
 
   for ( ; (trim == 0 || refcnt < trim) && r ; r = r->next)
   {
@@ -1556,9 +1560,11 @@ void mutt_write_references (LIST *r, FILE *f, int trim)
 
   while (refcnt-- > 0)
   {
-    fputc (' ', f);
+    if (multiline || space)
+      fputc (' ', f);
+    space = 1;
     fputs (ref[refcnt]->data, f);
-    if (refcnt >= 1)
+    if (multiline && refcnt >= 1)
       fputc ('\n', f);
   }
 
@@ -1972,6 +1978,9 @@ int mutt_write_rfc822_header (FILE *fp, ENVELOPE *env, BODY *attach,
     mutt_write_address_list (env->to, fp, 4, 0);
   }
   else if (mode > 0)
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
     fputs ("To: \n", fp);
 
   if (env->cc)
@@ -1980,6 +1989,9 @@ int mutt_write_rfc822_header (FILE *fp, ENVELOPE *env, BODY *attach,
     mutt_write_address_list (env->cc, fp, 4, 0);
   }
   else if (mode > 0)
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
     fputs ("Cc: \n", fp);
 
   if (env->bcc)
@@ -1991,8 +2003,28 @@ int mutt_write_rfc822_header (FILE *fp, ENVELOPE *env, BODY *attach,
     }
   }
   else if (mode > 0)
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
     fputs ("Bcc: \n", fp);
 
+#ifdef USE_NNTP
+  if (env->newsgroups)
+    fprintf (fp, "Newsgroups: %s\n", env->newsgroups);
+  else if (mode == 1 && option (OPTNEWSSEND))
+    fputs ("Newsgroups: \n", fp);
+
+  if (env->followup_to)
+    fprintf (fp, "Followup-To: %s\n", env->followup_to);
+  else if (mode == 1 && option (OPTNEWSSEND))
+    fputs ("Followup-To: \n", fp);
+
+  if (env->x_comment_to)
+    fprintf (fp, "X-Comment-To: %s\n", env->x_comment_to);
+  else if (mode == 1 && option (OPTNEWSSEND) && option (OPTXCOMMENTTO))
+    fputs ("X-Comment-To: \n", fp);
+#endif
+
   if (env->subject)
     mutt_write_one_header (fp, "Subject", env->subject, NULL, 0, 0);
   else if (mode == 1)
@@ -2011,6 +2043,9 @@ int mutt_write_rfc822_header (FILE *fp, ENVELOPE *env, BODY *attach,
     fputs ("Reply-To: \n", fp);
 
   if (env->mail_followup_to)
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
   {
     fputs ("Mail-Followup-To: ", fp);
     mutt_write_address_list (env->mail_followup_to, fp, 18, 0);
@@ -2072,7 +2107,7 @@ int mutt_write_rfc822_header (FILE *fp, ENVELOPE *env, BODY *attach,
   if (mode == 0 && !privacy && option (OPTXMAILER) && !has_agent)
   {
     /* Add a vanity header */
-    fprintf (fp, "User-Agent: Mutt/%s (%s)\n", MUTT_VERSION, ReleaseDate);
+    fprintf (fp, "User-Agent: NeoMutt/%s (%s)\n", PACKAGE_VERSION, OldMuttVer);
   }
 
   return (ferror (fp) == 0 ? 0 : -1);
@@ -2136,16 +2171,18 @@ char *mutt_gen_msgid (void)
   time_t now;
   struct tm *tm;
   const char *fqdn;
+  unsigned char rndid[MUTT_RANDTAG_LEN + 1];
 
+  mutt_rand_base32(rndid, sizeof(rndid) - 1);
+  rndid[MUTT_RANDTAG_LEN] = 0;
   now = time (NULL);
   tm = gmtime (&now);
   if(!(fqdn = mutt_fqdn(0)))
     fqdn = NONULL(Hostname);
 
-  snprintf (buf, sizeof (buf), "<%d%02d%02d%02d%02d%02d.G%c%u@%s>",
+  snprintf (buf, sizeof (buf), "<%d%02d%02d%02d%02d%02d.%s@%s>",
 	    tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour,
-	    tm->tm_min, tm->tm_sec, MsgIdPfx, (unsigned int)getpid (), fqdn);
-  MsgIdPfx = (MsgIdPfx == 'Z') ? 'A' : MsgIdPfx + 1;
+	    tm->tm_min, tm->tm_sec, rndid, fqdn);
   return (safe_strdup (buf));
 }
 
@@ -2354,6 +2391,23 @@ mutt_invoke_sendmail (ADDRESS *from,	/* the sender */
   size_t argslen = 0, argsmax = 0;
   int i;
 
+#ifdef USE_NNTP
+  if (option (OPTNEWSSEND))
+  {
+    char cmd[LONG_STRING];
+
+    mutt_FormatString (cmd, sizeof (cmd), 0, MuttIndexWindow->cols, NONULL (Inews), nntp_format_str, 0, 0);
+    if (!*cmd)
+    {
+      i = nntp_post (msg);
+      unlink (msg);
+      return i;
+    }
+
+    s = safe_strdup (cmd);
+  }
+#endif
+
   /* ensure that $sendmail is set to avoid a crash. http://dev.mutt.org/trac/ticket/3548 */
   if (!s)
   {
@@ -2384,6 +2438,10 @@ mutt_invoke_sendmail (ADDRESS *from,	/* the sender */
     i++;
   }
 
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+  {
+#endif
   if (eightbit && option (OPTUSE8BITMIME))
     args = add_option (args, &argslen, &argsmax, "-B8BITMIME");
 
@@ -2415,6 +2473,9 @@ mutt_invoke_sendmail (ADDRESS *from,	/* the sender */
   args = add_args (args, &argslen, &argsmax, to);
   args = add_args (args, &argslen, &argsmax, cc);
   args = add_args (args, &argslen, &argsmax, bcc);
+#ifdef USE_NNTP
+  }
+#endif
 
   if (argslen == argsmax)
     safe_realloc (&args, sizeof (char *) * (++argsmax));
@@ -2492,9 +2553,11 @@ void mutt_prepare_envelope (ENVELOPE *env, int final)
   rfc2047_encode_adrlist (env->from, "From");
   rfc2047_encode_adrlist (env->mail_followup_to, "Mail-Followup-To");
   rfc2047_encode_adrlist (env->reply_to, "Reply-To");
-  rfc2047_encode_string (&env->x_label);
 
   if (env->subject)
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND) || option (OPTMIMESUBJECT))
+#endif
   {
     rfc2047_encode_string (&env->subject);
   }
@@ -2517,7 +2580,6 @@ void mutt_unprepare_envelope (ENVELOPE *env)
   rfc2047_decode_adrlist (env->from);
   rfc2047_decode_adrlist (env->reply_to);
   rfc2047_decode (&env->subject);
-  rfc2047_decode (&env->x_label);
 }
 
 static int _mutt_bounce_message (FILE *fp, HEADER *h, ADDRESS *to, const char *resent_from,
@@ -2562,9 +2624,12 @@ static int _mutt_bounce_message (FILE *fp, HEADER *h, ADDRESS *to, const char *r
     mutt_copy_header (fp, h, f, ch_flags, NULL);
     fputc ('\n', f);
     mutt_copy_bytes (fp, f, h->content->length);
-    safe_fclose (&f);
     FREE (&msgid_str);
-
+    if (safe_fclose (&f) != 0) {
+      mutt_perror(tempfile);
+      unlink(tempfile);
+      return -1;
+    }
 #if USE_SMTP
     if (SmtpUrl)
       ret = mutt_smtp_send (env_from, to, NULL, NULL, tempfile,
@@ -2615,6 +2680,10 @@ int mutt_bounce_message (FILE *fp, HEADER *h, ADDRESS *to)
   }
   rfc822_write_address (resent_from, sizeof (resent_from), from, 0);
 
+#ifdef USE_NNTP
+  unset_option (OPTNEWSSEND);
+#endif
+
   /*
    * prepare recipient list. idna conversion appears to happen before this
    * function is called, since the user receives confirmation of the address
@@ -2690,7 +2759,44 @@ static void set_noconv_flags (BODY *b, short flag)
   }
 }
 
-int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int post, char *fcc)
+/* Handle a Fcc with multiple, comma separated entries. */
+int mutt_write_multiple_fcc (const char *path, HEADER *hdr, const char *msgid,
+        int post, char *fcc, char **finalpath)
+{
+  char fcc_tok[_POSIX_PATH_MAX];
+  char fcc_expanded[_POSIX_PATH_MAX];
+  char *tok = NULL;
+  int status;
+
+  strfcpy(fcc_tok, path, sizeof (fcc_tok));
+
+  tok = strtok(fcc_tok, ",");
+  dprint(1, (debugfile, "Fcc: initial mailbox = '%s'\n", tok));
+  /* mutt_expand_path already called above for the first token */
+  status = mutt_write_fcc (tok, hdr, msgid, post, fcc, finalpath);
+  if (status != 0)
+    return status;
+
+  while ((tok = strtok (NULL, ",")) != NULL)
+  {
+    if (!*tok)
+      continue;
+
+    /* Only call mutt_expand_path iff tok has some data */
+    dprint (1, (debugfile, "Fcc: additional mailbox token = '%s'\n", tok));
+    strfcpy (fcc_expanded, tok, sizeof (fcc_expanded));
+    mutt_expand_path (fcc_expanded, sizeof (fcc_expanded));
+    dprint (1, (debugfile, "     Additional mailbox expanded = '%s'\n", fcc_expanded));
+    status = mutt_write_fcc (fcc_expanded, hdr, msgid, post, fcc, finalpath);
+    if (status != 0)
+      return status;
+  }
+
+  return 0;
+}
+
+int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid,
+		    int post, char *fcc, char **finalpath)
 {
   CONTEXT f;
   MESSAGE *msg;
@@ -2879,6 +2985,8 @@ int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int post,
 
   if (mx_commit_message (msg, &f) != 0)
     r = -1;
+  else if (finalpath)
+    *finalpath = safe_strdup(msg->commited_path);
   mx_close_message (&f, &msg);
   mx_close_mailbox (&f, NULL);
 
diff --git a/sidebar.c b/sidebar.c
index 5b7edaf..d0c47c5 100644
--- a/sidebar.c
+++ b/sidebar.c
@@ -27,7 +27,9 @@
 #include "keymap.h"
 #include "mutt_curses.h"
 #include "mutt_menu.h"
+#include "mx.h"
 #include "sort.h"
+#include "sidebar.h"
 
 /* Previous values for some sidebar config */
 static short PreviousSort = SORT_ORDER;  /* sidebar_sort_method */
@@ -54,6 +56,39 @@ static int BotIndex = -1;    /* Last mailbox visible in sidebar */
 static int select_next (void);
 
 
+enum {
+	SB_SRC_NONE = 0,
+	SB_SRC_VIRT,
+	SB_SRC_INCOMING
+};
+static int sidebar_source = SB_SRC_NONE;
+
+static BUFFY *
+get_incoming (void)
+{
+	switch (sidebar_source) {
+	case SB_SRC_NONE:
+		sidebar_source = SB_SRC_INCOMING;
+
+#ifdef USE_NOTMUCH
+		if (option (OPTVIRTSPOOLFILE) && VirtIncoming) {
+			sidebar_source = SB_SRC_VIRT;
+			return VirtIncoming;
+		}
+		break;
+	case SB_SRC_VIRT:
+		if (VirtIncoming) {
+			return VirtIncoming;
+		}
+		break;
+#endif
+	case SB_SRC_INCOMING:
+		break;
+	}
+
+	return Incoming;	/* default */
+}
+
 /**
  * cb_format_str - Create the string to show in the sidebar
  * @dest:        Buffer in which to save string
@@ -202,7 +237,7 @@ static const char *cb_format_str(char *dest, size_t destlen, size_t col, int col
  * @buflen:  Buffer length
  * @width:   Desired width in screen cells
  * @box:     Mailbox name
- * @b:       Mailbox object
+ * @sbe:     Mailbox object
  *
  * Take all the relevant mailbox data and the desired screen width and then get
  * mutt_FormatString to do the actual work. mutt_FormatString will callback to
@@ -263,6 +298,9 @@ static int cb_qsort_sbe (const void *a, const void *b)
     case SORT_COUNT_NEW:
       result = (b2->msg_unread - b1->msg_unread);
       break;
+    case SORT_DESC:
+      result = mutt_strcmp (b1->desc, b2->desc);
+      break;
     case SORT_FLAGGED:
       result = (b2->msg_flagged - b1->msg_flagged);
       break;
@@ -324,7 +362,7 @@ static void update_entries_visibility (void)
  */
 static void unsort_entries (void)
 {
-  BUFFY *cur = Incoming;
+  BUFFY *cur = get_incoming();
   int i = 0, j;
   SBENTRY *tmp;
 
@@ -487,10 +525,17 @@ static int draw_divider (int num_rows, int num_cols)
 
   SETCOLOR(MT_COLOR_DIVIDER);
 
+  int col;
+  if (option (OPTSIDEBARONRIGHT)) {
+    col = 0;
+  } else {
+    col = SidebarWidth - delim_len;
+  }
+
   int i;
   for (i = 0; i < num_rows; i++)
   {
-    mutt_window_move (MuttSidebarWindow, i, SidebarWidth - delim_len);	//RAR 0 for rhs
+    mutt_window_move (MuttSidebarWindow, i, col);
     addstr (NONULL(SidebarDividerChar));
   }
 
@@ -501,21 +546,26 @@ static int draw_divider (int num_rows, int num_cols)
  * fill_empty_space - Wipe the remaining Sidebar space
  * @first_row:  Window line to start (0-based)
  * @num_rows:   Number of rows to fill
- * @width:      Width of the Sidebar (minus the divider)
+ * @div_width:  Width in screen characters taken by the divider
+ * @num_cols:   Number of columns to fill
  *
  * Write spaces over the area the sidebar isn't using.
  */
-static void fill_empty_space (int first_row, int num_rows, int width)
+static void fill_empty_space (int first_row, int num_rows, int div_width, int num_cols)
 {
   /* Fill the remaining rows with blank space */
   SETCOLOR(MT_COLOR_NORMAL);
 
+  if (!option (OPTSIDEBARONRIGHT))
+    div_width = 0;
+
   int r;
   for (r = 0; r < num_rows; r++)
   {
-    mutt_window_move (MuttSidebarWindow, first_row + r, 0);	//RAR rhs
+    mutt_window_move (MuttSidebarWindow, first_row + r, div_width);
+
     int i;
-    for (i = 0; i < width; i++)
+    for (i = 0; i < num_cols; i++)
       addch (' ');
   }
 }
@@ -577,7 +627,12 @@ static void draw_sidebar (int num_rows, int num_cols, int div_width)
     else
       SETCOLOR(MT_COLOR_NORMAL);
 
-    mutt_window_move (MuttSidebarWindow, row, 0);
+    int col = 0;
+    if (option (OPTSIDEBARONRIGHT)) {
+      col = div_width;
+    }
+
+    mutt_window_move (MuttSidebarWindow, row, col);
     if (Context && Context->realpath &&
         !mutt_strcmp (b->realpath, Context->realpath))
     {
@@ -644,6 +699,12 @@ static void draw_sidebar (int num_rows, int num_cols, int div_width)
         safe_strcat (sidebar_folder_name, sfn_len, tmp_folder_name);
       }
     }
+#ifdef USE_NOTMUCH
+    else if (b->magic == MUTT_NOTMUCH)
+    {
+      sidebar_folder_name = b->desc;
+    }
+#endif
     char str[STRING];
     make_sidebar_entry (str, sizeof (str), w, sidebar_folder_name, entry);
     printw ("%s", str);
@@ -652,7 +713,7 @@ static void draw_sidebar (int num_rows, int num_cols, int div_width)
     row++;
   }
 
-  fill_empty_space (row, num_rows - row, w);
+  fill_empty_space (row, num_rows - row, div_width, w);
 }
 
 
@@ -667,6 +728,14 @@ void mutt_sb_draw (void)
   if (!option (OPTSIDEBAR))
     return;
 
+#ifdef USE_SLANG_CURSES
+  int x = SLsmg_get_column();
+  int y = SLsmg_get_row();
+#else
+  int x = getcurx (stdscr);
+  int y = getcury (stdscr);
+#endif
+
   int num_rows  = MuttSidebarWindow->rows;
   int num_cols  = MuttSidebarWindow->cols;
 
@@ -674,9 +743,14 @@ void mutt_sb_draw (void)
   if (div_width < 0)
     return;
 
-  if (!Incoming)
+  BUFFY *b;
+  if (Entries == NULL)
+    for (b = get_incoming(); b; b = b->next)
+      mutt_sb_notify_mailbox (b, 1);
+
+  if (!get_incoming())
   {
-    fill_empty_space (0, num_rows, SidebarWidth - div_width);
+    fill_empty_space (0, num_rows, div_width, num_cols - div_width);
     return;
   }
 
@@ -684,6 +758,7 @@ void mutt_sb_draw (void)
     return;
 
   draw_sidebar (num_rows, num_cols, div_width);
+  move (y, x);
 }
 
 /**
@@ -918,7 +993,7 @@ void mutt_sb_set_buffystats (const CONTEXT *ctx)
 {
   /* Even if the sidebar's hidden,
    * we should take note of the new data. */
-  BUFFY *b = Incoming;
+  BUFFY *b = get_incoming();
   if (!ctx || !b)
     return;
 
@@ -995,6 +1070,9 @@ void mutt_sb_notify_mailbox (BUFFY *b, int created)
   if (!b)
     return;
 
+  if (sidebar_source == SB_SRC_NONE)
+    return;
+
   /* Any new/deleted mailboxes will cause a refresh.  As long as
    * they're valid, our pointers will be updated in prepare_sidebar() */
 
@@ -1045,3 +1123,36 @@ void mutt_sb_notify_mailbox (BUFFY *b, int created)
 
   SidebarNeedsRedraw = 1;
 }
+
+/**
+ * mutt_sb_toggle_virtual - Switch between regular and virtual folders
+ */
+void
+mutt_sb_toggle_virtual (void)
+{
+	if (sidebar_source == -1)
+		get_incoming();
+
+#ifdef USE_NOTMUCH
+	if ((sidebar_source == SB_SRC_INCOMING) && VirtIncoming)
+		sidebar_source = SB_SRC_VIRT;
+	else
+#endif
+		sidebar_source = SB_SRC_INCOMING;
+
+	TopIndex = -1;
+	OpnIndex = -1;
+	HilIndex = -1;
+	BotIndex = -1;
+
+	BUFFY *b;
+
+	EntryCount = 0;
+	FREE(&Entries);
+	EntryLen = 0;
+	for (b = get_incoming(); b; b = b->next)
+		mutt_sb_notify_mailbox (b, 1);
+
+	SidebarNeedsRedraw = 1;
+}
+
diff --git a/sidebar.h b/sidebar.h
index 3a04c5e..0ec1239 100644
--- a/sidebar.h
+++ b/sidebar.h
@@ -28,6 +28,7 @@ void         mutt_sb_draw (void);
 const char * mutt_sb_get_highlight (void);
 void         mutt_sb_notify_mailbox (BUFFY *b, int created);
 void         mutt_sb_set_buffystats (const CONTEXT *ctx);
-BUFFY *      mutt_sb_set_open_buffy (void);
+void         mutt_sb_set_open_buffy (void);
+void         mutt_sb_toggle_virtual (void);
 
 #endif /* SIDEBAR_H */
diff --git a/sort.c b/sort.c
index 76e9e79..9b1db9f 100644
--- a/sort.c
+++ b/sort.c
@@ -24,6 +24,11 @@
 #include "sort.h"
 #include "mutt_idna.h"
 
+#ifdef USE_NNTP
+#include "mx.h"
+#include "nntp.h"
+#endif
+
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
@@ -151,6 +156,17 @@ static int compare_order (const void *a, const void *b)
   HEADER **ha = (HEADER **) a;
   HEADER **hb = (HEADER **) b;
 
+#ifdef USE_NNTP
+  if (Context && Context->magic == MUTT_NNTP)
+  {
+    anum_t na = NHDR (*ha)->article_num;
+    anum_t nb = NHDR (*hb)->article_num;
+    int result = na == nb ? 0 : na > nb ? 1 : -1;
+    AUXSORT (result, a, b);
+    return (SORTCODE (result));
+  }
+  else
+#endif
   /* no need to auxsort because you will never have equality here */
   return (SORTCODE ((*ha)->index - (*hb)->index));
 }
@@ -210,6 +226,46 @@ static int compare_spam (const void *a, const void *b)
   return (SORTCODE(result));
 }
 
+int compare_label (const void *a, const void *b)
+{
+  HEADER **ppa = (HEADER **) a;
+  HEADER **ppb = (HEADER **) b;
+  int     ahas, bhas, result = 0;
+  LIST *la, *lb;
+
+  /* As with compare_spam, not all messages will have the x-label
+   * property.  Blank X-Labels are treated as null in the index
+   * display, so we'll consider them as null for sort, too.       */
+  ahas = (*ppa)->env && (*ppa)->env->labels;
+  bhas = (*ppb)->env && (*ppb)->env->labels;
+
+  /* First we bias toward a message with a label, if the other does not. */
+  if (ahas && !bhas)
+    return (SORTCODE(-1));
+  if (!ahas && bhas)
+    return (SORTCODE(1));
+
+  /* If neither has a label, use aux sort. */
+  if (!ahas && !bhas)
+  {
+    AUXSORT(result, a, b);
+    return (SORTCODE(result));
+  }
+
+  /* If both have a label, we just do a lexical compare. */
+  for (la = (*ppa)->env->labels, lb = (*ppb)->env->labels;
+       la && la->data && lb && lb->data && result == 0;
+       la = la->next, lb = lb->next)
+  {
+    result = mutt_strcasecmp(la->data, lb->data);
+  }
+  if (result == 0 && la == NULL)
+    return (SORTCODE(-1));
+  if (result == 0 && lb == NULL)
+    return (SORTCODE(1));
+  return (SORTCODE(result));
+}
+
 sort_t *mutt_get_sort_func (int method)
 {
   switch (method & SORT_MASK)
@@ -232,6 +288,8 @@ sort_t *mutt_get_sort_func (int method)
       return (compare_score);
     case SORT_SPAM:
       return (compare_spam);
+    case SORT_LABEL:
+      return (compare_label);
     default:
       return (NULL);
   }
diff --git a/sort.h b/sort.h
index 26afdc6..c969c09 100644
--- a/sort.h
+++ b/sort.h
@@ -35,6 +35,8 @@
 #define SORT_COUNT_NEW	16
 #define SORT_FLAGGED	17
 #define SORT_PATH	18
+#define SORT_DESC	19
+#define SORT_LABEL	20
 
 /* dgc: Sort & SortAux are shorts, so I'm bumping these bitflags up from
  * bits 4 & 5 to bits 8 & 9 to make room for more sort keys in the future. */
diff --git a/status.c b/status.c
index a8921a9..ec09093 100644
--- a/status.c
+++ b/status.c
@@ -27,6 +27,10 @@
 #include "mapping.h"
 #include "mx.h"
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include <string.h>
 #include <ctype.h>
 #include <unistd.h>
@@ -95,7 +99,20 @@ status_format_str (char *buf, size_t buflen, size_t col, int cols, char op, cons
       break;
 
     case 'f':
-      snprintf (fmt, sizeof(fmt), "%%%ss", prefix);
+    {
+#ifdef USE_NOTMUCH
+      char *p;
+      if (Context && Context->magic == MUTT_NOTMUCH &&
+                   (p = nm_get_description(Context)))
+	  strfcpy(tmp, p, sizeof (tmp));
+      else
+#endif
+#ifdef USE_COMPRESSED
+      if (Context && Context->compress_info && Context->realpath) {
+	 strfcpy (tmp, Context->realpath, sizeof (tmp));
+	 mutt_pretty_mailbox (tmp, sizeof (tmp));
+      } else
+#endif
       if (Context && Context->path)
       {
 	strfcpy (tmp, Context->path, sizeof (tmp));
@@ -103,9 +120,11 @@ status_format_str (char *buf, size_t buflen, size_t col, int cols, char op, cons
       }
       else
 	strfcpy (tmp, _("(no mailbox)"), sizeof (tmp));
+
+      snprintf (fmt, sizeof(fmt), "%%%ss", prefix);
       snprintf (buf, buflen, fmt, tmp);
       break;
-
+    }
     case 'F':
       if (!optional)
       {
@@ -266,8 +285,8 @@ status_format_str (char *buf, size_t buflen, size_t col, int cols, char op, cons
       break;
 
     case 'v':
-      snprintf (fmt, sizeof (fmt), "Mutt %%s");
-      snprintf (buf, buflen, fmt, MUTT_VERSION);
+      snprintf (fmt, sizeof (fmt), "NeoMutt %%s");
+      snprintf (buf, buflen, fmt, PACKAGE_VERSION);
       break;
 
     case 'V':
diff --git a/strndup.c b/strndup.c
new file mode 100644
index 0000000..c560cd5
--- /dev/null
+++ b/strndup.c
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2013 Karel Zak <kzak@redhat.com>
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+
+char *strndup(const char *s, size_t n)
+{
+	size_t len = strnlen(s, n);
+	char *new = safe_malloc((len + 1) * sizeof(char));
+	if (!new)
+		return NULL;
+	new[len] = '\0';
+	return (char *) memcpy(new, s, len);
+}
diff --git a/strnlen.c b/strnlen.c
new file mode 100644
index 0000000..278a988
--- /dev/null
+++ b/strnlen.c
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2013 Karel Zak <kzak@redhat.com>
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+
+size_t strnlen(const char *s, size_t maxlen)
+{
+        int i;
+
+        for (i = 0; i < maxlen; i++) {
+                if (s[i] == '\0')
+                        return i + 1;
+        }
+        return maxlen;
+}
diff --git a/url.c b/url.c
index 42a6e09..d11b8d7 100644
--- a/url.c
+++ b/url.c
@@ -39,13 +39,18 @@ static const struct mapping_t UrlMap[] =
   { "imaps", 	U_IMAPS },
   { "pop",  	U_POP },
   { "pops", 	U_POPS },
+  { "news",	U_NNTP },
+  { "snews",	U_NNTPS },
   { "mailto",	U_MAILTO },
+#ifdef USE_NOTMUCH
+  { "notmuch",  U_NOTMUCH },
+#endif
   { "smtp",     U_SMTP },
   { "smtps",    U_SMTPS },
   { NULL,	U_UNKNOWN }
 };
 
-static int url_pct_decode (char *s)
+int url_pct_decode (char *s)
 {
   char *d;
 
@@ -214,7 +219,7 @@ int url_ciss_tostring (ciss_url_t* ciss, char* dest, size_t len, int flags)
       safe_strcat (dest, len, "//");
     len -= (l = strlen (dest)); dest += l;
 
-    if (ciss->user)
+    if (ciss->user && (ciss->user[0] || !(flags & U_PATH)))
     {
       char u[STRING];
       url_pct_encode (u, sizeof (u), ciss->user);
diff --git a/url.h b/url.h
index 926416e..d07150f 100644
--- a/url.h
+++ b/url.h
@@ -8,9 +8,14 @@ typedef enum url_scheme
   U_POPS,
   U_IMAP,
   U_IMAPS,
+  U_NNTP,
+  U_NNTPS,
   U_SMTP,
   U_SMTPS,
   U_MAILTO,
+#ifdef USE_NOTMUCH
+  U_NOTMUCH,
+#endif
   U_UNKNOWN
 }
 url_scheme_t;
@@ -34,5 +39,6 @@ int url_parse_file (char *d, const char *src, size_t dl);
 int url_parse_ciss (ciss_url_t *ciss, char *src);
 int url_ciss_tostring (ciss_url_t* ciss, char* dest, size_t len, int flags);
 int url_parse_mailto (ENVELOPE *e, char **body, const char *src);
+int url_pct_decode (char *s);
 
 #endif
diff --git a/version.c b/version.c
new file mode 100644
index 0000000..41299a3
--- /dev/null
+++ b/version.c
@@ -0,0 +1,527 @@
+/**
+ * Copyright (C) 1996-2007 Michael R. Elkins <me@mutt.org>
+ * Copyright (C) 1999-2007 Thomas Roessler <roessler@does-not-exist.org>
+ * Copyright (C) 2016 Richard Russon
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <sys/utsname.h>
+
+#ifdef HAVE_STRINGPREP_H
+#include <stringprep.h>
+#elif defined (HAVE_IDN_STRINGPREP_H)
+#include <idn/stringprep.h>
+#endif
+#ifdef USE_SLANG_CURSES
+#include "slang.h"
+#endif
+
+#include "lib.h"
+
+/* #include "protos.h" */
+const char * mutt_make_version (void);
+void mutt_print_patchlist (void);
+
+/* #include "hcache.h" */
+const char * mutt_hcache_backend (void);
+
+const int SCREEN_WIDTH = 80;
+
+extern const char cc_version[];
+extern const char cc_cflags[];
+extern const char configure_options[];
+
+static const char *Copyright = N_(
+  "Copyright (C) 1996-2016 Michael R. Elkins <me@mutt.org>\n"
+  "Copyright (C) 1996-2002 Brandon Long <blong@fiction.net>\n"
+  "Copyright (C) 1997-2009 Thomas Roessler <roessler@does-not-exist.org>\n"
+  "Copyright (C) 1998-2005 Werner Koch <wk@isil.d.shuttle.de>\n"
+  "Copyright (C) 1999-2014 Brendan Cully <brendan@kublai.com>\n"
+  "Copyright (C) 1999-2002 Tommi Komulainen <Tommi.Komulainen@iki.fi>\n"
+  "Copyright (C) 2000-2004 Edmund Grimley Evans <edmundo@rano.org>\n"
+  "Copyright (C) 2006-2009 Rocco Rutte <pdmef@gmx.net>\n"
+  "Copyright (C) 2014-2016 Kevin J. McCarthy <kevin@8t8.us>\n"
+  "\n"
+  "Many others not mentioned here contributed code, fixes,\n"
+  "and suggestions.\n"
+);
+
+static const char *License = N_(
+  "    This program is free software; you can redistribute it and/or modify\n"
+  "    it under the terms of the GNU General Public License as published by\n"
+  "    the Free Software Foundation; either version 2 of the License, or\n"
+  "    (at your option) any later version.\n"
+  "\n"
+  "    This program is distributed in the hope that it will be useful,\n"
+  "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
+  "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
+  "    GNU General Public License for more details.\n"
+);
+
+static const char *Obtaining = N_(
+  "    You should have received a copy of the GNU General Public License\n"
+  "    along with this program; if not, write to the Free Software\n"
+  "    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
+);
+
+static const char *ReachingUs = N_(
+  "To learn more about NeoMutt, visit: http://www.neomutt.org/\n"
+  "If you find a bug in NeoMutt, please raise an issue at:\n"
+  "    https://github.com/neomutt/neomutt/issues\n"
+  "or send an email at: <neomutt-devel@neomutt.org>\n"
+);
+
+static const char *Notice = N_(
+  "Copyright (C) 1996-2016 Michael R. Elkins and others.\n"
+  "Mutt comes with ABSOLUTELY NO WARRANTY; for details type `mutt -vv'.\n"
+  "Mutt is free software, and you are welcome to redistribute it\n"
+  "under certain conditions; type `mutt -vv' for details.\n"
+);
+
+struct compile_options
+{
+  const char *name;
+  int enabled;
+};
+
+static struct compile_options comp_opts[] =
+{
+#ifdef CRYPT_BACKEND_CLASSIC_PGP
+  { "CRYPT_BACKEND_CLASSIC_PGP", 1 },
+#else
+  { "CRYPT_BACKEND_CLASSIC_PGP", 0 },
+#endif
+#ifdef CRYPT_BACKEND_CLASSIC_SMIME
+  { "CRYPT_BACKEND_CLASSIC_SMIME", 1 },
+#else
+  { "CRYPT_BACKEND_CLASSIC_SMIME", 0 },
+#endif
+#ifdef CRYPT_BACKEND_GPGME
+  { "CRYPT_BACKEND_GPGME", 1 },
+#else
+  { "CRYPT_BACKEND_GPGME", 0 },
+#endif
+#ifdef DEBUG
+  { "DEBUG", 1 },
+#else
+  { "DEBUG", 0 },
+#endif
+#ifdef DL_STANDALONE
+  { "DL_STANDALONE", 1 },
+#else
+  { "DL_STANDALONE", 0 },
+#endif
+#ifdef ENABLE_NLS
+  { "ENABLE_NLS", 1 },
+#else
+  { "ENABLE_NLS", 0 },
+#endif
+#ifdef EXACT_ADDRESS
+  { "EXACT_ADDRESS", 1 },
+#else
+  { "EXACT_ADDRESS", 0 },
+#endif
+#ifdef HOMESPOOL
+  { "HOMESPOOL", 1 },
+#else
+  { "HOMESPOOL", 0 },
+#endif
+#ifdef LOCALES_HACK
+  { "LOCALES_HACK", 1 },
+#else
+  { "LOCALES_HACK", 0 },
+#endif
+#ifdef SUN_ATTACHMENT
+  { "SUN_ATTACHMENT", 1 },
+#else
+  { "SUN_ATTACHMENT", 0 },
+#endif
+#ifdef HAVE_BKGDSET
+  { "HAVE_BKGDSET", 1 },
+#else
+  { "HAVE_BKGDSET", 0 },
+#endif
+#ifdef HAVE_COLOR
+  { "HAVE_COLOR", 1 },
+#else
+  { "HAVE_COLOR", 0 },
+#endif
+#ifdef HAVE_CURS_SET
+  { "HAVE_CURS_SET", 1 },
+#else
+  { "HAVE_CURS_SET", 0 },
+#endif
+#ifdef HAVE_GETADDRINFO
+  { "HAVE_GETADDRINFO", 1 },
+#else
+  { "HAVE_GETADDRINFO", 0 },
+#endif
+#ifdef HAVE_GETSID
+  { "HAVE_GETSID", 1 },
+#else
+  { "HAVE_GETSID", 0 },
+#endif
+#ifdef HAVE_ICONV
+  { "HAVE_ICONV", 1 },
+#else
+  { "HAVE_ICONV", 0 },
+#endif
+#ifdef HAVE_LANGINFO_CODESET
+  { "HAVE_LANGINFO_CODESET", 1 },
+#else
+  { "HAVE_LANGINFO_CODESET", 0 },
+#endif
+#ifdef HAVE_LANGINFO_YESEXPR
+  { "HAVE_LANGINFO_YESEXPR", 1 },
+#else
+  { "HAVE_LANGINFO_YESEXPR", 0 },
+#endif
+#ifdef HAVE_LIBIDN
+  { "HAVE_LIBIDN", 1 },
+#else
+  { "HAVE_LIBIDN", 0 },
+#endif
+#ifdef HAVE_META
+  { "HAVE_META", 1 },
+#else
+  { "HAVE_META", 0 },
+#endif
+#ifdef HAVE_REGCOMP
+  { "HAVE_REGCOMP", 1 },
+#else
+  { "HAVE_REGCOMP", 0 },
+#endif
+#ifdef HAVE_RESIZETERM
+  { "HAVE_RESIZETERM", 1 },
+#else
+  { "HAVE_RESIZETERM", 0 },
+#endif
+#ifdef HAVE_START_COLOR
+  { "HAVE_START_COLOR", 1 },
+#else
+  { "HAVE_START_COLOR", 0 },
+#endif
+#ifdef HAVE_TYPEAHEAD
+  { "HAVE_TYPEAHEAD", 1 },
+#else
+  { "HAVE_TYPEAHEAD", 0 },
+#endif
+#ifdef HAVE_WC_FUNCS
+  { "HAVE_WC_FUNCS", 1 },
+#else
+  { "HAVE_WC_FUNCS", 0 },
+#endif
+#ifdef ICONV_NONTRANS
+  { "ICONV_NONTRANS", 1 },
+#else
+  { "ICONV_NONTRANS", 0 },
+#endif
+#ifdef USE_COMPRESSED
+  { "USE_COMPRESSED", 1 },
+#else
+  { "USE_COMPRESSED", 0 },
+#endif
+#ifdef USE_DOTLOCK
+  { "USE_DOTLOCK", 1 },
+#else
+  { "USE_DOTLOCK", 0 },
+#endif
+#ifdef USE_FCNTL
+  { "USE_FCNTL", 1 },
+#else
+  { "USE_FCNTL", 0 },
+#endif
+#ifdef USE_FLOCK
+  { "USE_FLOCK", 1 },
+#else
+  { "USE_FLOCK", 0 },
+#endif
+#ifdef USE_FMEMOPEN
+  { "USE_FMEMOPEN", 1 },
+#else
+  { "USE_FMEMOPEN", 0 },
+#endif
+#ifdef USE_GNU_REGEX
+  { "USE_GNU_REGEX", 1 },
+#else
+  { "USE_GNU_REGEX", 0 },
+#endif
+#ifdef USE_GSS
+  { "USE_GSS", 1 },
+#else
+  { "USE_GSS", 0 },
+#endif
+#ifdef USE_HCACHE
+  { "USE_HCACHE", 1 },
+#else
+  { "USE_HCACHE", 0 },
+#endif
+#ifdef USE_IMAP
+  { "USE_IMAP", 1 },
+#else
+  { "USE_IMAP", 0 },
+#endif
+#ifdef USE_NOTMUCH
+  { "USE_NOTMUCH", 1 },
+#else
+  { "USE_NOTMUCH", 0 },
+#endif
+#ifdef USE_NNTP
+  { "USE_NNTP", 1 },
+#else
+  { "USE_NNTP", 0 },
+#endif
+#ifdef USE_POP
+  { "USE_POP", 1 },
+#else
+  { "USE_POP", 0 },
+#endif
+#ifdef USE_SASL
+  { "USE_SASL", 1 },
+#else
+  { "USE_SASL", 0 },
+#endif
+#ifdef USE_SETGID
+  { "USE_SETGID", 1 },
+#else
+  { "USE_SETGID", 0 },
+#endif
+#ifdef USE_SIDEBAR
+  { "USE_SIDEBAR", 1 },
+#else
+  { "USE_SIDEBAR", 0 },
+#endif
+#ifdef USE_SMTP
+  { "USE_SMTP", 1 },
+#else
+  { "USE_SMTP", 0 },
+#endif
+#ifdef USE_SSL_GNUTLS
+  { "USE_SSL_GNUTLS", 1 },
+#else
+  { "USE_SSL_GNUTLS", 0 },
+#endif
+#ifdef USE_SSL_OPENSSL
+  { "USE_SSL_OPENSSL", 1 },
+#else
+  { "USE_SSL_OPENSSL", 0 },
+#endif
+  { NULL, 0 }
+};
+
+/**
+ * print_compile_options - Print a list of enabled/disabled features
+ *
+ * The configure script lets uses enable/disable features.
+ * This shows the Mutt user which features are/aren't available.
+ *
+ * The output is of the form: "+ENABLED_FEATURE -DISABLED_FEATURE" and is
+ * wrapped to SCREEN_WIDTH characters.
+ */
+static void
+print_compile_options (void)
+{
+  int i;
+  char c;
+  int len;
+  int used = 0;
+
+  for (i = 0; comp_opts[i].name; i++)
+  {
+    len = strlen (comp_opts[i].name) + 2;   /* +/- and a space */
+    if ((used + len) > SCREEN_WIDTH)
+    {
+      used = 0;
+      puts ("");
+    }
+    used += len;
+    c = comp_opts[i].enabled ? '+' : '-';
+    printf ("%c%s ", c, comp_opts[i].name);
+  }
+  puts ("");
+}
+
+/**
+ * rstrip_in_place - Strip a trailing carriage return
+ * @s:  String to be modified
+ *
+ * The string has its last carriage return set to NUL.
+ * Returns:
+ *      The modified string
+ */
+static char *
+rstrip_in_place (char *s)
+{
+  if (!s)
+    return NULL;
+
+  char *p;
+
+  p = &s[strlen (s)];
+  if (p == s)
+    return s;
+  p--;
+  while ((p >= s) && ((*p == '\n') || (*p == '\r')))
+    *p-- = '\0';
+  return s;
+}
+
+/**
+ * print_version - Print system and compile info
+ *
+ * Print information about the current system Mutt is running on.
+ * Also print a list of all the compile-time information.
+ */
+void
+print_version (void)
+{
+  struct utsname uts;
+
+  puts (mutt_make_version());
+  puts (_(Notice));
+
+  uname (&uts);
+
+#ifdef _AIX
+  printf ("System: %s %s.%s", uts.sysname, uts.version, uts.release);
+#elif defined (SCO)
+  printf ("System: SCO %s", uts.release);
+#else
+  printf ("System: %s %s", uts.sysname, uts.release);
+#endif
+
+  printf (" (%s)", uts.machine);
+
+#ifdef NCURSES_VERSION
+  printf ("\nncurses: %s (compiled with %s)", curses_version(), NCURSES_VERSION);
+#elif defined (USE_SLANG_CURSES)
+  printf ("\nslang: %d", SLANG_VERSION);
+#endif
+
+#ifdef _LIBICONV_VERSION
+  printf ("\nlibiconv: %d.%d", _LIBICONV_VERSION >> 8,
+    _LIBICONV_VERSION & 0xff);
+#endif
+
+#ifdef HAVE_LIBIDN
+  printf ("\nlibidn: %s (compiled with %s)", stringprep_check_version (NULL),
+    STRINGPREP_VERSION);
+#endif
+
+#ifdef USE_HCACHE
+  printf ("\nhcache backend: %s", mutt_hcache_backend());
+#endif
+
+  puts ("\n\nCompiler:");
+  rstrip_in_place ((char *) cc_version);
+  puts (cc_version);
+
+  rstrip_in_place ((char *) configure_options);
+  printf ("\nConfigure options: %s\n", configure_options);
+
+  rstrip_in_place ((char *) cc_cflags);
+  printf ("\nCompilation CFLAGS: %s\n", cc_cflags);
+
+  puts (_("\nCompile options:"));
+  print_compile_options();
+
+#ifdef DOMAIN
+  printf ("DOMAIN=\"%s\"\n", DOMAIN);
+#else
+  puts ("-DOMAIN");
+#endif
+
+#ifdef MIXMASTER
+  printf ("MIXMASTER=\"%s\"\n", MIXMASTER);
+#else
+  puts ("-MIXMASTER");
+#endif
+
+#ifdef ISPELL
+  printf ("ISPELL=\"%s\"\n", ISPELL);
+#else
+  puts ("-ISPELL");
+#endif
+
+  printf ("SENDMAIL=\"%s\"\n", SENDMAIL);
+  printf ("MAILPATH=\"%s\"\n", MAILPATH);
+  printf ("PKGDATADIR=\"%s\"\n", PKGDATADIR);
+  printf ("SYSCONFDIR=\"%s\"\n", SYSCONFDIR);
+  printf ("EXECSHELL=\"%s\"\n", EXECSHELL);
+
+  puts ("");
+  mutt_print_patchlist();
+
+  puts ("");
+  puts (_(ReachingUs));
+}
+
+/**
+ * print_copyright - Print copyright message
+ *
+ * Print the authors' copyright messages, the GPL license and some contact
+ * information for the Mutt project.
+ */
+void
+print_copyright (void)
+{
+  puts (mutt_make_version());
+  puts (_(Copyright));
+  puts (_(License));
+  puts (_(Obtaining));
+  puts (_(ReachingUs));
+}
+
+/**
+ * feature_enabled - Test is a compile-time feature is enabled
+ * @name:  Compile-time symbol of the feature
+ *
+ * Many of the larger features of mutt can be disabled at compile time.
+ * They define a symbol and use #ifdef's around their code.
+ * The symbols are mirrored in "struct compile_options comp_opts[]" in this
+ * file.
+ *
+ * This function checks if one of these symbols is present in the code.
+ *
+ * These symbols are also seen in the output of "mutt -v".
+ *
+ * Returns:
+ *      1: Feature enables
+ *      0: Feature not enabled, or not compiled in
+ */
+int
+feature_enabled (const char *name)
+{
+  if (!name)
+    return 0;
+
+  int i;
+  for (i = 0; comp_opts[i].name; i++)
+  {
+    if (mutt_strcmp (name, comp_opts[i].name) == 0)
+    {
+      return 1;
+    }
+  }
+  return 0;
+}
+
diff --git a/version.h b/version.h
new file mode 100644
index 0000000..b46ebf8
--- /dev/null
+++ b/version.h
@@ -0,0 +1,26 @@
+/**
+ * Copyright (C) 2016 Richard Russon
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef _VERSION_H_
+#define _VERSION_H_
+
+void print_version (void);
+void print_copyright (void);
+int feature_enabled (const char *name);
+
+#endif /* _VERSION_H_ */
diff --git a/version.sh b/version.sh
deleted file mode 100644
index d7988df..0000000
--- a/version.sh
+++ /dev/null
@@ -1,68 +0,0 @@
-#!/bin/sh
-
-HG=hg
-
-# Switch to directory where this script lives so that further commands are run
-# from the root directory of the source.  The script path and srcdir are double
-# quoted to allow the space character to appear in the path.
-srcdir=`dirname "$0"` && cd "$srcdir" || exit 1
-
-# Ensure that we have a repo here and that mercurial is installed.  If
-# not, just cat the VERSION file; it contains the latest release number.
-{ [ -d ".hg" ] && $HG >/dev/null 2>&1; } \
-|| exec cat VERSION
-
-# This is a mercurial repo and we have the hg command.
-
-# Get essential properties of the current working copy
-set -- `$HG parents --template='{rev} {node|short}\n'`
-rev="$1"
-node="$2"
-
-# translate release tags into ##.##.## notation
-cleantag () {
-	case "$1" in
-		mutt-*-rel) echo "$1" | sed -e 's/mutt-//' -e 's/-rel//' | tr - . ;;
-		*)          echo "$1" ;;
-	esac
-}
-
-getdistance_old () {
-	# fudge it
-	set -- `$HG tags | sort -n -k 2 | egrep 'mutt-.*rel' | tail -1 | cut -d: -f1`
-	latesttag="$1"
-	latestrev="$2"
-	distance=`expr $rev - $latestrev`
-	echo $latesttag $distance
-}
-
-getdistance_new () {
-	$HG parents --template='{latesttag} {latesttagdistance}\n'
-}
-
-
-# latesttag appeared in hg 1.4.  Test for it.
-[ "`$HG log -r . --template='{latesttag}'`" = '' ] && 
-set -- `getdistance_old` ||
-set -- `getdistance_new`
-
-tag=`cleantag "$1"`
-dist=$2
-
-if [ $dist -eq 0 ]; then
-	dist=
-else
-	dist="+$dist"
-fi
-
-# if we have mq patches applied, mention it
-qparent=`$HG log -r qparent --template='{rev}\n' 2>/dev/null || echo $rev`
-qdelta=`expr $rev - $qparent`
-if [ $qdelta -eq 0 ]; then
-	qdist=""
-else
-	qdist=",mq+$qdelta"
-fi
-
-echo "$tag$dist$qdist ($node)"
-exit 0
