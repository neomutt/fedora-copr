diff --git c/ChangeLog.neomutt w/ChangeLog.neomutt
new file mode 100644
index 0000000..d89cedf
--- /dev/null
+++ w/ChangeLog.neomutt
@@ -0,0 +1,312 @@
+2016-10-03  Richard Russon  <rich@flatcap.org>
+* Build
+  - Fix install and dist targets
+
+2016-10-02  Richard Russon  <rich@flatcap.org>
+* Features
+  - Kyoto Cabinet header cache
+  - Compose to Sender
+  - Forgotten Attachment uses a regex
+  - Optimize LMDB's hcache backend
+  - Sensible-browser behaviour fixes
+* Bug Fixes
+  - Fixes repaint problem with $pager_index_lines #159
+  - Quasi-Delete: check there's a selection
+  - Bulletproof the pager
+  - Typo in the version string
+* Docs
+  - Add badges to README.neomutt
+  - Document the Kyoto cabinet hcache backend
+  - Fix the layout of the syntax file
+  - Make the license clear to github
+  - Fix the alignment in a 'nested-if' example
+  - Fix notmuch vim syntax file
+  - Added Mailinglist mailto links to "Where is NeoMutt" section
+  - Fix build of neomutt-syntax.vim
+  - Fixed typo of devel mailinglist name
+* Build
+  - Travis: install the kyoto-cabinet dev files
+  - Build source before docs
+  - Build fix for strndup / malloc
+  - Change gcc build options to prevent crashes
+* Upstream
+  - Ensure signatures exist when verifying multipart/signed emails. (closes #3881).
+  - RFC2047-decode mailto url headers after RFC2822 parsing. (closes #3879)
+  - RFC2047-decode mailto header values. (closes #3879)
+  - Reset invalid parsed received dates to 0.  (closes #3878)
+  - Clear pager position when toggling headers.
+  - Don't abort the menu editor on sigwinch. (closes #3875)
+  - Mark some gpgme pgp menu keybinding translations as fuzzy. (closes #3874)
+  - Check for NULL mx_ops in mx.c
+  - Use body color for gpgme output. (closes #3872)
+  - Fix gpgme segfault when querying candidates with a '+' in the address. (closes #3873)
+
+2016-09-16  Richard Russon  <rich@flatcap.org>
+* Bug Fixes
+  - Avoid segfault when listing mailboxes on startup
+    John Swinbank
+  - Fix buffer overrun in search for attach keyword
+    James McCoy
+  - Fix off-by-one in error message
+    Antonio Radici
+  - fix AC_INIT tarname parameter
+  - fix crash when exiting the pager
+  - fix another crash in the pager
+  - nntp: close message handles
+  - fix: make the pager more robust
+  - fix sidebar sort order
+  - fix notmuch tag completion
+* Docs
+  - doc: Removes bug entry in new-mail docs
+    Santiago Torres
+  - fix some translations in crypt-gpgme.c
+    Antonio Radici
+  - docs: mass tidy up
+* Upstream
+  - Fix sidebar documentation a bit
+  - Add unsidebar_whitelist command
+  - Remove the $locale configuration variable
+  - Add $attribution_locale configuration variable
+  - Add missing include <locale.h> to send.c and edit.c
+  - Filter out zero width no-break space (U+FEFF)
+  - Update a confusing and obsolete comment
+  - Moves mutt_copy_list to muttlib.c, where it belongs
+  - Redraw screen after an SSL cert prompt
+  - Preserve message-id and mft headers for recalled messages
+  - Fix openssl 1.1 compilation issues
+
+2016-09-10  Richard Russon  <rich@flatcap.org>
+* New Features
+  - Colouring Attachments with Regexp
+    Guillaume Brogi
+  - PGP Encrypt to Self
+    Guillaume Brogi
+  - Sensible Browser
+    Pierre-Elliott Bécue
+  - Reply using X-Original-To: header
+    Pierre-Elliott Bécue
+  - Purge Thread
+    Darshit Shah
+  - Forgotten attachment
+    Darshit Shah
+  - Add sidebar_ordinary color
+* Bug Fixes
+  - align the nntp code with mutt
+    Fabian Groffen
+  - check for new mail while in pager when idle
+    Stefan Assmann
+  - Allow the user to interrupt slow IO operations
+    Antonio Radici
+  - keywords: check there are emails to tag
+  - fix duplicate saved messages
+  - flatten contrib/keybase dir to fix install
+  - restore the pager keymapping 'i' to exit
+  - proposed fix for clearing labels
+  - notmuch: sync vfolder_format to folder_format
+* Docs
+  - Update List of Features and Authors
+* Build
+  - fix configure check for fmemopen
+  - use fixed version strings
+* Upstream
+  - Increase date buffer size for $folder_format.
+  - Disable ~X when message scoring.
+  - Fix pgpring reporting of DSA and Elgamal key lengths.
+  - Stub out getdnsdomainname() unless HAVE_GETADDRINFO.
+  - Autoconf: always check for getaddrinfo().
+  - Add missing sidebar contrib sample files to dist tarball.
+
+2016-08-27  Richard Russon  <rich@flatcap.org>
+* NeoMutt for Mutt 1.7.0
+* Build
+  - Disable fmemopen until bug is fixed
+* Contrib
+  - Keybase portability improvements
+    Joshua Jordi (JakkinStewart)
+
+2016-08-21  Richard Russon  <rich@flatcap.org>
+* Contrib
+  - Updates to Keybase Support
+    Joshua Jordi (JakkinStewart)
+* Bug Fixes
+  - Fix data-loss when appending a compressed file
+  - Don't paint invisible progress bars
+  - Revert to Mutt keybindings
+  - Don't de-tag emails after labelling them
+  - Don't whine if getrandom() fails
+    Adam Borowski (kilobyte)
+  - Fix display when 'from' field is invalid
+* Config
+  - Support for $XDG_CONFIG_HOME and $XDG_CONFIG_DIRS
+    Marco Hinz (mhinz)
+* Docs
+  - Fix DocBook validation
+  - Document NotMuch queries
+* Build
+  - More Autoconf improvements
+    Darshit Shah (darnir)
+  - Create Distribution Tarballs with autogen sources
+    Darshit Shah (darnir)
+
+2016-08-08  Richard Russon  <rich@flatcap.org>
+* New Features
+  - Timeout Hook - Run a command periodically
+  - Multiple fcc - Save multiple copies of outgoing mail
+* Contrib
+  - Keybase Integration
+    Joshua Jordi (JakkinStewart)
+* Devel
+  - Attached - Prevent missing attachments
+    Darshit Shah (darnir)
+  - Virtual Unmailboxes - Remove unwanted virtual mailboxes
+    Richard Russon (flatcap)
+* Bug Fixes
+  - Sidebar's inbox occasionally shows zero/wrong value
+  - Fix crash opening a second compressed mailbox
+* Config
+  - Look for /etc/NeoMuttrc and ~/.neomuttrc
+* Docs
+  - Fix broken links, typos
+  - Update project link
+  - Fix version string in the manual
+* Build
+  - Add option to disable fmemopen
+  - Install all the READMEs and contribs
+  - Big overhaul of the build
+    Darshit Shah (darnir)
+
+2016-07-23  Richard Russon  <rich@flatcap.org>
+* New Motto: "Teaching an Old Dog New Tricks"
+  - Thanks to Alok Singh
+* New Features
+  - New Mail Command - Execute a command on receipt of new mail
+  - vim-keybindings - Mutt config for vim users
+  - LMDB: In-memory header caching database
+  - SMIME Encrypt to Self - Secure storage of sensitive email
+* Bug Fixes
+  - rework mutt_draw_statusline()
+  - fix cursor position after sidebar redraw
+  - Add sidebar_format flag '%n' to display 'N' on new mail.
+  - fix index_format truncation problem
+  - Fix compiler warnings due to always true condition
+  - Change sidebar next/prev-new to look at buffy->new too.
+  - Change the default for sidebar_format to use %n.
+  - sidebar "unsorted" order to match Buffy list order.
+  - Include ncurses tinfo library if found.
+  - Sidebar width problem
+  - sidebar crash for non-existent mailbox
+  - Temporary compatibility workaround
+  - Reset buffy->new for the current mailbox in IMAP.
+  - version.sh regression
+  - crash when notmuch tries to read a message
+  - status line wrapping
+* Docs
+  - Mass tidy up of the docs
+  - Fix xml validation
+  - Add missing docs for new features
+* Travis
+  - New build system:
+    https://github.com/neomutt/travis-build
+    Now we have central control over what gets built
+
+2016-07-09  Richard Russon  <rich@flatcap.org>
+* Bug-fixes
+  - This release was a temporary measure
+
+2016-06-11  Richard Russon  <rich@flatcap.org>
+* Change in behaviour
+  - Temporarily disable $sidebar_refresh_time
+    Unfortunately, this was causing too many problems.
+    It will be fixed and re-enabled as soon as possible.
+* Bug Fixes
+  - Fix several crashes, on startup, in Keywords
+  - Reflow text now works as it should
+  - Lots of typos fixed
+  - Compress config bug prevented it working
+  - Some minor bug-fixes from mutt/default
+  - Single quote at line beginning misinterpreted by groff
+  - Setting $sidebar_width to more than 128 would cause bad things to happen.
+  - Fix alignment in the compose menu.
+  - Fix sidebar buffy stats updating on mailbox close.
+* Build Changes
+  - Sync whitespace to mutt/default
+  - Alter ChangeLog date format to simplify Makefiles
+  - Use the new notmuch functions that return a status
+  - Rename sidebar functions sb_* -> mutt_sb_*
+
+2016-05-23  Richard Russon  <rich@flatcap.org>
+* New Features:
+  - Keywords: Email Label/Keywords/Tagging
+  - Compress: Compressed mailboxes support
+  - NNTP: Talk to a usenet news server
+  - Separate mappings for <enter> and <return>
+  - New configure option: --enable-quick-build
+  - Various build fixes
+
+2016-05-02  Richard Russon  <rich@flatcap.org>
+* Update for Mutt-1.6.0
+* Bug Fixes:
+  - Build for Notmuch works if Sidebar is disabled
+  - Sidebar functions work even if the Sidebar is hidden
+  - sidebar-next-new, etc, only find *new* mail, as documented
+  - Notmuch supports *very* long queries
+
+2016-04-16  Richard Russon  <rich@flatcap.org>
+* Big Bugfix Release
+* Bug Fixes:
+  - Fix crash caused by sidebar_folder_indent
+  - Allow the user to change mailboxes again
+  - Correct sidebar's messages counts
+  - Only sort the sidebar if we're asked to
+  - Fix refresh of pager when toggling the sidebar
+  - Compose mode: make messages respect the TITLE_FMT
+  - Conditional include if sys/syscall.h
+  - Build fix for old compilers
+  - Try harder to keep track of the open mailbox
+* Changes to Features
+  - Allow sidebar_divider_char to be longer
+    (it was limited to one character)
+  - Ignore case when sorting the sidebar alphabetically
+* Other Changes
+  - Numerous small tweaks to the docs
+  - Lots of minor code tidy-ups
+  - Enabling NotMuch now forcibly enables Sidebar
+    (it is dependent on it, for now)
+  - A couple of bug fixes from mutt/stable
+
+2016-04-04  Richard Russon  <rich@flatcap.org>
+* Update for Mutt-1.6.0
+* No other changes in this release
+
+2016-03-28  Richard Russon  <rich@flatcap.org>
+* New Features
+  - skip-quoted          - skip quoted text
+  - limit-current-thread - limit index view to current thread
+* Sidebar Intro - A Gentle Introduction to the Sidebar (with pictures).
+
+2016-03-20  Richard Russon  <rich@flatcap.org>
+* Numerous small bugfixes
+* TravisCI integration
+
+2016-03-17  Richard Russon  <rich@flatcap.org>
+* New Features
+  - notmuch - email search support
+  - ifdef   - improvements
+
+2016-03-07  Richard Russon  <rich@flatcap.org>
+* First NeoMutt release
+* List of Features:
+  - bug-fixes    - various bug fixes
+  - cond-date    - use rules to choose date format
+  - fmemopen     - use memory buffers instead of files
+  - ifdef        - conditional config options
+  - index-color  - theme the email index
+  - initials     - expando for author's initials
+  - nested-if    - allow deeply nested conditions
+  - progress     - show a visual progress bar
+  - quasi-delete - mark emails to be hidden
+  - sidebar      - overview of mailboxes
+  - status-color - theming the status bar
+  - tls-sni      - negotiate for a certificate
+  - trash        - move 'deleted' emails to a trash bin
+
diff --git c/ChangeLog.nntp w/ChangeLog.nntp
new file mode 100644
index 0000000..1452e86
--- /dev/null
+++ w/ChangeLog.nntp
@@ -0,0 +1,416 @@
+* Wed Apr  6 2016 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.6.0
+- %R changed to %x in format strings
+
+* Wed Nov 25 2015 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed memory leaks
+- fixed SIGSEGV when reading hcache in some cases
+
+* Tue Nov 10 2015 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed error compiling with nntp and without imap or pop3
+- fixed error loading articles after <change-newsgroup> and <quit>
+
+* Wed Sep  2 2015 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.24
+- new option nntp_listgroup
+- use range in LISTGROUP command if possible
+
+* Thu Mar 13 2014 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.23
+
+* Tue Oct 29 2013 Vsevolod Volkov <vvv@mutt.org.ua>
+- minor bug fixed while removing new articles
+
+* Fri Oct 18 2013 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.22
+
+* Tue Nov 27 2012 Vsevolod Volkov <vvv@mutt.org.ua>
+- SASL authentication
+- new option nntp_authenticators
+
+* Fri Nov 16 2012 Vsevolod Volkov <vvv@mutt.org.ua>
+- support of NNTP commands: CAPABILITIES, STARTTLS, LIST NEWSGROUPS,
+  LIST OVERVIEW.FMT, OVER, DATE
+- added bcache support
+- newss URI scheme renamed to snews
+- removed option nntp_reconnect
+
+* Sun Sep 16 2012 Vsevolod Volkov <vvv@mutt.org.ua>
+- internal header caching replaced with hcache
+- new option newsgroups_charset
+
+* Wed Sep 16 2010 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.21
+
+* Thu Aug 13 2009 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed writting references in nntp_save_cache_group()
+
+* Tue Jun 15 2009 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.20
+
+* Tue Mar 20 2009 Vsevolod Volkov <vvv@mutt.org.ua>
+- save Date: header of recorded outgoing articles
+
+* Tue Jan  6 2009 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.19
+
+* Mon May 19 2008 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.18
+- fixed SIGSEGV when followup or forward to newsgroup
+
+* Sun Nov  4 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.17
+
+* Tue Jul  3 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed arguments of nntp_format_str()
+
+* Fri Jun 15 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed error selecting news group
+
+* Tue Jun 12 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.16
+
+* Wed Apr 11 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed posting error if $smtp_url is set
+- added support of print-style sequence %R (x-comment-to)
+
+* Sun Apr  8 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.15
+- nntp://... url changed to news://...
+- added indicator of fetching descriptions progress
+
+* Tue Feb 28 2007 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.14
+
+* Tue Aug 15 2006 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.13
+
+* Mon Jul 17 2006 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.12
+- fixed reading empty .newsrc
+
+* Sat Sep 17 2005 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.11
+
+* Sat Aug 13 2005 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.10
+
+* Sun Mar 13 2005 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.9
+
+* Sun Feb 13 2005 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.8
+
+* Sat Feb  5 2005 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.7
+- function mutt_update_list_file() moved to newsrc.c and changed algorithm
+
+* Thu Jul  8 2004 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed error in nntp_logout_all()
+
+* Sat Apr  3 2004 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed debug output in mutt_newsrc_update()
+- added optional support of LISTGROUP command
+- fixed typo in nntp_parse_xref()
+
+* Tue Feb  3 2004 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.6
+
+* Thu Dec 18 2003 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed compose menu
+
+* Thu Nov  6 2003 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.5.1
+
+* Wed Nov  5 2003 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.5
+- added space after newsgroup name in .newsrc file
+
+* Sun May 18 2003 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed SIGSEGV when posting article
+
+* Sat Mar 22 2003 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.4
+
+* Sat Dec 21 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.3
+- replace safe_free calls by the FREE macro
+
+* Fri Dec  6 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.2
+- nntp authentication can be passed after any command
+
+* Sat May  4 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.5.1
+
+* Thu May  2 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.99
+
+* Wed Mar 13 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.28
+- fixed SIGSEGV in <get-message>, <get-parent>, <get-children>,
+  <reconstruct-thread> functions
+- fixed message about nntp reconnect
+- fixed <attach-news-message> function using browser
+- added support of Followup-To: poster
+- added %n (new articles) in group_index_format
+- posting articles without inews by default
+
+* Wed Jan 23 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.27
+
+* Fri Jan 18 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.26
+
+* Thu Jan  3 2002 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.25
+- accelerated speed of access to news->newsgroups hash (by <gul@gul.kiev.ua>)
+- added default content disposition
+
+* Mon Dec  3 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.24
+
+* Fri Nov  9 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.23.2
+- fixed segfault if mutt_conn_find() returns null
+
+* Wed Oct 31 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.23.1
+- added support of LISTGROUP command
+- added support for servers with broken overview
+- disabled <flag-message> function on news server
+- fixed error storing bad authentication information
+
+* Wed Oct 10 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.23
+- fixed typo in buffy.c
+- added substitution of %s parameter in $inews variable
+
+* Fri Aug 31 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.22.1
+- update to 1.3.22
+
+* Thu Aug 23 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.21
+
+* Wed Jul 25 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.20
+- removed 'server-hook', use 'account-hook' instead
+- fixed error opening NNTP server without newsgroup using -f option
+
+* Fri Jun  8 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.19
+
+* Sat May  5 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.18
+- fixed typo in nntp_attempt_features()
+- changed algorithm of XGTITLE command testing
+- disabled writing of NNTP password in debug file
+- fixed reading and writing of long newsrc lines
+- changed checking of last line while reading lines from server
+- fixed possible buffer overrun in nntp_parse_newsrc_line()
+- removed checking of XHDR command
+- compare NNTP return codes without trailing space
+
+* Thu Mar 29 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.17
+- support for 'LIST NEWSGROUPS' command to read descriptions
+
+* Fri Mar  2 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.16
+
+* Wed Feb 14 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.15
+
+* Sun Jan 28 2001 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.14
+- show number of tagged messages patch from Felix von Leitner <leitner@fefe.de>
+
+* Sun Dec 31 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.13
+
+* Sat Dec 30 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- Fixed problem if last article in group is deleted
+
+* Fri Dec 22 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- Fixed checking of XGTITLE command on some servers
+
+* Mon Dec 18 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- Added \r in AUTHINFO commands
+
+* Mon Nov 27 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.12
+
+* Wed Nov  1 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.11
+- fixed error opening newsgroup from mutt started with -g or -G
+
+* Thu Oct 12 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.10
+- hotkey 'G' (get-message) replaced with '^G'
+
+* Thu Sep 21 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.9
+- changed delay displaying error messages from 1 to 2 seconds
+- fixed error compiling with nntp and without imap
+
+* Wed Sep  6 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- fixed catchup in index
+- fixed nntp_open_mailbox()
+
+* Sat Sep  2 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- functions <edit> and <delete-entry> disabled
+- format of news mailbox names changed to url form
+- option nntp_attempts removed
+- option reconnect_news renamed to nntp_reconnect
+- default value of nntp_poll changed from 30 to 60
+- error handling improved
+
+* Wed Aug 30 2000 Vsevolod Volkov <vvv@mutt.org.ua>
+- update to 1.3.8
+- new option show_only_unread
+- add newsgroup completion
+
+* Fri Aug  4 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.7
+
+* Sat Jul 29 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.6
+
+* Sun Jul  9 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.5
+- authentication code update
+- fix for changing to newsgroup from mailbox with read messages
+- socket code optimization
+
+* Wed Jun 21 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.4
+
+* Wed Jun 14 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- don't substitute current newsgroup with deleted new messages
+
+* Mon Jun 12 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.3
+- fix for substitution of newsgroup after reconnection
+- fix for loading newsgroups with very long names
+- fix for loading more than 32768 newsgroups
+
+* Wed May 24 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.2
+
+* Sat May 20 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3.1
+
+* Fri May 12 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.3
+
+* Thu May 11 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.2
+
+* Thu May  4 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.14
+
+* Sun Apr 23 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.12
+
+* Fri Apr  7 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- add substitution of newsgroup with new messages by default
+
+* Wed Apr  5 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- add attach message from newsgroup
+- add one-line help in newsreader mode
+- disable 'change-dir' command in newsgroups browser
+- add -G option
+
+* Tue Apr  4 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- get default news server name from file /etc/nntpserver
+- use case insensitive server names
+- add print-style sequence %s to $newsrc
+- add -g option
+
+* Sat Apr  1 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- remove 'X-FTN-Origin' header processing
+
+* Thu Mar 30 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.11
+- update to 1.1.10
+
+* Thu Mar 23 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix mutt_select_newsserver()
+- remove 'toggle-mode' function
+- add 'change-newsgroup' function
+
+* Wed Mar 22 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix server-hook
+
+* Tue Mar 21 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix error 'bounce' function after 'post'
+- add 'forward to newsgroup' function
+
+* Mon Mar 20 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- 'forward' function works in newsreader mode
+- add 'post' and 'followup' functions to pager and attachment menu
+- fix active descriptions and allowed flag reload
+
+* Tue Mar 14 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.9
+- remove deleted newsgroups from list
+
+* Mon Mar 13 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update .newsrc in browser
+
+* Sun Mar 12 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- reload .newsrc if externally modified
+- fix active cache update
+
+* Sun Mar  5 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.8
+
+* Sat Mar  4 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- patch *.update_list_file is not required
+- count lines when loading descriptions
+- remove cache of unsubscribed newsgroups
+
+* Thu Mar  2 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- load list of newsgroups from cache faster
+
+* Wed Mar  1 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.7
+
+* Tue Feb 29 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix unread messages in browser
+- fix newsrc_gen_entries()
+
+* Mon Feb 28 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix mutt_newsgroup_stat()
+- fix nntp_delete_cache()
+- fix nntp_get_status()
+- fix check_children()
+- fix nntp_fetch_headers()
+
+* Fri Feb 25 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.5
+
+* Thu Feb 24 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix updating new messages in cache
+
+* Mon Feb 21 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- change default cache filenames
+- fix updating new messages in cache
+
+* Fri Feb 18 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- fix segmentation fault in news groups browser
+
+* Tue Feb 15 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.4
+
+* Thu Feb 10 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.3
+
+* Sun Jan 30 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- add X-Comment-To editing
+- add my_hdr support for Newsgroups:, Followup-To: and X-Comment-To: headers
+- add variables $ask_followup_to and $ask_x_comment_to
+
+* Fri Jan 28 2000 Vsevolod Volkov <vvv@mutt.kiev.ua>
+- update to 1.1.2
diff --git c/GPL w/GPL
deleted file mode 100644
index b6f92f3..0000000
--- c/GPL
+++ /dev/null
@@ -1,340 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-                 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.
diff --git c/LICENSE.md w/LICENSE.md
new file mode 100644
index 0000000..0daa041
--- /dev/null
+++ w/LICENSE.md
@@ -0,0 +1,336 @@
+GNU General Public License
+==========================
+
+_Version 2, June 1991_  
+_Copyright © 1989, 1991 Free Software Foundation, Inc.,_  
+_51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA_
+
+Everyone is permitted to copy and distribute verbatim copies
+of this license document, but changing it is not allowed.
+
+### Preamble
+
+The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+We protect your rights with two steps: **(1)** copyright the software, and
+**(2)** offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+The precise terms and conditions for copying, distribution and
+modification follow.
+
+### TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+**0.** This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The “Program”, below,
+refers to any such program or work, and a “work based on the Program”
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term “modification”.)  Each licensee is addressed as “you”.
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+**1.** You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+**2.** You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+* **a)** You must cause the modified files to carry prominent notices
+stating that you changed the files and the date of any change.
+* **b)** You must cause any work that you distribute or publish, that in
+whole or in part contains or is derived from the Program or any
+part thereof, to be licensed as a whole at no charge to all third
+parties under the terms of this License.
+* **c)** If the modified program normally reads commands interactively
+when run, you must cause it, when started running for such
+interactive use in the most ordinary way, to print or display an
+announcement including an appropriate copyright notice and a
+notice that there is no warranty (or else, saying that you provide
+a warranty) and that users may redistribute the program under
+these conditions, and telling the user how to view a copy of this
+License.  (Exception: if the Program itself is interactive but
+does not normally print such an announcement, your work based on
+the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+**3.** You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+* **a)** Accompany it with the complete corresponding machine-readable
+source code, which must be distributed under the terms of Sections
+1 and 2 above on a medium customarily used for software interchange; or,
+* **b)** Accompany it with a written offer, valid for at least three
+years, to give any third party, for a charge no more than your
+cost of physically performing source distribution, a complete
+machine-readable copy of the corresponding source code, to be
+distributed under the terms of Sections 1 and 2 above on a medium
+customarily used for software interchange; or,
+* **c)** Accompany it with the information you received as to the offer
+to distribute corresponding source code.  (This alternative is
+allowed only for noncommercial distribution and only if you
+received the program in object code or executable form with such
+an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+**4.** You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+**5.** You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+**6.** Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+**7.** If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+**8.** If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+**9.** The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and “any
+later version”, you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+**10.** If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+### NO WARRANTY
+
+**11.** BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+**12.** IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+END OF TERMS AND CONDITIONS
+
+### How to Apply These Terms to Your New Programs
+
+If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the “copyright” line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+    
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+    
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w` and `show c` should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w` and `show c`; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a “copyright disclaimer” for the program, if
+necessary.  Here is a sample; alter the names:
+
+    Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+    `Gnomovision' (which makes passes at compilers) written by James Hacker.
+    
+    <signature of Ty Coon>, 1 April 1989
+    Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --git c/Makefile.am w/Makefile.am
index a052495..668f200 100644
--- c/Makefile.am
+++ w/Makefile.am
@@ -10,15 +10,17 @@ IMAP_SUBDIR = imap
 IMAP_INCLUDES = -I$(top_srcdir)/imap
 endif
 
-SUBDIRS = m4 po intl doc contrib $(IMAP_SUBDIR)
+SUBDIRS = $(IMAP_SUBDIR) m4 po intl doc contrib
 
-bin_SCRIPTS = muttbug flea $(SMIMEAUX_TARGET)
+bin_SCRIPTS = $(SMIMEAUX_TARGET)
 
 if BUILD_HCACHE
 HCVERSION = hcversion.h
 endif
 
-BUILT_SOURCES = keymap_defs.h patchlist.c reldate.h conststrings.c $(HCVERSION)
+distdir = neo$(PACKAGE)-$(VERSION)
+
+BUILT_SOURCES = keymap_defs.h patchlist.c oldmutt_ver.h conststrings.c hcachever.sh $(HCVERSION) $(top_srcdir)/.version
 
 bin_PROGRAMS = mutt $(DOTLOCK_TARGET) $(PGPAUX_TARGET)
 mutt_SOURCES = \
@@ -34,7 +36,7 @@ mutt_SOURCES = \
 	score.c send.c sendlib.c signal.c sort.c \
 	status.c system.c thread.c charset.c history.c lib.c \
 	muttlib.c editmsg.c mbyte.c \
-	url.c ascii.c crypt-mod.c crypt-mod.h safe_asprintf.c
+	url.c ascii.c crypt-mod.c crypt-mod.h safe_asprintf.c version.c
 
 nodist_mutt_SOURCES = $(BUILT_SOURCES)
 
@@ -50,33 +52,46 @@ DEFS=-DPKGDATADIR=\"$(pkgdatadir)\" -DSYSCONFDIR=\"$(sysconfdir)\" \
 
 AM_CPPFLAGS=-I. -I$(top_srcdir) $(IMAP_INCLUDES) $(GPGME_CFLAGS) -Iintl
 
-EXTRA_mutt_SOURCES = account.c bcache.c crypt-gpgme.c crypt-mod-pgp-classic.c \
+EXTRA_mutt_SOURCES = account.c bcache.c compress.c crypt-gpgme.c crypt-mod-pgp-classic.c \
 	crypt-mod-pgp-gpgme.c crypt-mod-smime-classic.c \
 	crypt-mod-smime-gpgme.c dotlock.c gnupgparse.c hcache.c md5.c \
 	mutt_idna.c mutt_sasl.c mutt_socket.c mutt_ssl.c mutt_ssl_gnutls.c \
 	mutt_tunnel.c pgp.c pgpinvoke.c pgpkey.c pgplib.c pgpmicalg.c \
 	pgppacket.c pop.c pop_auth.c pop_lib.c remailer.c resize.c sha1.c \
+	nntp.c newsrc.c \
 	sidebar.c smime.c smtp.c utf8.c wcwidth.c \
 	bcache.h browser.h hcache.h mbyte.h mutt_idna.h remailer.h url.h
 
-EXTRA_DIST = COPYRIGHT GPL OPS OPS.PGP OPS.CRYPT OPS.SMIME TODO UPDATING \
-	configure account.h \
-	attach.h buffy.h charset.h copy.h crypthash.h dotlock.h functions.h gen_defs \
+EXTRA_DIST = COPYRIGHT LICENSE.md OPS OPS.PGP OPS.CRYPT OPS.SMIME TODO UPDATING \
+	account.h \
+	attach.h buffy.h charset.h compress.h copy.h crypthash.h dotlock.h functions.h gen_defs \
 	globals.h hash.h history.h init.h keymap.h mutt_crypt.h \
 	mailbox.h mapping.h md5.h mime.h mutt.h mutt_curses.h mutt_menu.h \
 	mutt_regex.h mutt_sasl.h mutt_socket.h mutt_ssl.h mutt_tunnel.h \
 	mx.h pager.h pgp.h pop.h protos.h rfc1524.h rfc2047.h \
-	rfc2231.h rfc822.h rfc3676.h sha1.h sort.h mime.types VERSION prepare \
+	rfc2231.h rfc822.h rfc3676.h sha1.h sort.h mime.types \
+	nntp.h ChangeLog.nntp \
 	_regex.h OPS.MIX README.SECURITY remailer.c remailer.h browser.h \
 	mbyte.h lib.h extlib.c pgpewrap.c smime_keys.pl pgplib.h \
-	README.SSL smime.h group.h \
-	muttbug pgppacket.h depcomp ascii.h BEWARE PATCHES patchlist.sh \
-	ChangeLog mkchangelog.sh mutt_idna.h sidebar.h OPS.SIDEBAR \
+	README.SSL README.md README.neomutt README.notmuch smime.h group.h \
+	pgppacket.h depcomp ascii.h PATCHES patchlist.sh \
+	ChangeLog ChangeLog.neomutt mutt_idna.h sidebar.h OPS.SIDEBAR \
 	snprintf.c regex.c crypt-gpgme.h hcachever.sh.in \
-	txt2c.c txt2c.sh version.sh check_sec.sh
+	txt2c.c txt2c.sh version.h \
+	$(top_srcdir)/.version git-version-gen
 
 EXTRA_SCRIPTS = smime_keys
 
+if BUILD_NOTMUCH
+mutt_SOURCES += mutt_notmuch.c mutt_notmuch.h
+mutt_LDADD += $(NOTMUCH_LIBS)
+endif
+
+# kz
+EXTRA_DIST += UPDATING.kz OPS.NOTMUCH
+
+
+
 mutt_dotlock_SOURCES = mutt_dotlock.c
 mutt_dotlock_LDADD = $(LIBOBJS)
 mutt_dotlock_DEPENDENCIES = $(LIBOBJS)
@@ -112,15 +127,17 @@ conststrings.c: txt2c config.status
 
 CLEANFILES = mutt_dotlock.c keymap_alldefs.h $(BUILT_SOURCES)
 
-DISTCLEANFILES= flea smime_keys txt2c po/$(PACKAGE).pot
+DISTCLEANFILES= smime_keys txt2c po/$(PACKAGE).pot
 
 ACLOCAL_AMFLAGS = -I m4
 
 LDADD = $(LIBOBJS) $(INTLLIBS)
 
-flea:	muttbug.sh
-	cp muttbug.sh flea
-	chmod +x flea
+$(top_srcdir)/.version:
+	echo $(VERSION) > $@-t && mv $@-t $@
+
+dist-hook:
+	echo $(VERSION) > $(distdir)/.tarball-version
 
 smime_keys: $(srcdir)/smime_keys.pl
 	cp $(srcdir)/smime_keys.pl smime_keys
@@ -129,16 +146,22 @@ smime_keys: $(srcdir)/smime_keys.pl
 keymap_defs.h: $(OPS) $(srcdir)/gen_defs
 	$(srcdir)/gen_defs $(OPS) > keymap_defs.h
 
-keymap_alldefs.h: $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.PGP $(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME $(srcdir)/gen_defs
+keymap_alldefs.h: $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.NOTMUCH $(srcdir)/OPS.PGP $(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME $(srcdir)/gen_defs
 	rm -f $@
-	$(srcdir)/gen_defs $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.PGP \
+	$(srcdir)/gen_defs $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.NOTMUCH $(srcdir)/OPS.PGP \
 		$(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME \
 			> keymap_alldefs.h
 
-reldate.h: $(srcdir)/ChangeLog
-	echo 'const char *ReleaseDate = "'`head -n 1 $(srcdir)/ChangeLog | LC_ALL=C cut -d ' ' -f 1`'";' > reldate.h.tmp; \
-	cmp -s reldate.h.tmp reldate.h || cp reldate.h.tmp reldate.h; \
-	rm reldate.h.tmp
+oldmutt_ver.h:
+	version="1.7.0" && \
+	echo 'const char *OldMuttVer = "'$$version'";' > oldmutt_ver.h.tmp; \
+	cmp -s oldmutt_ver.h.tmp oldmutt_ver.h || mv oldmutt_ver.h.tmp oldmutt_ver.h
+
+# reldate.h:
+# 	date=`head -n 1 $(top_srcdir)/ChangeLog.neomutt | LC_ALL=C cut -b 1-10` && \
+# 	echo 'const char *ReleaseDate = "'$$date'";' > reldate.h.tmp; \
+# 	cmp -s reldate.h.tmp reldate.h || cp reldate.h.tmp reldate.h; \
+# 	rm reldate.h.tmp
 
 # The '#undef ENABLE_NLS' is to work around an automake ordering issue:
 # BUILT_SOURCES are processed before SUBDIRS.
@@ -184,17 +207,6 @@ pclean:
 check-security:
 	(cd $(top_srcdir) && ./check_sec.sh)
 
-commit:
-	@echo "make commit is obsolete; use hg-commit"; false
-
-update-changelog:
-	(cd $(top_srcdir); \
-	sh ./mkchangelog.sh | cat  - ChangeLog > ChangeLog.$$$$ && mv ChangeLog.$$$$ ChangeLog; \
-	$${VISUAL:-vi} ChangeLog)
-
-mutt-dist:
-	(cd $(srcdir) && ./build-release )
-
 update-doc:
 	(cd doc && $(MAKE) update-doc)
 
diff --git c/OPS w/OPS
index 02cea8e..2cce879 100644
--- c/OPS
+++ w/OPS
@@ -5,17 +5,20 @@ OP_ATTACH_VIEW_TEXT "view attachment as text"
 OP_ATTACH_COLLAPSE "Toggle display of subparts"
 OP_BOTTOM_PAGE "move to the bottom of the page"
 OP_BOUNCE_MESSAGE "remail a message to another user"
+OP_BROWSER_GOTO_FOLDER "swap the current folder position with $folder if it exists"
 OP_BROWSER_NEW_FILE "select a new file in this directory"
 OP_BROWSER_VIEW_FILE "view file"
 OP_BROWSER_TELL "display the currently selected file's name"
-OP_BROWSER_SUBSCRIBE "subscribe to current mailbox (IMAP only)"
-OP_BROWSER_UNSUBSCRIBE "unsubscribe from current mailbox (IMAP only)"
+OP_BROWSER_SUBSCRIBE "subscribe to current mbox (IMAP/NNTP only)"
+OP_BROWSER_UNSUBSCRIBE "unsubscribe from current mbox (IMAP/NNTP only)"
 OP_BROWSER_TOGGLE_LSUB "toggle view all/subscribed mailboxes (IMAP only)"
 OP_BUFFY_LIST "list mailboxes with new mail"
+OP_CATCHUP "mark all articles in newsgroup as read"
 OP_CHANGE_DIRECTORY "change directories"
 OP_CHECK_NEW "check mailboxes for new mail"
 OP_COMPOSE_ATTACH_FILE "attach file(s) to this message"
 OP_COMPOSE_ATTACH_MESSAGE "attach message(s) to this message"
+OP_COMPOSE_ATTACH_NEWS_MESSAGE "attach news article(s) to this message"
 OP_COMPOSE_EDIT_BCC "edit the BCC list"
 OP_COMPOSE_EDIT_CC "edit the CC list"
 OP_COMPOSE_EDIT_DESCRIPTION "edit attachment description"
@@ -26,7 +29,10 @@ OP_COMPOSE_EDIT_FROM "edit the from field"
 OP_COMPOSE_EDIT_HEADERS "edit the message with headers"
 OP_COMPOSE_EDIT_MESSAGE "edit the message"
 OP_COMPOSE_EDIT_MIME "edit attachment using mailcap entry"
+OP_COMPOSE_EDIT_NEWSGROUPS "edit the newsgroups list"
 OP_COMPOSE_EDIT_REPLY_TO "edit the Reply-To field"
+OP_COMPOSE_EDIT_FOLLOWUP_TO "edit the Followup-To field"
+OP_COMPOSE_EDIT_X_COMMENT_TO "edit the X-Comment-To field"
 OP_COMPOSE_EDIT_SUBJECT "edit the subject of this message"
 OP_COMPOSE_EDIT_TO "edit the TO list"
 OP_CREATE_MAILBOX "create a new mailbox (IMAP only)"
@@ -37,6 +43,7 @@ OP_COMPOSE_NEW_MIME "compose new attachment using mailcap entry"
 OP_COMPOSE_TOGGLE_RECODE "toggle recoding of this attachment"
 OP_COMPOSE_POSTPONE_MESSAGE "save this message to send later"
 OP_COMPOSE_RENAME_FILE "rename/move an attached file"
+OP_COMPOSE_TO_SENDER "compose a new message to the sender"
 OP_COMPOSE_SEND_MESSAGE "send the message"
 OP_COMPOSE_TOGGLE_DISPOSITION "toggle disposition between inline/attachment"
 OP_COMPOSE_TOGGLE_UNLINK "toggle whether to delete file after sending it"
@@ -56,6 +63,7 @@ OP_DELETE_THREAD "delete all messages in thread"
 OP_DISPLAY_ADDRESS "display full address of sender"
 OP_DISPLAY_HEADERS "display message and toggle header weeding"
 OP_DISPLAY_MESSAGE "display a message"
+OP_EDIT_LABEL "add, change, or delete a message's label"
 OP_EDIT_MESSAGE "edit the raw message"
 OP_EDITOR_BACKSPACE "delete the char in front of the cursor"
 OP_EDITOR_BACKWARD_CHAR "move the cursor one character to the left"
@@ -85,8 +93,13 @@ OP_EXIT "exit this menu"
 OP_FILTER "filter attachment through a shell command"
 OP_FIRST_ENTRY "move to the first entry"
 OP_FLAG_MESSAGE "toggle a message's 'important' flag"
+OP_FOLLOWUP "followup to newsgroup"
+OP_FORWARD_TO_GROUP "forward to newsgroup"
 OP_FORWARD_MESSAGE "forward a message with comments"
 OP_GENERIC_SELECT_ENTRY "select the current entry"
+OP_GET_CHILDREN "get all children of the current message"
+OP_GET_MESSAGE "get message with Message-Id"
+OP_GET_PARENT "get parent of the current message"
 OP_GROUP_REPLY "reply to all recipients"
 OP_HALF_DOWN "scroll down 1/2 page"
 OP_HALF_UP "scroll up 1/2 page"
@@ -94,11 +107,14 @@ OP_HELP "this screen"
 OP_JUMP "jump to an index number"
 OP_LAST_ENTRY "move to the last entry"
 OP_LIST_REPLY "reply to specified mailing list"
+OP_LOAD_ACTIVE "load list of all newsgroups from NNTP server"
 OP_MACRO "execute a macro"
 OP_MAIL "compose a new mail message"
 OP_MAIN_BREAK_THREAD "break the thread in two"
 OP_MAIN_CHANGE_FOLDER "open a different folder"
 OP_MAIN_CHANGE_FOLDER_READONLY "open a different folder in read only mode"
+OP_MAIN_CHANGE_GROUP "open a different newsgroup"
+OP_MAIN_CHANGE_GROUP_READONLY "open a different newsgroup in read only mode"
 OP_MAIN_CLEAR_FLAG "clear a status flag from a message"
 OP_MAIN_DELETE_PATTERN "delete messages matching a pattern"
 OP_MAIN_IMAP_FETCH "force retrieval of mail from IMAP server"
@@ -127,6 +143,7 @@ OP_MAIN_READ_SUBTHREAD "mark the current subthread as read"
 OP_MAIN_SET_FLAG "set a status flag on a message"
 OP_MAIN_SYNC_FOLDER "save changes to mailbox"
 OP_MAIN_TAG_PATTERN "tag messages matching a pattern"
+OP_MAIN_QUASI_DELETE "delete from mutt, don't touch on disk"
 OP_MAIN_UNDELETE_PATTERN "undelete messages matching a pattern"
 OP_MAIN_UNTAG_PATTERN "untag messages matching a pattern"
 OP_MIDDLE_PAGE "move to the middle of the page"
@@ -138,15 +155,18 @@ OP_PAGER_HIDE_QUOTED "toggle display of quoted text"
 OP_PAGER_SKIP_QUOTED "skip beyond quoted text"
 OP_PAGER_TOP "jump to the top of the message"
 OP_PIPE "pipe message/attachment to a shell command"
+OP_POST "post message to newsgroup"
 OP_PREV_ENTRY "move to the previous entry"
 OP_PREV_LINE "scroll up one line"
 OP_PREV_PAGE "move to the previous page"
 OP_PRINT "print the current entry"
 OP_PURGE_MESSAGE "really delete the current entry, bypassing the trash folder"
+OP_PURGE_THREAD "really delete the current thread, bypassing the trash folder"
 OP_QUERY "query external program for addresses"
 OP_QUERY_APPEND "append new query results to current results"
 OP_QUIT "save changes to mailbox and quit"
 OP_RECALL_MESSAGE "recall a postponed message"
+OP_RECONSTRUCT_THREAD "reconstruct thread containing current message"
 OP_REDRAW "clear and redraw the screen"
 OP_REFORMAT_WINCH "{internal}"
 OP_RENAME_MAILBOX "rename the current mailbox (IMAP only)"
@@ -161,22 +181,27 @@ OP_SEARCH_TOGGLE "toggle search pattern coloring"
 OP_SHELL_ESCAPE "invoke a command in a subshell"
 OP_SORT "sort messages"
 OP_SORT_REVERSE "sort messages in reverse order"
+OP_SUBSCRIBE_PATTERN "subscribe to newsgroups matching a pattern"
 OP_TAG "tag the current entry"
 OP_TAG_PREFIX "apply next function to tagged messages"
 OP_TAG_PREFIX_COND "apply next function ONLY to tagged messages"
 OP_TAG_SUBTHREAD "tag the current subthread"
 OP_TAG_THREAD "tag the current thread"
 OP_TOGGLE_NEW "toggle a message's 'new' flag"
+OP_TOGGLE_READ "toggle view of read messages"
 OP_TOGGLE_WRITE "toggle whether the mailbox will be rewritten"
 OP_TOGGLE_MAILBOXES "toggle whether to browse mailboxes or all files"
 OP_TOP_PAGE "move to the top of the page"
+OP_UNCATCHUP "mark all articles in newsgroup as unread"
 OP_UNDELETE "undelete the current entry"
 OP_UNDELETE_THREAD "undelete all messages in thread"
 OP_UNDELETE_SUBTHREAD "undelete all messages in subthread"
+OP_UNSUBSCRIBE_PATTERN "unsubscribe from newsgroups matching a pattern"
 OP_VERSION "show the Mutt version number and date"
 OP_VIEW_ATTACH "view attachment using mailcap entry if necessary"
 OP_VIEW_ATTACHMENTS "show MIME attachments"
 OP_WHAT_KEY "display the keycode for a key press"
+OP_LIMIT_CURRENT_THREAD "limit view to current thread"
 OP_MAIN_SHOW_LIMIT "show currently active limit pattern"
 OP_MAIN_COLLAPSE_THREAD "collapse/uncollapse current thread"
 OP_MAIN_COLLAPSE_ALL "collapse/uncollapse all threads"
diff --git c/OPS.NOTMUCH w/OPS.NOTMUCH
new file mode 100644
index 0000000..4508e4e
--- /dev/null
+++ w/OPS.NOTMUCH
@@ -0,0 +1,5 @@
+OP_MAIN_CHANGE_VFOLDER "open a different virtual folder"
+OP_MAIN_VFOLDER_FROM_QUERY "generate virtual folder from query"
+OP_MAIN_MODIFY_LABELS "modify (notmuch) tags"
+OP_MAIN_MODIFY_LABELS_THEN_HIDE "modify labels and then hide message"
+OP_MAIN_ENTIRE_THREAD "read entire thread of the current message"
diff --git c/OPS.SIDEBAR w/OPS.SIDEBAR
index 7e5b504..e39f80c 100644
--- c/OPS.SIDEBAR
+++ w/OPS.SIDEBAR
@@ -5,4 +5,5 @@ OP_SIDEBAR_PAGE_DOWN "scroll the sidebar down 1 page"
 OP_SIDEBAR_PAGE_UP "scroll the sidebar up 1 page"
 OP_SIDEBAR_PREV "move the highlight to previous mailbox"
 OP_SIDEBAR_PREV_NEW "move the highlight to previous mailbox with new mail"
+OP_SIDEBAR_TOGGLE_VIRTUAL "toggle between mailboxes and virtual mailboxes"
 OP_SIDEBAR_TOGGLE_VISIBLE "make the sidebar (in)visible"
diff --git c/PATCHES w/PATCHES
index e69de29..2bc250d 100644
--- c/PATCHES
+++ w/PATCHES
@@ -0,0 +1,29 @@
+patch-attach-headers-color-neomutt
+patch-compose-to-sender-neomutt
+patch-compress-neomutt
+patch-cond-date-neomutt
+patch-encrypt-to-self-neomutt
+patch-fmemopen-neomutt
+patch-forgotten-attachments-neomutt
+patch-ifdef-neomutt
+patch-index-color-neomutt
+patch-initials-neomutt
+patch-keywords-neomutt
+patch-kyoto-neomutt
+patch-limit-current-thread-neomutt
+patch-lmdb-neomutt
+patch-multiple-fcc-neomutt
+patch-nested-if-neomutt
+patch-new-mail-neomutt
+patch-nntp-neomutt
+patch-notmuch-neomutt
+patch-progress-neomutt
+patch-quasi-delete-neomutt
+patch-reply-with-xorig-neomutt
+patch-sensible-browser-neomutt
+patch-sidebar-neomutt
+patch-skip-quoted-neomutt
+patch-smime-encrypt-self-neomutt
+patch-status-color-neomutt
+patch-timeout-neomutt
+patch-tls-sni-neomutt
diff --git c/README.SSL w/README.SSL
index 75cac80..90290e0 100644
--- c/README.SSL
+++ w/README.SSL
@@ -5,7 +5,7 @@ Compilation
 -----------
 If you want to have SSL support in mutt, you need to install OpenSSL
 (http://www.openssl.org) libraries and headers before compiling.
-OpenSSL versions 0.9.3 through 0.9.6a have been tested.
+OpenSSL versions 0.9.3 through 1.0.1c have been tested.
 
 For SSL support to be enabled, you need to run the ``configure''
 script with ``--enable-imap --with-ssl[=PFX]'' parameters.  If the
@@ -65,6 +65,12 @@ certificate, the connection will be established. Accepted certificates
 can also be saved so that further connections to the server are
 automatically accepted. 
 
+If OpenSSL was built with support for ServerNameIndication (SNI) and TLS
+is used in the negotiation, mutt will send its idea of the server-name
+as part of the TLS negotiation.  This allows the server to select an
+appropriate certificate, in the event that one server handles multiple
+hostnames with different certificates.
+
 If your organization has several equivalent IMAP-servers, each of them
 should have a unique certificate which is signed with a common
 certificate.  If you want to use all of those servers, you don't need to
@@ -102,9 +108,15 @@ you know which options do not work, you can set the variables for non-working
 protocols to know.  The variables for the protocols are ssl_use_tlsv1, 
 ssl_use_sslv2, and ssl_use_sslv3.
 
+To verify TLS SNI support by a server, you can use:
+    openssl s_client -host <imap server> -port <port> \
+        -tls1 -servername <imap server>
+
+
 -- 
 Tommi Komulainen
 Tommi.Komulainen@iki.fi
 
-Updated by Jeremy Katz
-katzj@linuxpower.org
+Updated by:
+  Jeremy Katz <katzj@linuxpower.org>
+  Phil Pennock <mutt-dev@spodhuis.org>
diff --git c/README.neomutt w/README.neomutt
new file mode 100644
index 0000000..966b4b6
--- /dev/null
+++ w/README.neomutt
@@ -0,0 +1,104 @@
+# This is the NeoMutt Project
+
+[![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-blue.svg)](https://github.com/neomutt/neomutt/blob/neomutt/COPYRIGHT)
+[![Travis branch](https://api.travis-ci.org/neomutt/neomutt.svg?branch=neomutt)](https://travis-ci.org/neomutt/neomutt)
+[![Coverity Scan](https://img.shields.io/coverity/scan/3997.svg?maxAge=2592000)](https://scan.coverity.com/projects/neomutt-neomutt)
+
+## What is NeoMutt?
+
+* NeoMutt is a project of projects.
+* A place to gather all the patches against Mutt.
+* A place for all the developers to gather.
+
+Hopefully this will build the community and reduce duplicated effort.
+
+NeoMutt was created when Richard Russon (FlatCap) took all the old Mutt patches,
+sorted through them, fixed them up and documented them.
+
+## What Features does NeoMutt have?
+
+| Name                 | Description
+|----------------------|-------------------------------------------------------
+| Attach Headers Color | Color attachment headers using regexp
+| Compressed Folders   | Read from/write to compressed mailboxes
+| Conditional Dates    | Conditional Date Formatting
+| Encrypt-to-Self      | Save an self-encrypted copy of emails
+| Fmemopen             | Use fmemopen(3) for speedier temporary files
+| Ifdef                | Conditional config options
+| Index Color          | Theming of the Index List
+| Initials Expando     | Expando for Author's Initials
+| Keywords             | Labels/Tagging for emails
+| Limit-Current-Thread | Limit Index View to Current Thread
+| LMDB                 | LMDB backend for the header cache
+| Multiple fcc         | Save multiple copies of outgoing mail
+| Nested If            | Allow deeply nested conditionals in format strings
+| New Mail Command     | Run a command when new mail arrives
+| NNTP                 | Talk to a Usenet news server
+| Notmuch              | Powerful email search engine
+| Progress Bar         | Colourful Progress Bar
+| Quasi-Delete         | Hide emails from view, but don't delete them
+| Sensible-Browser     | Make the file browser behave
+| Sidebar              | Panel containing list of Mailboxes
+| Skip-Quoted          | Skip Quoted Text
+| Status Color         | Theming of the Status Bar
+| Timeout Hook         | Run a command periodically
+| TLS-SNI              | Negotiate with a Server for a Certificate
+| Trash Folder         | Automatically move emails to a trash bin
+
+## Contributed Scripts and Config
+
+- Keybase Integration
+  Joshua Jordi (JakkinStewart)
+- vim-keybindings - Mutt config for vim users
+  Ivan Tham (pickfire)
+
+## Where is NeoMutt?
+
+- Source Code:     https://github.com/neomutt/neomutt
+- Releases:        https://github.com/neomutt/neomutt/releases/latest
+- Questions/Bugs:  https://github.com/neomutt/neomutt/issues
+- Website:         http://www.neomutt.org/
+- IRC:             irc://irc.freenode.net/neomutt
+- Mailinglists:    [neomutt-users](mailto:neomutt-users-request@neomutt.org?subject=subscribe) 
+and [neomutt-devel](mailto:neomutt-devel-request@neomutt.org?subject=subscribe)
+- Development:     http://www.neomutt.org/devel/
+
+## NeoMutt Developers
+
+Here's a list of everyone who's helped NeoMutt:
+
+Alex Pearce, Ander Punnar, Antonio Radici, Baptiste Daroussin, Chris Salzberg,
+Christoph Berg, Darshit Shah, David Sterba, Elimar Riesebieter, Evgeni Golov,
+Fabian Groffen, Fabio Alessandro Locati, Faidon Liambotis, Guillaume Brogi,
+Ivan Tham, Johannes Frankenau, Johannes Weißl, Joshua Jordi, Karel Zak,
+Kurt Jaeger, Marco Hinz, Matteo Vescovi, Pierre-Elliott Bécue,
+Richard Hartmann, Richard Russon, Santiago Torres, Sven Guckes,
+Thomas Klausner, Udo Schweigert, Vsevolod Volkov, Werner Fink,
+Yoshiki Vázquez Baeza.
+
+## Original Patch Authors
+
+Without the original patch authors, there would be nothing.
+So, a Big Thank You to:
+
+Aaron Schrab, Alain Penders, Benjamin Kuperman, Cedric Duval, Chris Mason,
+Christian Aichinger, Christoph Berg, Christoph Rissner, David Champion,
+David Riebenbauer, David Sterba, David Wilson, Don Zickus, Elimar Riesebieter,
+Eric Davis, Evgeni Golov, Fabian Groffen, Felix von Leitner, Jan Synacek,
+Jason DeTiberus, Jeremiah Foster, Jeremy Katz, Josh Poimboeuf, Julius Plenz,
+Justin Hibbits, Karel Zak, Kirill Shutemov, Luke Macken, Mantas Mikulenas,
+Matteo Vescovi, Patrick Brisbin, Paul Miller, Phil Pennock,
+Philippe Le Brouster, Richard Russon, Rocco Rutte, Roland Rosenfeld, Sami Farin,
+Stefan Assmann, Stefan Kuhn, Steve Kemp, Terry Chan, Thomas Glanzmann,
+Thomer Gil, Tim Stoakes, Tyler Earnest, Victor Manuel Jaquez Leal,
+Vincent Lefevre, Vladimir Marek, Vsevolod Volkov.
+
+## Original Mutt Authors
+
+And of course, we should thank the original Mutt authors, including the original
+author Michael Elkins and all the people that have contributed to Mutt during
+its long history, see the Acknowledgements section of the user manual for a
+detailed list.
+
+http://www.neomutt.org/manual/miscellany.html#acknowledgements
+
diff --git c/README.notmuch w/README.notmuch
new file mode 100644
index 0000000..a36d1b2
--- /dev/null
+++ w/README.notmuch
@@ -0,0 +1,403 @@
+notmuch support for mutt
+------------------------
+
+ * notmuch is e-mail fulltext indexing and tagging engine; see
+   http://notmuchmail.org/ for more information.
+
+ * home page (wiki) and git:
+
+   https://github.com/karelzak/mutt-kz
+
+   Note that the master branch is rebased to be up to date with mutt upstream. Use
+   stable/v<version> branches for downstream packaging.
+
+ * mailing list:
+
+   https://admin.fedoraproject.org/mailman/listinfo/mutt-kz
+
+ * requirements:
+
+   notmuch >= 0.9
+
+ * compile:
+
+  $ git clone git://github.com/karelzak/mutt-kz.git
+  $ cd mutt-kz
+  $ ./prepare
+  $ ./configure --enable-notmuch [--enable-debug]
+  $ make
+
+ * Folders URI
+
+   notmuch://[<path>][?<item>=<name>[& ...]]
+
+   The <path> is an absolute path to the directory where the notmuch database
+   is found as returned by 'notmuch config get database.path' command. Note that
+   the <path> should NOT include .notmuch directory name.
+
+   If the "<path>" is not defined then $nm_default_uri or $folder is used,
+   for example:
+
+	set nm_default_uri = "notmuch:///home/foo/maildir"
+	virtual-mailboxes "My INBOX" "notmuch://?query=tag:inbox"
+
+   Items:
+
+      query=<string>
+
+	 See SEARCH SYNTAX in notmuch man page. Don't forget to use "and" and
+         "or" operators in your queries.
+
+      Note that proper URI should not contain blank space and all "bad" chars
+      should be encoded, for example
+
+	 "tag:AAA and tag:BBB" --encoding-> tag:AAA%20and%20tag:BBB
+
+      but mutt config file parser is smart enough to accept space in quoted
+      strings. It means that you can use
+
+         "notmuch:///foo?query=tag:AAA and tag:BBB"
+
+      in your config files to keep things readable.
+
+      See http://xapian.org/docs/queryparser.html for more details about Xapian
+      queries.
+
+
+      limit=<number>
+
+         Restricts number of messages/threads in the result. The default limit
+         is nm_db_limit.
+
+      type=<threads|messages>
+
+         Reads all matching messages or whole-threads. The default is 'messages'
+         or nm_query_type.
+
+
+ * commands:
+
+   change-vfolder:
+      - switch to another virtual folder, a new folder maybe be specified by
+        vfolder description (see virtual-mailboxes) or URI
+      - the default is next vfolder with unread messages
+      - default key: X
+
+   vfolder-from-query:
+      - generate new virtual folder from notmuch search query
+      - default key: <Esc>X
+      - note: TAB completion of 'tag:' names is available
+
+   modify-labels:
+      - add or remove notmuch tags; [+]<tag> to add, -<tag> to remove
+      - default key: `
+      - note: TAB completion of tag names is available
+      - example: "+AAA +BBB -CCC"
+
+   modify-labels-then-hide:
+      - same as <modify-labels> but message is marked by <quasi-delete>
+      - not mapped to any key
+      - note: TAB completion of tag names is available
+      - example (add "archive" notmuch tag and remove message from screen):
+
+       macro index A "<modify-labels-then-hide>+archive -inbox\n<sync-mailbox>"
+       macro index I "<modify-labels-then-hide>-inbox\n<sync-mailbox>"
+
+   quasi-delete:
+      - delete message from mutt (usually after <sync-mailbox> function), but
+        don't touch message on disk
+
+   entire-thread:
+      - add to the current list of the messages all messages that belongs to the same thread
+        as the current message. This command is useful when you have a new email in your INBOX
+        and you want to see the rest of the archived thread.
+      - default key: +
+
+ * Pattern modifiers:
+
+   Many of Mutt's commands allow you to specify a pattern to match (limit,
+   tag-pattern, delete-pattern, color, etc.). The following notmuch specific
+   mutt pattern modifiers are available:
+
+   - '~Y EXPR': Messages which contain EXPR in the list of labels.
+     Example:
+        # Color red all messages labeled as 'spam'.
+        color index    red      default        "~Y '\W?spam\W?'"
+
+ * muttrc:
+
+   Note that you can use notmuch specific mutt config file, see -F <config> in
+   mutt docs.
+
+
+   virtual-mailboxes <description> <uri> [ ...]
+
+      This command specifies one or more virtual folder. The folders are
+      accessible by command 'X'. It's possible to use the virtual mailbox
+      description as a sort key (e.g set sort_sidebar=desc)
+
+      example:
+
+      virtual-mailboxes "Linux Kernel" "notmuch:///whereis/db?query=tag:lkml&limit=1000" \
+                        "Filesystems"  "notmuch:///whereis/db?query=tag:fs" \
+                        "Music"        "notmuch:///another/db?query=tag:hard and tag:heavy"
+
+      The folder description is used for status line, folders browser, sidebar
+      and <change-vfolder> command (this command also accepts vfolder URI). The
+      folder-hook regex uses the URI.
+
+   virtual_spoolfile = <boolean>
+
+      When set, mutt will use the first virtual mailbox (see virtual-mailboxes)
+      as a spoolfile.
+
+      When set together with sidebar, mutt will use list of virtual folders in
+      the sidebar. It's possible to toggle between virtual and normal folders by
+      sidebar-toggle command.
+
+   tag-transforms <tag> <transform> [ ...]
+
+      This command specifies text transforms to be shown instead of the actual
+      tag names with '%g' in the index and pager formats. Note that Unicode
+      symbols can be used for transforms.
+
+      example:
+
+      tag-transforms "inbox"   "i"   \
+                     "unread"  "u"   \
+                     "replied" "↻ "  \
+                     "sent"    "➥ "  \
+                     "todo"    "T"   \
+                     "deleted" "DEL" \
+                     "invites" "CAL"
+
+   tag-formats <tag> <format sequence> [ ...]
+
+      Specify index formatting sequences for individual tags for direct
+      placement in the $index_format. The formats must start with 'G' and
+      the entire sequence is case sensitive.
+
+      example:
+
+      tag-formats "inbox"   "GI" \
+                  "unread"  "GU" \
+                  "replied" "GR" \
+                  "sent"    "GS" \
+                  "todo"    "Gt" \
+                  "deleted" "GD" \
+                  "invites" "Gi"
+
+      Now instead of using '%g' in your $index_format, which lists all tags
+      in a non-deterministic order, you can something like the following which puts
+      a transformed tag name in a specific spot on the index line:
+
+      set index_format='4C %S %[%y.%m.%d] %-18.18n %?GU?%GU& ? %?GR?%GR& ? %?GI?%GI& ? %s'
+
+      The %G formatting sequence may display all tags including tags hidden by
+      nm_hidden_tags.
+
+   nm_record = <boolean>
+
+      Add messages stored to the mutt record (see $record in the mutt docs)
+      also to notmuch DB. If you reply to an email then the new email inherits
+      tags from the original email.
+
+   nm_record_tags = <comma delimited list>
+
+      Tags that should be removed or added to the to the messages stored in the mutt record.
+
+      example:
+
+      set record = "~/sent-mails"
+      set nm_record = yes
+      set nm_record_tags = "-inbox,archive,me"
+
+   nm_open_timeout = <seconds>
+
+      This option specifies timeout for Notmuch database. Default is 5 seconds.
+
+   nm_default_uri = <uri>
+
+      This variable specifies the default Notmuch database in format
+      notmuch://<absolute path>, the URI is used for notmuch queries (ESC+X) when the
+      current folder is not based on notmuch. If the default URI is not specified
+      then mutt will try to use $folder variable (see mutt manual for more details).
+
+   nm_hidden_tags = <comma delimited list>
+
+      This variable specifies private notmuch tags which should not be printed
+      on screen (index, pager).
+
+      Default is "unread,draft,flagged,passed,replied,attachment".
+
+   nm_exclude_tags = <comma delimited list>
+
+      The messages tagged with these tags are excluded and not loaded
+      from notmuch DB to mutt unless specified explicitly.
+
+      Not set by default.
+
+   nm_unread_tag = <name>
+
+      This variable specifies notmuch tag which is used for unread messages. The
+      variable is used to count unread messages in DB only. All other mutt
+      commands use standard (e.g. maildir) flags.
+
+      Default is "unread".
+
+   nm_db_limit = <num>
+
+     This variable specifies notmuch query limit.
+
+     Default is unlimited.
+
+   nm_query_type = <threads|messages>
+
+     This variable specifies notmuch query type, supported types: 'threads' and
+     'messages'.
+
+     Default is 'messages'.
+
+   vfolder_format = <string>
+
+      This variable allows you to customize the file browser display for virtual
+      folders to your personal taste.  This string is similar to $folder_format,
+
+	%C   current folder number
+	%f   folder name (description)
+	%m   number of messages in the mailbox *
+	%n   number of unread messages in the mailbox *
+	%N   N if mailbox has new mail, blank otherwise
+	%>X  right justify the rest of the string and pad with character ``X''
+	%|X  pad to the end of the line with character ``X''
+	%*X  soft-fill with character ``X'' as pad
+
+      Default is "%2C %?n?%4n/&     ?%4m %N %f"
+
+   index_format and pager_format
+
+        %g   notmuch tags (labels)
+        %Gx  specific notmuch tag defined by tag-formats (see above)
+
+        for example:
+
+        tag-formats "inbox" "GI"
+        set index_format = "%4C %Z %?GI?%GI? ?  %[%d/%b]  %-16.15F %s %> %?g?(%g)?"
+        set pager_format = "-%Z- %C/%m: %-20.20n   %s%*  -- %?g?(%g)? - (%P)"
+
+
+* .muttrc example:
+
+	set record="~/Mail/Maildir/sent-mail"
+	set nm_record = yes
+	set nm_record_tags ="-inbox me archive"
+
+	set nm_default_uri="notmuch:///home/kzak/Mail/Maildir"
+	set virtual_spoolfile	= yes
+	set sort_browser        = unsorted
+
+	# normal folders
+	set mbox_type=Maildir
+	set folder="~/Mail/Maildir"
+	mailboxes =rh =fedora =misc
+
+	set sidebar_width	 = 35
+	set sidebar_visible	 = yes
+	set sidebar_sort_method  = unsorted
+	set sidebar_divider_char = │
+
+	color sidebar_new yellow default
+	color progress default magenta
+
+	bind index <left> sidebar-prev
+	bind index <right> sidebar-next
+	bind index <space> sidebar-open
+	bind index <Esc>S sidebar-toggle-virtual
+
+	set index_format="%4C %Z %?GI?%GI& ? %[%d/%b]  %-16.15F %?M?(%3M)&     ? %s %> %?g?%g?"
+
+        # virtual folders
+	virtual-mailboxes \
+	   "INBOX"                "notmuch://?query=tag:inbox and NOT tag:archive" \
+	   "Util-linux"           "notmuch://?query=tag:ul and NOT tag:archive" \
+	   "Bugs"                 "notmuch://?query=tag:bug NOT tag:archive" \
+	   "RH"                   "notmuch://?query=tag:rh and NOT tag:archive" \
+	   "Fedora"               "notmuch://?query=tag:fed and NOT tag:archive" \
+	   "Linux"                "notmuch://?query=tag:lk and NOT tag:archive" \
+	   "NFS"                  "notmuch://?query=tag:nfs and NOT tag:archive" \
+	   "Filesystems"          "notmuch://?query=tag:fs and NOT tag:archive" \
+	   "Security"             "notmuch://?query=tag:sec" \
+	   "Partitioning"         "notmuch://?query=tag:part" \
+	   "GNU"                  "notmuch://?query=tag:gnu" \
+	   "udev"                 "notmuch://?query=tag:udev" \
+	   "initrd"               "notmuch://?query=tag:initrd" \
+	   "Linux CZ"             "notmuch://?query=tag:cz" \
+	   "Notmuch"              "notmuch://?query=tag:nm" \
+	   "Procps"               "notmuch://?query=tag:proc" \
+	\
+	   " Util-linux  [archive]" "notmuch://?query=tag:ul and tag:archive" \
+	   " Bugs        [archive]" "notmuch://?query=tag:bug and tag:archive" \
+	   " RH          [archive]" "notmuch://?query=tag:rh and tag:archive" \
+	   " Fedora      [archive]" "notmuch://?query=tag:fed and tag:archive" \
+	   " Linux       [archive]" "notmuch://?query=tag:lk and tag:archive" \
+	   " Filesystems [archive]" "notmuch://?query=tag:fs and tag:archive" \
+
+	# move message to archive
+	macro index A "<modify-labels-then-hide>+archive -inbox\n<sync-mailbox>"
+
+	# remove message from inbox
+	macro index I "<modify-labels-then-hide>-inbox\n<sync-mailbox>"
+
+	# mark emails for git-am
+	# (e.g. "git am -i -3 $(notmuch search --output=files tag:PATCH)"
+	#
+	macro index P "<modify-labels>PATCH\n"
+	macro index <Esc>P "<modify-labels>-PATCH\n"
+
+
+* .procmailrc example:
+
+	NOINBOX="-r inbox"
+
+	### Add 'kw' (keyword) tag to all interesting e-mails and make the emails
+	### visible in inbox.
+	:0
+	* ^Subject:.*(mount|umount|libmount|losetup|util-linux|blkid|hwclock|mkswap|fdisk|parted|partition|gpt|topology)
+	{
+		TAGS="-t kw"
+		NOINBOX=""
+	}
+
+	### Deliver emails to maildirs by notmuch-deliver
+	### from notmuch contrib/
+	###
+	###    notmuch-deliver -t <tags> [-t ...] <maildir>
+
+	:0:notmuch.lock
+	* ^List-Id:.*linux.linux.cz
+	| notmuch-deliver $NOINBOX -t cz $TAGS linux.cz
+
+	:0:notmuch.lock
+	* ^X-Mailing-List:.*util-linux@vger.kernel.org
+	| notmuch-deliver -t ul $TAGS util-linux
+
+	:0:notmuch.lock
+	* ^List-Id:.*parted-devel.lists.alioth.debian.org
+	| notmuch-deliver $NOINBOX -t part $TAGS parted
+
+	### [...cut to make the example short...] ###
+
+	### All unmatched mails
+	:0:notmuch.lock
+	* ^From
+	| notmuch-deliver $TAGS misc
+
+	### fallback if notmuch does not work
+	:0:
+	* ^From
+	Mail/Maildir/misc/
+
+
+* another example:
+
+  http://notmuchmail.org/mutttips/
diff --git c/UPDATING.kz w/UPDATING.kz
new file mode 100644
index 0000000..1df36c0
--- /dev/null
+++ w/UPDATING.kz
@@ -0,0 +1,68 @@
+1.6.0.1:
+
++ rebase to mutt upstream 1.6.0
++ update to the new sidebar implementation. Note that all .muttrc options 
+  are prefixed by "sidebar_" now.
+
++ rebase is based on neomutt project (see https://github.com/neomutt) where are
+  maintained all non-upstream mutt changes, so it's easy to merge another
+  features like "trash", "ifdef", ... to mutt-kz.
+
++ the stable mutt-kz releases and tags are maintained in stable/v<version> branches, 
+  the master branch is going to be *rebased*. This development model help us to be 
+  up to date with mutt upstream.
+
+
+1.5.23.1:
+
++ integrated color status patch (original from Thomas Glanzmann)
+  https://thomas.glanzmann.de//mutt/#cstatus
++ integrated TLS Server Name Indication support patch (original from Phil Pennock)
++ improved sidebar functionality to optinaly show only folders with new emails
+  (sidebar-new, sitebar-next, ...)
+
++ fix notmuch DB usage
++ use unlocked libc IO in improve performance
++ security bug fix from original mutt
+
++ sync with the original mutt upstream
++ add sidebar_whitelist option
++ oppenc & pgp upstream sync and improvements
+
+
+1.5.22.1:
+
++ use git and github rather than hg to maintain source code
+
++ virtual folders based on notmuch queries
++ merge sidebar patch
++ merge index-color patch
+
++ <change-vfolder> command
++ <vfolder-from-query> command
++ <modify-labels> command to set/unset notmuch tags
++ <modify-labels-then-hide> command to set/unset notmuch tags and hide email
+  from the current view
++ <quasi-delete> command to delete message from mutt, but don't touch message
+  on the disk
++ <entire-thread> command to add to the current list of the messages all
+  messages that belongs to the same thread as the current message
++ ~Y EXPR  pattern modifier for notmuch labels for limit, tag-pattern,
+  delete-pattern, color etc.
++ virtual-mailboxes <desc> <uri> [...]  to specify list of the virtual mailboxes
++ virtual_spoolfile = <boolean> to use the first virtual mailbox as a spoolfile
++ tag-transforms <tag> <transform> to transform tag name to another name
++ tag-formats <tag> <format sequence> [ ...] to define tag specific formatting
+  sequence for $index_format
++ nm_record = <boolean> to add sent emails (mutt record) to notmuch DB
++ nm_record_tags = <comma delimited list> to specify tags for nm_record
++ nm_open_timeout = <seconds> to specify timeout for notmuch database
++ nm_default_uri = <uri>  the default URI to connect notmuch
++ nm_hidden_tags = <comma delimited list> to make some tags invisible for mutt user
++ nm_exclude_tags = <comma delimited list> - messages tagged with these tags
+  are excluded and not loaded from notmuch DB to mutt unless specified explicitly
++ nm_unread_tag = <name> to specify unread messages
++ nm_db_limit = <num> to specify notmuch query limit
++ nm_query_type = <threads|messages> to specify what to load from DB
++ vfolder_format = <string> to specify vfolders browser entry format
++ %g and %Gx index_format and pager_format formatting sequences
diff --git c/VERSION w/VERSION
deleted file mode 100644
index bd8bf88..0000000
--- c/VERSION
+++ /dev/null
@@ -1 +0,0 @@
-1.7.0
diff --git c/account.c w/account.c
index ce71180..ca0ee8e 100644
--- c/account.c
+++ w/account.c
@@ -51,8 +51,17 @@ int mutt_account_match (const ACCOUNT* a1, const ACCOUNT* a2)
     user = PopUser;
 #endif
   
+#ifdef USE_NNTP
+  if (a1->type == MUTT_ACCT_TYPE_NNTP && NntpUser)
+    user = NntpUser;
+#endif
+
   if (a1->flags & a2->flags & MUTT_ACCT_USER)
     return (!strcmp (a1->user, a2->user));
+#ifdef USE_NNTP
+  if (a1->type == MUTT_ACCT_TYPE_NNTP)
+    return a1->flags & MUTT_ACCT_USER && a1->user[0] ? 0 : 1;
+#endif
   if (a1->flags & MUTT_ACCT_USER)
     return (!strcmp (a1->user, user));
   if (a2->flags & MUTT_ACCT_USER)
@@ -130,6 +139,16 @@ void mutt_account_tourl (ACCOUNT* account, ciss_url_t* url)
   }
 #endif
 
+#ifdef USE_NNTP
+  if (account->type == MUTT_ACCT_TYPE_NNTP)
+  {
+    if (account->flags & MUTT_ACCT_SSL)
+      url->scheme = U_NNTPS;
+    else
+      url->scheme = U_NNTP;
+  }
+#endif
+
   url->host = account->host;
   if (account->flags & MUTT_ACCT_PORT)
     url->port = account->port;
@@ -155,6 +174,10 @@ int mutt_account_getuser (ACCOUNT* account)
   else if ((account->type == MUTT_ACCT_TYPE_POP) && PopUser)
     strfcpy (account->user, PopUser, sizeof (account->user));
 #endif
+#ifdef USE_NNTP
+  else if ((account->type == MUTT_ACCT_TYPE_NNTP) && NntpUser)
+    strfcpy (account->user, NntpUser, sizeof (account->user));
+#endif
   else if (option (OPTNOCURSES))
     return -1;
   /* prompt (defaults to unix username), copy into account->user */
@@ -217,6 +240,10 @@ int mutt_account_getpass (ACCOUNT* account)
   else if ((account->type == MUTT_ACCT_TYPE_SMTP) && SmtpPass)
     strfcpy (account->pass, SmtpPass, sizeof (account->pass));
 #endif
+#ifdef USE_NNTP
+  else if ((account->type == MUTT_ACCT_TYPE_NNTP) && NntpPass)
+    strfcpy (account->pass, NntpPass, sizeof (account->pass));
+#endif
   else if (option (OPTNOCURSES))
     return -1;
   else
diff --git c/account.h w/account.h
index f7932bf..653b7cc 100644
--- c/account.h
+++ w/account.h
@@ -29,7 +29,8 @@ enum
   MUTT_ACCT_TYPE_NONE = 0,
   MUTT_ACCT_TYPE_IMAP,
   MUTT_ACCT_TYPE_POP,
-  MUTT_ACCT_TYPE_SMTP
+  MUTT_ACCT_TYPE_SMTP,
+  MUTT_ACCT_TYPE_NNTP
 };
 
 /* account flags */
diff --git c/alias.c w/alias.c
index baeafb3..131629a 100644
--- c/alias.c
+++ w/alias.c
@@ -27,6 +27,7 @@
 
 #include <string.h>
 #include <ctype.h>
+#include <errno.h>
 
 ADDRESS *mutt_lookup_alias (const char *s)
 {
@@ -379,8 +380,10 @@ retry_name:
     recode_buf (buf, sizeof (buf));
     write_safe_address (rc, buf);
     fputc ('\n', rc);
-    safe_fclose (&rc);
-    mutt_message _("Alias added.");
+    if (safe_fsync_close(&rc) != 0)
+      mutt_message ("Trouble adding alias: %s.", strerror(errno));
+    else
+      mutt_message _("Alias added.");
   }
   else
     mutt_perror (buf);
diff --git c/attach.c w/attach.c
index 84cdf6d..d50d54a 100644
--- c/attach.c
+++ w/attach.c
@@ -765,7 +765,7 @@ int mutt_save_attachment (FILE *fp, BODY *m, char *path, int flags, HEADER *hdr)
       fseeko ((s.fpin = fp), m->offset, 0);
       mutt_decode_attachment (m, &s);
       
-      if (fclose (s.fpout) != 0)
+      if (safe_fsync_close (&s.fpout) != 0)
       {
 	mutt_perror ("fclose");
 	mutt_sleep (2);
@@ -800,7 +800,10 @@ int mutt_save_attachment (FILE *fp, BODY *m, char *path, int flags, HEADER *hdr)
       return (-1);
     }
     safe_fclose (&ofp);
-    safe_fclose (&nfp);
+    if (safe_fsync_close (&nfp) != 0) {
+      mutt_error _("Write fault!");
+      return (-1);
+    }
   }
 
   return 0;
@@ -814,6 +817,7 @@ int mutt_decode_save_attachment (FILE *fp, BODY *m, char *path,
   unsigned int saved_encoding = 0;
   BODY *saved_parts = NULL;
   HEADER *saved_hdr = NULL;
+  int ret = 0;
 
   memset (&s, 0, sizeof (s));
   s.flags = displaying;
@@ -871,7 +875,10 @@ int mutt_decode_save_attachment (FILE *fp, BODY *m, char *path,
 
   mutt_body_handler (m, &s);
 
-  safe_fclose (&s.fpout);
+  if (safe_fsync_close (&s.fpout) != 0) {
+    mutt_perror("fclose");
+    ret = -1;
+  }
   if (fp == NULL)
   {
     m->length = 0;
@@ -885,7 +892,7 @@ int mutt_decode_save_attachment (FILE *fp, BODY *m, char *path,
     safe_fclose (&s.fpin);
   }
 
-  return (0);
+  return ret;
 }
 
 /* Ok, the difference between send and receive:
diff --git c/attach.h w/attach.h
index 928408a..071f22c 100644
--- c/attach.h
+++ w/attach.h
@@ -50,7 +50,7 @@ void mutt_print_attachment_list (FILE *fp, int tag, BODY *top);
 
 void mutt_attach_bounce (FILE *, HEADER *, ATTACHPTR **, short, BODY *);
 void mutt_attach_resend (FILE *, HEADER *, ATTACHPTR **, short, BODY *);
-void mutt_attach_forward (FILE *, HEADER *, ATTACHPTR **, short, BODY *);
+void mutt_attach_forward (FILE *, HEADER *, ATTACHPTR **, short, BODY *, int);
 void mutt_attach_reply (FILE *, HEADER *, ATTACHPTR **, short, BODY *, int);
 
 #endif /* _ATTACH_H_ */
diff --git c/browser.c w/browser.c
index 15eccc5..5c99127 100644
--- c/browser.c
+++ w/browser.c
@@ -29,9 +29,16 @@
 #include "sort.h"
 #include "mailbox.h"
 #include "browser.h"
+#include "mx.h"
 #ifdef USE_IMAP
 #include "imap.h"
 #endif
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
 
 #include <stdlib.h>
 #include <dirent.h>
@@ -45,17 +52,32 @@
 static const struct mapping_t FolderHelp[] = {
   { N_("Exit"),  OP_EXIT },
   { N_("Chdir"), OP_CHANGE_DIRECTORY },
+  { N_("Goto"),  OP_BROWSER_GOTO_FOLDER },
   { N_("Mask"),  OP_ENTER_MASK },
   { N_("Help"),  OP_HELP },
   { NULL,	 0 }
 };
 
+#ifdef USE_NNTP
+static struct mapping_t FolderNewsHelp[] = {
+  { N_("Exit"),        OP_EXIT },
+  { N_("List"),        OP_TOGGLE_MAILBOXES },
+  { N_("Subscribe"),   OP_BROWSER_SUBSCRIBE },
+  { N_("Unsubscribe"), OP_BROWSER_UNSUBSCRIBE },
+  { N_("Catchup"),     OP_CATCHUP },
+  { N_("Mask"),        OP_ENTER_MASK },
+  { N_("Help"),        OP_HELP },
+  { NULL,              0 }
+};
+#endif
+
 typedef struct folder_t
 {
   struct folder_file *ff;
   int num;
 } FOLDER;
 
+static char OldLastDir[_POSIX_PATH_MAX] = "";
 static char LastDir[_POSIX_PATH_MAX] = "";
 static char LastDirBackup[_POSIX_PATH_MAX] = "";
 
@@ -85,6 +107,16 @@ static int browser_compare_subject (const void *a, const void *b)
   return ((BrowserSort & SORT_REVERSE) ? -r : r);
 }
 
+static int browser_compare_desc (const void *a, const void *b)
+{
+  struct folder_file *pa = (struct folder_file *) a;
+  struct folder_file *pb = (struct folder_file *) b;
+
+  int r = mutt_strcoll (pa->desc, pb->desc);
+
+  return ((BrowserSort & SORT_REVERSE) ? -r : r);
+}
+
 static int browser_compare_date (const void *a, const void *b)
 {
   struct folder_file *pa = (struct folder_file *) a;
@@ -105,26 +137,93 @@ static int browser_compare_size (const void *a, const void *b)
   return ((BrowserSort & SORT_REVERSE) ? -r : r);
 }
 
-static void browser_sort (struct browser_state *state)
+static int browser_compare_count (const void *a, const void *b)
+{
+  struct folder_file *pa = (struct folder_file *) a;
+  struct folder_file *pb = (struct folder_file *) b;
+
+  int r = 0;
+  if (pa->has_buffy && pb->has_buffy)
+    r = pa->msg_count - pb->msg_count;
+  else if (pa->has_buffy)
+    return r = -1;
+  else
+    return r = 1;
+
+  return ((BrowserSort & SORT_REVERSE) ? -r : r);
+}
+
+static int browser_compare_count_new (const void *a, const void *b)
 {
-  int (*f) (const void *, const void *);
+  struct folder_file *pa = (struct folder_file *) a;
+  struct folder_file *pb = (struct folder_file *) b;
+
+  int r = 0;
+  if (pa->has_buffy && pb->has_buffy)
+    r = pa->msg_unread - pb->msg_unread;
+  else if (pa->has_buffy)
+    return r = -1;
+  else
+    return r = 1;
+
+  return ((BrowserSort & SORT_REVERSE) ? -r : r);
+}
+
+/* Wild compare function that calls the others. It's useful
+ * because it provides a way to tell "../" is always on the
+ * top of the list, independently of the sort method.
+ */
+static int browser_compare (const void *a, const void *b)
+{
+  struct folder_file *pa = (struct folder_file *) a;
+  struct folder_file *pb = (struct folder_file *) b;
+
+  if ((mutt_strcoll (pa->desc, "../") == 0) ||
+       (mutt_strcoll (pa->desc, "..") == 0))
+    return -1;
+  if ((mutt_strcoll (pb->desc, "../") == 0) ||
+       (mutt_strcoll (pb->desc, "..") == 0))
+    return 1;
 
   switch (BrowserSort & SORT_MASK)
   {
-    case SORT_ORDER:
-      return;
     case SORT_DATE:
-      f = browser_compare_date;
-      break;
+      return browser_compare_date(a, b);
     case SORT_SIZE:
-      f = browser_compare_size;
-      break;
+      return browser_compare_size(a, b);
+    case SORT_DESC:
+      return browser_compare_desc(a, b);
+    case SORT_COUNT:
+      return browser_compare_count(a, b);
+    case SORT_COUNT_NEW:
+      return browser_compare_count_new(a, b);
     case SORT_SUBJECT:
     default:
-      f = browser_compare_subject;
+      return browser_compare_subject(a, b);
+  }
+}
+
+/* Call to qsort using browser_compare function. Some
+ * specific sort methods are not used via NNTP.
+ */
+static void browser_sort (struct browser_state *state)
+{
+  switch (BrowserSort & SORT_MASK)
+  {
+    /* Also called "I don't care"-sort-method. */
+    case SORT_ORDER:
+      return;
+#ifdef USE_NNTP
+    case SORT_SIZE:
+    case SORT_DATE:
+      if (option (OPTNEWS))
+        return;
+#endif
+    default:
       break;
   }
-  qsort (state->entry, state->entrylen, sizeof (struct folder_file), f);
+
+  qsort (state->entry, state->entrylen, sizeof (struct folder_file), browser_compare);
 }
 
 static int link_is_dir (const char *folder, const char *path)
@@ -146,7 +245,7 @@ folder_format_str (char *dest, size_t destlen, size_t col, int cols, char op, co
 		   unsigned long data, format_flag flags)
 {
   char fn[SHORT_STRING], tmp[SHORT_STRING], permission[11];
-  char date[16], *t_fmt;
+  char date[SHORT_STRING], *t_fmt;
   time_t tnow;
   FOLDER *folder = (FOLDER *) data;
   struct passwd *pw;
@@ -176,11 +275,12 @@ folder_format_str (char *dest, size_t destlen, size_t col, int cols, char op, co
 	  tnow = time (NULL);
 	  t_fmt = tnow - folder->ff->mtime < 31536000 ? "%b %d %H:%M" : "%b %d  %Y";
 	}
-	if (do_locales)
-	  setlocale(LC_TIME, NONULL (Locale)); /* use environment if $locale is not set */
-	else
-	  setlocale(LC_TIME, "C");
-	strftime (date, sizeof (date), t_fmt, localtime (&folder->ff->mtime));
+
+        if (!do_locales)
+          setlocale (LC_TIME, "C");
+        strftime (date, sizeof (date), t_fmt, localtime (&folder->ff->mtime));
+        if (!do_locales)
+          setlocale (LC_TIME, "");
 
 	mutt_format_s (dest, destlen, fmt, date);
       }
@@ -191,6 +291,12 @@ folder_format_str (char *dest, size_t destlen, size_t col, int cols, char op, co
     case 'f':
     {
       char *s;
+
+#ifdef USE_NOTMUCH
+      if (mx_is_notmuch(folder->ff->name))
+        s = NONULL (folder->ff->desc);
+      else
+#endif
 #ifdef USE_IMAP
       if (folder->ff->imap)
 	s = NONULL (folder->ff->desc);
@@ -340,8 +446,112 @@ folder_format_str (char *dest, size_t destlen, size_t col, int cols, char op, co
   return (src);
 }
 
+#ifdef USE_NNTP
+static const char *
+newsgroup_format_str (char *dest, size_t destlen, size_t col, int cols, char op, const char *src,
+		      const char *fmt, const char *ifstring, const char *elsestring,
+		      unsigned long data, format_flag flags)
+{
+  char fn[SHORT_STRING], tmp[SHORT_STRING];
+  FOLDER *folder = (FOLDER *) data;
+
+  switch (op)
+  {
+    case 'C':
+      snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+      snprintf (dest, destlen, tmp, folder->num + 1);
+      break;
+
+    case 'f':
+      strncpy (fn, folder->ff->name, sizeof(fn) - 1);
+      snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+      snprintf (dest, destlen, tmp, fn);
+      break;
+
+    case 'N':
+      snprintf (tmp, sizeof (tmp), "%%%sc", fmt);
+      if (folder->ff->nd->subscribed)
+	snprintf (dest, destlen, tmp, ' ');
+      else
+	snprintf (dest, destlen, tmp, folder->ff->new ? 'N' : 'u');
+      break;
+
+    case 'M':
+      snprintf (tmp, sizeof (tmp), "%%%sc", fmt);
+      if (folder->ff->nd->deleted)
+	snprintf (dest, destlen, tmp, 'D');
+      else
+	snprintf (dest, destlen, tmp, folder->ff->nd->allowed ? ' ' : '-');
+      break;
+
+    case 's':
+      if (flags & MUTT_FORMAT_OPTIONAL)
+      {
+	if (folder->ff->nd->unread != 0)
+	  mutt_FormatString (dest, destlen, col, cols, ifstring, newsgroup_format_str,
+		data, flags);
+	else
+	  mutt_FormatString (dest, destlen, col, cols, elsestring, newsgroup_format_str,
+		data, flags);
+      }
+      else if (Context && Context->data == folder->ff->nd)
+      {
+	snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	snprintf (dest, destlen, tmp, Context->unread);
+      }
+      else
+      {
+	snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	snprintf (dest, destlen, tmp, folder->ff->nd->unread);
+      }
+      break;
+
+    case 'n':
+      if (Context && Context->data == folder->ff->nd)
+      {
+	snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	snprintf (dest, destlen, tmp, Context->new);
+      }
+      else if (option (OPTMARKOLD) &&
+		folder->ff->nd->lastCached >= folder->ff->nd->firstMessage &&
+		folder->ff->nd->lastCached <= folder->ff->nd->lastMessage)
+      {
+	snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	snprintf (dest, destlen, tmp, folder->ff->nd->lastMessage - folder->ff->nd->lastCached);
+      }
+      else
+      {
+	snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	snprintf (dest, destlen, tmp, folder->ff->nd->unread);
+      }
+      break;
+
+    case 'd':
+      if (folder->ff->nd->desc != NULL)
+      {
+	char *buf = safe_strdup (folder->ff->nd->desc);
+	if (NewsgroupsCharset && *NewsgroupsCharset)
+	  mutt_convert_string (&buf, NewsgroupsCharset, Charset, MUTT_ICONV_HOOK_FROM);
+	mutt_filter_unprintable (&buf);
+
+	snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+	snprintf (dest, destlen, tmp, buf);
+	FREE (&buf);
+      }
+      else
+      {
+	snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+	snprintf (dest, destlen, tmp, "");
+      }
+      break;
+  }
+  return (src);
+}
+#endif /* USE_NNTP */
+
 static void add_folder (MUTTMENU *m, struct browser_state *state,
-			const char *name, const struct stat *s, BUFFY *b)
+			const char *name, const char *desc, const struct stat *s, BUFFY *b,
+			void *data)
 {
   if (state->entrylen == state->entrymax)
   {
@@ -365,6 +575,8 @@ static void add_folder (MUTTMENU *m, struct browser_state *state,
     
     (state->entry)[state->entrylen].local = 1;
   }
+  else
+    (state->entry)[state->entrylen].local = 0;
 
   if (b)
   {
@@ -375,10 +587,14 @@ static void add_folder (MUTTMENU *m, struct browser_state *state,
   }
 
   (state->entry)[state->entrylen].name = safe_strdup (name);
-  (state->entry)[state->entrylen].desc = safe_strdup (name);
+  (state->entry)[state->entrylen].desc = safe_strdup(desc ? desc : name);
 #ifdef USE_IMAP
   (state->entry)[state->entrylen].imap = 0;
 #endif
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+    (state->entry)[state->entrylen].nd = (NNTP_DATA *)data;
+#endif
   (state->entrylen)++;
 }
 
@@ -394,9 +610,35 @@ static void init_state (struct browser_state *state, MUTTMENU *menu)
     menu->data = state->entry;
 }
 
+/* get list of all files/newsgroups with mask */
 static int examine_directory (MUTTMENU *menu, struct browser_state *state,
 			      char *d, const char *prefix)
 {
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    NNTP_SERVER *nserv = CurrentNewsSrv;
+    unsigned int i;
+
+/*  mutt_buffy_check (0); */
+    init_state (state, menu);
+
+    for (i = 0; i < nserv->groups_num; i++)
+    {
+      NNTP_DATA *nntp_data = nserv->groups_list[i];
+      if (!nntp_data)
+	continue;
+      if (prefix && *prefix &&
+	  strncmp (prefix, nntp_data->group, strlen (prefix)))
+	continue;
+      if (!((regexec (Mask.rx, nntp_data->group, 0, NULL, 0) == 0) ^ Mask.not))
+	continue;
+      add_folder (menu, state, nntp_data->group, NULL, NULL, NULL, nntp_data);
+    }
+  }
+  else
+#endif /* USE_NNTP */
+  {
   struct stat s;
   DIR *dp;
   struct dirent *de;
@@ -463,17 +705,67 @@ static int examine_directory (MUTTMENU *menu, struct browser_state *state,
       tmp->msg_count = Context->msgcount;
       tmp->msg_unread = Context->unread;
     }
-    add_folder (menu, state, de->d_name, &s, tmp);
+    add_folder (menu, state, de->d_name, NULL, &s, tmp, NULL);
   }
   closedir (dp);  
+  }
+  browser_sort (state);
+  return 0;
+}
+
+#ifdef USE_NOTMUCH
+static int examine_vfolders (MUTTMENU *menu, struct browser_state *state)
+{
+  BUFFY *tmp = VirtIncoming;
+
+  if (!VirtIncoming)
+    return (-1);
+  mutt_buffy_check (0);
+
+  init_state (state, menu);
+
+  do
+  {
+    if (mx_is_notmuch (tmp->path))
+    {
+      nm_nonctx_get_count(tmp->path, &tmp->msg_count, &tmp->msg_unread);
+      add_folder (menu, state, tmp->path, tmp->desc, NULL, tmp, NULL);
+      continue;
+    }
+  }
+  while ((tmp = tmp->next));
   browser_sort (state);
   return 0;
 }
+#endif
 
+/* get list of mailboxes/subscribed newsgroups */
 static int examine_mailboxes (MUTTMENU *menu, struct browser_state *state)
 {
   struct stat s;
   char buffer[LONG_STRING];
+
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    NNTP_SERVER *nserv = CurrentNewsSrv;
+    unsigned int i;
+
+/*  mutt_buffy_check (0); */
+    init_state (state, menu);
+
+    for (i = 0; i < nserv->groups_num; i++)
+    {
+      NNTP_DATA *nntp_data = nserv->groups_list[i];
+      if (nntp_data && (nntp_data->new || (nntp_data->subscribed &&
+	 (nntp_data->unread || !option (OPTSHOWONLYUNREAD)))))
+	add_folder (menu, state, nntp_data->group, NULL, NULL,
+		    NULL, nntp_data);
+    }
+  }
+  else
+#endif
+  {
   BUFFY *tmp = Incoming;
 
   if (!Incoming)
@@ -494,14 +786,21 @@ static int examine_mailboxes (MUTTMENU *menu, struct browser_state *state)
 #ifdef USE_IMAP
     if (mx_is_imap (tmp->path))
     {
-      add_folder (menu, state, tmp->path, NULL, tmp);
+      add_folder (menu, state, tmp->path, NULL, NULL, tmp, NULL);
       continue;
     }
 #endif
 #ifdef USE_POP
     if (mx_is_pop (tmp->path))
     {
-      add_folder (menu, state, tmp->path, NULL, tmp);
+      add_folder (menu, state, tmp->path, NULL, NULL, tmp, NULL);
+      continue;
+    }
+#endif
+#ifdef USE_NNTP
+    if (mx_is_nntp (tmp->path))
+    {
+      add_folder (menu, state, tmp->path, NULL, NULL, tmp, NULL);
       continue;
     }
 #endif
@@ -530,18 +829,30 @@ static int examine_mailboxes (MUTTMENU *menu, struct browser_state *state)
     strfcpy (buffer, NONULL(tmp->path), sizeof (buffer));
     mutt_pretty_mailbox (buffer, sizeof (buffer));
 
-    add_folder (menu, state, buffer, &s, tmp);
+    add_folder (menu, state, buffer, NULL, &s, tmp, NULL);
   }
   while ((tmp = tmp->next));
+  }
   browser_sort (state);
   return 0;
 }
 
 static int select_file_search (MUTTMENU *menu, regex_t *re, int n)
 {
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+    return (regexec (re, ((struct folder_file *) menu->data)[n].desc, 0, NULL, 0));
+#endif
   return (regexec (re, ((struct folder_file *) menu->data)[n].name, 0, NULL, 0));
 }
 
+#ifdef USE_NOTMUCH
+static int select_vfolder_search (MUTTMENU *menu, regex_t *re, int n)
+{
+  return (regexec (re, ((struct folder_file *) menu->data)[n].desc, 0, NULL, 0));
+}
+#endif
+
 static void folder_entry (char *s, size_t slen, MUTTMENU *menu, int num)
 {
   FOLDER folder;
@@ -549,10 +860,48 @@ static void folder_entry (char *s, size_t slen, MUTTMENU *menu, int num)
   folder.ff = &((struct folder_file *) menu->data)[num];
   folder.num = num;
   
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+    mutt_FormatString (s, slen, 0, MuttIndexWindow->cols, NONULL(GroupFormat), newsgroup_format_str, 
+      (unsigned long) &folder, MUTT_FORMAT_ARROWCURSOR);
+  else
+#endif
   mutt_FormatString (s, slen, 0, MuttIndexWindow->cols, NONULL(FolderFormat), folder_format_str, 
       (unsigned long) &folder, MUTT_FORMAT_ARROWCURSOR);
 }
 
+#ifdef USE_NOTMUCH
+static void vfolder_entry (char *s, size_t slen, MUTTMENU *menu, int num)
+{
+  FOLDER folder;
+
+  folder.ff = &((struct folder_file *) menu->data)[num];
+  folder.num = num;
+
+  mutt_FormatString (s, slen, 0, MuttIndexWindow->cols, NONULL(VirtFolderFormat), folder_format_str,
+      (unsigned long) &folder, MUTT_FORMAT_ARROWCURSOR);
+}
+#endif
+
+/* Public function
+ *
+ * This function takes a menu and a state and defines the current
+ * entry that should be highlighted.
+ */
+void mutt_browser_highlight_default (struct browser_state *state, MUTTMENU *menu)
+{
+  menu->top = 0;
+  /* Reset menu position to 1.
+   * We do not risk overflow as the init_menu function changes
+   * current if it is bigger than state->entrylen.
+   */
+  if ((mutt_strcmp (state->entry[0].desc, "..")  == 0) ||
+      (mutt_strcmp (state->entry[0].desc, "../") == 0))
+    menu->current = 1;
+  else
+    menu->current = 0;
+}
+
 static void init_menu (struct browser_state *state, MUTTMENU *menu, char *title,
 		       size_t titlelen, int buffy)
 {
@@ -569,21 +918,76 @@ static void init_menu (struct browser_state *state, MUTTMENU *menu, char *title,
 
   menu->tagged = 0;
   
-  if (buffy)
-    snprintf (title, titlelen, _("Mailboxes [%d]"), mutt_buffy_check (0));
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    if (buffy)
+      snprintf (title, titlelen, _("Subscribed newsgroups"));
+    else
+      snprintf (title, titlelen, _("Newsgroups on server [%s]"),
+		CurrentNewsSrv->conn->account.host);
+  }
   else
+#endif
   {
-    strfcpy (path, LastDir, sizeof (path));
-    mutt_pretty_mailbox (path, sizeof (path));
+    if (buffy)
+    {
+      menu->is_mailbox_list = 1;
+      snprintf (title, titlelen, _("Mailboxes [%d]"), mutt_buffy_check (0));
+    }
+    else
+    {
+      menu->is_mailbox_list = 0;
+      strfcpy (path, LastDir, sizeof (path));
+      mutt_pretty_mailbox (path, sizeof (path));
+      snprintf (title, titlelen, _("Directory [%s], File mask: %s"),
+               path, NONULL(Mask.pattern));
+    }
+  }
+
+  /* Browser tracking feature.
+   * The goal is to highlight the good directory if LastDir is the parent dir
+   * of OldLastDir (this occurs mostly when one hit "../"). It should also work
+   * properly when the user is in examine_mailboxes-mode.
+   */
+  int ldlen = mutt_strlen (LastDir);
+  if ((ldlen > 0) && (mutt_strncmp (LastDir, OldLastDir, ldlen) == 0))
+  {
+    char TargetDir[_POSIX_PATH_MAX] = "";
+
 #ifdef USE_IMAP
-  if (state->imap_browse && option (OPTIMAPLSUB))
-    snprintf (title, titlelen, _("Subscribed [%s], File mask: %s"),
-	      path, NONULL (Mask.pattern));
-  else
+    /* Use mx_is_imap to check what kind of dir is OldLastDir.
+     */
+    if (mx_is_imap (OldLastDir))
+    {
+      strfcpy (TargetDir, OldLastDir, sizeof (TargetDir));
+      imap_clean_path (TargetDir, sizeof (TargetDir));
+    }
+    else
 #endif
-    snprintf (title, titlelen, _("Directory [%s], File mask: %s"),
-	      path, NONULL(Mask.pattern));
+      strfcpy (TargetDir,
+              strrchr (OldLastDir, '/') + 1,
+              sizeof (TargetDir));
+
+    /* If we get here, it means that LastDir is the parent directory of
+     * OldLastDir.  I.e., we're returning from a subdirectory, and we want
+     * to position the cursor on the directory we're returning from. */
+    unsigned int i, matched = 0;
+    for (i = 0; i < state->entrylen; i++)
+    {
+      if (mutt_strcmp (state->entry[i].name, TargetDir) == 0)
+      {
+        menu->current = i;
+        matched = 1;
+        break;
+      }
+    }
+    if (!matched)
+      mutt_browser_highlight_default(state, menu);
   }
+  else
+    mutt_browser_highlight_default(state, menu);
+
   menu->redraw = REDRAW_FULL;
 }
 
@@ -603,6 +1007,23 @@ static int file_tag (MUTTMENU *menu, int n, int m)
   return ff->tagged - ot;
 }
 
+/* Public function
+ *
+ * This function helps the browser to know which directory has
+ * been selected. It should be called anywhere a confirm hit is done
+ * to open a new directory/file which is a maildir/mbox.
+ *
+ * We could check if the sort method is appropriate with this feature.
+ */
+void mutt_browser_select_dir (char *f)
+{
+  strfcpy (OldLastDir, f, sizeof (OldLastDir));
+
+  /* Method that will fetch the parent path depending on the
+     type of the path. */
+  mutt_get_parent_path (LastDir, OldLastDir, sizeof (LastDir));
+}
+
 void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *numfiles)
 {
   char buf[_POSIX_PATH_MAX];
@@ -617,6 +1038,11 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
   int folder   = (flags & MUTT_SEL_FOLDER) ? 1 : 0;
   int buffy    = (flags & MUTT_SEL_BUFFY)  ? 1 : 0;
 
+  /* Keeps in memory the directory we were in when hitting '='
+   * to go directly to $folder (Maildir)
+   */
+  char GotoSwapper[_POSIX_PATH_MAX] = "";
+
   buffy = buffy && folder;
   
   memset (&state, 0, sizeof (struct browser_state));
@@ -624,6 +1050,31 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
   if (!folder)
     strfcpy (LastDirBackup, LastDir, sizeof (LastDirBackup));
 
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    if (*f)
+      strfcpy (prefix, f, sizeof (prefix));
+    else
+    {
+      NNTP_SERVER *nserv = CurrentNewsSrv;
+      unsigned int i;
+
+      /* default state for news reader mode is browse subscribed newsgroups */
+      buffy = 0;
+      for (i = 0; i < nserv->groups_num; i++)
+      {
+	NNTP_DATA *nntp_data = nserv->groups_list[i];
+	if (nntp_data && nntp_data->subscribed)
+	{
+	  buffy = 1;
+	  break;
+	}
+      }
+    }
+  }
+  else
+#endif
   if (*f)
   {
     mutt_expand_path (f, flen);
@@ -671,13 +1122,86 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
     }
 #endif
   }
-  else 
+#ifdef USE_NOTMUCH
+  else if (!(flags & MUTT_SEL_VFOLDER))
+#else
+  else
+#endif
   {
     if (!folder)
       getcwd (LastDir, sizeof (LastDir));
-    else if (!LastDir[0])
-      strfcpy (LastDir, NONULL(Maildir), sizeof (LastDir));
-    
+    else
+    {
+      /* Whether we use the tracking feature of the browser depends
+       * on which sort method we chose to use. This variable is defined
+       * only to help readability of the code.
+       */
+      short browser_track;
+
+      switch (BrowserSort & SORT_MASK)
+      {
+        case SORT_DESC:
+        case SORT_SUBJECT:
+        case SORT_ORDER:
+          browser_track = 1;
+          break;
+
+        default:
+          browser_track = 0;
+          break;
+      }
+
+      /* We use mutt_browser_select_dir to initialize the two
+       * variables (LastDir, OldLastDir) at the appropriate
+       * values.
+       *
+       * We do it only when LastDir is not set (first pass there)
+       * or when CurrentFolder and OldLastDir are not the same.
+       * This code is executed only when we list files, not when
+       * we press up/down keys to navigate in a displayed list.
+       *
+       * We only do this when CurrentFolder has been set (ie, not
+       * when listing folders on startup with "mutt -y").
+       *
+       * This tracker is only used when browser_track is true,
+       * meaning only with sort methods SUBJECT/DESC for now.
+       */
+      if (CurrentFolder)
+      {
+        if (!LastDir[0])
+        {
+          /* If browsing in "local"-mode, than we chose to define LastDir to
+           * MailDir
+           */
+          switch (mx_get_magic (CurrentFolder))
+          {
+            case MUTT_MBOX:
+            case MUTT_MMDF:
+            case MUTT_MH:
+            case MUTT_MAILDIR:
+              if (Maildir)
+                strfcpy (LastDir, NONULL(Maildir), sizeof (LastDir));
+              else if (Spoolfile)
+                mutt_browser_select_dir (Spoolfile);
+              break;
+            default:
+              mutt_browser_select_dir (CurrentFolder);
+              break;
+          }
+        }
+        else if (mutt_strcmp (CurrentFolder, OldLastDir) != 0)
+        {
+          mutt_browser_select_dir (CurrentFolder);
+        }
+      }
+
+      /* When browser tracking feature is disabled, shoot a 0
+       * on first char of OldLastDir to make it useless.
+       */
+      if (!browser_track)
+        OldLastDir[0] = '\0';
+    }
+
 #ifdef USE_IMAP
     if (!buffy && mx_is_imap (LastDir))
     {
@@ -699,6 +1223,12 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 
   *f = 0;
 
+#ifdef USE_NOTMUCH
+  if (flags & MUTT_SEL_VFOLDER) {
+    if (examine_vfolders (NULL, &state) == -1)
+      goto bail;
+  } else
+#endif
   if (buffy)
   {
     if (examine_mailboxes (NULL, &state) == -1)
@@ -708,9 +1238,10 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 #ifdef USE_IMAP
   if (!state.imap_browse)
 #endif
+  {
   if (examine_directory (NULL, &state, LastDir, prefix) == -1)
     goto bail;
-
+  }
   menu = mutt_new_menu (MENU_FOLDER);
   menu->make_entry = folder_entry;
   menu->search = select_file_search;
@@ -719,7 +1250,18 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
   if (multiple)
     menu->tag = file_tag;
 
+#ifdef USE_NOTMUCH
+  if (flags & MUTT_SEL_VFOLDER) {
+    menu->make_entry = vfolder_entry;
+    menu->search = select_vfolder_search;
+  } else
+#endif
+    menu->make_entry = folder_entry;
+
   menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_FOLDER,
+#ifdef USE_NNTP
+    option (OPTNEWS) ? FolderNewsHelp :
+#endif
     FolderHelp);
 
   init_menu (&state, menu, title, sizeof (title), buffy);
@@ -765,8 +1307,6 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 #endif
 	    )
 	  {
-	    char OldLastDir[_POSIX_PATH_MAX];
-
 	    /* save the old directory */
 	    strfcpy (OldLastDir, LastDir, sizeof (OldLastDir));
 
@@ -851,14 +1391,19 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 		goto bail;
 	      }
 	    }
-	    menu->current = 0; 
-	    menu->top = 0; 
+            mutt_browser_highlight_default (&state, menu);
 	    init_menu (&state, menu, title, sizeof (title), buffy);
+            if (GotoSwapper[0])
+              GotoSwapper[0] = '\0';
 	    break;
 	  }
 	}
 
+#ifdef USE_NNTP
+	if (buffy || option (OPTNEWS))
+#else
 	if (buffy)
+#endif
 	{
 	  strfcpy (f, state.entry[menu->current].name, flen);
 	  mutt_expand_path (f, flen);
@@ -867,6 +1412,10 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	else if (state.imap_browse)
           strfcpy (f, state.entry[menu->current].name, flen);
 #endif
+#ifdef USE_NOTMUCH
+	else if (mx_is_notmuch(state.entry[menu->current].name))
+	  strfcpy (f, state.entry[menu->current].name, flen);
+#endif
 	else
 	  mutt_concat_path (f, LastDir, state.entry[menu->current].name, flen);
 
@@ -916,14 +1465,6 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
         break;
 
 #ifdef USE_IMAP
-      case OP_BROWSER_SUBSCRIBE:
-	imap_subscribe (state.entry[menu->current].name, 1);
-	break;
-
-      case OP_BROWSER_UNSUBSCRIBE:
-	imap_subscribe (state.entry[menu->current].name, 0);
-	break;
-
       case OP_BROWSER_TOGGLE_LSUB:
 	if (option (OPTIMAPLSUB))
 	  unset_option (OPTIMAPLSUB);
@@ -950,8 +1491,7 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	  imap_browse (LastDir, &state);
 	  browser_sort (&state);
 	  menu->data = state.entry;
-	  menu->current = 0; 
-	  menu->top = 0; 
+          mutt_browser_highlight_default (&state, menu);
 	  init_menu (&state, menu, title, sizeof (title), buffy);
 	  MAYBE_REDRAW (menu->redraw);
 	}
@@ -973,8 +1513,7 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	    imap_browse (LastDir, &state);
 	    browser_sort (&state);
 	    menu->data = state.entry;
-	    menu->current = 0;
-	    menu->top = 0;
+            mutt_browser_highlight_default (&state, menu);
 	    init_menu (&state, menu, title, sizeof (title), buffy);
 	    MAYBE_REDRAW (menu->redraw);
 	  }
@@ -1026,6 +1565,11 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
       
       case OP_CHANGE_DIRECTORY:
 
+#ifdef USE_NNTP
+	if (option (OPTNEWS))
+	  break;
+#endif
+
 	strfcpy (buf, LastDir, sizeof (buf));
 #ifdef USE_IMAP
 	if (!state.imap_browse)
@@ -1052,8 +1596,7 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	    imap_browse (LastDir, &state);
 	    browser_sort (&state);
 	    menu->data = state.entry;
-	    menu->current = 0; 
-	    menu->top = 0; 
+            mutt_browser_highlight_default (&state, menu);
 	    init_menu (&state, menu, title, sizeof (title), buffy);
 	  }
 	  else
@@ -1083,8 +1626,7 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 		    goto bail;
 		  }
 		}
-		menu->current = 0;
-		menu->top = 0;
+                mutt_browser_highlight_default (&state, menu);
 		init_menu (&state, menu, title, sizeof (title), buffy);
 	      }
 	      else
@@ -1172,9 +1714,9 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	  int reverse = (i == OP_SORT_REVERSE);
 	  
 	  switch (mutt_multi_choice ((reverse) ?
-	      _("Reverse sort by (d)ate, (a)lpha, si(z)e or do(n)'t sort? ") :
-	      _("Sort by (d)ate, (a)lpha, si(z)e or do(n)'t sort? "),
-	      _("dazn")))
+	      _("Reverse sort by (d)ate, (a)lpha, si(z)e, d(e)scription, (c)ount, ne(w) count, or do(n)'t sort? ") :
+	      _("Sort by (d)ate, (a)lpha, si(z)e, d(e)scription, (c)ount, ne(w) count, or do(n)'t sort? "),
+	      _("dazecwn")))
 	  {
 	    case -1: /* abort */
 	      resort = 0;
@@ -1192,7 +1734,19 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	      BrowserSort = SORT_SIZE;
 	      break;
 
-            case 4: /* do(n)'t sort */
+            case 4: /* d(e)scription */
+	      BrowserSort = SORT_DESC;
+	      break;
+
+            case 5: /* (c)ount */
+	      BrowserSort = SORT_COUNT;
+	      break;
+
+            case 6: /* ne(w) count */
+	      BrowserSort = SORT_COUNT_NEW;
+	      break;
+
+            case 7: /* do(n)'t sort */
 	      BrowserSort = SORT_ORDER;
 	      resort = 0;
 	      break;
@@ -1201,6 +1755,7 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	  {
 	    BrowserSort |= reverse ? SORT_REVERSE : 0;
 	    browser_sort (&state);
+            mutt_browser_highlight_default (&state, menu);
 	    menu->redraw = REDRAW_FULL;
 	  }
 	  break;
@@ -1209,7 +1764,32 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
       case OP_TOGGLE_MAILBOXES:
 	buffy = 1 - buffy;
 
+      case OP_BROWSER_GOTO_FOLDER:
       case OP_CHECK_NEW:
+        if (i == OP_BROWSER_GOTO_FOLDER)
+        {
+          /* When in mailboxes mode, disables this feature */
+          if (Maildir)
+          {
+            dprint(5, (debugfile, "= hit! Maildir: %s, LastDir: %s\n", Maildir, LastDir));
+            if (!GotoSwapper[0])
+            {
+              if (mutt_strcmp (LastDir, Maildir) != 0)
+              {
+                /* Stores into GotoSwapper LastDir, and swaps to Maildir */
+                strfcpy (GotoSwapper, LastDir, sizeof (GotoSwapper));
+                strfcpy (OldLastDir, LastDir, sizeof (OldLastDir));
+                strfcpy (LastDir, Maildir, sizeof (LastDir));
+              }
+            }
+            else
+            {
+              strfcpy (OldLastDir, LastDir, sizeof (OldLastDir));
+              strfcpy (LastDir, GotoSwapper, sizeof (LastDir));
+              GotoSwapper[0] = '\0';
+            }
+          }
+        }
 	destroy_state (&state);
 	prefix[0] = 0;
 	killPrefix = 0;
@@ -1291,6 +1871,209 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	  else
 	    mutt_error _("Error trying to view file");
 	}
+	break;
+
+#ifdef USE_NNTP
+      case OP_CATCHUP:
+      case OP_UNCATCHUP:
+	if (option (OPTNEWS))
+	{
+	  struct folder_file *f = &state.entry[menu->current];
+	  int rc;
+	  NNTP_DATA *nntp_data;
+
+	  rc = nntp_newsrc_parse (CurrentNewsSrv);
+	  if (rc < 0)
+	    break;
+
+	  if (i == OP_CATCHUP)
+	    nntp_data = mutt_newsgroup_catchup (CurrentNewsSrv, f->name);
+	  else
+	    nntp_data = mutt_newsgroup_uncatchup (CurrentNewsSrv, f->name);
+
+	  if (nntp_data)
+	  {
+/*	    FOLDER folder;
+	    struct folder_file ff;
+	    char buffer[_POSIX_PATH_MAX + SHORT_STRING];
+
+	    folder.ff = &ff;
+	    folder.ff->name = f->name;
+	    folder.ff->st = NULL;
+	    folder.ff->is_new = nntp_data->new;
+	    folder.ff->nntp_data = nntp_data;
+	    FREE (&f->desc);
+	    mutt_FormatString (buffer, sizeof (buffer), 0, NONULL(GroupFormat),
+		  newsgroup_format_str, (unsigned long) &folder,
+		  MUTT_FORMAT_ARROWCURSOR);
+	    f->desc = safe_strdup (buffer); */
+	    nntp_newsrc_update (CurrentNewsSrv);
+	    if (menu->current + 1 < menu->max)
+	      menu->current++;
+	    menu->redraw = REDRAW_MOTION_RESYNCH;
+	  }
+	  if (rc)
+	    menu->redraw = REDRAW_INDEX;
+	  nntp_newsrc_close (CurrentNewsSrv);
+	}
+	break;
+
+      case OP_LOAD_ACTIVE:
+	if (option (OPTNEWS))
+	{
+	  NNTP_SERVER *nserv = CurrentNewsSrv;
+	  unsigned int i;
+
+	  if (nntp_newsrc_parse (nserv) < 0)
+	    break;
+
+	  for (i = 0; i < nserv->groups_num; i++)
+	  {
+	    NNTP_DATA *nntp_data = nserv->groups_list[i];
+	    if (nntp_data)
+	      nntp_data->deleted = 1;
+	  }
+	  nntp_active_fetch (nserv);
+	  nntp_newsrc_update (nserv);
+	  nntp_newsrc_close (nserv);
+
+	  destroy_state (&state);
+	  if (buffy)
+	    examine_mailboxes (menu, &state);
+	  else
+	    examine_directory (menu, &state, NULL, NULL);
+	  init_menu (&state, menu, title, sizeof (title), buffy);
+	}
+	break;
+#endif /* USE_NNTP */
+
+#if defined USE_IMAP || defined USE_NNTP
+      case OP_BROWSER_SUBSCRIBE:
+      case OP_BROWSER_UNSUBSCRIBE:
+#endif
+#ifdef USE_NNTP
+      case OP_SUBSCRIBE_PATTERN:
+      case OP_UNSUBSCRIBE_PATTERN:
+	if (option (OPTNEWS))
+	{
+	  NNTP_SERVER *nserv = CurrentNewsSrv;
+	  NNTP_DATA *nntp_data;
+	  regex_t *rx = (regex_t *) safe_malloc (sizeof (regex_t));
+	  char *s = buf;
+	  int rc, j = menu->current;
+
+	  if (i == OP_SUBSCRIBE_PATTERN || i == OP_UNSUBSCRIBE_PATTERN)
+	  {
+	    char tmp[STRING];
+	    int err;
+
+	    buf[0] = 0;
+	    if (i == OP_SUBSCRIBE_PATTERN)
+	      snprintf (tmp, sizeof (tmp), _("Subscribe pattern: "));
+	    else
+	      snprintf (tmp, sizeof (tmp), _("Unsubscribe pattern: "));
+	    if (mutt_get_field (tmp, buf, sizeof (buf), 0) != 0 || !buf[0])
+	    {
+	      FREE (&rx);
+	      break;
+	    }
+
+	    err = REGCOMP (rx, s, REG_NOSUB);
+	    if (err)
+	    {
+	      regerror (err, rx, buf, sizeof (buf));
+	      regfree (rx);
+	      FREE (&rx);
+	      mutt_error ("%s", buf);
+	      break;
+	    }
+	    menu->redraw = REDRAW_FULL;
+	    j = 0;
+	  }
+	  else if (!state.entrylen)
+	  {
+	    mutt_error _("No newsgroups match the mask");
+	    break;
+	  }
+
+	  rc = nntp_newsrc_parse (nserv);
+	  if (rc < 0)
+	    break;
+
+	  for ( ; j < state.entrylen; j++)
+	  {
+	    struct folder_file *f = &state.entry[j];
+
+	    if (i == OP_BROWSER_SUBSCRIBE || i == OP_BROWSER_UNSUBSCRIBE ||
+		  regexec (rx, f->name, 0, NULL, 0) == 0)
+	    {
+	      if (i == OP_BROWSER_SUBSCRIBE || i == OP_SUBSCRIBE_PATTERN)
+		nntp_data = mutt_newsgroup_subscribe (nserv, f->name);
+	      else
+		nntp_data = mutt_newsgroup_unsubscribe (nserv, f->name);
+/*	      if (nntp_data)
+	      {
+		FOLDER folder;
+		char buffer[_POSIX_PATH_MAX + SHORT_STRING];
+
+		folder.name = f->name;
+		folder.f = NULL;
+		folder.new = nntp_data->new;
+		folder.nd = nntp_data;
+		FREE (&f->desc);
+		mutt_FormatString (buffer, sizeof (buffer), 0, NONULL(GroupFormat),
+			newsgroup_format_str, (unsigned long) &folder,
+			MUTT_FORMAT_ARROWCURSOR);
+		f->desc = safe_strdup (buffer);
+	      } */
+	    }
+	    if (i == OP_BROWSER_SUBSCRIBE || i == OP_BROWSER_UNSUBSCRIBE)
+	    {
+	      if (menu->current + 1 < menu->max)
+		menu->current++;
+	      menu->redraw = REDRAW_MOTION_RESYNCH;
+	      break;
+	    }
+	  }
+	  if (i == OP_SUBSCRIBE_PATTERN)
+	  {
+	    unsigned int i;
+
+	    for (i = 0; nserv && i < nserv->groups_num; i++)
+	    {
+	      nntp_data = nserv->groups_list[i];
+	      if (nntp_data && nntp_data->group && !nntp_data->subscribed)
+	      {
+		if (regexec (rx, nntp_data->group, 0, NULL, 0) == 0)
+		{
+		  mutt_newsgroup_subscribe (nserv, nntp_data->group);
+		  add_folder (menu, &state, nntp_data->group, NULL, NULL, NULL, nntp_data);
+		}
+	      }
+	    }
+	    init_menu (&state, menu, title, sizeof (title), buffy);
+	  }
+	  if (rc > 0)
+	    menu->redraw = REDRAW_FULL;
+	  nntp_newsrc_update (nserv);
+	  nntp_clear_cache (nserv);
+	  nntp_newsrc_close (nserv);
+	  if (i != OP_BROWSER_SUBSCRIBE && i != OP_BROWSER_UNSUBSCRIBE)
+	    regfree (rx);
+	  FREE (&rx);
+	}
+#ifdef USE_IMAP
+	else
+#endif /* USE_IMAP && USE_NNTP */
+#endif /* USE_NNTP */
+#ifdef USE_IMAP
+	{
+	  if (i == OP_BROWSER_SUBSCRIBE)
+	    imap_subscribe (state.entry[menu->current].name, 1);
+	  else
+	    imap_subscribe (state.entry[menu->current].name, 0);
+	}
+#endif /* USE_IMAP */
     }
   }
   
@@ -1298,5 +2081,6 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
   
   if (!folder)
     strfcpy (LastDir, LastDirBackup, sizeof (LastDir));
-  
+  if (GotoSwapper[0])
+    GotoSwapper[0] = '\0';
 }
diff --git c/browser.h w/browser.h
index 67e62ea..439be9d 100644
--- c/browser.h
+++ w/browser.h
@@ -19,6 +19,10 @@
 #ifndef _BROWSER_H
 #define _BROWSER_H 1
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
+
 struct folder_file
 {
   mode_t mode;
@@ -43,6 +47,9 @@ struct folder_file
   unsigned inferiors : 1;
 #endif
   unsigned has_buffy : 1;
+#ifdef USE_NNTP
+  NNTP_DATA *nd;
+#endif
   unsigned local : 1; /* folder is on local filesystem */
   unsigned tagged : 1;
 };
diff --git c/buffy.c w/buffy.c
index 1306297..8d488f7 100644
--- c/buffy.c
+++ w/buffy.c
@@ -36,6 +36,10 @@
 #include "imap.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include <string.h>
 #include <sys/stat.h>
 #include <dirent.h>
@@ -217,6 +221,8 @@ static BUFFY *buffy_new (const char *path)
 
 static void buffy_free (BUFFY **mailbox)
 {
+  if (mailbox && *mailbox)
+    FREE (&(*mailbox)->desc);
   FREE (mailbox); /* __FREE_CHECKED__ */
 }
 
@@ -462,63 +468,64 @@ static int buffy_mbox_check (BUFFY* mailbox, struct stat *sb, int check_stats)
   return rc;
 }
 
-/* Check all Incoming for new mail and total/new/flagged messages
- * force: if true, ignore BuffyTimeout and check for new mail anyway
- */
-int mutt_buffy_check (int force)
+#ifdef USE_NOTMUCH
+int mutt_parse_virtual_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *err)
 {
-  BUFFY *tmp;
-  struct stat sb;
-  struct stat contex_sb;
-  time_t t;
-  int check_stats = 0;
-#ifdef USE_SIDEBAR
-  short orig_new;
-  int orig_count, orig_unread, orig_flagged;
-#endif
+  BUFFY **tmp;
+  char buf[_POSIX_PATH_MAX + LONG_STRING + 32];   /* path to DB + query + URI "decoration" */
 
-  sb.st_size=0;
-  contex_sb.st_dev=0;
-  contex_sb.st_ino=0;
+  while (MoreArgs (s))
+  {
+    char *desc;
 
-#ifdef USE_IMAP
-  /* update postponed count as well, on force */
-  if (force)
-    mutt_update_num_postponed ();
-#endif
+    mutt_extract_token (path, s, 0);
+    if (path->data && *path->data)
+      desc = safe_strdup( path->data);
+    else
+      continue;
 
-  /* fastest return if there are no mailboxes */
-  if (!Incoming)
-    return 0;
-  t = time (NULL);
-  if (!force && (t - BuffyTime < BuffyTimeout))
-    return BuffyCount;
+    mutt_extract_token (path, s, 0);
+    strfcpy (buf, path->data, sizeof (buf));
 
-  if (option (OPTMAILCHECKSTATS) &&
-      (t - BuffyStatsTime >= BuffyCheckStatsInterval))
-  {
-    check_stats = 1;
-    BuffyStatsTime = t;
-  }
+    /* Skip empty tokens. */
+    if(!*buf) {
+	    FREE(&desc);
+	    continue;
+    }
 
-  BuffyTime = t;
-  BuffyCount = 0;
-  BuffyNotify = 0;
+    /* avoid duplicates */
+    for (tmp = &VirtIncoming; *tmp; tmp = &((*tmp)->next))
+    {
+      if (mutt_strcmp (buf, (*tmp)->path) == 0)
+      {
+	dprint(3,(debugfile,"virtual mailbox '%s' already registered as '%s'\n", buf, (*tmp)->path));
+	break;
+      }
+    }
 
-#ifdef USE_IMAP
-  BuffyCount += imap_buffy_check (force, check_stats);
-#endif
+    if (!*tmp)
+      *tmp = buffy_new (buf);
 
-  /* check device ID and serial number instead of comparing paths */
-  if (!Context || Context->magic == MUTT_IMAP || Context->magic == MUTT_POP
-      || stat (Context->path, &contex_sb) != 0)
-  {
-    contex_sb.st_dev=0;
-    contex_sb.st_ino=0;
+    (*tmp)->new = 0;
+    (*tmp)->notified = 1;
+    (*tmp)->newly_created = 0;
+    (*tmp)->size = 0;
+    (*tmp)->desc = desc;
   }
-  
-  for (tmp = Incoming; tmp; tmp = tmp->next)
-  {
+  return 0;
+}
+#endif
+
+static void buffy_check (BUFFY *tmp, struct stat *contex_sb, int check_stats)
+{
+    struct stat sb;
+#ifdef USE_SIDEBAR
+    short orig_new;
+    int orig_count, orig_unread, orig_flagged;
+#endif
+
+    sb.st_size=0;
+
 #ifdef USE_SIDEBAR
     orig_new = tmp->new;
     orig_count = tmp->msg_count;
@@ -534,6 +541,15 @@ int mutt_buffy_check (int force)
 	tmp->magic = MUTT_POP;
       else
 #endif
+#ifdef USE_NNTP
+      if ((tmp->magic == MUTT_NNTP) || mx_is_nntp (tmp->path))
+	tmp->magic = MUTT_NNTP;
+#endif
+#ifdef USE_NOTMUCH
+      if (mx_is_notmuch (tmp->path))
+	tmp->magic = MUTT_NOTMUCH;
+      else
+#endif
       if (stat (tmp->path, &sb) != 0 || (S_ISREG(sb.st_mode) && sb.st_size == 0) ||
 	  (!tmp->magic && (tmp->magic = mx_get_magic (tmp->path)) <= 0))
       {
@@ -542,16 +558,20 @@ int mutt_buffy_check (int force)
 	tmp->newly_created = 1;
 	tmp->magic = 0;
 	tmp->size = 0;
-	continue;
+	return;
       }
     }
 
     /* check to see if the folder is the currently selected folder
      * before polling */
     if (!Context || !Context->path ||
-	(( tmp->magic == MUTT_IMAP || tmp->magic == MUTT_POP )
+#ifdef USE_NNTP
+	(( tmp->magic == MUTT_IMAP || tmp->magic == MUTT_POP || tmp->magic == MUTT_NNTP )
+#else
+	(( tmp->magic == MUTT_IMAP || tmp->magic == MUTT_POP || tmp->magic == MUTT_NOTMUCH)
+#endif
 	    ? mutt_strcmp (tmp->path, Context->path) :
-	      (sb.st_dev != contex_sb.st_dev || sb.st_ino != contex_sb.st_ino)))
+	      (sb.st_dev != contex_sb->st_dev || sb.st_ino != contex_sb->st_ino)))
     {
       switch (tmp->magic)
       {
@@ -570,6 +590,18 @@ int mutt_buffy_check (int force)
           if (mh_buffy (tmp, check_stats) > 0)
             BuffyCount++;
           break;
+#ifdef USE_NOTMUCH
+        case MUTT_NOTMUCH:
+          tmp->msg_count = 0;
+          tmp->msg_unread = 0;
+          tmp->msg_flagged = 0;
+          nm_nonctx_get_count(tmp->path, &tmp->msg_count, &tmp->msg_unread);
+          if (tmp->msg_unread > 0) {
+            BuffyCount++;
+            tmp->new = 1;
+          }
+          break;
+#endif
       }
     }
     else if (option(OPTCHECKMBOXSIZE) && Context && Context->path)
@@ -587,8 +619,72 @@ int mutt_buffy_check (int force)
       tmp->notified = 0;
     else if (!tmp->notified)
       BuffyNotify++;
+}
+
+/* Check all Incoming for new mail and total/new/flagged messages
+ * force: if true, ignore BuffyTimeout and check for new mail anyway
+ */
+int mutt_buffy_check (int force)
+{
+  BUFFY *tmp;
+  struct stat contex_sb;
+  time_t t;
+  int check_stats = 0;
+  contex_sb.st_dev=0;
+  contex_sb.st_ino=0;
+
+#ifdef USE_IMAP
+  /* update postponed count as well, on force */
+  if (force)
+    mutt_update_num_postponed ();
+#endif
+
+  /* fastest return if there are no mailboxes */
+#ifdef USE_NOTMUCH
+  if (!Incoming && !VirtIncoming)
+    return 0;
+#else
+  if (!Incoming)
+    return 0;
+#endif
+  t = time (NULL);
+  if (!force && (t - BuffyTime < BuffyTimeout))
+    return BuffyCount;
+
+  if (option (OPTMAILCHECKSTATS) &&
+      (t - BuffyStatsTime >= BuffyCheckStatsInterval))
+  {
+    check_stats = 1;
+    BuffyStatsTime = t;
   }
 
+  BuffyTime = t;
+  BuffyCount = 0;
+  BuffyNotify = 0;
+
+#ifdef USE_IMAP
+  BuffyCount += imap_buffy_check (force, check_stats);
+#endif
+
+  /* check device ID and serial number instead of comparing paths */
+  if (!Context || Context->magic == MUTT_IMAP || Context->magic == MUTT_POP
+#ifdef USE_NNTP
+      || Context->magic == MUTT_NNTP
+#endif
+      || stat (Context->path, &contex_sb) != 0)
+  {
+    contex_sb.st_dev=0;
+    contex_sb.st_ino=0;
+  }
+
+  for (tmp = Incoming; tmp; tmp = tmp->next)
+    buffy_check(tmp, &contex_sb, check_stats);
+
+#ifdef USE_NOTMUCH
+  for (tmp = VirtIncoming; tmp; tmp = tmp->next)
+    buffy_check(tmp, &contex_sb, check_stats);
+#endif
+
   BuffyDoneTime = BuffyTime;
   return (BuffyCount);
 }
@@ -704,6 +800,35 @@ void mutt_buffy (char *s, size_t slen)
   *s = '\0';
 }
 
+#ifdef USE_NOTMUCH
+void mutt_buffy_vfolder (char *s, size_t slen)
+{
+  BUFFY *tmp;
+  int pass, found = 0;
+
+  if (mutt_buffy_check (0))
+  {
+    for (pass = 0; pass < 2; pass++) {
+      for (tmp = VirtIncoming; tmp; tmp = tmp->next)
+      {
+	if ((found || pass) && tmp->new)
+	{
+	  strfcpy (s, tmp->desc, slen);
+	  return;
+	}
+	if (mutt_strcmp (s, tmp->path) == 0)
+	  found = 1;
+      }
+    }
+
+    mutt_buffy_check (1); /* buffy was wrong - resync things */
+  }
+
+  /* no folders with new mail */
+  *s = '\0';
+}
+#endif
+
 /* fetch buffy object for given path, if present */
 static BUFFY* buffy_get (const char *path)
 {
diff --git c/buffy.h w/buffy.h
index 561f5e7..a042484 100644
--- c/buffy.h
+++ w/buffy.h
@@ -28,6 +28,7 @@ typedef struct buffy_t
   char path[_POSIX_PATH_MAX];
   char realpath[_POSIX_PATH_MAX]; /* used for duplicate detection, context comparison,
                                      and the sidebar */
+  char *desc;
   off_t size;
   struct buffy_t *next;
   short new;			/* mailbox has new mail */
@@ -49,6 +50,11 @@ WHERE BUFFY *Incoming INITVAL (0);
 WHERE short BuffyTimeout INITVAL (3);
 WHERE short BuffyCheckStatsInterval INITVAL (60);
 
+#ifdef USE_NOTMUCH
+WHERE BUFFY *VirtIncoming INITVAL (0);
+void mutt_buffy_vfolder (char *s, size_t slen);
+#endif
+
 extern time_t BuffyDoneTime;	/* last time we knew for sure how much mail there was */
 
 BUFFY *mutt_find_mailbox (const char *path);
diff --git c/color.c w/color.c
index c33d41e..7ce67c6 100644
--- c/color.c
+++ w/color.c
@@ -34,7 +34,15 @@ int ColorQuoteUsed;
 int ColorDefs[MT_COLOR_MAX];
 COLOR_LINE *ColorHdrList = NULL;
 COLOR_LINE *ColorBodyList = NULL;
+COLOR_LINE *ColorAttachList = NULL;
+COLOR_LINE *ColorStatusList = NULL;
 COLOR_LINE *ColorIndexList = NULL;
+COLOR_LINE *ColorIndexAuthorList = NULL;
+COLOR_LINE *ColorIndexFlagsList = NULL;
+COLOR_LINE *ColorIndexSubjectList = NULL;
+#ifdef USE_NOTMUCH
+COLOR_LINE *ColorIndexTagList = NULL;
+#endif
 
 /* local to this file */
 static int ColorQuoteSize;
@@ -89,10 +97,24 @@ static const struct mapping_t Fields[] =
   { "body",		MT_COLOR_BODY },
   { "message",		MT_COLOR_MESSAGE },
   { "attachment",	MT_COLOR_ATTACHMENT },
+  { "attach_headers",	MT_COLOR_ATTACH_HEADERS },
   { "search",		MT_COLOR_SEARCH },
   { "bold",		MT_COLOR_BOLD },
   { "underline",	MT_COLOR_UNDERLINE },
   { "index",		MT_COLOR_INDEX },
+  { "progress",		MT_COLOR_PROGRESS },
+  { "index_author",	MT_COLOR_INDEX_AUTHOR },
+  { "index_collapsed",	MT_COLOR_INDEX_COLLAPSED },
+  { "index_date",	MT_COLOR_INDEX_DATE },
+  { "index_flags",	MT_COLOR_INDEX_FLAGS },
+  { "index_label",	MT_COLOR_INDEX_LABEL },
+  { "index_number",	MT_COLOR_INDEX_NUMBER },
+  { "index_size",	MT_COLOR_INDEX_SIZE },
+  { "index_subject",	MT_COLOR_INDEX_SUBJECT },
+#ifdef USE_NOTMUCH
+  { "index_tag",	MT_COLOR_INDEX_TAG },
+  { "index_tags",	MT_COLOR_INDEX_TAGS },
+#endif
   { "prompt",		MT_COLOR_PROMPT },
 #ifdef USE_SIDEBAR
   { "sidebar_divider",	MT_COLOR_DIVIDER },
@@ -100,6 +122,7 @@ static const struct mapping_t Fields[] =
   { "sidebar_highlight",MT_COLOR_HIGHLIGHT },
   { "sidebar_indicator",MT_COLOR_SB_INDICATOR },
   { "sidebar_new",	MT_COLOR_NEW },
+  { "sidebar_ordinary",	MT_COLOR_ORDINARY },
   { "sidebar_spoolfile",MT_COLOR_SB_SPOOLFILE },
 #endif
   { NULL,		0 }
@@ -395,12 +418,64 @@ int mutt_parse_unmono (BUFFER *buf, BUFFER *s, unsigned long data,
   return _mutt_parse_uncolor(buf, s, data, err, 0);
 }
 
+/**
+ * mutt_do_uncolor - XXX
+ */
+static void
+mutt_do_uncolor (BUFFER *buf, BUFFER *s, COLOR_LINE **ColorList,
+                 int *do_cache, int parse_uncolor)
+{
+  COLOR_LINE *tmp, *last = NULL;
+
+  do
+  {
+    mutt_extract_token (buf, s, 0);
+    if (mutt_strcmp ("*", buf->data) == 0)
+    {
+      for (tmp = *ColorList; tmp; )
+      {
+        if (!*do_cache)
+	{
+          *do_cache = 1;
+        }
+        last = tmp;
+        tmp = tmp->next;
+        mutt_free_color_line (&last, parse_uncolor);
+      }
+      *ColorList = NULL;
+    }
+    else
+    {
+      for (last = NULL, tmp = *ColorList; tmp; last = tmp, tmp = tmp->next)
+      {
+        if (mutt_strcmp (buf->data, tmp->pattern) == 0)
+	{
+          if (!*do_cache)
+	  {
+            *do_cache = 1;
+          }
+          dprint (1, (debugfile,"Freeing pattern \"%s\" from ColorList\n",
+                               tmp->pattern));
+          if (last)
+	  {
+            last->next = tmp->next;
+          }
+	  else
+	  {
+            *ColorList = tmp->next;
+          }
+          mutt_free_color_line (&tmp, parse_uncolor);
+          break;
+        }
+      }
+    }
+  } while (MoreArgs (s));
+}
+
 static int _mutt_parse_uncolor (BUFFER *buf, BUFFER *s, unsigned long data,
 				BUFFER *err, short parse_uncolor)
 {
   int object = 0, do_cache = 0;
-  COLOR_LINE *tmp, *last = NULL;
-  COLOR_LINE **list;
 
   mutt_extract_token (buf, s, 0);
 
@@ -410,13 +485,15 @@ static int _mutt_parse_uncolor (BUFFER *buf, BUFFER *s, unsigned long data,
     return (-1);
   }
 
-  if (mutt_strncmp (buf->data, "index", 5) == 0)
-    list = &ColorIndexList;
-  else if (mutt_strncmp (buf->data, "body", 4) == 0)
-    list = &ColorBodyList;
-  else if (mutt_strncmp (buf->data, "header", 7) == 0)
-    list = &ColorHdrList;
-  else
+  if (object > MT_COLOR_INDEX_SUBJECT) { /* uncolor index column */
+    ColorDefs[object] = 0;
+    set_option (OPTFORCEREDRAWINDEX);
+    return 0;
+  }
+
+  if ((mutt_strncmp (buf->data, "body",   4) != 0) &&
+      (mutt_strncmp (buf->data, "header", 6) != 0) &&
+      (mutt_strncmp (buf->data, "index",  5) != 0))
   {
     snprintf (err->data, err->dsize,
 	      _("%s: command valid only for index, body, header objects"),
@@ -453,43 +530,24 @@ static int _mutt_parse_uncolor (BUFFER *buf, BUFFER *s, unsigned long data,
     return 0;
   }
 
-  do
-  {
-    mutt_extract_token (buf, s, 0);
-    if (!mutt_strcmp ("*", buf->data))
-    {
-      for (tmp = *list; tmp; )
-      {
-        if (!do_cache)
-	  do_cache = 1;
-	last = tmp;
-	tmp = tmp->next;
-	mutt_free_color_line(&last, parse_uncolor);
-      }
-      *list = NULL;
-    }
-    else
-    {
-      for (last = NULL, tmp = *list; tmp; last = tmp, tmp = tmp->next)
-      {
-	if (!mutt_strcmp (buf->data, tmp->pattern))
-	{
-          if (!do_cache)
-	    do_cache = 1;
-	  dprint(1,(debugfile,"Freeing pattern \"%s\" from color list\n",
-	                       tmp->pattern));
-	  if (last)
-	    last->next = tmp->next;
-	  else
-	    *list = tmp->next;
-	  mutt_free_color_line(&tmp, parse_uncolor);
-	  break;
-	}
-      }
-    }
-  }
-  while (MoreArgs (s));
-
+  if (object == MT_COLOR_BODY)
+    mutt_do_uncolor (buf, s, &ColorBodyList, &do_cache, parse_uncolor);
+  else if (object == MT_COLOR_HEADER)
+    mutt_do_uncolor (buf, s, &ColorHdrList, &do_cache, parse_uncolor);
+  else if (object == MT_COLOR_ATTACH_HEADERS)
+    mutt_do_uncolor (buf, s, &ColorAttachList, &do_cache, parse_uncolor);
+  else if (object == MT_COLOR_INDEX)
+    mutt_do_uncolor (buf, s, &ColorIndexList, &do_cache, parse_uncolor);
+  else if (object == MT_COLOR_INDEX_AUTHOR)
+    mutt_do_uncolor (buf, s, &ColorIndexAuthorList, &do_cache, parse_uncolor);
+  else if (object == MT_COLOR_INDEX_FLAGS)
+    mutt_do_uncolor (buf, s, &ColorIndexFlagsList, &do_cache, parse_uncolor);
+  else if (object == MT_COLOR_INDEX_SUBJECT)
+    mutt_do_uncolor (buf, s, &ColorIndexSubjectList, &do_cache, parse_uncolor);
+#ifdef USE_NOTMUCH
+  else if (object == MT_COLOR_INDEX_TAG)
+    mutt_do_uncolor(buf, s, &ColorIndexTagList, &do_cache, parse_uncolor);
+#endif
 
   if (do_cache && !option (OPTNOCURSES))
   {
@@ -506,7 +564,7 @@ static int _mutt_parse_uncolor (BUFFER *buf, BUFFER *s, unsigned long data,
 static int 
 add_pattern (COLOR_LINE **top, const char *s, int sensitive,
 	     int fg, int bg, int attr, BUFFER *err,
-	     int is_index)
+	     int is_index, int match)
 {
 
   /* is_index used to store compiled pattern
@@ -577,6 +635,7 @@ add_pattern (COLOR_LINE **top, const char *s, int sensitive,
     }
     tmp->next = *top;
     tmp->pattern = safe_strdup (s);
+    tmp->match = match;
 #ifdef HAVE_COLOR
     if(fg != -1 && bg != -1)
     {
@@ -719,7 +778,7 @@ _mutt_parse_color (BUFFER *buf, BUFFER *s, BUFFER *err,
 		   parser_callback_t callback, short dry_run)
 {
   int object = 0, attr = 0, fg = 0, bg = 0, q_level = 0;
-  int r = 0;
+  int r = 0, match = 0;
 
   if(parse_object(buf, s, &object, &q_level, err) == -1)
     return -1;
@@ -729,18 +788,26 @@ _mutt_parse_color (BUFFER *buf, BUFFER *s, BUFFER *err,
 
   /* extract a regular expression if needed */
   
-  if (object == MT_COLOR_HEADER || object == MT_COLOR_BODY || object == MT_COLOR_INDEX)
-  {
+  if ((object == MT_COLOR_BODY) ||
+      (object == MT_COLOR_HEADER) ||
+      (object == MT_COLOR_ATTACH_HEADERS) ||
+      (object == MT_COLOR_INDEX) ||
+      (object == MT_COLOR_INDEX_AUTHOR) ||
+      (object == MT_COLOR_INDEX_FLAGS) ||
+#ifdef USE_NOTMUCH
+      (object == MT_COLOR_INDEX_TAG) ||
+#endif
+      (object == MT_COLOR_INDEX_SUBJECT)) {
     if (!MoreArgs (s))
     {
       strfcpy (err->data, _("too few arguments"), err->dsize);
-      return (-1);
+      return -1;
     }
 
     mutt_extract_token (buf, s, 0);
   }
    
-  if (MoreArgs (s))
+  if (MoreArgs (s) && (object != MT_COLOR_STATUS))
   {
     strfcpy (err->data, _("too many arguments"), err->dsize);
     return (-1);
@@ -765,14 +832,67 @@ _mutt_parse_color (BUFFER *buf, BUFFER *s, BUFFER *err,
 #endif
   
   if (object == MT_COLOR_HEADER)
-    r = add_pattern (&ColorHdrList, buf->data, 0, fg, bg, attr, err,0);
+    r = add_pattern (&ColorHdrList, buf->data, 0, fg, bg, attr, err, 0, match);
   else if (object == MT_COLOR_BODY)
-    r = add_pattern (&ColorBodyList, buf->data, 1, fg, bg, attr, err, 0);
+    r = add_pattern (&ColorBodyList, buf->data, 1, fg, bg, attr, err, 0, match);
+  else if (object == MT_COLOR_ATTACH_HEADERS)
+    r = add_pattern (&ColorAttachList, buf->data, 1, fg, bg, attr, err, 0, match);
+  else if ((object == MT_COLOR_STATUS) && MoreArgs (s)) {
+    /* 'color status fg bg' can have up to 2 arguments:
+     * 0 arguments: sets the default status color (handled below by else part)
+     * 1 argument : colorize pattern on match
+     * 2 arguments: colorize nth submatch of pattern
+     */
+    mutt_extract_token (buf, s, 0);
+
+    if (MoreArgs (s)) {
+      BUFFER temporary;
+      memset (&temporary, 0, sizeof (BUFFER));
+      mutt_extract_token (&temporary, s, 0);
+      match = atoi (temporary.data);
+      FREE(&temporary.data);
+    }
+
+    if (MoreArgs (s)) {
+      strfcpy (err->data, _("too many arguments"), err->dsize);
+      return -1;
+    }
+
+    r = add_pattern (&ColorStatusList, buf->data, 1,
+		    fg, bg, attr, err, 0, match);
+  }
   else if (object == MT_COLOR_INDEX)
   {
-    r = add_pattern (&ColorIndexList, buf->data, 1, fg, bg, attr, err, 1);
+    r = add_pattern (&ColorIndexList, buf->data, 1,
+		    fg, bg, attr, err, 1, match);
+    set_option (OPTFORCEREDRAWINDEX);
+  }
+  else if (object == MT_COLOR_INDEX_AUTHOR)
+  {
+    r = add_pattern (&ColorIndexAuthorList, buf->data, 1,
+		    fg, bg, attr, err, 1, match);
+    set_option (OPTFORCEREDRAWINDEX);
+  }
+  else if (object == MT_COLOR_INDEX_FLAGS)
+  {
+    r = add_pattern (&ColorIndexFlagsList, buf->data, 1,
+		    fg, bg, attr, err, 1, match);
     set_option (OPTFORCEREDRAWINDEX);
   }
+  else if (object == MT_COLOR_INDEX_SUBJECT)
+  {
+    r = add_pattern (&ColorIndexSubjectList, buf->data, 1,
+		    fg, bg, attr, err, 1, match);
+    set_option (OPTFORCEREDRAWINDEX);
+  }
+#ifdef USE_NOTMUCH
+  else if (object == MT_COLOR_INDEX_TAG)
+  {
+    r = add_pattern (&ColorIndexTagList, buf->data, 1,
+		    fg, bg, attr, err, 1, match);
+    set_option (OPTFORCEREDRAWINDEX);
+  }
+#endif
   else if (object == MT_COLOR_QUOTED)
   {
     if (q_level >= ColorQuoteSize)
@@ -798,7 +918,11 @@ _mutt_parse_color (BUFFER *buf, BUFFER *s, BUFFER *err,
       ColorQuote[q_level] = fgbgattr_to_color(fg, bg, attr);
   }
   else
+  {
     ColorDefs[object] = fgbgattr_to_color(fg, bg, attr);
+    if (object > MT_COLOR_INDEX_AUTHOR)
+      set_option (OPTFORCEREDRAWINDEX);
+  }
 
   return (r);
 }
diff --git c/commands.c w/commands.c
index 2202a67..6daf2c1 100644
--- c/commands.c
+++ w/commands.c
@@ -40,6 +40,10 @@
 #include "imap.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include "buffy.h"
 
 #include <errno.h>
@@ -61,6 +65,7 @@ int mutt_display_message (HEADER *cur)
   char tempfile[_POSIX_PATH_MAX], buf[LONG_STRING];
   int rc = 0, builtin = 0;
   int cmflags = MUTT_CM_DECODE | MUTT_CM_DISPLAY | MUTT_CM_CHARCONV;
+  int chflags;
   FILE *fpout = NULL;
   FILE *fpfilterout = NULL;
   pid_t filterpid = -1;
@@ -145,8 +150,14 @@ int mutt_display_message (HEADER *cur)
     fputs ("\n\n", fpout);
   }
 
-  res = mutt_copy_message (fpout, Context, cur, cmflags,
-       	(option (OPTWEED) ? (CH_WEED | CH_REORDER) : 0) | CH_DECODE | CH_FROM | CH_DISPLAY);
+  chflags = (option (OPTWEED) ? (CH_WEED | CH_REORDER) : 0)
+           | CH_DECODE | CH_FROM | CH_DISPLAY;
+#ifdef USE_NOTMUCH
+  if (Context->magic == MUTT_NOTMUCH)
+    chflags |= CH_VIRTUAL;
+#endif
+  res = mutt_copy_message (fpout, Context, cur, cmflags, chflags);
+
   if ((safe_fclose (&fpout) != 0 && errno != EPIPE) || res < 0)
   {
     mutt_error (_("Could not copy message"));
@@ -533,9 +544,9 @@ int mutt_select_sort (int reverse)
   int method = Sort; /* save the current method in case of abort */
 
   switch (mutt_multi_choice (reverse ?
-			     _("Rev-Sort (d)ate/(f)rm/(r)ecv/(s)ubj/t(o)/(t)hread/(u)nsort/si(z)e/s(c)ore/s(p)am?: ") :
-			     _("Sort (d)ate/(f)rm/(r)ecv/(s)ubj/t(o)/(t)hread/(u)nsort/si(z)e/s(c)ore/s(p)am?: "),
-			     _("dfrsotuzcp")))
+			     _("Rev-Sort Date/Frm/Recv/Subj/tO/Thread/Unsort/siZe/sCore/sPam/Label?: ") :
+			     _("Sort Date/Frm/Recv/Subj/tO/Thread/Unsort/siZe/sCore/sPam/Label?: "),
+			     _("dfrsotuzcpl")))
   {
   case -1: /* abort - don't resort */
     return -1;
@@ -579,6 +590,10 @@ int mutt_select_sort (int reverse)
   case 10: /* s(p)am */
     Sort = SORT_SPAM;
     break;
+
+  case 11: /* (l)abel */
+    Sort = SORT_LABEL;
+    break;
   }
   if (reverse)
     Sort |= SORT_REVERSE;
@@ -837,6 +852,16 @@ int mutt_save_message (HEADER *h, int delete,
 
   if (mx_open_mailbox (buf, MUTT_APPEND, &ctx) != NULL)
   {
+#ifdef USE_COMPRESSED
+    /* If we're saving to a compressed mailbox, the stats won't be updated
+     * until the next open.  Until then, improvise. */
+    BUFFY *cm = NULL;
+    if (ctx.compress_info)
+      cm = mutt_find_mailbox (ctx.realpath);
+    /* We probably haven't been opened yet */
+    if (cm && (cm->msg_count == 0))
+      cm = NULL;
+#endif
     if (h)
     {
       if (_mutt_save_message(h, &ctx, delete, decode, decrypt) != 0)
@@ -844,22 +869,54 @@ int mutt_save_message (HEADER *h, int delete,
         mx_close_mailbox (&ctx, NULL);
         return -1;
       }
+#ifdef USE_COMPRESSED
+      if (cm)
+      {
+        cm->msg_count++;
+        if (!h->read)
+          cm->msg_unread++;
+        if (h->flagged)
+          cm->msg_flagged++;
+      }
+#endif
     }
     else
     {
+      int rc = 0;
+
+#ifdef USE_NOTMUCH
+      if (Context->magic == MUTT_NOTMUCH)
+        nm_longrun_init(Context, TRUE);
+#endif
       for (i = 0; i < Context->vcount; i++)
       {
 	if (Context->hdrs[Context->v2r[i]]->tagged)
 	{
 	  mutt_message_hook (Context, Context->hdrs[Context->v2r[i]], MUTT_MESSAGEHOOK);
-	  if (_mutt_save_message(Context->hdrs[Context->v2r[i]],
-			     &ctx, delete, decode, decrypt) != 0)
+	  if ((rc = _mutt_save_message(Context->hdrs[Context->v2r[i]],
+			     &ctx, delete, decode, decrypt) != 0))
+	    break;
+#ifdef USE_COMPRESSED
+          if (cm)
           {
-            mx_close_mailbox (&ctx, NULL);
-            return -1;
+            HEADER *h = Context->hdrs[Context->v2r[i]];
+            cm->msg_count++;
+            if (!h->read)
+              cm->msg_unread++;
+            if (h->flagged)
+              cm->msg_flagged++;
           }
+#endif
 	}
       }
+#ifdef USE_NOTMUCH
+      if (Context->magic == MUTT_NOTMUCH)
+        nm_longrun_done(Context);
+#endif
+      if (rc != 0) {
+	mx_close_mailbox (&ctx, NULL);
+	return -1;
+      }
     }
 
     need_buffy_cleanup = (ctx.magic == MUTT_MBOX || ctx.magic == MUTT_MMDF);
@@ -879,7 +936,7 @@ int mutt_save_message (HEADER *h, int delete,
 
 void mutt_version (void)
 {
-  mutt_message ("Mutt %s (%s)", MUTT_VERSION, ReleaseDate);
+  mutt_message ("NeoMutt %s (%s)", PACKAGE_VERSION, OldMuttVer);
 }
 
 void mutt_edit_content_type (HEADER *h, BODY *b, FILE *fp)
diff --git c/complete.c w/complete.c
index d0ee4af..b383786 100644
--- c/complete.c
+++ w/complete.c
@@ -25,6 +25,9 @@
 #include "mailbox.h"
 #include "imap.h"
 #endif
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
 
 #include <dirent.h>
 #include <string.h>
@@ -48,9 +51,70 @@ int mutt_complete (char *s, size_t slen)
   char filepart[_POSIX_PATH_MAX];
 #ifdef USE_IMAP
   char imap_path[LONG_STRING];
+#endif
 
   dprint (2, (debugfile, "mutt_complete: completing %s\n", s));
 
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    NNTP_SERVER *nserv = CurrentNewsSrv;
+    unsigned int n = 0;
+
+    strfcpy (filepart, s, sizeof (filepart));
+
+    /* special case to handle when there is no filepart yet
+     * find the first subscribed newsgroup */
+    len = mutt_strlen (filepart);
+    if (len == 0)
+    {
+      for (; n < nserv->groups_num; n++)
+      {
+	NNTP_DATA *nntp_data = nserv->groups_list[n];
+
+	if (nntp_data && nntp_data->subscribed)
+	{
+	  strfcpy (filepart, nntp_data->group, sizeof (filepart));
+	  init = 1;
+	  n++;
+	  break;
+	}
+      }
+    }
+
+    for (; n < nserv->groups_num; n++)
+    {
+      NNTP_DATA *nntp_data = nserv->groups_list[n];
+
+      if (nntp_data && nntp_data->subscribed &&
+	  mutt_strncmp (nntp_data->group, filepart, len) == 0)
+      {
+	if (init)
+	{
+	  for (i = 0; filepart[i] && nntp_data->group[i]; i++)
+	  {
+	    if (filepart[i] != nntp_data->group[i])
+	    {
+	      filepart[i] = 0;
+	      break;
+	    }
+	  }
+	  filepart[i] = 0;
+	}
+	else
+	{
+	  strfcpy (filepart, nntp_data->group, sizeof (filepart));
+	  init = 1;
+	}
+      }
+    }
+
+    strfcpy (s, filepart, slen);
+    return (init ? 0 : -1);
+  }
+#endif
+
+#ifdef USE_IMAP
   /* we can use '/' as a delimiter, imap_complete rewrites it */
   if (*s == '=' || *s == '+' || *s == '!')
   {
diff --git c/compose.c w/compose.c
index b4d0c41..e47afff 100644
--- c/compose.c
+++ w/compose.c
@@ -32,11 +32,16 @@
 #include "mailbox.h"
 #include "sort.h"
 #include "charset.h"
+#include "mx.h"
 
 #ifdef MIXMASTER
 #include "remailer.h"
 #endif
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
+
 #include <errno.h>
 #include <string.h>
 #include <sys/stat.h>
@@ -67,11 +72,17 @@ enum
   HDR_CRYPT,
   HDR_CRYPTINFO,
 
+#ifdef USE_NNTP
+  HDR_NEWSGROUPS,
+  HDR_FOLLOWUPTO,
+  HDR_XCOMMENTTO,
+#endif
+
   HDR_ATTACH  = (HDR_FCC + 5) /* where to start printing the attachments */
 };
 
-#define HDR_XOFFSET 10
-#define TITLE_FMT "%10s" /* Used for Prompts, which are ASCII */
+#define HDR_XOFFSET 14
+#define TITLE_FMT "%14s" /* Used for Prompts, which are ASCII */
 #define W (MuttIndexWindow->cols - HDR_XOFFSET)
 
 static const char * const Prompts[] =
@@ -83,6 +94,15 @@ static const char * const Prompts[] =
   "Subject: ",
   "Reply-To: ",
   "Fcc: "
+#ifdef USE_NNTP
+#ifdef MIXMASTER
+  ,""
+#endif
+  ,""
+  ,"Newsgroups: "
+  ,"Followup-To: "
+  ,"X-Comment-To: "
+#endif
 };
 
 static const struct mapping_t ComposeHelp[] = {
@@ -97,6 +117,19 @@ static const struct mapping_t ComposeHelp[] = {
   { NULL,	0 }
 };
 
+#ifdef USE_NNTP
+static struct mapping_t ComposeNewsHelp[] = {
+  { N_("Send"),		OP_COMPOSE_SEND_MESSAGE },
+  { N_("Abort"),	OP_EXIT },
+  { "Newsgroups",	OP_COMPOSE_EDIT_NEWSGROUPS },
+  { "Subj",		OP_COMPOSE_EDIT_SUBJECT },
+  { N_("Attach file"),	OP_COMPOSE_ATTACH_FILE },
+  { N_("Descrip"),	OP_COMPOSE_EDIT_DESCRIPTION },
+  { N_("Help"),		OP_HELP },
+  { NULL,		0 }
+};
+#endif
+
 static void snd_entry (char *b, size_t blen, MUTTMENU *menu, int num)
 {
   mutt_FormatString (b, blen, 0, MuttIndexWindow->cols, NONULL (AttachFormat), mutt_attach_fmt,
@@ -250,9 +283,28 @@ static void draw_envelope_addr (int line, ADDRESS *addr)
 static void draw_envelope (HEADER *msg, char *fcc)
 {
   draw_envelope_addr (HDR_FROM, msg->env->from);
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+  {
+#endif
   draw_envelope_addr (HDR_TO, msg->env->to);
   draw_envelope_addr (HDR_CC, msg->env->cc);
   draw_envelope_addr (HDR_BCC, msg->env->bcc);
+#ifdef USE_NNTP
+  }
+  else
+  {
+    mutt_window_mvprintw (MuttIndexWindow, HDR_TO, 0, TITLE_FMT, Prompts[HDR_NEWSGROUPS - 1]);
+    mutt_paddstr (W, NONULL (msg->env->newsgroups));
+    mutt_window_mvprintw (MuttIndexWindow, HDR_CC, 0, TITLE_FMT, Prompts[HDR_FOLLOWUPTO - 1]);
+    mutt_paddstr (W, NONULL (msg->env->followup_to));
+    if (option (OPTXCOMMENTTO))
+    {
+      mutt_window_mvprintw (MuttIndexWindow, HDR_BCC, 0, TITLE_FMT, Prompts[HDR_XCOMMENTTO - 1]);
+      mutt_paddstr (W, NONULL (msg->env->x_comment_to));
+    }
+  }
+#endif
   mutt_window_mvprintw (MuttIndexWindow, HDR_SUBJECT, 0, TITLE_FMT, Prompts[HDR_SUBJECT]);
   mutt_paddstr (W, NONULL (msg->env->subject));
   draw_envelope_addr (HDR_REPLYTO, msg->env->reply_to);
@@ -448,8 +500,8 @@ compose_format_str (char *buf, size_t buflen, size_t col, int cols, char op, con
       break;
 
     case 'v':
-      snprintf (fmt, sizeof (fmt), "Mutt %%s");
-      snprintf (buf, buflen, fmt, MUTT_VERSION);
+      snprintf (fmt, sizeof (fmt), "NeoMutt %%s");
+      snprintf (buf, buflen, fmt, PACKAGE_VERSION);
       break;
 
     case 0:
@@ -505,6 +557,12 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
   /* Sort, SortAux could be changed in mutt_index_menu() */
   int oldSort, oldSortAux;
   struct stat st;
+#ifdef USE_NNTP
+  int news = 0;		/* is it a news article ? */
+
+  if (option (OPTNEWSSEND))
+    news++;
+#endif
 
   mutt_attach_init (msg->content);
   idx = mutt_gen_attach_list (msg->content, -1, idx, &idxlen, &idxmax, 0, 1);
@@ -515,10 +573,18 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
   menu->make_entry = snd_entry;
   menu->tag = mutt_tag_attach;
   menu->data = idx;
+#ifdef USE_NNTP
+  if (news)
+    menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_COMPOSE, ComposeNewsHelp);
+  else
+#endif
   menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_COMPOSE, ComposeHelp);
 
   while (loop)
   {
+#ifdef USE_NNTP
+    unset_option (OPTNEWS);	/* for any case */
+#endif
     switch (op = mutt_menuLoop (menu))
     {
       case OP_REDRAW:
@@ -531,6 +597,10 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
         mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
 	break;
       case OP_COMPOSE_EDIT_TO:
+#ifdef USE_NNTP
+	if (news)
+	  break;
+#endif
 	menu->redraw = edit_address_list (HDR_TO, &msg->env->to);
 	if (option (OPTCRYPTOPPORTUNISTICENCRYPT))
 	{
@@ -540,6 +610,10 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
         mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
       case OP_COMPOSE_EDIT_BCC:
+#ifdef USE_NNTP
+	if (news)
+	  break;
+#endif
 	menu->redraw = edit_address_list (HDR_BCC, &msg->env->bcc);
 	if (option (OPTCRYPTOPPORTUNISTICENCRYPT))
 	{
@@ -549,6 +623,10 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
         mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
 	break;
       case OP_COMPOSE_EDIT_CC:
+#ifdef USE_NNTP
+	if (news)
+	  break;
+#endif
 	menu->redraw = edit_address_list (HDR_CC, &msg->env->cc);
 	if (option (OPTCRYPTOPPORTUNISTICENCRYPT))
 	{
@@ -557,6 +635,62 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	}
         mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);	
         break;
+#ifdef USE_NNTP
+      case OP_COMPOSE_EDIT_NEWSGROUPS:
+	if (news)
+	{
+	  if (msg->env->newsgroups)
+	    strfcpy (buf, msg->env->newsgroups, sizeof (buf));
+	  else
+	    buf[0] = 0;
+	  if (mutt_get_field ("Newsgroups: ", buf, sizeof (buf), 0) == 0)
+	  {
+	    mutt_str_replace (&msg->env->newsgroups, buf);
+	    mutt_window_move (MuttIndexWindow, HDR_TO, HDR_XOFFSET);
+	    if (msg->env->newsgroups)
+	      mutt_paddstr (W, msg->env->newsgroups);
+	    else
+	      clrtoeol ();
+	  }
+	}
+	break;
+      case OP_COMPOSE_EDIT_FOLLOWUP_TO:
+	if (news)
+	{
+	  if (msg->env->followup_to)
+	    strfcpy (buf, msg->env->followup_to, sizeof (buf));
+	  else
+	    buf[0] = 0;
+	  if (mutt_get_field ("Followup-To: ", buf, sizeof (buf), 0) == 0)
+	  {
+	    mutt_str_replace (&msg->env->followup_to, buf);
+	    mutt_window_move (MuttIndexWindow, HDR_CC, HDR_XOFFSET);
+	    if (msg->env->followup_to)
+	      mutt_paddstr (W, msg->env->followup_to);
+	    else
+	      clrtoeol ();
+	  }
+	}
+	break;
+      case OP_COMPOSE_EDIT_X_COMMENT_TO:
+	if (news && option (OPTXCOMMENTTO))
+	{
+	  if (msg->env->x_comment_to)
+	    strfcpy (buf, msg->env->x_comment_to, sizeof (buf));
+	  else
+	    buf[0] = 0;
+	  if (mutt_get_field ("X-Comment-To: ", buf, sizeof (buf), 0) == 0)
+	  {
+	    mutt_str_replace (&msg->env->x_comment_to, buf);
+	    mutt_window_move (MuttIndexWindow, HDR_BCC, HDR_XOFFSET);
+	    if (msg->env->x_comment_to)
+	      mutt_paddstr (W, msg->env->x_comment_to);
+	    else
+	      clrtoeol ();
+	  }
+	}
+	break;
+#endif
       case OP_COMPOSE_EDIT_SUBJECT:
 	if (msg->env->subject)
 	  strfcpy (buf, msg->env->subject, sizeof (buf));
@@ -687,7 +821,8 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  numfiles = 0;
 	  files = NULL;
 
-	  if (_mutt_enter_fname (prompt, fname, sizeof (fname), &menu->redraw, 0, 1, &files, &numfiles) == -1 ||
+	  if (_mutt_enter_fname (prompt, fname, sizeof (fname),
+			&menu->redraw, 0, 1, &files, &numfiles, 0) == -1 ||
 	      *fname == '\0')
 	    break;
 
@@ -725,6 +860,9 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
         break;
 
       case OP_COMPOSE_ATTACH_MESSAGE:
+#ifdef USE_NNTP
+      case OP_COMPOSE_ATTACH_NEWS_MESSAGE:
+#endif
 	{
 	  char *prompt;
 	  HEADER *h;
@@ -732,7 +870,22 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  fname[0] = 0;
 	  prompt = _("Open mailbox to attach message from");
 
+#ifdef USE_NNTP
+	  unset_option (OPTNEWS);
+	  if (op == OP_COMPOSE_ATTACH_NEWS_MESSAGE)
+	  {
+	    if (!(CurrentNewsSrv = nntp_select_server (NewsServer, 0)))
+	      break;
+
+	    prompt = _("Open newsgroup to attach message from");
+	    set_option (OPTNEWS);
+	  }
+#endif
+
 	  if (Context)
+#ifdef USE_NNTP
+	  if ((op == OP_COMPOSE_ATTACH_MESSAGE) ^ (Context->magic == MUTT_NNTP))
+#endif
 	  {
 	    strfcpy (fname, NONULL (Context->path), sizeof (fname));
 	    mutt_pretty_mailbox (fname, sizeof (fname));
@@ -741,6 +894,11 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  if (mutt_enter_fname (prompt, fname, sizeof (fname), &menu->redraw, 1) == -1 || !fname[0])
 	    break;
 
+#ifdef USE_NNTP
+	  if (option (OPTNEWS))
+	    nntp_expand_path (fname, sizeof (fname), &CurrentNewsSrv->conn->account);
+	  else
+#endif
 	  mutt_expand_path (fname, sizeof (fname));
 #ifdef USE_IMAP
           if (!mx_is_imap (fname))
@@ -748,6 +906,9 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 #ifdef USE_POP
           if (!mx_is_pop (fname))
 #endif
+#ifdef USE_NNTP
+	  if (!mx_is_nntp (fname) && !option (OPTNEWS))
+#endif
 	  /* check to make sure the file exists and is readable */
 	  if (access (fname, R_OK) == -1)
 	  {
@@ -1232,7 +1393,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
          if (msg->content->next)
            msg->content = mutt_make_multipart (msg->content);
 
-         if (mutt_write_fcc (fname, msg, NULL, 0, NULL) < 0)
+         if (mutt_write_fcc (fname, msg, NULL, 0, NULL, NULL) < 0)
            msg->content = mutt_remove_multipart (msg->content);
          else
            mutt_message _("Message written.");
diff --git c/compress.c w/compress.c
new file mode 100644
index 0000000..aadf094
--- /dev/null
+++ w/compress.c
@@ -0,0 +1,918 @@
+/* Copyright (C) 1997 Alain Penders <Alain@Finale-Dev.com>
+ * Copyright (C) 2016 Richard Russon <rich@flatcap.org>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <errno.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include "mutt.h"
+#include "mailbox.h"
+#include "mutt_curses.h"
+#include "mx.h"
+
+/* Notes:
+ * Any references to compressed files also apply to encrypted files.
+ * ctx->path     == plaintext file
+ * ctx->realpath == compressed file
+ */
+
+/**
+ * struct COMPRESS_INFO - Private data for compress
+ *
+ * This object gets attached to the mailbox's CONTEXT.
+ */
+typedef struct
+{
+  const char *append;             /* append-hook command */
+  const char *close;              /* close-hook  command */
+  const char *open;               /* open-hook   command */
+  off_t size;                     /* size of the compressed file */
+  struct mx_ops *child_ops;       /* callbacks of de-compressed file */
+} COMPRESS_INFO;
+
+
+/**
+ * lock_mailbox - Try to lock a mailbox (exclusively)
+ * @ctx:  Mailbox to lock
+ * @fp:   File pointer to the mailbox file
+ * @excl: Lock exclusively?
+ *
+ * Try to (exclusively) lock the mailbox.  If we succeed, then we mark the
+ * mailbox as locked.  If we fail, but we didn't want exclusive rights, then
+ * the mailbox will be marked readonly.
+ *
+ * Returns:
+ *      1: Success (locked or readonly)
+ *      0: Error (can't lock the file)
+ */
+static int
+lock_mailbox (CONTEXT *ctx, FILE *fp, int excl)
+{
+  if (!ctx || !fp)
+    return 0;
+
+  int r = mx_lock_file (ctx->realpath, fileno (fp), excl, 1, 1);
+
+  if (r == 0)
+  {
+    ctx->locked = 1;
+  }
+  else if (excl == 0)
+  {
+    ctx->readonly = 1;
+    return 1;
+  }
+
+  return (r == 0);
+}
+
+/**
+ * unlock_mailbox - Unlock a mailbox
+ * @ctx: Mailbox to unlock
+ * @fp:  File pointer to mailbox file
+ *
+ * Unlock a mailbox previously locked by lock_mailbox().
+ */
+static void
+unlock_mailbox (CONTEXT *ctx, FILE *fp)
+{
+  if (!ctx || !fp)
+    return;
+
+  if (!ctx->locked)
+    return;
+
+  fflush (fp);
+
+  mx_unlock_file (ctx->realpath, fileno (fp), 1);
+  ctx->locked = 0;
+}
+
+/**
+ * setup_paths - Set the mailbox paths
+ * @ctx: Mailbox to modify
+ *
+ * Save the compressed filename in ctx->realpath.
+ * Create a temporary filename and put its name in ctx->path.
+ *
+ * Note: The temporary file is NOT created.
+ * Note: ctx->path will be freed by restore_path()
+ */
+static void
+setup_paths (CONTEXT *ctx)
+{
+  if (!ctx)
+    return;
+
+  char tmppath[_POSIX_PATH_MAX];
+
+  /* Setup the right paths */
+  ctx->realpath = ctx->path;
+
+  /* We will uncompress to /tmp */
+  mutt_mktemp (tmppath, sizeof (tmppath));
+  ctx->path = safe_strdup (tmppath);
+}
+
+/**
+ * restore_path - Put back the original mailbox name
+ * @ctx: Mailbox to modify
+ *
+ * When we use a compressed mailbox, we change the CONTEXT to refer to the
+ * uncompressed file.  We store the original name in ctx->realpath.
+ *      ctx->path     = "/tmp/mailbox"
+ *      ctx->realpath = "mailbox.gz"
+ *
+ * When we have finished with a compressed mailbox, we put back the original
+ * name.
+ *      ctx->path     = "mailbox.gz"
+ *      ctx->realpath = NULL
+ */
+static void
+restore_path (CONTEXT *ctx)
+{
+  if (!ctx)
+    return;
+
+  FREE(&ctx->path);
+  ctx->path = ctx->realpath;
+  ctx->realpath = NULL;
+}
+
+/**
+ * get_size - Get the size of a file
+ * @path: File to measure
+ *
+ * Returns:
+ *      number: Size in bytes
+ *      0:      On error
+ */
+static int
+get_size (const char *path)
+{
+  if (!path)
+    return 0;
+
+  struct stat sb;
+  if (stat (path, &sb) != 0)
+    return 0;
+
+  return sb.st_size;
+}
+
+/**
+ * store_size - Save the size of the compressed file
+ * @ctx: Mailbox
+ *
+ * Save the compressed file size in the compress_info struct.
+ */
+static void
+store_size (const CONTEXT *ctx)
+{
+  if (!ctx)
+    return;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return;
+
+  ci->size = get_size (ctx->realpath);
+}
+
+/**
+ * find_hook - Find a hook to match a path
+ * @type: Type of hook, e.g. MUTT_CLOSEHOOK
+ * @path: Filename to test
+ *
+ * Each hook has a type and a pattern.
+ * Find a command that matches the type and path supplied. e.g.
+ *
+ * User config:
+ *      open-hook '\.gz$' "gzip -cd '%f' > '%t'"
+ *
+ * Call:
+ *      find_hook (MUTT_OPENHOOK, "myfile.gz");
+ *
+ * Returns:
+ *      string: Matching hook command
+ *      NULL:   No matches
+ */
+static const char *
+find_hook (int type, const char *path)
+{
+  if (!path)
+    return NULL;
+
+  const char *c = mutt_find_hook (type, path);
+  if (!c || !*c)
+    return NULL;
+
+  return c;
+}
+
+/**
+ * set_compress_info - Find the compress hooks for a mailbox
+ * @ctx: Mailbox to examine
+ *
+ * When a mailbox is opened, we check if there are any matching hooks.
+ *
+ * Note: Caller must free the COMPRESS_INFO when done.
+ *
+ * Returns:
+ *      COMPRESS_INFO: Hook info for the mailbox's path
+ *      NULL:          On error
+ */
+static COMPRESS_INFO *
+set_compress_info (CONTEXT *ctx)
+{
+  if (!ctx || !ctx->path)
+    return NULL;
+
+  if (ctx->compress_info)
+    return ctx->compress_info;
+
+  /* Open is compulsory */
+  const char *o = find_hook (MUTT_OPENHOOK,   ctx->path);
+  if (!o)
+    return NULL;
+
+  const char *c = find_hook (MUTT_CLOSEHOOK,  ctx->path);
+  const char *a = find_hook (MUTT_APPENDHOOK, ctx->path);
+
+  COMPRESS_INFO *ci = safe_calloc (1, sizeof (COMPRESS_INFO));
+  ctx->compress_info = ci;
+
+  ci->open   = o;
+  ci->close  = c;
+  ci->append = a;
+
+  return ci;
+}
+
+/**
+ * cb_format_str - Expand the filenames in the command string
+ * @dest:        Buffer in which to save string
+ * @destlen:     Buffer length
+ * @col:         Starting column, UNUSED
+ * @cols:        Number of screen columns, UNUSED
+ * @op:          printf-like operator, e.g. 't'
+ * @src:         printf-like format string
+ * @fmt:         Field formatting string, UNUSED
+ * @ifstring:    If condition is met, display this string, UNUSED
+ * @elsestring:  Otherwise, display this string, UNUSED
+ * @data:        Pointer to the mailbox CONTEXT
+ * @flags:       Format flags, UNUSED
+ *
+ * cb_format_str is a callback function for mutt_FormatString.  It understands
+ * two operators. '%f' : 'from' filename, '%t' : 'to' filename.
+ *
+ * Returns: src (unchanged)
+ */
+static const char *
+cb_format_str (char *dest, size_t destlen, size_t col, int cols, char op, const char *src,
+  const char *fmt, const char *ifstring, const char *elsestring,
+  unsigned long data, format_flag flags)
+{
+  if (!dest || (data == 0))
+    return src;
+
+  CONTEXT *ctx = (CONTEXT *) data;
+
+  switch (op)
+  {
+    case 'f':
+      /* Compressed file */
+      snprintf (dest, destlen, "%s", ctx->realpath);
+      break;
+    case 't':
+      /* Plaintext, temporary file */
+      snprintf (dest, destlen, "%s", ctx->path);
+      break;
+  }
+  return src;
+}
+
+/**
+ * expand_command_str - Expand placeholders in command string
+ * @ctx:    Mailbox for paths
+ * @buf:    Buffer to store the command
+ * @buflen: Size of the buffer
+ *
+ * This function takes a hook command and expands the filename placeholders
+ * within it.  The function calls mutt_FormatString() to do the replacement
+ * which calls our callback function cb_format_str(). e.g.
+ *
+ * Template command:
+ *      gzip -cd '%f' > '%t'
+ *
+ * Result:
+ *      gzip -dc '~/mail/abc.gz' > '/tmp/xyz'
+ */
+static void
+expand_command_str (const CONTEXT *ctx, const char *cmd, char *buf, int buflen)
+{
+  if (!ctx || !cmd || !buf)
+    return;
+
+  mutt_FormatString (buf, buflen, 0, buflen, cmd, cb_format_str, (unsigned long) ctx, 0);
+}
+
+/**
+ * execute_command - Run a system command
+ * @ctx:         Mailbox to work with
+ * @command:     Command string to execute
+ * @create_file: Should the tmp file be created?
+ * @progress:    Message to show the user
+ *
+ * Run the supplied command, taking care of all the Mutt requirements,
+ * such as locking files and blocking signals.
+ *
+ * Returns:
+ *      1: Success
+ *      0: Failure
+ */
+static int
+execute_command (CONTEXT *ctx, const char *command, int create_file, const char *progress)
+{
+  if (!ctx || !command || !progress)
+    return 0;
+
+  if (!ctx->quiet)
+    mutt_message (progress, ctx->realpath);
+
+  FILE *fp;
+  if (create_file)
+    fp = fopen (ctx->realpath, "a");
+  else
+    fp = fopen (ctx->realpath, "r");
+
+  if (!fp)
+  {
+    mutt_perror (ctx->realpath);
+    return 0;
+  }
+
+  mutt_block_signals();
+  /* If we're creating the file, lock it exclusively */
+  if (!lock_mailbox (ctx, fp, create_file))
+  {
+    safe_fclose (&fp);
+    mutt_unblock_signals();
+    mutt_error (_("Unable to lock mailbox!"));
+    return 0;
+  }
+
+  endwin();
+  fflush (stdout);
+
+  char sys_cmd[HUGE_STRING];
+
+  expand_command_str (ctx, command, sys_cmd, sizeof (sys_cmd));
+
+  int rc = mutt_system (sys_cmd);
+  if (rc != 0)
+  {
+    mutt_any_key_to_continue (NULL);
+    mutt_error (_("Error executing: %s\n"), sys_cmd);
+  }
+
+  unlock_mailbox (ctx, fp);
+  mutt_unblock_signals();
+  safe_fclose (&fp);
+
+  return 1;
+}
+
+/**
+ * open_read - Open a compressed mailbox for reading
+ * @ctx: Mailbox to open
+ *
+ * Decompress the mailbox and set up the paths and hooks needed.
+ *
+ * Note: The message handling will be delegated to the mbox code.
+ *
+ * Returns:
+ *      1: Success
+ *      0: Failure
+ */
+static int
+open_read (CONTEXT *ctx)
+{
+  if (!ctx)
+    return 0;
+
+  COMPRESS_INFO *ci = set_compress_info (ctx);
+  if (!ci)
+  {
+    ctx->magic = 0;
+    return 0;
+  }
+
+  /* If there's no close-hook, or the file isn't writable */
+  if (!ci->close || (access (ctx->path, W_OK) != 0))
+    ctx->readonly = 1;
+
+  setup_paths (ctx);
+  store_size (ctx);
+
+  int rc = execute_command (ctx, ci->open, 0, _("Decompressing %s"));
+  if (rc == 0)
+  {
+    goto or_fail;
+  }
+
+  ctx->magic = mx_get_magic (ctx->path);
+  if (ctx->magic == 0)
+  {
+    mutt_error (_("Can't identify the contents of the compressed file"));
+    goto or_fail;
+  }
+
+  ci->child_ops = mx_get_ops (ctx->magic);
+  if (!ci->child_ops)
+  {
+    mutt_error (_("Can't find mailbox ops for mailbox type %d"), ctx->magic);
+    goto or_fail;
+  }
+
+  return 1;
+
+or_fail:
+  /* remove the partial uncompressed file */
+  remove (ctx->path);
+  restore_path (ctx);
+  return 0;
+}
+
+
+struct mx_ops mx_comp_ops;
+
+/**
+ * open_mailbox - Open a compressed mailbox
+ * @ctx: Mailbox to open
+ *
+ * Set up a compressed mailbox to be read.
+ * First call open_read() to decompress the file.
+ * Then determine the type of the mailbox so we can delegate the handling of
+ * messages.
+ */
+static int
+open_mailbox (CONTEXT *ctx)
+{
+  if (!ctx || (ctx->magic != MUTT_COMPRESSED))
+    return 1;
+
+  if (!open_read (ctx))
+    return 1;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return 1;
+
+  struct mx_ops *ops = ci->child_ops;
+  if (!ops)
+    return 1;
+
+  /* Delegate */
+  return ops->open (ctx);
+}
+
+/**
+ * open_append_mailbox - Open a compressed mailbox for appending
+ * @ctx:   Mailbox to open
+ * @flags: e.g. Does the file already exist?
+ *
+ * To append to a compressed mailbox we need an append-hook (or both open- and
+ * close-hooks).
+ *
+ * Returns:
+ *       0: Success
+ *      -1: Failure
+ */
+static int
+open_append_mailbox (CONTEXT *ctx, int flags)
+{
+  if (!ctx)
+    return -1;
+
+  /* If this succeeds, we know there's an open-hook */
+  COMPRESS_INFO *ci = set_compress_info (ctx);
+  if (!ci)
+    return -1;
+
+  /* To append we need an append-hook or a close-hook */
+  if (!ci->append && !ci->close)
+  {
+    FREE(&ctx->compress_info);
+    mutt_error (_("Cannot append without an append-hook or close-hook : %s"), ctx->path);
+    return -1;
+  }
+
+  ctx->magic = DefaultMagic;
+  /* We can only deal with mbox and mmdf mailboxes */
+  if ((ctx->magic != MUTT_MBOX) && (ctx->magic != MUTT_MMDF))
+    return -1;
+
+  setup_paths (ctx);
+
+  ctx->mx_ops = &mx_comp_ops;
+  ci->child_ops = mx_get_ops (ctx->magic);
+  if (!ci->child_ops)
+  {
+    mutt_error (_("Can't find mailbox ops for mailbox type %d"), ctx->magic);
+    return -1;
+  }
+
+  if (ci->append)
+  {
+    /* Create an empty temporary file */
+    ctx->fp = safe_fopen (ctx->path, "w");
+    if (!ctx->fp)
+    {
+      mutt_perror (ctx->path);
+      goto oa_fail;
+    }
+  }
+  else
+  {
+    /* Open the existing mailbox */
+    int rc = execute_command (ctx, ci->open, 0, _("Decompressing %s"));
+    if (rc == 0)
+    {
+      mutt_error (_("Compress command failed: %s"), ci->open);
+      goto oa_fail;
+    }
+    ctx->fp = safe_fopen (ctx->path, "a");
+    if (!ctx->fp)
+    {
+      mutt_perror (ctx->path);
+      goto oa_fail;
+    }
+  }
+
+  return 0;
+
+oa_fail:
+  /* remove the partial uncompressed file */
+  remove (ctx->path);
+  restore_path (ctx);
+  return -1;
+}
+
+/**
+ * close_mailbox - Close a compressed mailbox
+ * @ctx: Mailbox to close
+ *
+ * If the mailbox has been changed then re-compress the tmp file.
+ * Then delete the tmp file.
+ *
+ * Returns:
+ *       0: Success
+ *      -1: Failure
+ */
+static int
+close_mailbox (CONTEXT *ctx)
+{
+  if (!ctx)
+    return -1;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return -1;
+
+  safe_fclose (&ctx->fp);
+
+  /* sync has already been called, so we only need to delete some files */
+  if (!ctx->append)
+  {
+    /* If the file was removed, remove the compressed folder too */
+    if ((access (ctx->path, F_OK) != 0) && !option (OPTSAVEEMPTY))
+    {
+      remove (ctx->realpath);
+    }
+    else
+    {
+      remove (ctx->path);
+    }
+
+    restore_path (ctx);
+    FREE(&ctx->compress_info);
+    return 0;
+  }
+
+  const char *append;
+  const char *msg;
+
+  /* The file exists and we can append */
+  if ((access (ctx->realpath, F_OK) == 0) && ci->append)
+  {
+    append = ci->append;
+    msg = _("Compressed-appending to %s...");
+  }
+  else
+  {
+    append = ci->close;
+    msg = _("Compressing %s...");
+  }
+
+  int rc = execute_command (ctx, append, 1, msg);
+  if (rc == 0)
+  {
+    mutt_any_key_to_continue (NULL);
+    mutt_error (_(" %s: Error compressing mailbox!  Uncompressed one kept!\n"), ctx->path);
+  }
+
+  remove (ctx->path);
+  restore_path (ctx);
+  FREE(&ctx->compress_info);
+
+  return 0;
+}
+
+/**
+ * check_mailbox - Check for changes in the compressed file
+ * @ctx: Mailbox
+ *
+ * If the compressed file changes in size but the mailbox hasn't been changed
+ * in Mutt, then we can close and reopen the mailbox.
+ *
+ * If the mailbox has been changed in Mutt, warn the user.
+ *
+ * The return codes are picked to match mx_check_mailbox().
+ *
+ * Returns:
+ *      0:              Mailbox OK
+ *      MUTT_REOPENED:  The mailbox was closed and reopened
+ *      -1:             Mailbox bad
+ */
+static int
+check_mailbox (CONTEXT *ctx, int *index_hint)
+{
+  if (!ctx)
+    return -1;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return -1;
+
+  int size = get_size (ctx->realpath);
+  if (size == ci->size)
+    return 0;
+
+  if (ctx->changed)
+  {
+    FREE(&ctx->compress_info);
+    restore_path (ctx);
+    mutt_error (_("Mailbox was corrupted!"));
+    return -1;
+  }
+
+  close_mailbox (ctx);
+
+  const char *path = ctx->path;
+  ctx->path = NULL;
+
+  mx_open_mailbox (path, 0, ctx);
+  FREE(&path);
+
+  return MUTT_REOPENED;
+}
+
+
+/**
+ * open_message - Delegated to mbox handler
+ */
+static int
+open_message (CONTEXT *ctx,  MESSAGE *msg, int msgno)
+{
+  if (!ctx)
+    return -1;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return -1;
+
+  struct mx_ops *ops = ci->child_ops;
+  if (!ops)
+    return -1;
+
+  /* Delegate */
+  return ops->open_msg (ctx, msg, msgno);
+}
+
+/**
+ * close_message - Delegated to mbox handler
+ */
+static int
+close_message (CONTEXT *ctx, MESSAGE *msg)
+{
+  if (!ctx)
+    return -1;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return -1;
+
+  struct mx_ops *ops = ci->child_ops;
+  if (!ops)
+    return -1;
+
+  /* Delegate */
+  return ops->close_msg (ctx, msg);
+}
+
+/**
+ * commit_message - Delegated to mbox handler
+ */
+static int
+commit_message (CONTEXT *ctx, MESSAGE *msg)
+{
+  if (!ctx)
+    return -1;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return -1;
+
+  struct mx_ops *ops = ci->child_ops;
+  if (!ops)
+    return -1;
+
+  /* Delegate */
+  return ops->commit_msg (ctx, msg);
+}
+
+/**
+ * open_new_message - Delegated to mbox handler
+ */
+static int
+open_new_message (MESSAGE *msg, CONTEXT *ctx, HEADER *hdr)
+{
+  if (!ctx)
+    return -1;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return -1;
+
+  struct mx_ops *ops = ci->child_ops;
+  if (!ops)
+    return -1;
+
+  /* Delegate */
+  return ops->open_new_msg (msg, ctx, hdr);
+}
+
+
+/**
+ * comp_can_append - Can we append to this path?
+ * @path: pathname of file to be tested
+ *
+ * To append to a file we can either use an 'append-hook' or a combination of
+ * 'open-hook' and 'close-hook'.
+ *
+ * A match means it's our responsibility to append to the file.
+ *
+ * Returns:
+ *      1: Yes, we can append to the file
+ *      0: No, appending isn't possible
+ */
+int
+comp_can_append (CONTEXT *ctx)
+{
+  if (!ctx)
+    return 0;
+
+  /* If this succeeds, we know there's an open-hook */
+  COMPRESS_INFO *ci = set_compress_info (ctx);
+  if (!ci)
+    return 0;
+
+  /* We have an open-hook, so to append we need an append-hook,
+   * or a close-hook. */
+  if (ci->append || ci->close)
+    return 1;
+
+  mutt_error (_("Cannot append without an append-hook or close-hook : %s"), ctx->path);
+  return 0;
+}
+
+/**
+ * comp_can_read - Can we read from this file?
+ * @path: Pathname of file to be tested
+ *
+ * Search for an 'open-hook' with a regex that matches the path.
+ *
+ * A match means it's our responsibility to open the file.
+ *
+ * Returns:
+ *      1: Yes, we can read the file
+ *      0: No, we cannot read the file
+ */
+int
+comp_can_read (const char *path)
+{
+  if (!path)
+    return 0;
+
+  if (find_hook (MUTT_OPENHOOK, path))
+    return 1;
+  else
+    return 0;
+}
+
+/**
+ * comp_sync - Save changes to the compressed mailbox file
+ * @ctx: Mailbox to sync
+ *
+ * Changes in Mutt only affect the tmp file.  Calling comp_sync() will commit
+ * them to the compressed file.
+ *
+ * Returns:
+ *       0: Success
+ *      -1: Failure
+ */
+int
+comp_sync (CONTEXT *ctx)
+{
+  if (!ctx)
+    return -1;
+
+  COMPRESS_INFO *ci = ctx->compress_info;
+  if (!ci)
+    return -1;
+
+  if (!ci->close)
+  {
+    mutt_error (_("Can't sync a compressed file without a close-hook"));
+    return -1;
+  }
+
+  int rc = execute_command (ctx, ci->close, 1, _("Compressing %s"));
+  if (rc == 0)
+    return -1;
+
+  store_size (ctx);
+
+  return 0;
+}
+
+/**
+ * comp_valid_command - Is this command string allowed?
+ * @cmd:  Command string
+ *
+ * A valid command string must have both "%f" (from file) and "%t" (to file).
+ * We don't check if we can actually run the command.
+ *
+ * Returns:
+ *      1: Valid command
+ *      0: "%f" and/or "%t" is missing
+ */
+int
+comp_valid_command (const char *cmd)
+{
+  if (!cmd)
+    return 0;
+
+  return (strstr (cmd, "%f") && strstr (cmd, "%t"));
+}
+
+
+/**
+ * mx_comp_ops - Mailbox callback functions
+ *
+ * Compress only uses open, close and check.
+ * The message functions are delegated to mbox.
+ */
+struct mx_ops mx_comp_ops =
+{
+  .open         = open_mailbox,
+  .open_append  = open_append_mailbox,
+  .close        = close_mailbox,
+  .check        = check_mailbox,
+  .open_msg     = open_message,
+  .close_msg    = close_message,
+  .commit_msg   = commit_message,
+  .open_new_msg = open_new_message
+};
+
diff --git c/compress.h w/compress.h
new file mode 100644
index 0000000..26beae6
--- /dev/null
+++ w/compress.h
@@ -0,0 +1,29 @@
+/* Copyright (C) 1997 Alain Penders <Alain@Finale-Dev.com>
+ * Copyright (C) 2016 Richard Russon <rich@flatcap.org>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef _COMPRESS_H_
+#define _COMPRESS_H_
+
+int comp_can_append    (CONTEXT *ctx);
+int comp_can_read      (const char *path);
+int comp_sync          (CONTEXT *ctx);
+int comp_valid_command (const char *cmd);
+
+extern struct mx_ops mx_comp_ops;
+
+#endif /* _COMPRESS_H_ */
diff --git c/configure.ac w/configure.ac
index 75517f6..473fed7 100644
--- c/configure.ac
+++ w/configure.ac
@@ -3,15 +3,15 @@ dnl Process this file with autoconf to produce a configure script.
 dnl !!! WHEN ADDING NEW CONFIGURE TESTS, PLEASE ADD CODE TO MAIN.C !!!
 dnl !!! TO DUMP THEIR RESULTS WHEN MUTT -V IS CALLED            !!!
 
-AC_INIT([mutt],[m4_esyscmd(tr -d \\n <VERSION)])
+CFLAGS=$CFLAGS
+LDFLAGS=$LDFLAGS
+
+AC_INIT([NeoMutt], [20161003], [neomutt-devel@neomutt.org], [mutt], [http://www.neomutt.org])
 AC_CONFIG_SRCDIR(mutt.h)
 AM_INIT_AUTOMAKE
 AC_CONFIG_HEADERS([config.h])
 
-AC_SUBST([CONFIG_STATUS_DEPENDENCIES], ['$(top_srcdir)/VERSION'])
-
-MUTT_VERSION=`env sh "$srcdir/version.sh"`
-AC_DEFINE_UNQUOTED(MUTT_VERSION,"$MUTT_VERSION", [Full textual version string.])
+AC_DEFINE(MUTT_VERSION, "1.7.0", [Version of upstream Mutt])
 
 AC_USE_SYSTEM_EXTENSIONS
 
@@ -29,6 +29,14 @@ AC_MSG_RESULT($mutt_cv_prefix)
 
 AC_PROG_CC
 AC_PROG_CC_C99
+if test "$ac_cv_prog_cc_c99" = "no"; then
+  AC_ERROR([Compiler does not support C99. Aborting.])
+fi
+
+if test "$CC" = "gcc"; then
+  CFLAGS="$CFLAGS -fno-delete-null-pointer-checks"
+fi
+
 AC_SEARCH_LIBS([strerror],[cposix])
 if test "x$U" != "x"; then
   AC_MSG_ERROR(Compiler not ANSI compliant)
@@ -121,20 +129,16 @@ AC_DEFINE_UNQUOTED(SENDMAIL,"$ac_cv_path_SENDMAIL", [Where to find sendmail on y
 OPS='$(srcdir)/OPS'
 
 AC_MSG_CHECKING([whether to build with GPGME support])
-AC_ARG_ENABLE(gpgme, AS_HELP_STRING([--enable-gpgme],[Enable GPGME support]),
-[       if test x$enableval = xyes; then
-		enable_gpgme=yes
-	fi
-])
+AC_ARG_ENABLE(gpgme, AS_HELP_STRING([--enable-gpgme],[Enable GPGME support]), enable_gpgme=$enableval, enable_gpgme=no)
 
-if test x"$enable_gpgme" = xyes; then
-   AC_MSG_RESULT(yes)
+AS_IF([test x$enable_gpgme = "xyes"], [
+   AC_MSG_RESULT([yes])
    AM_PATH_GPGME(1.0.0, AC_DEFINE(CRYPT_BACKEND_GPGME, 1,
 		 [Defined, if GPGME support is enabled]),
 		 [gpgme_found=no])
-   if test x"$gpgme_found" = xno; then
+   AS_IF([test x$gpgme_found = "xno"], [
       AC_MSG_ERROR([*** GPGME not found ***])
-   else
+   ], [
       AM_PATH_GPGME(1.1.1, AC_DEFINE(HAVE_GPGME_PKA_TRUST, 1,
 				  [Define if GPGME supports PKA]))
       #needed to get GPGME_LIBS and al correctly
@@ -146,43 +150,67 @@ if test x"$enable_gpgme" = xyes; then
       AC_CHECK_FUNCS([gpgme_op_export_keys])
       LIBS="$saved_LIBS"
       MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS crypt-gpgme.o crypt-mod-pgp-gpgme.o crypt-mod-smime-gpgme.o"
-   fi
-else
+   ])
+], [
    AC_MSG_RESULT([no])
-fi
+])
 
-AC_ARG_ENABLE(pgp, AS_HELP_STRING([--disable-pgp],[Disable PGP support]),
-[       if test x$enableval = xno ; then
-                have_pgp=no
-        fi
+AC_ARG_ENABLE(pgp, AS_HELP_STRING([--disable-pgp],[Disable PGP support]), enable_pgp=$enableval, enable_pgp=yes)
+AS_IF([test x$enable_pgp != "xno"], [
+	   AC_DEFINE(CRYPT_BACKEND_CLASSIC_PGP, 1, [Define if you want classic PGP Support.])
+	   PGPAUX_TARGET="pgpring\$(EXEEXT) pgpewrap\$(EXEEXT)"
+	   MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS pgp.o pgpinvoke.o pgpkey.o pgplib.o gnupgparse.o pgpmicalg.o pgppacket.o crypt-mod-pgp-classic.o"
 ])
 
-if test x$have_pgp != xno ; then
-        AC_DEFINE(CRYPT_BACKEND_CLASSIC_PGP,1, [Define if you want classic PGP support.])
-        PGPAUX_TARGET="pgpring\$(EXEEXT) pgpewrap\$(EXEEXT)"
-        MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS pgp.o pgpinvoke.o pgpkey.o pgplib.o gnupgparse.o pgpmicalg.o pgppacket.o crypt-mod-pgp-classic.o"
-fi
+AC_ARG_ENABLE(smime, AS_HELP_STRING([--disable-smime],[Disable SMIME support]), enable_smime=$enableval, enable_smime=yes)
+AS_IF([test x$enable_smime != "xno"], [
+       AC_DEFINE(CRYPT_BACKEND_CLASSIC_SMIME, 1, [Define if you want classic S/MIME support.])
+       MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS smime.o crypt-mod-smime-classic.o"
+       SMIMEAUX_TARGET="smime_keys"
+])
 
-AC_ARG_ENABLE(smime, AS_HELP_STRING([--disable-smime],[Disable SMIME support]),
-[	if test x$enableval = xno ; then
-		have_smime=no
-	fi
+AC_ARG_ENABLE(sidebar, AC_HELP_STRING([--enable-sidebar], [Enable Sidebar support]), enable_sidebar=$enableval, enable_sidebar=no)
+AS_IF([test x$enable_sidebar = "xyes"], [
+	   AC_DEFINE(USE_SIDEBAR, 1, [Define if you want support for the sidebar.])
+	   OPS="$OPS \$(srcdir)/OPS.SIDEBAR"
+	   MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS sidebar.o"
 ])
- 
-if test x$have_smime != xno ; then
-	AC_DEFINE(CRYPT_BACKEND_CLASSIC_SMIME, 1, [Define if you want classic S/MIME support.])
-	MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS smime.o crypt-mod-smime-classic.o"
-	SMIMEAUX_TARGET="smime_keys"
-fi
 
-AC_ARG_ENABLE(sidebar, AC_HELP_STRING([--enable-sidebar], [Enable Sidebar support]),
-[       if test x$enableval = xyes ; then
-		AC_DEFINE(USE_SIDEBAR, 1, [Define if you want support for the sidebar.])
-		OPS="$OPS \$(srcdir)/OPS.SIDEBAR"
-                MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS sidebar.o"
-        fi
+AC_ARG_ENABLE(compressed, AC_HELP_STRING([--enable-compressed], [Enable compressed folders support]),
+              enable_compressed=$enableval, enable_compressed=no
+)
+AS_IF([test x$enable_compressed = "xyes"], [
+	   AC_DEFINE(USE_COMPRESSED, 1, [Define to enable compressed folders support.])
+	   MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS compress.o"
+])
+AM_CONDITIONAL(BUILD_COMPRESS, test x$enable_compressed = xyes)
+
+dnl Clean up this code. Maybe also use pkg_config
+AC_ARG_ENABLE(notmuch, AC_HELP_STRING([--enable-notmuch], [Enable NOTMUCH support]), enable_notmuch=$enableval, enable_notmuch=no)
+AS_IF([test x$enable_notmuch = "xyes"], [
+		AC_CHECK_LIB(notmuch, notmuch_database_open,,
+			AC_MSG_ERROR([Unable to find Notmuch library]))
+		AC_DEFINE(USE_NOTMUCH,1,[ Define if you want support for the notmuch. ])
+		NOTMUCH_LIBS="-lnotmuch"
+		OPS="$OPS \$(srcdir)/OPS.NOTMUCH"
+		need_notmuch="yes"
+
+		AC_MSG_CHECKING([for notmuch api version 3])
+		AC_COMPILE_IFELSE( [AC_LANG_PROGRAM(
+					[[#include <notmuch.h>]],
+					[[notmuch_database_open("/path", NOTMUCH_DATABASE_MODE_READ_ONLY, (notmuch_database_t**)NULL);]]
+					)],
+		[notmuch_api_3=yes
+			AC_DEFINE([NOTMUCH_API_3], 1, [Define to 1 if you have the notmuch api version 3.])
+			],
+		[notmuch_api_3=no]
+		)
+		AC_MSG_RESULT([$notmuch_api_3])
 ])
+AM_CONDITIONAL(BUILD_NOTMUCH, test x$need_notmuch = xyes)
+
 
+dnl TODO: Clean this up. Needs some work understanding and fixing the AC_ARG_WITH
 AC_ARG_WITH(mixmaster, AS_HELP_STRING([--with-mixmaster@<:@=PATH@:>@],[Include Mixmaster support]),
   [if test "$withval" != no
    then
@@ -319,10 +347,11 @@ main ()
 AC_HEADER_STDC
 
 AC_CHECK_HEADERS(stdarg.h sys/ioctl.h ioctl.h sysexits.h)
-AC_CHECK_HEADERS(sys/time.h sys/resource.h)
+AC_CHECK_HEADERS(sys/time.h sys/resource.h sys/syscall.h)
 AC_CHECK_HEADERS(unix.h)
 
 AC_CHECK_FUNCS(setrlimit getsid)
+AC_CHECK_FUNCS(fgets_unlocked fgetc_unlocked)
 
 AC_MSG_CHECKING(for sig_atomic_t in signal.h)
 AC_EGREP_HEADER(sig_atomic_t,signal.h,
@@ -364,7 +393,7 @@ AC_CHECK_TYPE(ssize_t, int)
 
 AC_CHECK_FUNCS(fgetpos memmove setegid srand48 strerror)
 
-AC_REPLACE_FUNCS([setenv strcasecmp strdup strsep strtok_r wcscasecmp])
+AC_REPLACE_FUNCS([setenv strcasecmp strdup strndup strnlen strsep strtok_r wcscasecmp])
 AC_REPLACE_FUNCS([strcasestr mkdtemp])
 
 AC_CHECK_FUNC(getopt)
@@ -588,6 +617,12 @@ need_socket="no"
 
 dnl -- socket dependencies --
 
+dnl getaddrinfo is used by getdomain.c, and requires libnsl and
+dnl libsocket on some platforms
+AC_CHECK_FUNC(gethostent, , AC_CHECK_LIB(nsl, gethostent))
+AC_CHECK_FUNC(setsockopt, , AC_CHECK_LIB(socket, setsockopt))
+AC_CHECK_FUNCS(getaddrinfo)
+
 AC_ARG_ENABLE(pop,  AS_HELP_STRING([--enable-pop],[Enable POP3 support]),
 [       if test x$enableval = xyes ; then
                 AC_DEFINE(USE_POP,1,[ Define if you want support for the POP3 protocol. ])
@@ -610,6 +645,15 @@ AC_ARG_ENABLE(imap, AS_HELP_STRING([--enable-imap],[Enable IMAP support]),
 ])
 AM_CONDITIONAL(BUILD_IMAP, test x$need_imap = xyes)
 
+AC_ARG_ENABLE(nntp, AC_HELP_STRING([--enable-nntp],[Enable NNTP support]),
+[	if test x$enableval = xyes ; then
+		AC_DEFINE(USE_NNTP,1,[ Define if you want support for the NNTP protocol. ])
+		MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS nntp.o newsrc.o"
+		need_nntp="yes"
+		need_socket="yes"
+	fi
+])
+
 AC_ARG_ENABLE(smtp, AS_HELP_STRING([--enable-smtp],[include internal SMTP relay support]),
 	[if test $enableval = yes; then
 		AC_DEFINE(USE_SMTP, 1, [Include internal SMTP relay support])
@@ -617,7 +661,7 @@ AC_ARG_ENABLE(smtp, AS_HELP_STRING([--enable-smtp],[include internal SMTP relay
 		need_socket="yes"
 	fi])
 
-if test x"$need_imap" = xyes -o x"$need_pop" = xyes ; then
+if test x"$need_imap" = xyes -o x"$need_pop" = xyes -o x"$need_nntp" = xyes ; then
   MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS bcache.o"
 fi
 
@@ -631,9 +675,6 @@ then
                 AC_MSG_RESULT([no])
                 AC_DEFINE(socklen_t,int,
                         [ Define to 'int' if <sys/socket.h> doesn't have it. ]))
-        AC_CHECK_FUNC(gethostent, , AC_CHECK_LIB(nsl, gethostent))
-        AC_CHECK_FUNC(setsockopt, , AC_CHECK_LIB(socket, setsockopt))
-        AC_CHECK_FUNCS(getaddrinfo)
         AC_DEFINE(USE_SOCKET,1,
                 [ Include code for socket support. Set automatically if you enable POP3 or IMAP ])
         MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS account.o mutt_socket.o mutt_tunnel.o"
@@ -686,13 +727,16 @@ AC_ARG_WITH(ssl, AS_HELP_STRING([--with-ssl@<:@=PFX@:>@],[Enable TLS support usi
 
             crypto_libs=""
             AC_CHECK_LIB(z, deflate, [crypto_libs=-lz])
-            AC_CHECK_LIB(crypto, X509_new,
-              [crypto_libs="-lcrypto $crypto_libs"],, [$crypto_libs])
+            AC_CHECK_LIB(crypto, X509_STORE_CTX_new,
+              [crypto_libs="-lcrypto $crypto_libs"],
+              AC_MSG_ERROR([Unable to find SSL library]), [$crypto_libs])
             AC_CHECK_LIB(ssl, SSL_new,,
               AC_MSG_ERROR([Unable to find SSL library]), [$crypto_libs])
 
             LIBS="$LIBS $crypto_libs"
             AC_CHECK_FUNCS(RAND_status RAND_egd)
+            AC_CHECK_DECLS([SSL_set_mode, SSL_MODE_AUTO_RETRY],,
+              AC_MSG_ERROR([Unable to find decent SSL header]), [[#include <openssl/ssl.h>]])
 
             AC_DEFINE(USE_SSL,1,[ Define if you want support for SSL. ])
             AC_DEFINE(USE_SSL_OPENSSL,1,[ Define if you want support for SSL via OpenSSL. ])
@@ -860,11 +904,14 @@ AC_ARG_ENABLE(exact-address, AS_HELP_STRING([--enable-exact-address],[Enable reg
 dnl -- start cache --
 db_found=no
 db_requested=auto
+hcache_db_used=no
 AC_ARG_ENABLE(hcache, AS_HELP_STRING([--enable-hcache],[Enable header caching]))
 AC_ARG_WITH(tokyocabinet, AS_HELP_STRING([--without-tokyocabinet],[Don't use tokyocabinet even if it is available]))
+AC_ARG_WITH(kyotocabinet, AS_HELP_STRING([--without-kyotocabinet],[Don't use kyotocabinet even if it is available]))
 AC_ARG_WITH(qdbm, AS_HELP_STRING([--without-qdbm],[Don't use qdbm even if it is available]))
 AC_ARG_WITH(gdbm, AS_HELP_STRING([--without-gdbm],[Don't use gdbm even if it is available]))
 AC_ARG_WITH(bdb, AS_HELP_STRING([--with-bdb@<:@=DIR@:>@],[Use BerkeleyDB4 if gdbm is not available]))
+AC_ARG_WITH(lmdb, AS_HELP_STRING([--with-lmdb@<:@=DIR@:>@],[Use LMDB if gdbm is not available]))
 
 db_found=no
 if test x$enable_hcache = xyes
@@ -880,7 +927,16 @@ then
 
     if test -n "$with_tokyocabinet" && test "$with_tokyocabinet" != "no"
     then
-      db_requested=tc
+      db_requested=TokyoCabinet
+    fi
+    if test -n "$with_kyotocabinet" && test "$with_kyotocabinet" != "no"
+    then
+      if test "$db_requested" != "auto"
+      then
+        AC_MSG_ERROR([more than one header cache engine requested.])
+      else
+        db_requested=KyotoCabinet
+      fi
     fi
     if test -n "$with_qdbm" && test "$with_qdbm" != "no"
     then
@@ -888,7 +944,7 @@ then
       then
         AC_MSG_ERROR([more than one header cache engine requested.])
       else
-        db_requested=qdbm
+        db_requested=QDBM
       fi
     fi
     if test -n "$with_gdbm" && test "$with_gdbm" != "no"
@@ -897,7 +953,7 @@ then
       then
         AC_MSG_ERROR([more than one header cache engine requested.])
       else
-        db_requested=gdbm
+        db_requested=GDBM
       fi
     fi
     if test -n "$with_bdb" && test "$with_bdb" != "no"
@@ -906,13 +962,22 @@ then
       then
         AC_MSG_ERROR([more than one header cache engine requested.])
       else
-        db_requested=bdb
+        db_requested=BDB
+      fi
+    fi
+    if test -n "$with_lmdb" && test "$with_lmdb" != "no"
+    then
+      if test "$db_requested" != "auto"
+      then
+        AC_MSG_ERROR([more than one header cache engine requested.])
+      else
+        db_requested=LMDB
       fi
     fi
     
     dnl -- Tokyo Cabinet --
     if test "$with_tokyocabinet" != "no" \
-	    && test "$db_requested" = auto -o "$db_requested" = tc
+	    && test "$db_requested" = auto -o "$db_requested" = TokyoCabinet
     then
       if test -n "$with_tokyocabinet" && test "$with_tokyocabinet" != "yes"
       then
@@ -924,7 +989,7 @@ then
       AC_CHECK_LIB(tokyocabinet, tcbdbopen,
         [MUTTLIBS="$MUTTLIBS -ltokyocabinet"
          AC_DEFINE(HAVE_TC, 1, [Tokyo Cabinet Support])
-         db_found=tc],
+         db_found=TokyoCabinet],
         [CPPFLAGS="$OLDCPPFLAGS"
          LDFLAGS="$OLDLDFLAGS"]))
       if test "$db_requested" != auto && test "$db_found" != "$db_requested"
@@ -933,9 +998,32 @@ then
       fi
     fi
 
+    dnl -- Kyoto Cabinet --
+    if test "$with_kyotocabinet" != "no" \
+        && test "$db_requested" = auto -o "$db_requested" = KyotoCabinet
+    then
+      if test -n "$with_kyotocabinet" && test "$with_kyotocabinet" != "yes"
+      then
+        CPPFLAGS="$CPPFLAGS -I$with_kyotocabinet/include"
+        LDFLAGS="$LDFLAGS -L$with_kyotocabinet/lib"
+      fi
+
+      AC_CHECK_HEADER(kclangc.h,
+      AC_CHECK_LIB(kyotocabinet, kcdbopen,
+        [MUTTLIBS="$MUTTLIBS -lkyotocabinet"
+         AC_DEFINE(HAVE_KC, 1, [Kyoto Cabinet Support])
+         db_found=KyotoCabinet],
+        [CPPFLAGS="$OLDCPPFLAGS"
+         LDFLAGS="$OLDLDFLAGS"]))
+      if test "$db_requested" != auto && test "$db_found" != "$db_requested"
+      then
+        AC_MSG_ERROR([Kyoto Cabinet could not be used. Check config.log for details.])
+      fi
+    fi
+
     dnl -- QDBM --
     if test "$with_qdbm" != "no" && test $db_found = no \
-	    && test "$db_requested" = auto -o "$db_requested" = qdbm
+	    && test "$db_requested" = auto -o "$db_requested" = QDBM
     then
       if test -n "$with_qdbm" && test "$with_qdbm" != "yes"
       then
@@ -956,7 +1044,7 @@ then
       AC_CHECK_LIB(qdbm, vlopen,
         [MUTTLIBS="$MUTTLIBS -lqdbm"
          AC_DEFINE(HAVE_QDBM, 1, [QDBM Support])
-         db_found=qdbm],
+         db_found=QDBM],
         [CPPFLAGS="$OLDCPPFLAGS"
          LDFLAGS="$OLDLDFLAGS"])
       LIBS="$saved_LIBS"
@@ -968,7 +1056,7 @@ then
 
     dnl -- GDBM --
     if test x$with_gdbm != xno && test $db_found = no \
-	    && test "$db_requested" = auto -o "$db_requested" = gdbm
+	    && test "$db_requested" = auto -o "$db_requested" = GDBM
     then
         if test "$with_gdbm" != "yes"
         then
@@ -986,7 +1074,7 @@ then
         then
           AC_DEFINE(HAVE_GDBM, 1, [GDBM Support])
           MUTTLIBS="$MUTTLIBS -lgdbm"
-          db_found=gdbm
+          db_found=GDBM
         fi
         if test "$db_requested" != auto && test "$db_found" != "$db_requested"
         then
@@ -996,7 +1084,8 @@ then
 
     dnl -- BDB --
     ac_bdb_prefix="$with_bdb"
-    if test x$ac_bdb_prefix != xno && test $db_found = no
+    if test x$with_bdb != xno && test $db_found = no \
+	    && test "$db_requested" = auto -o "$db_requested" = BDB
     then
         if test x$ac_bdb_prefix = xyes || test x$ac_bdb_prefix = x
         then
@@ -1046,17 +1135,46 @@ then
             CPPFLAGS="$OLDCPPFLAGS -I$BDB_INCLUDE_DIR"
             LIBS="$OLDLIBS -L$BDB_LIB_DIR -l$BDB_LIB"
             AC_DEFINE(HAVE_DB4, 1, [Berkeley DB4 Support])
-            db_found=bdb
+            db_found=BDB
         else
             AC_MSG_RESULT(no)
         fi
     fi
 
+    dnl -- LMDB --
+    if test x$with_lmdb != xno && test $db_found = no \
+	    && test "$db_requested" = auto -o "$db_requested" = LMDB
+    then
+        if test "$with_lmdb" != "yes"
+        then
+          CPPFLAGS="$CPPFLAGS -I$with_lmdb/include"
+          LDFLAGS="$LDFLAGS -L$with_lmdb/lib"
+        fi
+        saved_LIBS="$LIBS"
+        LIBS="$LIBS -llmdb"
+        AC_CACHE_CHECK(for mdb_env_create, ac_cv_mdbenvcreate,[
+            ac_cv_mdbenvcreate=no
+            AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <lmdb.h>]], [[mdb_env_create(0);]])],[ac_cv_mdbenvcreate=yes],[])
+        ])
+        LIBS="$saved_LIBS"
+        if test "$ac_cv_mdbenvcreate" = yes
+        then
+          AC_DEFINE(HAVE_LMDB, 1, [LMDB Support])
+          MUTTLIBS="$MUTTLIBS -llmdb"
+          db_found=LMDB
+        fi
+        if test "$db_requested" != auto && test "$db_found" != "$db_requested"
+        then
+          AC_MSG_ERROR([LMDB could not be used. Check config.log for details.])
+        fi
+    fi
+
     if test $db_found = no
     then
-        AC_MSG_ERROR([You need Tokyo Cabinet, QDBM, GDBM or Berkeley DB4 for hcache])
+        AC_MSG_ERROR([You need Tokyo Cabinet, Kyoto Cabinet, QDBM, GDBM, Berkeley DB4 or LMDB for hcache])
     fi
 fi
+hcache_db_used=$db_found
 dnl -- end cache --
 
 AM_CONDITIONAL(BUILD_HCACHE, test x$db_found != xno)
@@ -1075,6 +1193,7 @@ AC_SUBST(MUTTLIBS)
 AC_SUBST(MUTT_LIB_OBJECTS)
 AC_SUBST(LIBIMAP)
 AC_SUBST(LIBIMAPDEPS)
+AC_SUBST(NOTMUCH_LIBS)
 
 dnl -- iconv/gettext --
 
@@ -1318,6 +1437,21 @@ if test $mutt_cv_langinfo_yesexpr = yes; then
   AC_DEFINE(HAVE_LANGINFO_YESEXPR,1,[ Define if you have <langinfo.h> and nl_langinfo(YESEXPR). ])
 fi
 
+# Only enable fmemopen if both fmemopen() and open_memstream()
+# AND --enable-fmemopen is given.
+have_fmemopen=yes
+AC_CHECK_FUNCS(fmemopen open_memstream, [], [have_fmemopen=no])
+
+AC_ARG_ENABLE(fmemopen, AS_HELP_STRING([--enable-fmemopen],[Use fmemopen]),
+	[use_fmemopen=$enableval], [use_fmemopen=no]
+)
+
+AS_IF([test $have_fmemopen = "yes" && test $use_fmemopen = "yes"],
+      # Temporarily disable fmemopen, due to a bug
+      [AC_DEFINE(USE_FMEMOPEN, 0, [Use fmemopen])],
+      [use_fmemopen=no]
+)
+
 dnl Documentation tools
 have_openjade="no"
 AC_PATH_PROG([OSPCAT], [ospcat], [none])
@@ -1353,5 +1487,24 @@ fi
 
 AC_CONFIG_FILES(Makefile contrib/Makefile doc/Makefile imap/Makefile
         intl/Makefile m4/Makefile po/Makefile.in
-        hcachever.sh muttbug.sh doc/instdoc.sh)
+        hcachever.sh doc/instdoc.sh)
 AC_OUTPUT
+
+AC_MSG_NOTICE([Summary of build options:
+
+  Version:           ${PACKAGE_VERSION}
+  Host OS:           ${host_os}
+  Install prefix:    ${prefix}
+  Compiler:          ${CC}
+  CFlags:            ${CFLAGS} ${CPPFLAGS}
+  LDFlags:           ${LDFLAGS}
+  Libs:              ${LIBS}
+
+  GPGME:             $enable_gpgme
+  PGP:               $enable_pgp
+  SMIME:             $enable_smime
+  Sidebar:           $enable_sidebar
+  Notmuch:           $enable_notmuch
+  Compressed Folder: $enable_compressed
+  Header Cache:      $hcache_db_used
+])
diff --git c/contrib/Makefile.am w/contrib/Makefile.am
index 4abd2c7..69c2ea8 100644
--- c/contrib/Makefile.am
+++ w/contrib/Makefile.am
@@ -3,29 +3,45 @@
 subdir = contrib
 
 SAMPLES = Mush.rc Pine.rc gpg.rc pgp2.rc pgp5.rc pgp6.rc Tin.rc \
-	sample.muttrc  sample.mailcap sample.muttrc-tlr \
-	colors.default colors.linux smime.rc \
+	sample.mailcap sample.muttrc sample.muttrc-sidebar sample.muttrc-tlr \
+	sample.vimrc-sidebar colors.default colors.linux smime.rc \
 	ca-bundle.crt smime_keys_test.pl mutt_xtitle
 
 EXTRA_DIST = language.txt language50.txt  \
 	patch.slang-1.2.2.keypad.1	\
 	$(SAMPLES) \
 	iconv/README \
-	iconv/make.sh
+	iconv/make.sh \
+	vim-keybindings \
+	keybase
+
+CONTRIB_DIRS = vim-keybindings keybase
 
 install-data-local:
-	$(MKDIR_P) $(DESTDIR)$(docdir)/samples $(DESTDIR)$(docdir)/samples/iconv
+	$(INSTALL) -d -m 755 $(DESTDIR)$(docdir)/samples $(DESTDIR)$(docdir)/samples/iconv
 	for f in $(SAMPLES) ; do \
 		$(INSTALL) -m 644 $(srcdir)/$$f $(DESTDIR)$(docdir)/samples ;	\
 	done
 	for f in $(srcdir)/iconv/*.rc ; do					\
 		$(INSTALL) -m 644 $$f $(DESTDIR)$(docdir)/samples/iconv	  ;	\
 	done
+	for d in $(CONTRIB_DIRS); do						\
+		echo "Installing $$d" ;	\
+		$(INSTALL) -d -m 755 $(DESTDIR)$(docdir)/$$d ;\
+		for f in $(srcdir)/$$d/*; do	\
+			echo "Installing $$f" ;	\
+			$(INSTALL) -m 644 $$f $(DESTDIR)$(docdir)/$$d ; \
+		done \
+	done
+	chmod +x $(DESTDIR)$(docdir)/keybase/*.sh
 
 uninstall-local:
 	for f in $(SAMPLES) ; do \
 		rm -f $(DESTDIR)$(docdir)/samples/$$f ; \
 	done
+	for d in $(CONTRIB_DIRS); do						\
+		rm -fr $(DESTDIR)$(docdir)/$$d;	                		\
+	done
 	-rm -rf $(DESTDIR)$(docdir)/samples/iconv
 	-rmdir $(DESTDIR)$(docdir)/samples
 	-rmdir $(DESTDIR)$(docdir)
diff --git c/contrib/keybase/LICENSE w/contrib/keybase/LICENSE
new file mode 100644
index 0000000..cf1ab25
--- /dev/null
+++ w/contrib/keybase/LICENSE
@@ -0,0 +1,24 @@
+This is free and unencumbered software released into the public domain.
+
+Anyone is free to copy, modify, publish, use, compile, sell, or
+distribute this software, either in source code form or as a compiled
+binary, for any purpose, commercial or non-commercial, and by any
+means.
+
+In jurisdictions that recognize copyright laws, the author or authors
+of this software dedicate any and all copyright interest in the
+software to the public domain. We make this dedication for the benefit
+of the public at large and to the detriment of our heirs and
+successors. We intend this dedication to be an overt act of
+relinquishment in perpetuity of all present and future rights to this
+software under copyright law.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+For more information, please refer to <http://unlicense.org>
diff --git c/contrib/keybase/README.md w/contrib/keybase/README.md
new file mode 100644
index 0000000..9d57ac6
--- /dev/null
+++ w/contrib/keybase/README.md
@@ -0,0 +1,45 @@
+# KeybaseMutt
+
+A work in progress. KeybaseMutt exists to let its users utilize Keybase within mutt. (Unfortunately, not natively (yet).)
+
+## Quick start
+
+Run the install script. It will set up the directory's and paths for you. Do what it says or suffer the consequences!
+
+Then just throw these into your .muttrc
+
+`set editor = 'echo %s > ~/.mutt/keybaseMutt/.tmp; vim %s'`
+
+`macro compose K "<enter-command>unset wait_key<enter><shell-escape>python ~/.mutt/keybaseMutt/keybase.py<enter><enter-command>set wait_key<enter>`
+
+Done!
+
+## How to use KeybaseMutt
+
+Write an email. In the screen right before you send your email (called the pager mode), press "K".
+
+![](pagerMode.png)
+(Press 'K' when you're here)
+
+You can now use four Keybase commands in this "shell". (I thought it best to limit the user to four commands for security reasons. Running unusual commands would overwrite the email, forcing the user to rewrite the email again.)
+
+The commands are:
+- `keybase encrypt [user]`
+- `keybase pgp encrypt [user]`
+- `keybase sign`
+- `keybase pgp sign`
+
+
+## Decrypting and verifying messages
+
+Unfortunately, there isn't an easy way to decrypt or verify messages through a macro. Instead, you'll need to use the pipe feature of mutt.
+
+Opening the email, you'll need to navigate to the actual attachment. (Press "V" when you're reading the email.)
+
+![](attachmentView.png)
+
+Then pipe ("|") it through the one of the scripts. (like "pgpverify.sh" or "decrypt.sh")
+
+Please note, using an attachment is very important when decrypting emails that include html. The scripts are unable to seperate html and text.
+
+Make sure that the attachment is "text/plain" rather than "text/html".
diff --git c/contrib/keybase/attachmentView.png w/contrib/keybase/attachmentView.png
new file mode 100644
index 0000000..5caf908
--- /dev/null
+++ w/contrib/keybase/attachmentView.png
@@ -0,0 +1,957 @@
+Image: /tmp/LCUXoE_attachmentView.png
+  Format: PNG (Portable Network Graphics)
+  Mime type: image/png
+  Class: DirectClass
+  Geometry: 1920x1080+0+0
+  Resolution: 28.35x28.35
+  Print size: 67.7249x38.0952
+  Units: PixelsPerCentimeter
+  Type: TrueColorAlpha
+  Endianess: Undefined
+  Colorspace: sRGB
+  Depth: 8-bit
+  Channel depth:
+    red: 8-bit
+    green: 8-bit
+    blue: 8-bit
+    alpha: 1-bit
+  Channel statistics:
+    Pixels: 2073600
+    Red:
+      min: 0 (0)
+      max: 252 (0.988235)
+      mean: 9.94406 (0.0389963)
+      standard deviation: 43.0652 (0.168883)
+      kurtosis: 21.4793
+      skewness: 4.76177
+      entropy: 0.0967944
+    Green:
+      min: 0 (0)
+      max: 233 (0.913725)
+      mean: 13.8239 (0.0542114)
+      standard deviation: 48.5369 (0.190341)
+      kurtosis: 12.3828
+      skewness: 3.64861
+      entropy: 0.0989181
+    Blue:
+      min: 0 (0)
+      max: 231 (0.905882)
+      mean: 15.7559 (0.0617879)
+      standard deviation: 52.8322 (0.207185)
+      kurtosis: 8.97564
+      skewness: 3.2382
+      entropy: 0.105655
+    Alpha:
+      min: 255 (1)
+      max: 255 (1)
+      mean: 255 (1)
+      standard deviation: 0 (0)
+      kurtosis: 0
+      skewness: 0
+      entropy: 0
+  Image statistics:
+    Overall:
+      min: 0 (0)
+      max: 252 (0.988235)
+      mean: 9.88097 (0.0387489)
+      standard deviation: 41.838 (0.164071)
+      kurtosis: 19.9752
+      skewness: 4.61451
+      entropy: 0.0753419
+  Colors: 852
+  Histogram:
+   1861266: (  0,  0,  0,255) #000000FF black
+         2: (  0,  0,  1,255) #000001FF srgba(0,0,1,1)
+        57: (  0,  1,  1,255) #000101FF srgba(0,1,1,1)
+        12: (  0,  1,  2,255) #000102FF srgba(0,1,2,1)
+         1: (  0,  1,  3,255) #000103FF srgba(0,1,3,1)
+        59: (  0,  2,  2,255) #000202FF srgba(0,2,2,1)
+        20: (  0,  3,  3,255) #000303FF srgba(0,3,3,1)
+        63: (  0,  4,  4,255) #000404FF srgba(0,4,4,1)
+        50: (  0,  5,  5,255) #000505FF srgba(0,5,5,1)
+        26: (  0,  6,  6,255) #000606FF srgba(0,6,6,1)
+        31: (  0,  7,  7,255) #000707FF srgba(0,7,7,1)
+        24: (  0,  8,  8,255) #000808FF srgba(0,8,8,1)
+        12: (  0,  9,  9,255) #000909FF srgba(0,9,9,1)
+        27: (  0, 10, 10,255) #000A0AFF srgba(0,10,10,1)
+        25: (  0, 11, 11,255) #000B0BFF srgba(0,11,11,1)
+        11: (  0, 12, 12,255) #000C0CFF srgba(0,12,12,1)
+         9: (  0, 13, 13,255) #000D0DFF srgba(0,13,13,1)
+         3: (  0,129,131,255) #008183FF srgba(0,129,131,1)
+         1: (  0,136,138,255) #00888AFF srgba(0,136,138,1)
+         3: (  0,137,139,255) #00898BFF srgba(0,137,139,1)
+         1: (  0,143,145,255) #008F91FF srgba(0,143,145,1)
+         4: (  0,145,147,255) #009193FF srgba(0,145,147,1)
+         1: (  1,  0,  2,255) #010002FF srgba(1,0,2,1)
+         1: (  1,  1,  0,255) #010100FF srgba(1,1,0,1)
+        98: (  1,  1,  1,255) #010101FF srgba(1,1,1,1)
+       238: (  1,  1,  2,255) #010102FF srgba(1,1,2,1)
+         5: (  1,  1,  3,255) #010103FF srgba(1,1,3,1)
+         1: (  1,  2,  1,255) #010201FF srgba(1,2,1,1)
+       222: (  1,  2,  2,255) #010202FF srgba(1,2,2,1)
+       101: (  1,  2,  3,255) #010203FF srgba(1,2,3,1)
+         9: (  1,  2,  4,255) #010204FF srgba(1,2,4,1)
+         2: (  1,  3,  3,255) #010303FF srgba(1,3,3,1)
+         4: (  1,  3,  4,255) #010304FF srgba(1,3,4,1)
+         1: (  1,  3,  5,255) #010305FF srgba(1,3,5,1)
+         4: (  1, 13, 13,255) #010D0DFF srgba(1,13,13,1)
+        15: (  1, 14, 14,255) #010E0EFF srgba(1,14,14,1)
+         7: (  1, 15, 15,255) #010F0FFF srgba(1,15,15,1)
+        11: (  1, 15, 16,255) #010F10FF srgba(1,15,16,1)
+        12: (  1, 16, 16,255) #011010FF srgba(1,16,16,1)
+         3: (  1, 17, 17,255) #011111FF srgba(1,17,17,1)
+         5: (  1, 17, 18,255) #011112FF srgba(1,17,18,1)
+         6: (  1, 18, 18,255) #011212FF srgba(1,18,18,1)
+         2: (  1, 18, 19,255) #011213FF srgba(1,18,19,1)
+        14: (  1, 19, 19,255) #011313FF srgba(1,19,19,1)
+         4: (  1, 20, 20,255) #011414FF srgba(1,20,20,1)
+        10: (  1, 20, 21,255) #011415FF srgba(1,20,21,1)
+        34: (  1, 21, 21,255) #011515FF srgba(1,21,21,1)
+         7: (  1, 21, 22,255) #011516FF srgba(1,21,22,1)
+        10: (  1, 22, 22,255) #011616FF srgba(1,22,22,1)
+         7: (  1, 23, 23,255) #011717FF srgba(1,23,23,1)
+        37: (  1, 23, 24,255) #011718FF srgba(1,23,24,1)
+         6: (  1, 24, 24,255) #011818FF srgba(1,24,24,1)
+        12: (  1, 24, 25,255) #011819FF srgba(1,24,25,1)
+         6: (  1, 25, 25,255) #011919FF srgba(1,25,25,1)
+        15: (  1, 26, 26,255) #011A1AFF srgba(1,26,26,1)
+         8: (  1, 26, 27,255) #011A1BFF srgba(1,26,27,1)
+        19: (  1, 27, 27,255) #011B1BFF srgba(1,27,27,1)
+         8: (  1, 27, 28,255) #011B1CFF srgba(1,27,28,1)
+         7: (  1, 28, 28,255) #011C1CFF srgba(1,28,28,1)
+         7: (  1, 29, 29,255) #011D1DFF srgba(1,29,29,1)
+         3: (  1, 29, 30,255) #011D1EFF srgba(1,29,30,1)
+         6: (  1, 30, 30,255) #011E1EFF srgba(1,30,30,1)
+        13: (  1, 30, 31,255) #011E1FFF srgba(1,30,31,1)
+         6: (  1, 31, 31,255) #011F1FFF srgba(1,31,31,1)
+         9: (  1, 32, 32,255) #012020FF srgba(1,32,32,1)
+        15: (  1, 32, 33,255) #012021FF srgba(1,32,33,1)
+        57: (  1, 33, 33,255) #012121FF srgba(1,33,33,1)
+         9: (  1, 33, 34,255) #012122FF srgba(1,33,34,1)
+         2: (  1, 34, 34,255) #012222FF srgba(1,34,34,1)
+         4: (  1, 35, 35,255) #012323FF srgba(1,35,35,1)
+        22: (  1, 35, 36,255) #012324FF srgba(1,35,36,1)
+         9: (  1, 36, 36,255) #012424FF srgba(1,36,36,1)
+        21: (  1, 36, 37,255) #012425FF srgba(1,36,37,1)
+         2: (  1, 37, 37,255) #012525FF srgba(1,37,37,1)
+        41: (  1, 38, 38,255) #012626FF srgba(1,38,38,1)
+         1: (  2,  1,  2,255) #020102FF srgba(2,1,2,1)
+         1: (  2,  2,  1,255) #020201FF srgba(2,2,1,1)
+       193: (  2,  2,  2,255) #020202FF srgba(2,2,2,1)
+       434: (  2,  2,  3,255) #020203FF srgba(2,2,3,1)
+        75: (  2,  2,  4,255) #020204FF srgba(2,2,4,1)
+       278: (  2,  3,  3,255) #020303FF srgba(2,3,3,1)
+      1301: (  2,  3,  4,255) #020304FF srgba(2,3,4,1)
+       205: (  2,  3,  5,255) #020305FF srgba(2,3,5,1)
+        17: (  2,  4,  4,255) #020404FF srgba(2,4,4,1)
+        98: (  2,  4,  5,255) #020405FF srgba(2,4,5,1)
+        12: (  2,  4,  6,255) #020406FF srgba(2,4,6,1)
+         1: (  2,  4,  7,255) #020407FF srgba(2,4,7,1)
+         1: (  2,  4,  8,255) #020408FF srgba(2,4,8,1)
+         1: (  2,  4, 11,255) #02040BFF srgba(2,4,11,1)
+         6: (  2,  5,  8,255) #020508FF srgba(2,5,8,1)
+         1: (  2,  5, 12,255) #02050CFF srgba(2,5,12,1)
+         2: (  2,  6,  9,255) #020609FF srgba(2,6,9,1)
+         1: (  2,  7, 12,255) #02070CFF srgba(2,7,12,1)
+         1: (  2, 15, 14,255) #020F0EFF srgba(2,15,14,1)
+         7: (  2, 39, 39,255) #022727FF srgba(2,39,39,1)
+         8: (  2, 39, 40,255) #022728FF srgba(2,39,40,1)
+        31: (  2, 40, 40,255) #022828FF srgba(2,40,40,1)
+         6: (  2, 41, 41,255) #022929FF srgba(2,41,41,1)
+         2: (  2, 41, 42,255) #02292AFF srgba(2,41,42,1)
+         1: (  2, 42, 42,255) #022A2AFF srgba(2,42,42,1)
+        16: (  2, 42, 43,255) #022A2BFF srgba(2,42,43,1)
+         6: (  2, 43, 43,255) #022B2BFF srgba(2,43,43,1)
+         9: (  2, 44, 44,255) #022C2CFF srgba(2,44,44,1)
+         7: (  2, 44, 45,255) #022C2DFF srgba(2,44,45,1)
+        74: (  2, 45, 45,255) #022D2DFF srgba(2,45,45,1)
+        15: (  2, 45, 46,255) #022D2EFF srgba(2,45,46,1)
+        13: (  2, 46, 47,255) #022E2FFF srgba(2,46,47,1)
+        13: (  2, 47, 48,255) #022F30FF srgba(2,47,48,1)
+         8: (  2, 48, 48,255) #023030FF srgba(2,48,48,1)
+        10: (  2, 48, 49,255) #023031FF srgba(2,48,49,1)
+        24: (  2, 49, 50,255) #023132FF srgba(2,49,50,1)
+        11: (  2, 50, 51,255) #023233FF srgba(2,50,51,1)
+        12: (  2, 51, 51,255) #023333FF srgba(2,51,51,1)
+         5: (  2, 51, 52,255) #023334FF srgba(2,51,52,1)
+        49: (  2, 52, 53,255) #023435FF srgba(2,52,53,1)
+        10: (  2, 53, 54,255) #023536FF srgba(2,53,54,1)
+         4: (  2, 54, 54,255) #023636FF srgba(2,54,54,1)
+        30: (  2, 54, 55,255) #023637FF srgba(2,54,55,1)
+         5: (  2, 55, 56,255) #023738FF srgba(2,55,56,1)
+         3: (  2, 56, 57,255) #023839FF srgba(2,56,57,1)
+        18: (  2, 57, 57,255) #023939FF srgba(2,57,57,1)
+        17: (  2, 57, 58,255) #02393AFF srgba(2,57,58,1)
+        26: (  2, 58, 59,255) #023A3BFF srgba(2,58,59,1)
+        70: (  2, 59, 60,255) #023B3CFF srgba(2,59,60,1)
+         6: (  2, 60, 61,255) #023C3DFF srgba(2,60,61,1)
+        42: (  2, 61, 62,255) #023D3EFF srgba(2,61,62,1)
+         3: (  2, 62, 63,255) #023E3FFF srgba(2,62,63,1)
+         5: (  2, 63, 63,255) #023F3FFF srgba(2,63,63,1)
+         7: (  2, 63, 64,255) #023F40FF srgba(2,63,64,1)
+         1: (  3,  3,  2,255) #030302FF srgba(3,3,2,1)
+        13: (  3,  3,  3,255) #030303FF grey1
+       365: (  3,  3,  4,255) #030304FF srgba(3,3,4,1)
+       152: (  3,  3,  5,255) #030305FF srgba(3,3,5,1)
+        14: (  3,  3,  6,255) #030306FF srgba(3,3,6,1)
+       254: (  3,  4,  4,255) #030404FF srgba(3,4,4,1)
+      2342: (  3,  4,  5,255) #030405FF srgba(3,4,5,1)
+      1371: (  3,  4,  6,255) #030406FF srgba(3,4,6,1)
+        16: (  3,  4,  7,255) #030407FF srgba(3,4,7,1)
+         1: (  3,  4, 10,255) #03040AFF srgba(3,4,10,1)
+        16: (  3,  5,  5,255) #030505FF srgba(3,5,5,1)
+       351: (  3,  5,  6,255) #030506FF srgba(3,5,6,1)
+       104: (  3,  5,  7,255) #030507FF srgba(3,5,7,1)
+         4: (  3,  5,  8,255) #030508FF srgba(3,5,8,1)
+         1: (  3,  5,  9,255) #030509FF srgba(3,5,9,1)
+         1: (  3,  6,  7,255) #030607FF srgba(3,6,7,1)
+         1: (  3,  6,  8,255) #030608FF srgba(3,6,8,1)
+         6: (  3,  6,  9,255) #030609FF srgba(3,6,9,1)
+         2: (  3,  6, 10,255) #03060AFF srgba(3,6,10,1)
+         6: (  3,  7, 11,255) #03070BFF srgba(3,7,11,1)
+         1: (  3,  7, 12,255) #03070CFF srgba(3,7,12,1)
+         1: (  3,  8, 12,255) #03080CFF srgba(3,8,12,1)
+         2: (  3,  8, 13,255) #03080DFF srgba(3,8,13,1)
+         1: (  3,  9, 14,255) #03090EFF srgba(3,9,14,1)
+         3: (  3,  9, 15,255) #03090FFF srgba(3,9,15,1)
+         1: (  3,  9, 16,255) #030910FF srgba(3,9,16,1)
+         1: (  3, 10, 17,255) #030A11FF srgba(3,10,17,1)
+         1: (  3, 11, 18,255) #030B12FF srgba(3,11,18,1)
+         4: (  3, 11, 19,255) #030B13FF srgba(3,11,19,1)
+         2: (  3, 11, 20,255) #030B14FF srgba(3,11,20,1)
+         4: (  3, 12, 20,255) #030C14FF srgba(3,12,20,1)
+         8: (  3, 12, 21,255) #030C15FF srgba(3,12,21,1)
+         1: (  3, 13, 22,255) #030D16FF srgba(3,13,22,1)
+         6: (  3, 13, 23,255) #030D17FF srgba(3,13,23,1)
+         9: (  3, 13, 24,255) #030D18FF srgba(3,13,24,1)
+        11: (  3, 14, 24,255) #030E18FF srgba(3,14,24,1)
+        98: (  3, 64, 65,255) #034041FF srgba(3,64,65,1)
+         3: (  3, 65, 66,255) #034142FF srgba(3,65,66,1)
+         3: (  3, 66, 66,255) #034242FF srgba(3,66,66,1)
+        22: (  3, 66, 67,255) #034243FF srgba(3,66,67,1)
+         6: (  3, 67, 68,255) #034344FF srgba(3,67,68,1)
+         7: (  3, 68, 69,255) #034445FF srgba(3,68,69,1)
+        10: (  3, 69, 69,255) #034545FF srgba(3,69,69,1)
+         3: (  3, 69, 70,255) #034546FF srgba(3,69,70,1)
+        12: (  3, 70, 71,255) #034647FF srgba(3,70,71,1)
+         7: (  3, 71, 72,255) #034748FF srgba(3,71,72,1)
+         8: (  3, 72, 72,255) #034848FF srgba(3,72,72,1)
+         5: (  3, 72, 73,255) #034849FF srgba(3,72,73,1)
+        19: (  3, 73, 74,255) #03494AFF srgba(3,73,74,1)
+         2: (  3, 74, 75,255) #034A4BFF srgba(3,74,75,1)
+         5: (  3, 75, 75,255) #034B4BFF srgba(3,75,75,1)
+         2: (  3, 75, 76,255) #034B4CFF srgba(3,75,76,1)
+        57: (  3, 76, 77,255) #034C4DFF srgba(3,76,77,1)
+         6: (  3, 77, 78,255) #034D4EFF srgba(3,77,78,1)
+        13: (  3, 77, 79,255) #034D4FFF srgba(3,77,79,1)
+        18: (  3, 78, 79,255) #034E4FFF srgba(3,78,79,1)
+        11: (  3, 79, 80,255) #034F50FF srgba(3,79,80,1)
+         3: (  3, 80, 81,255) #035051FF srgba(3,80,81,1)
+        12: (  3, 80, 82,255) #035052FF srgba(3,80,82,1)
+        12: (  3, 81, 82,255) #035152FF srgba(3,81,82,1)
+        13: (  3, 82, 83,255) #035253FF srgba(3,82,83,1)
+         9: (  3, 83, 84,255) #035354FF srgba(3,83,84,1)
+        11: (  3, 83, 85,255) #035355FF srgba(3,83,85,1)
+         1: (  3, 84, 85,255) #035455FF srgba(3,84,85,1)
+        13: (  3, 85, 86,255) #035556FF srgba(3,85,86,1)
+         1: (  3, 86, 87,255) #035657FF srgba(3,86,87,1)
+        10: (  3, 86, 88,255) #035658FF srgba(3,86,88,1)
+         8: (  3, 87, 88,255) #035758FF srgba(3,87,88,1)
+        16: (  3, 88, 89,255) #035859FF srgba(3,88,89,1)
+         1: (  4,  3,  2,255) #040302FF srgba(4,3,2,1)
+         3: (  4,  4,  4,255) #040404FF srgba(4,4,4,1)
+       190: (  4,  4,  5,255) #040405FF srgba(4,4,5,1)
+       394: (  4,  4,  6,255) #040406FF srgba(4,4,6,1)
+        19: (  4,  4,  7,255) #040407FF srgba(4,4,7,1)
+         1: (  4,  5,  4,255) #040504FF srgba(4,5,4,1)
+        46: (  4,  5,  5,255) #040505FF srgba(4,5,5,1)
+      2302: (  4,  5,  6,255) #040506FF srgba(4,5,6,1)
+      1828: (  4,  5,  7,255) #040507FF srgba(4,5,7,1)
+        68: (  4,  5,  8,255) #040508FF srgba(4,5,8,1)
+        14: (  4,  6,  6,255) #040606FF srgba(4,6,6,1)
+       938: (  4,  6,  7,255) #040607FF srgba(4,6,7,1)
+       886: (  4,  6,  8,255) #040608FF srgba(4,6,8,1)
+        25: (  4,  6,  9,255) #040609FF srgba(4,6,9,1)
+         1: (  4,  6, 10,255) #04060AFF srgba(4,6,10,1)
+        11: (  4,  7,  8,255) #040708FF srgba(4,7,8,1)
+         8: (  4,  7,  9,255) #040709FF srgba(4,7,9,1)
+         1: (  4,  7, 13,255) #04070DFF srgba(4,7,13,1)
+         1: (  4,  8,  9,255) #040809FF srgba(4,8,9,1)
+         1: (  4,  8, 11,255) #04080BFF srgba(4,8,11,1)
+         1: (  4, 15, 14,255) #040F0EFF srgba(4,15,14,1)
+         1: (  4, 15, 15,255) #040F0FFF srgba(4,15,15,1)
+         7: (  4, 89, 90,255) #04595AFF srgba(4,89,90,1)
+        14: (  4, 89, 91,255) #04595BFF srgba(4,89,91,1)
+         1: (  4, 90, 91,255) #045A5BFF srgba(4,90,91,1)
+        11: (  4, 91, 92,255) #045B5CFF srgba(4,91,92,1)
+         8: (  4, 92, 93,255) #045C5DFF srgba(4,92,93,1)
+        10: (  4, 92, 94,255) #045C5EFF srgba(4,92,94,1)
+         5: (  4, 93, 94,255) #045D5EFF srgba(4,93,94,1)
+        13: (  4, 94, 95,255) #045E5FFF srgba(4,94,95,1)
+        16: (  4, 95, 96,255) #045F60FF srgba(4,95,96,1)
+        12: (  4, 95, 97,255) #045F61FF srgba(4,95,97,1)
+         4: (  4, 96, 97,255) #046061FF srgba(4,96,97,1)
+        10: (  4, 97, 98,255) #046162FF srgba(4,97,98,1)
+         3: (  4, 98,100,255) #046264FF srgba(4,98,100,1)
+         8: (  4, 99,100,255) #046364FF srgba(4,99,100,1)
+        20: (  4,100,101,255) #046465FF srgba(4,100,101,1)
+         9: (  4,101,102,255) #046566FF srgba(4,101,102,1)
+        13: (  4,101,103,255) #046567FF srgba(4,101,103,1)
+        85: (  4,102,103,255) #046667FF srgba(4,102,103,1)
+        21: (  4,103,104,255) #046768FF srgba(4,103,104,1)
+         6: (  4,104,105,255) #046869FF srgba(4,104,105,1)
+         5: (  4,104,106,255) #04686AFF srgba(4,104,106,1)
+         9: (  4,105,106,255) #04696AFF srgba(4,105,106,1)
+        30: (  4,106,107,255) #046A6BFF srgba(4,106,107,1)
+        12: (  4,107,108,255) #046B6CFF srgba(4,107,108,1)
+         7: (  4,107,109,255) #046B6DFF srgba(4,107,109,1)
+         3: (  4,108,109,255) #046C6DFF srgba(4,108,109,1)
+         4: (  4,108,110,255) #046C6EFF srgba(4,108,110,1)
+         3: (  4,109,111,255) #046D6FFF srgba(4,109,111,1)
+         5: (  4,110,111,255) #046E6FFF srgba(4,110,111,1)
+        11: (  4,110,112,255) #046E70FF srgba(4,110,112,1)
+        12: (  4,111,112,255) #046F70FF srgba(4,111,112,1)
+         2: (  4,111,113,255) #046F71FF srgba(4,111,113,1)
+         3: (  4,112,114,255) #047072FF srgba(4,112,114,1)
+         8: (  4,113,114,255) #047172FF srgba(4,113,114,1)
+        13: (  4,113,115,255) #047173FF srgba(4,113,115,1)
+        40: (  4,114,115,255) #047273FF srgba(4,114,115,1)
+         1: (  4,136,137,255) #048889FF srgba(4,136,137,1)
+         3: (  4,137,139,255) #04898BFF srgba(4,137,139,1)
+         1: (  4,138,139,255) #048A8BFF srgba(4,138,139,1)
+         2: (  4,138,140,255) #048A8CFF srgba(4,138,140,1)
+         1: (  4,140,141,255) #048C8DFF srgba(4,140,141,1)
+         1: (  4,142,144,255) #048E90FF srgba(4,142,144,1)
+         1: (  4,145,147,255) #049193FF srgba(4,145,147,1)
+         1: (  4,146,148,255) #049294FF srgba(4,146,148,1)
+         1: (  4,147,149,255) #049395FF srgba(4,147,149,1)
+         1: (  4,148,150,255) #049496FF srgba(4,148,150,1)
+         4: (  4,149,151,255) #049597FF srgba(4,149,151,1)
+         1: (  5,  4, 12,255) #05040CFF srgba(5,4,12,1)
+         1: (  5,  5,  4,255) #050504FF srgba(5,5,4,1)
+        15: (  5,  5,  5,255) #050505FF grey2
+        32: (  5,  5,  6,255) #050506FF srgba(5,5,6,1)
+        48: (  5,  5,  7,255) #050507FF srgba(5,5,7,1)
+         9: (  5,  5,  8,255) #050508FF srgba(5,5,8,1)
+         1: (  5,  5,  9,255) #050509FF srgba(5,5,9,1)
+         1: (  5,  6,  5,255) #050605FF srgba(5,6,5,1)
+        17: (  5,  6,  6,255) #050606FF srgba(5,6,6,1)
+       974: (  5,  6,  7,255) #050607FF srgba(5,6,7,1)
+      2398: (  5,  6,  8,255) #050608FF srgba(5,6,8,1)
+       220: (  5,  6,  9,255) #050609FF srgba(5,6,9,1)
+         1: (  5,  6, 10,255) #05060AFF srgba(5,6,10,1)
+         2: (  5,  7,  7,255) #050707FF srgba(5,7,7,1)
+       753: (  5,  7,  8,255) #050708FF srgba(5,7,8,1)
+      1382: (  5,  7,  9,255) #050709FF srgba(5,7,9,1)
+       156: (  5,  7, 10,255) #05070AFF srgba(5,7,10,1)
+         3: (  5,  7, 11,255) #05070BFF srgba(5,7,11,1)
+        11: (  5,  8,  9,255) #050809FF srgba(5,8,9,1)
+        55: (  5,  8, 10,255) #05080AFF srgba(5,8,10,1)
+        18: (  5,  8, 11,255) #05080BFF srgba(5,8,11,1)
+         2: (  5,  8, 12,255) #05080CFF srgba(5,8,12,1)
+         2: (  5,  9, 11,255) #05090BFF srgba(5,9,11,1)
+         1: (  5,  9, 12,255) #05090CFF srgba(5,9,12,1)
+         1: (  5, 15, 15,255) #050F0FFF srgba(5,15,15,1)
+         1: (  5, 16, 28,255) #05101CFF srgba(5,16,28,1)
+        14: (  5,114,116,255) #057274FF srgba(5,114,116,1)
+         3: (  5,115,117,255) #057375FF srgba(5,115,117,1)
+        10: (  5,116,117,255) #057475FF srgba(5,116,117,1)
+        35: (  5,116,118,255) #057476FF srgba(5,116,118,1)
+         8: (  5,117,118,255) #057576FF srgba(5,117,118,1)
+         1: (  5,117,119,255) #057577FF srgba(5,117,119,1)
+         6: (  5,118,120,255) #057678FF srgba(5,118,120,1)
+         4: (  5,119,120,255) #057778FF srgba(5,119,120,1)
+         3: (  5,119,121,255) #057779FF srgba(5,119,121,1)
+         2: (  5,120,121,255) #057879FF srgba(5,120,121,1)
+         2: (  5,120,122,255) #05787AFF srgba(5,120,122,1)
+         5: (  5,121,123,255) #05797BFF srgba(5,121,123,1)
+         7: (  5,123,124,255) #057B7CFF srgba(5,123,124,1)
+         5: (  5,123,125,255) #057B7DFF srgba(5,123,125,1)
+         7: (  5,124,126,255) #057C7EFF srgba(5,124,126,1)
+         1: (  5,125,126,255) #057D7EFF srgba(5,125,126,1)
+         5: (  5,125,127,255) #057D7FFF srgba(5,125,127,1)
+         4: (  5,126,127,255) #057E7FFF srgba(5,126,127,1)
+         3: (  5,126,128,255) #057E80FF srgba(5,126,128,1)
+         6: (  5,127,129,255) #057F81FF srgba(5,127,129,1)
+        10: (  5,128,129,255) #058081FF srgba(5,128,129,1)
+        43: (  5,128,130,255) #058082FF srgba(5,128,130,1)
+         3: (  5,129,130,255) #058182FF srgba(5,129,130,1)
+         1: (  5,129,131,255) #058183FF srgba(5,129,131,1)
+        12: (  5,130,132,255) #058284FF srgba(5,130,132,1)
+         4: (  5,131,132,255) #058384FF srgba(5,131,132,1)
+        20: (  5,131,133,255) #058385FF srgba(5,131,133,1)
+         3: (  5,132,133,255) #058485FF srgba(5,132,133,1)
+         7: (  5,132,134,255) #058486FF srgba(5,132,134,1)
+        74: (  5,133,135,255) #058587FF srgba(5,133,135,1)
+         3: (  5,134,135,255) #058687FF srgba(5,134,135,1)
+         3: (  5,134,136,255) #058688FF srgba(5,134,136,1)
+        13: (  5,135,136,255) #058788FF srgba(5,135,136,1)
+         9: (  5,135,137,255) #058789FF srgba(5,135,137,1)
+         5: (  5,136,138,255) #05888AFF srgba(5,136,138,1)
+         9: (  5,137,138,255) #05898AFF srgba(5,137,138,1)
+         9: (  5,137,139,255) #05898BFF srgba(5,137,139,1)
+        12: (  5,138,140,255) #058A8CFF srgba(5,138,140,1)
+        19: (  5,139,141,255) #058B8DFF srgba(5,139,141,1)
+         6: (  5,143,145,255) #058F91FF srgba(5,143,145,1)
+         8: (  5,144,146,255) #059092FF srgba(5,144,146,1)
+         2: (  5,145,147,255) #059193FF srgba(5,145,147,1)
+         1: (  5,146,147,255) #059293FF srgba(5,146,147,1)
+         2: (  5,147,149,255) #059395FF srgba(5,147,149,1)
+         2: (  5,148,150,255) #059496FF srgba(5,148,150,1)
+         1: (  5,149,151,255) #059597FF srgba(5,149,151,1)
+        27: (  5,150,152,255) #059698FF srgba(5,150,152,1)
+        15: (  5,151,153,255) #059799FF srgba(5,151,153,1)
+         1: (  6,  5,  7,255) #060507FF srgba(6,5,7,1)
+         6: (  6,  6,  6,255) #060606FF srgba(6,6,6,1)
+        11: (  6,  6,  7,255) #060607FF srgba(6,6,7,1)
+        25: (  6,  6,  8,255) #060608FF srgba(6,6,8,1)
+        11: (  6,  6,  9,255) #060609FF srgba(6,6,9,1)
+       319: (  6,  7,  8,255) #060708FF srgba(6,7,8,1)
+      1480: (  6,  7,  9,255) #060709FF srgba(6,7,9,1)
+       329: (  6,  7, 10,255) #06070AFF srgba(6,7,10,1)
+         1: (  6,  7, 11,255) #06070BFF srgba(6,7,11,1)
+         3: (  6,  8,  8,255) #060808FF srgba(6,8,8,1)
+       426: (  6,  8,  9,255) #060809FF srgba(6,8,9,1)
+      2185: (  6,  8, 10,255) #06080AFF srgba(6,8,10,1)
+       501: (  6,  8, 11,255) #06080BFF srgba(6,8,11,1)
+        12: (  6,  8, 12,255) #06080CFF srgba(6,8,12,1)
+        31: (  6,  9, 10,255) #06090AFF srgba(6,9,10,1)
+       109: (  6,  9, 11,255) #06090BFF srgba(6,9,11,1)
+        96: (  6,  9, 12,255) #06090CFF srgba(6,9,12,1)
+         7: (  6,  9, 13,255) #06090DFF srgba(6,9,13,1)
+         1: (  6,  9, 21,255) #060915FF srgba(6,9,21,1)
+         5: (  6, 10, 12,255) #060A0CFF srgba(6,10,12,1)
+         1: (  6, 10, 14,255) #060A0EFF srgba(6,10,14,1)
+         1: (  6, 11, 13,255) #060B0DFF srgba(6,11,13,1)
+         3: (  6,139,141,255) #068B8DFF srgba(6,139,141,1)
+        10: (  6,140,142,255) #068C8EFF srgba(6,140,142,1)
+        26: (  6,141,143,255) #068D8FFF srgba(6,141,143,1)
+        14: (  6,142,144,255) #068E90FF srgba(6,142,144,1)
+        12: (  6,143,145,255) #068F91FF srgba(6,143,145,1)
+        10: (  6,144,146,255) #069092FF srgba(6,144,146,1)
+        33: (  6,145,147,255) #069193FF srgba(6,145,147,1)
+         6: (  6,146,148,255) #069294FF srgba(6,146,148,1)
+        15: (  6,147,149,255) #069395FF srgba(6,147,149,1)
+        23: (  6,148,150,255) #069496FF srgba(6,148,150,1)
+        14: (  6,149,151,255) #069597FF srgba(6,149,151,1)
+       101: (  6,150,152,255) #069698FF srgba(6,150,152,1)
+        57: (  6,151,153,255) #069799FF srgba(6,151,153,1)
+     30834: (  6,152,154,255) #06989AFF srgba(6,152,154,1)
+         1: (  7,  6,  7,255) #070607FF srgba(7,6,7,1)
+         1: (  7,  7,  7,255) #070707FF srgba(7,7,7,1)
+         3: (  7,  7,  8,255) #070708FF srgba(7,7,8,1)
+         4: (  7,  7,  9,255) #070709FF srgba(7,7,9,1)
+        36: (  7,  8,  9,255) #070809FF srgba(7,8,9,1)
+       450: (  7,  8, 10,255) #07080AFF srgba(7,8,10,1)
+       234: (  7,  8, 11,255) #07080BFF srgba(7,8,11,1)
+        10: (  7,  8, 12,255) #07080CFF srgba(7,8,12,1)
+       166: (  7,  9, 10,255) #07090AFF srgba(7,9,10,1)
+      1512: (  7,  9, 11,255) #07090BFF srgba(7,9,11,1)
+       818: (  7,  9, 12,255) #07090CFF srgba(7,9,12,1)
+        26: (  7,  9, 13,255) #07090DFF srgba(7,9,13,1)
+         2: (  7,  9, 14,255) #07090EFF srgba(7,9,14,1)
+        30: (  7, 10, 11,255) #070A0BFF srgba(7,10,11,1)
+       254: (  7, 10, 12,255) #070A0CFF srgba(7,10,12,1)
+       195: (  7, 10, 13,255) #070A0DFF srgba(7,10,13,1)
+        24: (  7, 10, 14,255) #070A0EFF srgba(7,10,14,1)
+         1: (  7, 10, 15,255) #070A0FFF srgba(7,10,15,1)
+         4: (  7, 11, 13,255) #070B0DFF srgba(7,11,13,1)
+         5: (  7, 11, 14,255) #070B0EFF srgba(7,11,14,1)
+         4: (  7, 11, 15,255) #070B0FFF srgba(7,11,15,1)
+         1: (  7, 13, 27,255) #070D1BFF srgba(7,13,27,1)
+         1: (  7, 19, 30,255) #07131EFF srgba(7,19,30,1)
+         2: (  8,  7,  7,255) #080707FF srgba(8,7,7,1)
+         4: (  8,  8,  8,255) #080808FF grey3
+         4: (  8,  8,  9,255) #080809FF srgba(8,8,9,1)
+         5: (  8,  8, 10,255) #08080AFF srgba(8,8,10,1)
+         1: (  8,  8, 12,255) #08080CFF srgba(8,8,12,1)
+         2: (  8,  9,  8,255) #080908FF srgba(8,9,8,1)
+         8: (  8,  9, 10,255) #08090AFF srgba(8,9,10,1)
+       134: (  8,  9, 11,255) #08090BFF srgba(8,9,11,1)
+       106: (  8,  9, 12,255) #08090CFF srgba(8,9,12,1)
+         3: (  8,  9, 13,255) #08090DFF srgba(8,9,13,1)
+        53: (  8, 10, 11,255) #080A0BFF srgba(8,10,11,1)
+      1134: (  8, 10, 12,255) #080A0CFF srgba(8,10,12,1)
+       919: (  8, 10, 13,255) #080A0DFF srgba(8,10,13,1)
+       108: (  8, 10, 14,255) #080A0EFF srgba(8,10,14,1)
+         3: (  8, 10, 15,255) #080A0FFF srgba(8,10,15,1)
+         3: (  8, 11, 12,255) #080B0CFF srgba(8,11,12,1)
+       194: (  8, 11, 13,255) #080B0DFF srgba(8,11,13,1)
+       493: (  8, 11, 14,255) #080B0EFF srgba(8,11,14,1)
+        87: (  8, 11, 15,255) #080B0FFF srgba(8,11,15,1)
+         7: (  8, 11, 16,255) #080B10FF srgba(8,11,16,1)
+        14: (  8, 12, 14,255) #080C0EFF srgba(8,12,14,1)
+        33: (  8, 12, 15,255) #080C0FFF srgba(8,12,15,1)
+        16: (  8, 12, 16,255) #080C10FF srgba(8,12,16,1)
+         1: (  8, 12, 17,255) #080C11FF srgba(8,12,17,1)
+         1: (  8, 13, 16,255) #080D10FF srgba(8,13,16,1)
+         1: (  8, 19, 29,255) #08131DFF srgba(8,19,29,1)
+         1: (  9,  8, 11,255) #09080BFF srgba(9,8,11,1)
+         1: (  9,  9, 10,255) #09090AFF srgba(9,9,10,1)
+         1: (  9,  9, 11,255) #09090BFF srgba(9,9,11,1)
+         1: (  9,  9, 12,255) #09090CFF srgba(9,9,12,1)
+         4: (  9, 10, 11,255) #090A0BFF srgba(9,10,11,1)
+        27: (  9, 10, 12,255) #090A0CFF srgba(9,10,12,1)
+        42: (  9, 10, 13,255) #090A0DFF srgba(9,10,13,1)
+         8: (  9, 10, 14,255) #090A0EFF srgba(9,10,14,1)
+        14: (  9, 11, 12,255) #090B0CFF srgba(9,11,12,1)
+       288: (  9, 11, 13,255) #090B0DFF srgba(9,11,13,1)
+       514: (  9, 11, 14,255) #090B0EFF srgba(9,11,14,1)
+        94: (  9, 11, 15,255) #090B0FFF srgba(9,11,15,1)
+        11: (  9, 11, 16,255) #090B10FF srgba(9,11,16,1)
+         1: (  9, 12, 13,255) #090C0DFF srgba(9,12,13,1)
+       174: (  9, 12, 14,255) #090C0EFF srgba(9,12,14,1)
+       376: (  9, 12, 15,255) #090C0FFF srgba(9,12,15,1)
+       154: (  9, 12, 16,255) #090C10FF srgba(9,12,16,1)
+        19: (  9, 12, 17,255) #090C11FF srgba(9,12,17,1)
+         1: (  9, 12, 18,255) #090C12FF srgba(9,12,18,1)
+         9: (  9, 13, 15,255) #090D0FFF srgba(9,13,15,1)
+        39: (  9, 13, 16,255) #090D10FF srgba(9,13,16,1)
+        36: (  9, 13, 17,255) #090D11FF srgba(9,13,17,1)
+         6: (  9, 13, 18,255) #090D12FF srgba(9,13,18,1)
+         2: (  9, 13, 19,255) #090D13FF srgba(9,13,19,1)
+         1: (  9, 14, 17,255) #090E11FF srgba(9,14,17,1)
+         3: (  9, 14, 18,255) #090E12FF srgba(9,14,18,1)
+         2: (  9, 14, 19,255) #090E13FF srgba(9,14,19,1)
+         1: (  9,153,153,255) #099999FF srgba(9,153,153,1)
+         1: ( 10, 10,  9,255) #0A0A09FF srgba(10,10,9,1)
+         1: ( 10, 10, 10,255) #0A0A0AFF grey4
+         2: ( 10, 10, 12,255) #0A0A0CFF srgba(10,10,12,1)
+         1: ( 10, 11, 11,255) #0A0B0BFF srgba(10,11,11,1)
+         5: ( 10, 11, 12,255) #0A0B0CFF srgba(10,11,12,1)
+        12: ( 10, 11, 13,255) #0A0B0DFF srgba(10,11,13,1)
+         9: ( 10, 11, 14,255) #0A0B0EFF srgba(10,11,14,1)
+         1: ( 10, 11, 15,255) #0A0B0FFF srgba(10,11,15,1)
+         4: ( 10, 12, 13,255) #0A0C0DFF srgba(10,12,13,1)
+        97: ( 10, 12, 14,255) #0A0C0EFF srgba(10,12,14,1)
+       164: ( 10, 12, 15,255) #0A0C0FFF srgba(10,12,15,1)
+        90: ( 10, 12, 16,255) #0A0C10FF srgba(10,12,16,1)
+         9: ( 10, 12, 17,255) #0A0C11FF srgba(10,12,17,1)
+        28: ( 10, 13, 15,255) #0A0D0FFF srgba(10,13,15,1)
+       196: ( 10, 13, 16,255) #0A0D10FF srgba(10,13,16,1)
+       154: ( 10, 13, 17,255) #0A0D11FF srgba(10,13,17,1)
+        19: ( 10, 13, 18,255) #0A0D12FF srgba(10,13,18,1)
+         8: ( 10, 14, 16,255) #0A0E10FF srgba(10,14,16,1)
+        41: ( 10, 14, 17,255) #0A0E11FF srgba(10,14,17,1)
+        50: ( 10, 14, 18,255) #0A0E12FF srgba(10,14,18,1)
+        18: ( 10, 14, 19,255) #0A0E13FF srgba(10,14,19,1)
+         1: ( 10, 14, 20,255) #0A0E14FF srgba(10,14,20,1)
+         1: ( 10, 15, 17,255) #0A0F11FF srgba(10,15,17,1)
+         4: ( 10, 15, 19,255) #0A0F13FF srgba(10,15,19,1)
+         1: ( 10, 26, 30,255) #0A1A1EFF srgba(10,26,30,1)
+         1: ( 10, 27, 30,255) #0A1B1EFF srgba(10,27,30,1)
+         1: ( 10, 30, 29,255) #0A1E1DFF srgba(10,30,29,1)
+         1: ( 10, 30, 30,255) #0A1E1EFF srgba(10,30,30,1)
+         1: ( 10,154,153,255) #0A9A99FF srgba(10,154,153,1)
+         1: ( 11, 11, 11,255) #0B0B0BFF srgba(11,11,11,1)
+         1: ( 11, 11, 12,255) #0B0B0CFF srgba(11,11,12,1)
+         1: ( 11, 11, 13,255) #0B0B0DFF srgba(11,11,13,1)
+         1: ( 11, 12, 13,255) #0B0C0DFF srgba(11,12,13,1)
+         5: ( 11, 12, 14,255) #0B0C0EFF srgba(11,12,14,1)
+         5: ( 11, 12, 15,255) #0B0C0FFF srgba(11,12,15,1)
+         3: ( 11, 12, 16,255) #0B0C10FF srgba(11,12,16,1)
+         1: ( 11, 12, 17,255) #0B0C11FF srgba(11,12,17,1)
+         6: ( 11, 13, 15,255) #0B0D0FFF srgba(11,13,15,1)
+        37: ( 11, 13, 16,255) #0B0D10FF srgba(11,13,16,1)
+        22: ( 11, 13, 17,255) #0B0D11FF srgba(11,13,17,1)
+         7: ( 11, 13, 18,255) #0B0D12FF srgba(11,13,18,1)
+         3: ( 11, 13, 19,255) #0B0D13FF srgba(11,13,19,1)
+        13: ( 11, 14, 16,255) #0B0E10FF srgba(11,14,16,1)
+        67: ( 11, 14, 17,255) #0B0E11FF srgba(11,14,17,1)
+        94: ( 11, 14, 18,255) #0B0E12FF srgba(11,14,18,1)
+        30: ( 11, 14, 19,255) #0B0E13FF srgba(11,14,19,1)
+         2: ( 11, 14, 20,255) #0B0E14FF srgba(11,14,20,1)
+         3: ( 11, 15, 17,255) #0B0F11FF srgba(11,15,17,1)
+        19: ( 11, 15, 18,255) #0B0F12FF srgba(11,15,18,1)
+        37: ( 11, 15, 19,255) #0B0F13FF srgba(11,15,19,1)
+        26: ( 11, 15, 20,255) #0B0F14FF srgba(11,15,20,1)
+         3: ( 11, 15, 21,255) #0B0F15FF srgba(11,15,21,1)
+         4: ( 11, 16, 21,255) #0B1015FF srgba(11,16,21,1)
+         3: ( 12, 12, 12,255) #0C0C0CFF srgba(12,12,12,1)
+         1: ( 12, 12, 15,255) #0C0C0FFF srgba(12,12,15,1)
+         2: ( 12, 13, 15,255) #0C0D0FFF srgba(12,13,15,1)
+         2: ( 12, 13, 16,255) #0C0D10FF srgba(12,13,16,1)
+         1: ( 12, 13, 19,255) #0C0D13FF srgba(12,13,19,1)
+         1: ( 12, 14, 15,255) #0C0E0FFF srgba(12,14,15,1)
+         3: ( 12, 14, 16,255) #0C0E10FF srgba(12,14,16,1)
+         6: ( 12, 14, 17,255) #0C0E11FF srgba(12,14,17,1)
+        16: ( 12, 14, 18,255) #0C0E12FF srgba(12,14,18,1)
+         3: ( 12, 14, 19,255) #0C0E13FF srgba(12,14,19,1)
+         3: ( 12, 15, 17,255) #0C0F11FF srgba(12,15,17,1)
+        23: ( 12, 15, 18,255) #0C0F12FF srgba(12,15,18,1)
+        46: ( 12, 15, 19,255) #0C0F13FF srgba(12,15,19,1)
+        18: ( 12, 15, 20,255) #0C0F14FF srgba(12,15,20,1)
+         2: ( 12, 15, 21,255) #0C0F15FF srgba(12,15,21,1)
+         4: ( 12, 16, 18,255) #0C1012FF srgba(12,16,18,1)
+        17: ( 12, 16, 19,255) #0C1013FF srgba(12,16,19,1)
+        38: ( 12, 16, 20,255) #0C1014FF srgba(12,16,20,1)
+        20: ( 12, 16, 21,255) #0C1015FF srgba(12,16,21,1)
+         3: ( 12, 16, 22,255) #0C1016FF srgba(12,16,22,1)
+         1: ( 12, 17, 18,255) #0C1112FF srgba(12,17,18,1)
+         3: ( 12, 17, 19,255) #0C1113FF srgba(12,17,19,1)
+         4: ( 12, 17, 20,255) #0C1114FF srgba(12,17,20,1)
+         7: ( 12, 17, 21,255) #0C1115FF srgba(12,17,21,1)
+         6: ( 12, 17, 22,255) #0C1116FF srgba(12,17,22,1)
+         1: ( 12, 17, 23,255) #0C1117FF srgba(12,17,23,1)
+         1: ( 12, 18, 22,255) #0C1216FF srgba(12,18,22,1)
+         1: ( 12, 18, 23,255) #0C1217FF srgba(12,18,23,1)
+         2: ( 13, 13, 15,255) #0D0D0FFF srgba(13,13,15,1)
+         2: ( 13, 14, 17,255) #0D0E11FF srgba(13,14,17,1)
+         4: ( 13, 15, 18,255) #0D0F12FF srgba(13,15,18,1)
+         1: ( 13, 15, 20,255) #0D0F14FF srgba(13,15,20,1)
+         1: ( 13, 15, 21,255) #0D0F15FF srgba(13,15,21,1)
+         8: ( 13, 16, 19,255) #0D1013FF srgba(13,16,19,1)
+        20: ( 13, 16, 20,255) #0D1014FF srgba(13,16,20,1)
+        19: ( 13, 16, 21,255) #0D1015FF srgba(13,16,21,1)
+         2: ( 13, 16, 22,255) #0D1016FF srgba(13,16,22,1)
+         1: ( 13, 17, 18,255) #0D1112FF srgba(13,17,18,1)
+        18: ( 13, 17, 20,255) #0D1114FF srgba(13,17,20,1)
+        28: ( 13, 17, 21,255) #0D1115FF srgba(13,17,21,1)
+        17: ( 13, 17, 22,255) #0D1116FF srgba(13,17,22,1)
+         1: ( 13, 17, 23,255) #0D1117FF srgba(13,17,23,1)
+         1: ( 13, 18, 19,255) #0D1213FF srgba(13,18,19,1)
+         2: ( 13, 18, 20,255) #0D1214FF srgba(13,18,20,1)
+         1: ( 13, 18, 21,255) #0D1215FF srgba(13,18,21,1)
+         4: ( 13, 18, 22,255) #0D1216FF srgba(13,18,22,1)
+        15: ( 13, 18, 23,255) #0D1217FF srgba(13,18,23,1)
+         3: ( 13, 18, 24,255) #0D1218FF srgba(13,18,24,1)
+         1: ( 13, 19, 23,255) #0D1317FF srgba(13,19,23,1)
+         1: ( 13, 19, 24,255) #0D1318FF srgba(13,19,24,1)
+         1: ( 14, 14, 18,255) #0E0E12FF srgba(14,14,18,1)
+         1: ( 14, 15, 17,255) #0E0F11FF srgba(14,15,17,1)
+         1: ( 14, 15, 18,255) #0E0F12FF srgba(14,15,18,1)
+         1: ( 14, 15, 19,255) #0E0F13FF srgba(14,15,19,1)
+         1: ( 14, 15, 21,255) #0E0F15FF srgba(14,15,21,1)
+         2: ( 14, 16, 18,255) #0E1012FF srgba(14,16,18,1)
+         1: ( 14, 16, 19,255) #0E1013FF srgba(14,16,19,1)
+         4: ( 14, 16, 20,255) #0E1014FF srgba(14,16,20,1)
+         2: ( 14, 16, 21,255) #0E1015FF srgba(14,16,21,1)
+         1: ( 14, 17, 20,255) #0E1114FF srgba(14,17,20,1)
+         6: ( 14, 17, 21,255) #0E1115FF srgba(14,17,21,1)
+        13: ( 14, 17, 22,255) #0E1116FF srgba(14,17,22,1)
+         1: ( 14, 17, 23,255) #0E1117FF srgba(14,17,23,1)
+         1: ( 14, 18, 21,255) #0E1215FF srgba(14,18,21,1)
+        14: ( 14, 18, 22,255) #0E1216FF srgba(14,18,22,1)
+         9: ( 14, 18, 23,255) #0E1217FF srgba(14,18,23,1)
+         3: ( 14, 18, 24,255) #0E1218FF srgba(14,18,24,1)
+         1: ( 14, 19, 20,255) #0E1314FF srgba(14,19,20,1)
+         1: ( 14, 19, 21,255) #0E1315FF srgba(14,19,21,1)
+         2: ( 14, 19, 22,255) #0E1316FF srgba(14,19,22,1)
+         7: ( 14, 19, 23,255) #0E1317FF srgba(14,19,23,1)
+        11: ( 14, 19, 24,255) #0E1318FF srgba(14,19,24,1)
+         2: ( 14, 20, 22,255) #0E1416FF srgba(14,20,22,1)
+         2: ( 14, 20, 23,255) #0E1417FF srgba(14,20,23,1)
+         2: ( 14, 20, 24,255) #0E1418FF srgba(14,20,24,1)
+         1: ( 14, 30, 30,255) #0E1E1EFF srgba(14,30,30,1)
+         1: ( 15, 15, 18,255) #0F0F12FF srgba(15,15,18,1)
+         1: ( 15, 16, 20,255) #0F1014FF srgba(15,16,20,1)
+         1: ( 15, 17, 18,255) #0F1112FF srgba(15,17,18,1)
+         1: ( 15, 18, 20,255) #0F1214FF srgba(15,18,20,1)
+         1: ( 15, 18, 22,255) #0F1216FF srgba(15,18,22,1)
+         3: ( 15, 18, 23,255) #0F1217FF srgba(15,18,23,1)
+         2: ( 15, 19, 22,255) #0F1316FF srgba(15,19,22,1)
+        10: ( 15, 19, 23,255) #0F1317FF srgba(15,19,23,1)
+         5: ( 15, 19, 24,255) #0F1318FF srgba(15,19,24,1)
+         1: ( 15, 20, 21,255) #0F1415FF srgba(15,20,21,1)
+         1: ( 15, 20, 23,255) #0F1417FF srgba(15,20,23,1)
+         3: ( 15, 20, 24,255) #0F1418FF srgba(15,20,24,1)
+         1: ( 15, 22, 24,255) #0F1618FF srgba(15,22,24,1)
+         1: ( 16, 16, 19,255) #101013FF srgba(16,16,19,1)
+         1: ( 16, 18, 23,255) #101217FF srgba(16,18,23,1)
+         1: ( 16, 19, 21,255) #101315FF srgba(16,19,21,1)
+         1: ( 16, 19, 23,255) #101317FF srgba(16,19,23,1)
+         1: ( 16, 20, 23,255) #101417FF srgba(16,20,23,1)
+         1: ( 16, 20, 24,255) #101418FF srgba(16,20,24,1)
+         4: ( 16, 20, 25,255) #101419FF srgba(16,20,25,1)
+         1: ( 16, 21, 25,255) #101519FF srgba(16,21,25,1)
+         1: ( 16, 21, 26,255) #10151AFF srgba(16,21,26,1)
+         1: ( 16, 22, 24,255) #101618FF srgba(16,22,24,1)
+         1: ( 17, 20, 22,255) #111416FF srgba(17,20,22,1)
+         1: ( 17, 20, 25,255) #111419FF srgba(17,20,25,1)
+         1: ( 17, 21, 26,255) #11151AFF srgba(17,21,26,1)
+         1: ( 17, 22, 25,255) #111619FF srgba(17,22,25,1)
+         1: ( 17, 22, 26,255) #11161AFF srgba(17,22,26,1)
+         1: ( 17, 23, 25,255) #111719FF srgba(17,23,25,1)
+         7: ( 18, 19, 18,255) #121312FF srgba(18,19,18,1)
+         2: ( 18, 20, 22,255) #121416FF srgba(18,20,22,1)
+         1: ( 18, 21, 26,255) #12151AFF srgba(18,21,26,1)
+         1: ( 18, 23, 25,255) #121719FF srgba(18,23,25,1)
+         1: ( 18,156,151,255) #129C97FF srgba(18,156,151,1)
+         1: ( 19, 21, 25,255) #131519FF srgba(19,21,25,1)
+         1: ( 20, 23, 26,255) #14171AFF srgba(20,23,26,1)
+         1: ( 20, 26, 30,255) #141A1EFF srgba(20,26,30,1)
+         1: ( 21, 30, 30,255) #151E1EFF srgba(21,30,30,1)
+         1: ( 22, 29, 30,255) #161D1EFF srgba(22,29,30,1)
+         1: ( 23, 25, 27,255) #17191BFF srgba(23,25,27,1)
+         2: ( 24, 25, 24,255) #181918FF srgba(24,25,24,1)
+         1: ( 24, 26, 28,255) #181A1CFF srgba(24,26,28,1)
+         1: ( 24, 27, 29,255) #181B1DFF srgba(24,27,29,1)
+        26: ( 25, 26, 25,255) #191A19FF srgba(25,26,25,1)
+         1: ( 25, 27, 28,255) #191B1CFF srgba(25,27,28,1)
+         3: ( 25, 28, 30,255) #191C1EFF srgba(25,28,30,1)
+       829: ( 26, 27, 26,255) #1A1B1AFF srgba(26,27,26,1)
+         1: ( 26, 27, 27,255) #1A1B1BFF srgba(26,27,27,1)
+         1: ( 28, 29, 30,255) #1C1D1EFF srgba(28,29,30,1)
+       864: ( 30, 30, 29,255) #1E1E1DFF srgba(30,30,29,1)
+     66332: ( 52,101,164,255) #3465A4FF srgba(52,101,164,1)
+        11: ( 53,102,163,255) #3566A3FF srgba(53,102,163,1)
+         6: ( 54,102,164,255) #3666A4FF srgba(54,102,164,1)
+         8: ( 54,103,163,255) #3667A3FF srgba(54,103,163,1)
+        10: ( 55,103,162,255) #3767A2FF srgba(55,103,162,1)
+         2: ( 56,104,162,255) #3868A2FF srgba(56,104,162,1)
+        10: ( 57,104,162,255) #3968A2FF srgba(57,104,162,1)
+         8: ( 58,104,161,255) #3A68A1FF srgba(58,104,161,1)
+        26: ( 58,105,161,255) #3A69A1FF srgba(58,105,161,1)
+         7: ( 59,105,161,255) #3B69A1FF srgba(59,105,161,1)
+        11: ( 60,106,161,255) #3C6AA1FF srgba(60,106,161,1)
+         3: ( 61,107,160,255) #3D6BA0FF srgba(61,107,160,1)
+        58: ( 62,107,160,255) #3E6BA0FF srgba(62,107,160,1)
+         6: ( 62,108,160,255) #3E6CA0FF srgba(62,108,160,1)
+         2: ( 63,108,159,255) #3F6C9FFF srgba(63,108,159,1)
+         1: ( 64,109,159,255) #406D9FFF srgba(64,109,159,1)
+        15: ( 65,110,159,255) #416E9FFF srgba(65,110,159,1)
+         3: ( 66,110,158,255) #426E9EFF srgba(66,110,158,1)
+         9: ( 67,110,158,255) #436E9EFF srgba(67,110,158,1)
+         8: ( 68,111,157,255) #446F9DFF srgba(68,111,157,1)
+         9: ( 69,112,156,255) #45709CFF srgba(69,112,156,1)
+         1: ( 70,112,157,255) #46709DFF srgba(70,112,157,1)
+         3: ( 70,113,156,255) #46719CFF srgba(70,113,156,1)
+        45: ( 71,113,156,255) #47719CFF srgba(71,113,156,1)
+         2: ( 72,114,156,255) #48729CFF srgba(72,114,156,1)
+         4: ( 73,115,155,255) #49739BFF srgba(73,115,155,1)
+        21: ( 74,116,155,255) #4A749BFF srgba(74,116,155,1)
+         1: ( 75,116,154,255) #4B749AFF srgba(75,116,154,1)
+         7: ( 76,116,154,255) #4C749AFF srgba(76,116,154,1)
+         3: ( 77,117,154,255) #4D759AFF srgba(77,117,154,1)
+         8: ( 78,118,153,255) #4E7699FF srgba(78,118,153,1)
+         5: ( 80,119,152,255) #507798FF srgba(80,119,152,1)
+         3: ( 81,120,151,255) #517897FF srgba(81,120,151,1)
+        19: ( 81,120,152,255) #517898FF srgba(81,120,152,1)
+         1: ( 82,121,152,255) #527998FF srgba(82,121,152,1)
+         2: ( 83,122,150,255) #537A96FF srgba(83,122,150,1)
+         2: ( 83,122,151,255) #537A97FF srgba(83,122,151,1)
+         1: ( 84,122,150,255) #547A96FF srgba(84,122,150,1)
+         3: ( 85,123,149,255) #557B95FF srgba(85,123,149,1)
+        17: ( 86,124,150,255) #567C96FF srgba(86,124,150,1)
+        10: ( 87,124,149,255) #577C95FF srgba(87,124,149,1)
+         3: ( 88,125,148,255) #587D94FF srgba(88,125,148,1)
+         2: ( 88,125,149,255) #587D95FF srgba(88,125,149,1)
+         7: ( 89,126,148,255) #597E94FF srgba(89,126,148,1)
+         6: ( 90,127,147,255) #5A7F93FF srgba(90,127,147,1)
+         9: ( 92,128,147,255) #5C8093FF srgba(92,128,147,1)
+         2: ( 93,128,146,255) #5D8092FF srgba(93,128,146,1)
+         4: ( 94,129,146,255) #5E8192FF srgba(94,129,146,1)
+         3: ( 96,130,145,255) #608291FF srgba(96,130,145,1)
+         1: ( 97,131,145,255) #618391FF srgba(97,131,145,1)
+         4: ( 98,132,144,255) #628490FF srgba(98,132,144,1)
+        11: ( 99,132,144,255) #638490FF srgba(99,132,144,1)
+         3: (100,133,143,255) #64858FFF srgba(100,133,143,1)
+         8: (100,133,144,255) #648590FF srgba(100,133,144,1)
+         5: (101,134,142,255) #65868EFF srgba(101,134,142,1)
+         3: (102,134,143,255) #66868FFF srgba(102,134,143,1)
+         5: (103,134,142,255) #67868EFF srgba(103,134,142,1)
+         9: (104,135,142,255) #68878EFF srgba(104,135,142,1)
+         4: (105,136,141,255) #69888DFF srgba(105,136,141,1)
+         7: (106,137,141,255) #6A898DFF srgba(106,137,141,1)
+         5: (107,137,141,255) #6B898DFF srgba(107,137,141,1)
+        46: (108,138,140,255) #6C8A8CFF srgba(108,138,140,1)
+         5: (109,139,140,255) #6D8B8CFF srgba(109,139,140,1)
+         4: (110,140,139,255) #6E8C8BFF srgba(110,140,139,1)
+         2: (111,139,139,255) #6F8B8BFF srgba(111,139,139,1)
+         9: (112,140,139,255) #708C8BFF srgba(112,140,139,1)
+         1: (112,141,138,255) #708D8AFF srgba(112,141,138,1)
+        10: (115,142,138,255) #738E8AFF srgba(115,142,138,1)
+         7: (115,143,137,255) #738F89FF srgba(115,143,137,1)
+         2: (116,144,136,255) #749088FF srgba(116,144,136,1)
+         4: (117,144,137,255) #759089FF srgba(117,144,137,1)
+        17: (118,145,136,255) #769188FF srgba(118,145,136,1)
+         1: (119,145,135,255) #779187FF srgba(119,145,135,1)
+         2: (119,146,136,255) #779288FF srgba(119,146,136,1)
+         3: (120,146,135,255) #789287FF srgba(120,146,135,1)
+        39: (121,146,134,255) #799286FF srgba(121,146,134,1)
+         3: (122,147,135,255) #7A9387FF srgba(122,147,135,1)
+         1: (123,147,134,255) #7B9386FF srgba(123,147,134,1)
+         6: (123,148,133,255) #7B9485FF srgba(123,148,133,1)
+         7: (124,149,133,255) #7C9585FF srgba(124,149,133,1)
+         4: (126,150,133,255) #7E9685FF srgba(126,150,133,1)
+         8: (127,150,132,255) #7F9684FF srgba(127,150,132,1)
+        25: (127,151,132,255) #7F9784FF srgba(127,151,132,1)
+         5: (128,152,132,255) #809884FF srgba(128,152,132,1)
+         5: (129,152,131,255) #819883FF srgba(129,152,131,1)
+         7: (130,152,131,255) #829883FF srgba(130,152,131,1)
+        28: (131,152,131,255) #839883FF srgba(131,152,131,1)
+         6: (132,154,130,255) #849A82FF srgba(132,154,130,1)
+         5: (133,154,130,255) #859A82FF srgba(133,154,130,1)
+        33: (134,155,129,255) #869B81FF srgba(134,155,129,1)
+         1: (135,155,128,255) #879B80FF srgba(135,155,128,1)
+         1: (135,156,129,255) #879C81FF srgba(135,156,129,1)
+        11: (136,157,128,255) #889D80FF srgba(136,157,128,1)
+         4: (137,157,128,255) #899D80FF srgba(137,157,128,1)
+         4: (138,158,128,255) #8A9E80FF srgba(138,158,128,1)
+         3: (139,157,127,255) #8B9D7FFF srgba(139,157,127,1)
+         2: (139,158,127,255) #8B9E7FFF srgba(139,158,127,1)
+         6: (140,159,127,255) #8C9F7FFF srgba(140,159,127,1)
+         3: (142,160,126,255) #8EA07EFF srgba(142,160,126,1)
+         2: (143,160,126,255) #8FA07EFF srgba(143,160,126,1)
+        15: (143,161,125,255) #8FA17DFF srgba(143,161,125,1)
+         1: (144,162,125,255) #90A27DFF srgba(144,162,125,1)
+         5: (146,163,124,255) #92A37CFF srgba(146,163,124,1)
+         1: (147,163,124,255) #93A37CFF srgba(147,163,124,1)
+         1: (147,164,123,255) #93A47BFF srgba(147,164,123,1)
+         2: (149,164,123,255) #95A47BFF srgba(149,164,123,1)
+         7: (150,165,122,255) #96A57AFF srgba(150,165,122,1)
+         2: (151,165,123,255) #97A57BFF srgba(151,165,123,1)
+         8: (151,166,122,255) #97A67AFF srgba(151,166,122,1)
+        20: (152,167,122,255) #98A77AFF srgba(152,167,122,1)
+         2: (153,168,121,255) #99A879FF srgba(153,168,121,1)
+         1: (153,169,120,255) #99A978FF srgba(153,169,120,1)
+         4: (154,169,121,255) #9AA979FF srgba(154,169,121,1)
+         2: (155,170,120,255) #9BAA78FF srgba(155,170,120,1)
+         1: (156,170,119,255) #9CAA77FF srgba(156,170,119,1)
+         7: (158,171,119,255) #9EAB77FF srgba(158,171,119,1)
+         6: (159,172,118,255) #9FAC76FF srgba(159,172,118,1)
+         2: (160,172,118,255) #A0AC76FF srgba(160,172,118,1)
+         2: (161,173,118,255) #A1AD76FF srgba(161,173,118,1)
+         2: (162,174,117,255) #A2AE75FF srgba(162,174,117,1)
+         2: (164,175,116,255) #A4AF74FF srgba(164,175,116,1)
+         6: (165,176,116,255) #A5B074FF srgba(165,176,116,1)
+         1: (166,176,115,255) #A6B073FF srgba(166,176,115,1)
+         4: (167,177,115,255) #A7B173FF srgba(167,177,115,1)
+         1: (168,177,115,255) #A8B173FF srgba(168,177,115,1)
+         4: (169,179,114,255) #A9B372FF srgba(169,179,114,1)
+         3: (170,179,114,255) #AAB372FF srgba(170,179,114,1)
+         4: (172,180,113,255) #ACB471FF srgba(172,180,113,1)
+         5: (174,182,112,255) #AEB670FF srgba(174,182,112,1)
+         2: (175,182,112,255) #AFB670FF srgba(175,182,112,1)
+         8: (176,182,111,255) #B0B66FFF srgba(176,182,111,1)
+         1: (177,183,111,255) #B1B76FFF srgba(177,183,111,1)
+         4: (177,184,111,255) #B1B86FFF srgba(177,184,111,1)
+        12: (178,184,110,255) #B2B86EFF srgba(178,184,110,1)
+         2: (179,185,110,255) #B3B96EFF srgba(179,185,110,1)
+         8: (180,185,109,255) #B4B96DFF srgba(180,185,109,1)
+         9: (181,186,110,255) #B5BA6EFF srgba(181,186,110,1)
+         1: (181,187,109,255) #B5BB6DFF srgba(181,187,109,1)
+         2: (182,187,108,255) #B6BB6CFF srgba(182,187,108,1)
+        17: (184,187,108,255) #B8BB6CFF srgba(184,187,108,1)
+         5: (185,188,107,255) #B9BC6BFF srgba(185,188,107,1)
+         1: (185,189,108,255) #B9BD6CFF srgba(185,189,108,1)
+         2: (187,190,106,255) #BBBE6AFF srgba(187,190,106,1)
+         2: (188,190,107,255) #BCBE6BFF srgba(188,190,107,1)
+         2: (189,191,106,255) #BDBF6AFF srgba(189,191,106,1)
+         2: (189,192,105,255) #BDC069FF srgba(189,192,105,1)
+         6: (190,192,105,255) #BEC069FF srgba(190,192,105,1)
+        11: (192,194,104,255) #C0C268FF srgba(192,194,104,1)
+         2: (193,194,104,255) #C1C268FF srgba(193,194,104,1)
+         4: (195,195,103,255) #C3C367FF srgba(195,195,103,1)
+        49: (196,196,103,255) #C4C467FF srgba(196,196,103,1)
+         3: (197,197,102,255) #C5C566FF srgba(197,197,102,1)
+         4: (198,197,102,255) #C6C566FF srgba(198,197,102,1)
+         3: (199,198,102,255) #C7C666FF srgba(199,198,102,1)
+        68: (200,199,101,255) #C8C765FF srgba(200,199,101,1)
+         2: (201,200,101,255) #C9C865FF srgba(201,200,101,1)
+         5: (202,200,100,255) #CAC864FF srgba(202,200,100,1)
+         3: (203,200,100,255) #CBC864FF srgba(203,200,100,1)
+         4: (204,201, 99,255) #CCC963FF srgba(204,201,99,1)
+         1: (204,201,100,255) #CCC964FF srgba(204,201,100,1)
+        63: (206,202, 99,255) #CECA63FF srgba(206,202,99,1)
+         5: (207,203, 98,255) #CFCB62FF srgba(207,203,98,1)
+        13: (208,204, 98,255) #D0CC62FF srgba(208,204,98,1)
+         2: (208,212,204,255) #D0D4CCFF srgba(208,212,204,1)
+         2: (209,205, 97,255) #D1CD61FF srgba(209,205,97,1)
+         1: (209,209,207,255) #D1D1CFFF srgba(209,209,207,1)
+        13: (210,205, 97,255) #D2CD61FF srgba(210,205,97,1)
+         3: (210,214,206,255) #D2D6CEFF srgba(210,214,206,1)
+         4: (211,206, 97,255) #D3CE61FF srgba(211,206,97,1)
+       859: (211,215,207,255) #D3D7CFFF srgba(211,215,207,1)
+         7: (212,206, 96,255) #D4CE60FF srgba(212,206,96,1)
+         4: (213,207, 96,255) #D5CF60FF srgba(213,207,96,1)
+         8: (214,207, 96,255) #D6CF60FF srgba(214,207,96,1)
+        10: (215,208, 95,255) #D7D05FFF srgba(215,208,95,1)
+        25: (216,209, 94,255) #D8D15EFF srgba(216,209,94,1)
+         9: (216,209, 95,255) #D8D15FFF srgba(216,209,95,1)
+         4: (216,210, 94,255) #D8D25EFF srgba(216,210,94,1)
+         6: (217,210, 93,255) #D9D25DFF srgba(217,210,93,1)
+        15: (218,211, 94,255) #DAD35EFF srgba(218,211,94,1)
+         6: (219,211, 92,255) #DBD35CFF srgba(219,211,92,1)
+         1: (219,212, 93,255) #DBD45DFF srgba(219,212,93,1)
+         2: (220,212, 93,255) #DCD45DFF srgba(220,212,93,1)
+        19: (221,212, 92,255) #DDD45CFF srgba(221,212,92,1)
+         4: (222,213, 91,255) #DED55BFF srgba(222,213,91,1)
+         3: (223,214, 91,255) #DFD65BFF srgba(223,214,91,1)
+        53: (224,215, 91,255) #E0D75BFF srgba(224,215,91,1)
+         4: (225,215, 90,255) #E1D75AFF srgba(225,215,90,1)
+         2: (226,216, 90,255) #E2D85AFF srgba(226,216,90,1)
+        17: (227,217, 89,255) #E3D959FF srgba(227,217,89,1)
+        11: (228,218, 89,255) #E4DA59FF srgba(228,218,89,1)
+         1: (229,217, 89,255) #E5D959FF srgba(229,217,89,1)
+         4: (230,218, 88,255) #E6DA58FF srgba(230,218,88,1)
+        14: (231,219, 88,255) #E7DB58FF srgba(231,219,88,1)
+         2: (232,220, 87,255) #E8DC57FF srgba(232,220,87,1)
+     69119: (232,232,231,255) #E8E8E7FF srgba(232,232,231,1)
+         4: (233,221, 87,255) #E9DD57FF srgba(233,221,87,1)
+        42: (234,221, 87,255) #EADD57FF srgba(234,221,87,1)
+        15: (234,222, 86,255) #EADE56FF srgba(234,222,86,1)
+         8: (235,222, 86,255) #EBDE56FF srgba(235,222,86,1)
+        13: (236,223, 86,255) #ECDF56FF srgba(236,223,86,1)
+         3: (237,224, 85,255) #EDE055FF srgba(237,224,85,1)
+        22: (238,224, 85,255) #EEE055FF srgba(238,224,85,1)
+         8: (239,224, 84,255) #EFE054FF srgba(239,224,84,1)
+        17: (240,225, 84,255) #F0E154FF srgba(240,225,84,1)
+         7: (241,226, 84,255) #F1E254FF srgba(241,226,84,1)
+        14: (242,226, 83,255) #F2E253FF srgba(242,226,83,1)
+         4: (242,227, 83,255) #F2E353FF srgba(242,227,83,1)
+        10: (243,227, 83,255) #F3E353FF srgba(243,227,83,1)
+        25: (244,228, 82,255) #F4E452FF srgba(244,228,82,1)
+         3: (245,229, 82,255) #F5E552FF srgba(245,229,82,1)
+        13: (246,229, 82,255) #F6E552FF srgba(246,229,82,1)
+        25: (246,230, 82,255) #F6E652FF srgba(246,230,82,1)
+        11: (247,229, 81,255) #F7E551FF srgba(247,229,81,1)
+        14: (248,230, 80,255) #F8E650FF srgba(248,230,80,1)
+         3: (249,231, 81,255) #F9E751FF srgba(249,231,81,1)
+        12: (250,231, 80,255) #FAE750FF srgba(250,231,80,1)
+         5: (250,232, 79,255) #FAE84FFF srgba(250,232,79,1)
+        19: (251,232, 80,255) #FBE850FF srgba(251,232,80,1)
+       882: (252,233, 79,255) #FCE94FFF srgba(252,233,79,1)
+  Rendering intent: Perceptual
+  Gamma: 0.454545
+  Chromaticity:
+    red primary: (0.64,0.33)
+    green primary: (0.3,0.6)
+    blue primary: (0.15,0.06)
+    white point: (0.3127,0.329)
+  Background color: white
+  Border color: srgba(223,223,223,1)
+  Matte color: grey74
+  Transparent color: none
+  Interlace: None
+  Intensity: Undefined
+  Compose: Over
+  Page geometry: 1920x1080+0+0
+  Dispose: Undefined
+  Iterations: 0
+  Compression: Zip
+  Orientation: Undefined
+  Properties:
+    date:create: 2016-08-28T15:23:12+01:00
+    date:modify: 2016-08-28T15:23:12+01:00
+    png:bKGD: chunk was found (see Background color, above)
+    png:IHDR.bit-depth-orig: 8
+    png:IHDR.bit_depth: 8
+    png:IHDR.color-type-orig: 6
+    png:IHDR.color_type: 6 (RGBA)
+    png:IHDR.interlace_method: 0 (Not interlaced)
+    png:IHDR.width,height: 1920, 1080
+    png:pHYs: x_res=2835, y_res=2835, units=1
+    png:sRGB: intent=0 (Perceptual Intent)
+    png:tIME: 2016-08-08T21:04:28Z
+    signature: 1d6beb4912b57dccdbe07d81279a116d866fdd29bc955f5e79215ac148b0ae75
+  Artifacts:
+    filename: /tmp/LCUXoE_attachmentView.png
+    verbose: true
+  Tainted: False
+  Filesize: 57.5KB
+  Number pixels: 2.074M
+  Pixels per second: 345.6GB
+  User time: 0.000u
+  Elapsed time: 0:01.000
+  Version: ImageMagick 6.9.3-0 Q16 x86_64 2016-02-03 http://www.imagemagick.org
diff --git c/contrib/keybase/decrypt.sh w/contrib/keybase/decrypt.sh
new file mode 100755
index 0000000..73d37b2
--- /dev/null
+++ w/contrib/keybase/decrypt.sh
@@ -0,0 +1,2 @@
+#!/bin/sh
+sed -n 's/^.*BEGIN KEYBASE/BEGIN KEYBASE/p' | keybase decrypt
diff --git c/contrib/keybase/install.sh w/contrib/keybase/install.sh
new file mode 100644
index 0000000..5466d04
--- /dev/null
+++ w/contrib/keybase/install.sh
@@ -0,0 +1,59 @@
+#!/bin/sh
+
+# If no directory exists, make it exist.
+if [ -d "$HOME/.mutt/keybaseMutt" ]; then
+
+	# If someone already has a backup, complain.
+	if [ -d "$HOME/.mutt/keybaseMuttBACKUP" ]; then
+		#echo "$HOME/.mutt/keybaseMuttBACKUP exists"
+		echo "You are going to overwrite your backup. Are you sure you want to do this? [y|n]"
+		read -r overwrite
+
+		# If they want to delete their backup.
+		if [ "$overwrite" = 'y' ]; then
+			cp -R "$HOME/.mutt/keybaseMutt" "$HOME/.mutt/keybaseMuttBACKUP"
+			rm -r "$HOME/.mutt/keybaseMutt"
+			mkdir -p "$HOME/.mutt/keybaseMutt/scripts"
+
+		# Otherwise, abort mission.
+		else
+			echo "ABORT! ABORT! ABORT!"
+			exit 1
+		fi
+
+	elif [ ! -d "$HOME/.mutt/keybaseMuttBACKUP" ]; then
+		echo "Backing up previous install."
+		cp -R "$HOME/.mutt/keybaseMutt" "$HOME/.mutt/keybaseMuttBACKUP"
+		rm -r "$HOME/.mutt/keybaseMutt"
+		mkdir -p "$HOME/.mutt/keybaseMutt/scripts"
+	fi
+# Otherwise, make a backup
+elif [ ! -d "$HOME/.mutt/keybaseMutt" ]; then
+	echo "Installing your program..."
+	mkdir -p "$HOME/.mutt/keybaseMutt/scripts"
+
+fi
+
+# Copy my directory to your directory.
+cp ./keybase.py  "$HOME/.mutt/keybaseMutt"
+cp ./pgpdecrypt.sh "$HOME/.mutt/keybaseMutt/scripts"
+cp ./decrypt.sh "$HOME/.mutt/keybaseMutt/scripts"
+cp ./verify.sh "$HOME/.mutt/keybaseMutt/scripts"
+cp ./pgpverify.sh "$HOME/.mutt/keybaseMutt/scripts"
+
+# Yay! Stuff's installed!
+echo "You'll need to include a path to '~/.mutt/keybaseMutt/scripts' in your shell's rc file. If you've done this previously on your computer, press 'n'."
+echo "Do you use [b]ash, [k]sh, or [z]sh? [n]"
+echo "(You use $SHELL)"
+read -r shellInput
+if [ "$shellInput" = 'b' ]; then
+	echo 'export PATH="$PATH:~/.mutt/keybaseMutt/scripts"' >> "$HOME/.bashrc"
+elif [ "$shellInput" = 'k' ]; then
+	echo 'export PATH="$PATH:~/.mutt/keybaseMutt/scripts"' >> "$HOME/.kshrc"
+elif [ "$shellInput" = 'z' ]; then
+	echo 'export PATH="$PATH:~/.mutt/keybaseMutt/scripts"' >> "$HOME/.zshrc"
+else 
+	echo "If you use something another shell, you'll need to add the path manually."
+fi
+
+echo "Please restart your shell to be able to use the scripts (closing and reopening the terminal is easiest)."
diff --git c/contrib/keybase/keybase.py w/contrib/keybase/keybase.py
new file mode 100644
index 0000000..33a6e1d
--- /dev/null
+++ w/contrib/keybase/keybase.py
@@ -0,0 +1,60 @@
+#! /usr/bin/env python
+# Written by Joshua Jordi
+
+import os
+
+def helpfunc():
+    print("Run keybase commands here as if you were using keybase. WARNING: this program is not capable of MIME formatting. Only inline.")
+    print("To encrypt, use keybase syntax. (ie. 'keybase encrypt jakkinstewart' or 'keybase pgp encrypt jakkinstewart') Do not include a '-i' or '-o'. This script uses them in the background. Including either flag will mess with the script. (Unless that's what you want to do.)")
+    print("Don't worry about finding or attaching the file, the macro will take care of that.")
+    print("To sign, give it the style ('sign' or 'pgp sign'. It will automatically include the signature in the file.")
+    print("This program will not be able to decrypt or verify messages. I've created separate scripts for that.")
+    print('Type "quit" to quit.')
+
+def encryptSign(parameters):
+    os.system('echo $HOME > .file')
+    directory = open('.file', 'r')
+    pwd = directory.read().strip('\n')
+    directory.close()
+    tmp = open("%s/.mutt/keybaseMutt/.tmp" % pwd, "r")
+    tmp = tmp.read().strip("\n")
+    print("Working....")
+    os.system('%s -i %s -o %s' % (parameters, tmp, tmp))
+    print("Done!")
+
+#def sign(parameters):
+#    os.system('pwd > .file')
+#    directory = open('.file', 'r')
+#    pwd = directory.read().strip('\n')
+#    directory.close()
+#    tmp = open('%s/.mutt/keybaseMutt/.tmp' % pwd, 'r')
+#    tmp = tmp.read().strip('\n')
+#    print("Working...")
+#    os.system('%s -i %s -o %s' % (parameters, tmp, tmp))
+#    print("Done!")
+
+exitVar = ''
+
+print("Type help to learn how to use me.")
+
+while exitVar.lower() != 'quit':
+    inputStuffs = input('mutt#: ')
+    if (inputStuffs.lower() == 'help'):
+        helpfunc()
+
+    elif ('encrypt' in inputStuffs):
+        encryptSign(inputStuffs)
+
+    #elif ('decrypt' in inputStuffs):
+    #    decrypt(inputStuffs)
+
+    elif ('sign' in inputStuffs):
+        encryptSign(inputStuffs)
+
+    elif ('quit' in inputStuffs or 'exit' in inputStuffs):
+        exitVar = 'quit'
+
+    else:
+        print("You didn't use a known keybase command.")
+
+os.system('rm .file')
diff --git c/contrib/keybase/muttrc w/contrib/keybase/muttrc
new file mode 100644
index 0000000..ff65db9
--- /dev/null
+++ w/contrib/keybase/muttrc
@@ -0,0 +1,2 @@
+set editor = 'echo %s > ~/.mutt/keybaseMutt/.tmp; vim %s'
+macro compose K "<enter-command>unset wait_key<enter><shell-escape>python ~/.mutt/keybaseMutt/keybase.py<enter><enter-command>set wait_key<enter>
diff --git c/contrib/keybase/pagerMode.png w/contrib/keybase/pagerMode.png
new file mode 100644
index 0000000..52d5989
--- /dev/null
+++ w/contrib/keybase/pagerMode.png
@@ -0,0 +1,854 @@
+Image: /tmp/Mp3D2x_pagerMode.png
+  Format: PNG (Portable Network Graphics)
+  Mime type: image/png
+  Class: DirectClass
+  Geometry: 1920x1080+0+0
+  Resolution: 28.35x28.35
+  Print size: 67.7249x38.0952
+  Units: PixelsPerCentimeter
+  Type: TrueColorAlpha
+  Endianess: Undefined
+  Colorspace: sRGB
+  Depth: 8-bit
+  Channel depth:
+    red: 8-bit
+    green: 8-bit
+    blue: 8-bit
+    alpha: 1-bit
+  Channel statistics:
+    Pixels: 2073600
+    Red:
+      min: 0 (0)
+      max: 252 (0.988235)
+      mean: 11.7944 (0.0462526)
+      standard deviation: 44.941 (0.176239)
+      kurtosis: 18.4131
+      skewness: 4.39526
+      entropy: 0.105298
+    Green:
+      min: 0 (0)
+      max: 233 (0.913725)
+      mean: 16.1722 (0.0634204)
+      standard deviation: 50.6401 (0.198589)
+      kurtosis: 10.1704
+      skewness: 3.31685
+      entropy: 0.107892
+    Blue:
+      min: 0 (0)
+      max: 231 (0.905882)
+      mean: 18.5708 (0.0728267)
+      standard deviation: 55.6317 (0.218164)
+      kurtosis: 6.86178
+      skewness: 2.88999
+      entropy: 0.11074
+    Alpha:
+      min: 255 (1)
+      max: 255 (1)
+      mean: 255 (1)
+      standard deviation: 0 (0)
+      kurtosis: 0
+      skewness: 0
+      entropy: 0
+  Image statistics:
+    Overall:
+      min: 0 (0)
+      max: 252 (0.988235)
+      mean: 11.6344 (0.0456249)
+      standard deviation: 43.815 (0.171823)
+      kurtosis: 16.7758
+      skewness: 4.23948
+      entropy: 0.0809827
+  Colors: 749
+  Histogram:
+   1827461: (  0,  0,  0,255) #000000FF black
+       195: (  0,  0,  1,255) #000001FF srgba(0,0,1,1)
+        33: (  0,  0,  2,255) #000002FF srgba(0,0,2,1)
+         3: (  0,  0,  3,255) #000003FF srgba(0,0,3,1)
+         7: (  0,  1,  0,255) #000100FF srgba(0,1,0,1)
+       114: (  0,  1,  1,255) #000101FF srgba(0,1,1,1)
+         8: (  0,  1,  2,255) #000102FF srgba(0,1,2,1)
+         7: (  0,  1,  3,255) #000103FF srgba(0,1,3,1)
+         9: (  0,  1,  4,255) #000104FF srgba(0,1,4,1)
+        64: (  0,  2,  2,255) #000202FF srgba(0,2,2,1)
+         1: (  0,  2,  3,255) #000203FF srgba(0,2,3,1)
+         9: (  0,  2,  5,255) #000205FF srgba(0,2,5,1)
+         3: (  0,  2,  6,255) #000206FF srgba(0,2,6,1)
+        21: (  0,  3,  3,255) #000303FF srgba(0,3,3,1)
+        95: (  0,  4,  4,255) #000404FF srgba(0,4,4,1)
+        62: (  0,  5,  5,255) #000505FF srgba(0,5,5,1)
+        42: (  0,  6,  6,255) #000606FF srgba(0,6,6,1)
+        56: (  0,  7,  7,255) #000707FF srgba(0,7,7,1)
+        36: (  0,  8,  8,255) #000808FF srgba(0,8,8,1)
+        12: (  0,  9,  9,255) #000909FF srgba(0,9,9,1)
+        44: (  0, 10, 10,255) #000A0AFF srgba(0,10,10,1)
+        54: (  0, 11, 11,255) #000B0BFF srgba(0,11,11,1)
+        29: (  0, 12, 12,255) #000C0CFF srgba(0,12,12,1)
+         7: (  0, 13, 13,255) #000D0DFF srgba(0,13,13,1)
+         3: (  1,  0,  0,255) #010000FF srgba(1,0,0,1)
+         4: (  1,  0,  1,255) #010001FF srgba(1,0,1,1)
+         1: (  1,  1,  0,255) #010100FF srgba(1,1,0,1)
+       156: (  1,  1,  1,255) #010101FF srgba(1,1,1,1)
+        17: (  1,  1,  2,255) #010102FF srgba(1,1,2,1)
+         2: (  1,  1,  4,255) #010104FF srgba(1,1,4,1)
+         4: (  1,  2,  2,255) #010202FF srgba(1,2,2,1)
+         2: (  1,  2,  4,255) #010204FF srgba(1,2,4,1)
+         1: (  1,  2,  5,255) #010205FF srgba(1,2,5,1)
+         2: (  1,  3,  6,255) #010306FF srgba(1,3,6,1)
+        15: (  1, 13, 13,255) #010D0DFF srgba(1,13,13,1)
+        22: (  1, 14, 14,255) #010E0EFF srgba(1,14,14,1)
+         9: (  1, 15, 15,255) #010F0FFF srgba(1,15,15,1)
+         8: (  1, 15, 16,255) #010F10FF srgba(1,15,16,1)
+        22: (  1, 16, 16,255) #011010FF srgba(1,16,16,1)
+         4: (  1, 17, 17,255) #011111FF srgba(1,17,17,1)
+         5: (  1, 17, 18,255) #011112FF srgba(1,17,18,1)
+        11: (  1, 18, 18,255) #011212FF srgba(1,18,18,1)
+         3: (  1, 18, 19,255) #011213FF srgba(1,18,19,1)
+        21: (  1, 19, 19,255) #011313FF srgba(1,19,19,1)
+         6: (  1, 20, 20,255) #011414FF srgba(1,20,20,1)
+        15: (  1, 20, 21,255) #011415FF srgba(1,20,21,1)
+        51: (  1, 21, 21,255) #011515FF srgba(1,21,21,1)
+         9: (  1, 21, 22,255) #011516FF srgba(1,21,22,1)
+        14: (  1, 22, 22,255) #011616FF srgba(1,22,22,1)
+         8: (  1, 23, 23,255) #011717FF srgba(1,23,23,1)
+        51: (  1, 23, 24,255) #011718FF srgba(1,23,24,1)
+         9: (  1, 24, 24,255) #011818FF srgba(1,24,24,1)
+        23: (  1, 24, 25,255) #011819FF srgba(1,24,25,1)
+        10: (  1, 25, 25,255) #011919FF srgba(1,25,25,1)
+        18: (  1, 26, 26,255) #011A1AFF srgba(1,26,26,1)
+        17: (  1, 26, 27,255) #011A1BFF srgba(1,26,27,1)
+        20: (  1, 27, 27,255) #011B1BFF srgba(1,27,27,1)
+        12: (  1, 27, 28,255) #011B1CFF srgba(1,27,28,1)
+        35: (  1, 28, 28,255) #011C1CFF srgba(1,28,28,1)
+        14: (  1, 29, 29,255) #011D1DFF srgba(1,29,29,1)
+         9: (  1, 29, 30,255) #011D1EFF srgba(1,29,30,1)
+         8: (  1, 30, 30,255) #011E1EFF srgba(1,30,30,1)
+        17: (  1, 30, 31,255) #011E1FFF srgba(1,30,31,1)
+         9: (  1, 31, 31,255) #011F1FFF srgba(1,31,31,1)
+        10: (  1, 32, 32,255) #012020FF srgba(1,32,32,1)
+        12: (  1, 32, 33,255) #012021FF srgba(1,32,33,1)
+        54: (  1, 33, 33,255) #012121FF srgba(1,33,33,1)
+        14: (  1, 33, 34,255) #012122FF srgba(1,33,34,1)
+         7: (  1, 34, 34,255) #012222FF srgba(1,34,34,1)
+         5: (  1, 35, 35,255) #012323FF srgba(1,35,35,1)
+        26: (  1, 35, 36,255) #012324FF srgba(1,35,36,1)
+         8: (  1, 36, 36,255) #012424FF srgba(1,36,36,1)
+        13: (  1, 36, 37,255) #012425FF srgba(1,36,37,1)
+         5: (  1, 37, 37,255) #012525FF srgba(1,37,37,1)
+       113: (  1, 38, 38,255) #012626FF srgba(1,38,38,1)
+         1: (  2,  1,  2,255) #020102FF srgba(2,1,2,1)
+        71: (  2,  2,  2,255) #020202FF srgba(2,2,2,1)
+         1: (  2,  2,  3,255) #020203FF srgba(2,2,3,1)
+         1: (  2,  3,  6,255) #020306FF srgba(2,3,6,1)
+         1: (  2,  4,  7,255) #020407FF srgba(2,4,7,1)
+         2: (  2, 38, 39,255) #022627FF srgba(2,38,39,1)
+         8: (  2, 39, 39,255) #022727FF srgba(2,39,39,1)
+        12: (  2, 39, 40,255) #022728FF srgba(2,39,40,1)
+        33: (  2, 40, 40,255) #022828FF srgba(2,40,40,1)
+         2: (  2, 41, 41,255) #022929FF srgba(2,41,41,1)
+         9: (  2, 41, 42,255) #02292AFF srgba(2,41,42,1)
+         1: (  2, 42, 42,255) #022A2AFF srgba(2,42,42,1)
+        67: (  2, 42, 43,255) #022A2BFF srgba(2,42,43,1)
+        10: (  2, 43, 43,255) #022B2BFF srgba(2,43,43,1)
+        10: (  2, 44, 44,255) #022C2CFF srgba(2,44,44,1)
+        15: (  2, 44, 45,255) #022C2DFF srgba(2,44,45,1)
+        71: (  2, 45, 45,255) #022D2DFF srgba(2,45,45,1)
+        17: (  2, 45, 46,255) #022D2EFF srgba(2,45,46,1)
+        24: (  2, 46, 47,255) #022E2FFF srgba(2,46,47,1)
+        19: (  2, 47, 48,255) #022F30FF srgba(2,47,48,1)
+         5: (  2, 48, 48,255) #023030FF srgba(2,48,48,1)
+         9: (  2, 48, 49,255) #023031FF srgba(2,48,49,1)
+        57: (  2, 49, 50,255) #023132FF srgba(2,49,50,1)
+         9: (  2, 50, 51,255) #023233FF srgba(2,50,51,1)
+         9: (  2, 51, 51,255) #023333FF srgba(2,51,51,1)
+        13: (  2, 51, 52,255) #023334FF srgba(2,51,52,1)
+        52: (  2, 52, 53,255) #023435FF srgba(2,52,53,1)
+        25: (  2, 53, 54,255) #023536FF srgba(2,53,54,1)
+         9: (  2, 54, 54,255) #023636FF srgba(2,54,54,1)
+        29: (  2, 54, 55,255) #023637FF srgba(2,54,55,1)
+         6: (  2, 55, 56,255) #023738FF srgba(2,55,56,1)
+         7: (  2, 56, 57,255) #023839FF srgba(2,56,57,1)
+         7: (  2, 57, 57,255) #023939FF srgba(2,57,57,1)
+        20: (  2, 57, 58,255) #02393AFF srgba(2,57,58,1)
+        24: (  2, 58, 59,255) #023A3BFF srgba(2,58,59,1)
+        76: (  2, 59, 60,255) #023B3CFF srgba(2,59,60,1)
+         5: (  2, 60, 60,255) #023C3CFF srgba(2,60,60,1)
+         7: (  2, 60, 61,255) #023C3DFF srgba(2,60,61,1)
+        38: (  2, 61, 62,255) #023D3EFF srgba(2,61,62,1)
+         4: (  2, 62, 63,255) #023E3FFF srgba(2,62,63,1)
+         5: (  2, 63, 63,255) #023F3FFF srgba(2,63,63,1)
+         5: (  2, 63, 64,255) #023F40FF srgba(2,63,64,1)
+         1: (  3,  3,  2,255) #030302FF srgba(3,3,2,1)
+       135: (  3,  3,  3,255) #030303FF grey1
+         1: (  3,  3,  4,255) #030304FF srgba(3,3,4,1)
+         1: (  3,  4,  4,255) #030404FF srgba(3,4,4,1)
+       117: (  3, 64, 65,255) #034041FF srgba(3,64,65,1)
+        14: (  3, 65, 66,255) #034142FF srgba(3,65,66,1)
+        10: (  3, 66, 66,255) #034242FF srgba(3,66,66,1)
+        32: (  3, 66, 67,255) #034243FF srgba(3,66,67,1)
+        18: (  3, 67, 68,255) #034344FF srgba(3,67,68,1)
+         7: (  3, 68, 69,255) #034445FF srgba(3,68,69,1)
+        12: (  3, 69, 69,255) #034545FF srgba(3,69,69,1)
+         2: (  3, 69, 70,255) #034546FF srgba(3,69,70,1)
+        27: (  3, 70, 71,255) #034647FF srgba(3,70,71,1)
+         9: (  3, 71, 72,255) #034748FF srgba(3,71,72,1)
+         8: (  3, 72, 72,255) #034848FF srgba(3,72,72,1)
+        21: (  3, 72, 73,255) #034849FF srgba(3,72,73,1)
+        24: (  3, 73, 74,255) #03494AFF srgba(3,73,74,1)
+         2: (  3, 74, 75,255) #034A4BFF srgba(3,74,75,1)
+        17: (  3, 75, 75,255) #034B4BFF srgba(3,75,75,1)
+         6: (  3, 75, 76,255) #034B4CFF srgba(3,75,76,1)
+        65: (  3, 76, 77,255) #034C4DFF srgba(3,76,77,1)
+         8: (  3, 77, 78,255) #034D4EFF srgba(3,77,78,1)
+        14: (  3, 77, 79,255) #034D4FFF srgba(3,77,79,1)
+        20: (  3, 78, 79,255) #034E4FFF srgba(3,78,79,1)
+        31: (  3, 79, 80,255) #034F50FF srgba(3,79,80,1)
+         3: (  3, 80, 81,255) #035051FF srgba(3,80,81,1)
+        16: (  3, 80, 82,255) #035052FF srgba(3,80,82,1)
+        14: (  3, 81, 82,255) #035152FF srgba(3,81,82,1)
+        20: (  3, 82, 83,255) #035253FF srgba(3,82,83,1)
+        18: (  3, 83, 84,255) #035354FF srgba(3,83,84,1)
+         8: (  3, 83, 85,255) #035355FF srgba(3,83,85,1)
+         1: (  3, 84, 85,255) #035455FF srgba(3,84,85,1)
+        13: (  3, 85, 86,255) #035556FF srgba(3,85,86,1)
+         3: (  3, 86, 87,255) #035657FF srgba(3,86,87,1)
+         5: (  3, 86, 88,255) #035658FF srgba(3,86,88,1)
+         8: (  3, 87, 88,255) #035758FF srgba(3,87,88,1)
+        26: (  3, 88, 89,255) #035859FF srgba(3,88,89,1)
+         5: (  4,  4,  3,255) #040403FF srgba(4,4,3,1)
+        49: (  4,  4,  4,255) #040404FF srgba(4,4,4,1)
+         2: (  4,  4,  5,255) #040405FF srgba(4,4,5,1)
+         1: (  4,  4,  6,255) #040406FF srgba(4,4,6,1)
+         6: (  4,  5,  4,255) #040504FF srgba(4,5,4,1)
+         1: (  4,  5,  5,255) #040505FF srgba(4,5,5,1)
+         7: (  4, 89, 90,255) #04595AFF srgba(4,89,90,1)
+        14: (  4, 89, 91,255) #04595BFF srgba(4,89,91,1)
+         2: (  4, 90, 91,255) #045A5BFF srgba(4,90,91,1)
+        19: (  4, 91, 92,255) #045B5CFF srgba(4,91,92,1)
+        10: (  4, 92, 93,255) #045C5DFF srgba(4,92,93,1)
+        16: (  4, 92, 94,255) #045C5EFF srgba(4,92,94,1)
+        12: (  4, 93, 94,255) #045D5EFF srgba(4,93,94,1)
+        17: (  4, 94, 95,255) #045E5FFF srgba(4,94,95,1)
+        11: (  4, 95, 96,255) #045F60FF srgba(4,95,96,1)
+        11: (  4, 95, 97,255) #045F61FF srgba(4,95,97,1)
+         9: (  4, 96, 97,255) #046061FF srgba(4,96,97,1)
+        13: (  4, 97, 98,255) #046162FF srgba(4,97,98,1)
+         4: (  4, 98, 99,255) #046263FF srgba(4,98,99,1)
+         5: (  4, 98,100,255) #046264FF srgba(4,98,100,1)
+         6: (  4, 99,100,255) #046364FF srgba(4,99,100,1)
+         9: (  4,100,101,255) #046465FF srgba(4,100,101,1)
+         8: (  4,101,102,255) #046566FF srgba(4,101,102,1)
+        17: (  4,101,103,255) #046567FF srgba(4,101,103,1)
+       117: (  4,102,103,255) #046667FF srgba(4,102,103,1)
+        18: (  4,103,104,255) #046768FF srgba(4,103,104,1)
+         9: (  4,104,105,255) #046869FF srgba(4,104,105,1)
+        17: (  4,104,106,255) #04686AFF srgba(4,104,106,1)
+        23: (  4,105,106,255) #04696AFF srgba(4,105,106,1)
+        46: (  4,106,107,255) #046A6BFF srgba(4,106,107,1)
+        13: (  4,107,108,255) #046B6CFF srgba(4,107,108,1)
+         4: (  4,107,109,255) #046B6DFF srgba(4,107,109,1)
+         3: (  4,108,109,255) #046C6DFF srgba(4,108,109,1)
+        15: (  4,108,110,255) #046C6EFF srgba(4,108,110,1)
+         3: (  4,109,111,255) #046D6FFF srgba(4,109,111,1)
+         7: (  4,110,111,255) #046E6FFF srgba(4,110,111,1)
+         8: (  4,110,112,255) #046E70FF srgba(4,110,112,1)
+        26: (  4,111,112,255) #046F70FF srgba(4,111,112,1)
+         7: (  4,111,113,255) #046F71FF srgba(4,111,113,1)
+         5: (  4,112,114,255) #047072FF srgba(4,112,114,1)
+        15: (  4,113,114,255) #047172FF srgba(4,113,114,1)
+        19: (  4,113,115,255) #047173FF srgba(4,113,115,1)
+        45: (  4,114,115,255) #047273FF srgba(4,114,115,1)
+        35: (  5,  5,  5,255) #050505FF grey2
+         1: (  5,  6,  6,255) #050606FF srgba(5,6,6,1)
+        17: (  5,114,116,255) #057274FF srgba(5,114,116,1)
+         1: (  5,115,117,255) #057375FF srgba(5,115,117,1)
+        14: (  5,116,117,255) #057475FF srgba(5,116,117,1)
+        66: (  5,116,118,255) #057476FF srgba(5,116,118,1)
+        11: (  5,117,118,255) #057576FF srgba(5,117,118,1)
+         6: (  5,118,120,255) #057678FF srgba(5,118,120,1)
+         7: (  5,119,120,255) #057778FF srgba(5,119,120,1)
+         2: (  5,119,121,255) #057779FF srgba(5,119,121,1)
+         6: (  5,120,122,255) #05787AFF srgba(5,120,122,1)
+        30: (  5,121,123,255) #05797BFF srgba(5,121,123,1)
+        12: (  5,123,124,255) #057B7CFF srgba(5,123,124,1)
+         8: (  5,123,125,255) #057B7DFF srgba(5,123,125,1)
+         7: (  5,124,126,255) #057C7EFF srgba(5,124,126,1)
+         1: (  5,125,126,255) #057D7EFF srgba(5,125,126,1)
+         8: (  5,125,127,255) #057D7FFF srgba(5,125,127,1)
+         4: (  5,126,127,255) #057E7FFF srgba(5,126,127,1)
+         5: (  5,126,128,255) #057E80FF srgba(5,126,128,1)
+         6: (  5,127,129,255) #057F81FF srgba(5,127,129,1)
+        13: (  5,128,129,255) #058081FF srgba(5,128,129,1)
+        55: (  5,128,130,255) #058082FF srgba(5,128,130,1)
+         2: (  5,129,130,255) #058182FF srgba(5,129,130,1)
+         3: (  5,129,131,255) #058183FF srgba(5,129,131,1)
+        26: (  5,130,132,255) #058284FF srgba(5,130,132,1)
+         5: (  5,131,132,255) #058384FF srgba(5,131,132,1)
+        20: (  5,131,133,255) #058385FF srgba(5,131,133,1)
+        15: (  5,132,133,255) #058485FF srgba(5,132,133,1)
+         3: (  5,132,134,255) #058486FF srgba(5,132,134,1)
+        73: (  5,133,135,255) #058587FF srgba(5,133,135,1)
+         6: (  5,134,135,255) #058687FF srgba(5,134,135,1)
+         2: (  5,134,136,255) #058688FF srgba(5,134,136,1)
+        10: (  5,135,136,255) #058788FF srgba(5,135,136,1)
+        14: (  5,135,137,255) #058789FF srgba(5,135,137,1)
+         8: (  5,136,138,255) #05888AFF srgba(5,136,138,1)
+        12: (  5,137,138,255) #05898AFF srgba(5,137,138,1)
+        12: (  5,137,139,255) #05898BFF srgba(5,137,139,1)
+        14: (  5,138,140,255) #058A8CFF srgba(5,138,140,1)
+        24: (  5,139,141,255) #058B8DFF srgba(5,139,141,1)
+         1: (  6,  6,  5,255) #060605FF srgba(6,6,5,1)
+        20: (  6,  6,  6,255) #060606FF srgba(6,6,6,1)
+         1: (  6,  7,  6,255) #060706FF srgba(6,7,6,1)
+         1: (  6,  7,  8,255) #060708FF srgba(6,7,8,1)
+         1: (  6,  8, 11,255) #06080BFF srgba(6,8,11,1)
+         6: (  6,139,141,255) #068B8DFF srgba(6,139,141,1)
+        10: (  6,140,142,255) #068C8EFF srgba(6,140,142,1)
+        42: (  6,141,143,255) #068D8FFF srgba(6,141,143,1)
+        40: (  6,142,144,255) #068E90FF srgba(6,142,144,1)
+        15: (  6,143,145,255) #068F91FF srgba(6,143,145,1)
+        20: (  6,144,146,255) #069092FF srgba(6,144,146,1)
+        40: (  6,145,147,255) #069193FF srgba(6,145,147,1)
+        31: (  6,146,148,255) #069294FF srgba(6,146,148,1)
+        28: (  6,147,149,255) #069395FF srgba(6,147,149,1)
+        39: (  6,148,150,255) #069496FF srgba(6,148,150,1)
+        23: (  6,149,151,255) #069597FF srgba(6,149,151,1)
+       132: (  6,150,152,255) #069698FF srgba(6,150,152,1)
+       109: (  6,151,153,255) #069799FF srgba(6,151,153,1)
+     29532: (  6,152,154,255) #06989AFF srgba(6,152,154,1)
+        21: (  7,  7,  6,255) #070706FF srgba(7,7,6,1)
+        84: (  7,  7,  7,255) #070707FF srgba(7,7,7,1)
+        22: (  7,  8,  7,255) #070807FF srgba(7,8,7,1)
+         1: (  7,  8,  9,255) #070809FF srgba(7,8,9,1)
+         1: (  7,  9, 12,255) #07090CFF srgba(7,9,12,1)
+         1: (  8,  8,  7,255) #080807FF srgba(8,8,7,1)
+        11: (  8,  8,  8,255) #080808FF grey3
+         1: (  8,  9,  8,255) #080908FF srgba(8,9,8,1)
+         3: (  8,  9,  9,255) #080909FF srgba(8,9,9,1)
+         1: (  9,  9,  8,255) #090908FF srgba(9,9,8,1)
+        24: (  9,  9,  9,255) #090909FF srgba(9,9,9,1)
+         1: (  9, 10,  9,255) #090A09FF srgba(9,10,9,1)
+        27: ( 10, 10, 10,255) #0A0A0AFF grey4
+         6: ( 11, 11, 11,255) #0B0B0BFF srgba(11,11,11,1)
+         5: ( 12, 12, 11,255) #0C0C0BFF srgba(12,12,11,1)
+         1: ( 12, 12, 12,255) #0C0C0CFF srgba(12,12,12,1)
+         9: ( 12, 13, 12,255) #0C0D0CFF srgba(12,13,12,1)
+         1: ( 13, 13, 12,255) #0D0D0CFF srgba(13,13,12,1)
+        41: ( 13, 13, 13,255) #0D0D0DFF grey5
+        10: ( 14, 14, 14,255) #0E0E0EFF srgba(14,14,14,1)
+        24: ( 15, 15, 15,255) #0F0F0FFF grey6
+         2: ( 15, 16, 15,255) #0F100FFF srgba(15,16,15,1)
+        14: ( 16, 16, 15,255) #10100FFF srgba(16,16,15,1)
+         6: ( 16, 16, 16,255) #101010FF srgba(16,16,16,1)
+        23: ( 16, 17, 16,255) #101110FF srgba(16,17,16,1)
+         1: ( 17, 17, 17,255) #111111FF srgba(17,17,17,1)
+         1: ( 17, 17, 18,255) #111112FF srgba(17,17,18,1)
+         6: ( 17, 18, 17,255) #111211FF srgba(17,18,17,1)
+        28: ( 18, 18, 18,255) #121212FF grey7
+         1: ( 18, 19, 20,255) #121314FF srgba(18,19,20,1)
+         1: ( 19, 19, 18,255) #131312FF srgba(19,19,18,1)
+         3: ( 19, 19, 19,255) #131313FF srgba(19,19,19,1)
+         2: ( 19, 20, 20,255) #131414FF srgba(19,20,20,1)
+        13: ( 20, 20, 19,255) #141413FF srgba(20,20,19,1)
+        11: ( 21, 21, 20,255) #151514FF srgba(21,21,20,1)
+         3: ( 21, 21, 21,255) #151515FF srgba(21,21,21,1)
+        12: ( 21, 22, 21,255) #151615FF srgba(21,22,21,1)
+        18: ( 22, 23, 22,255) #161716FF srgba(22,23,22,1)
+        24: ( 23, 24, 23,255) #171817FF srgba(23,24,23,1)
+        19: ( 24, 24, 24,255) #181818FF srgba(24,24,24,1)
+         4: ( 25, 25, 24,255) #191918FF srgba(25,25,24,1)
+        16: ( 25, 26, 25,255) #191A19FF srgba(25,26,25,1)
+         8: ( 26, 26, 25,255) #1A1A19FF srgba(26,26,25,1)
+        90: ( 26, 26, 26,255) #1A1A1AFF grey10
+       935: ( 26, 27, 26,255) #1A1B1AFF srgba(26,27,26,1)
+         1: ( 26, 27, 28,255) #1A1B1CFF srgba(26,27,28,1)
+        73: ( 27, 27, 27,255) #1B1B1BFF srgba(27,27,27,1)
+        19: ( 27, 28, 27,255) #1B1C1BFF srgba(27,28,27,1)
+      3160: ( 28, 28, 28,255) #1C1C1CFF grey11
+         8: ( 28, 29, 28,255) #1C1D1CFF srgba(28,29,28,1)
+        19: ( 29, 30, 28,255) #1D1E1CFF srgba(29,30,28,1)
+       867: ( 30, 30, 29,255) #1E1E1DFF srgba(30,30,29,1)
+     32137: ( 30, 30, 30,255) #1E1E1EFF srgba(30,30,30,1)
+         3: ( 31, 31, 30,255) #1F1F1EFF srgba(31,31,30,1)
+         2: ( 31, 32, 31,255) #1F201FFF srgba(31,32,31,1)
+        12: ( 32, 33, 32,255) #202120FF srgba(32,33,32,1)
+       132: ( 33, 34, 32,255) #212220FF srgba(33,34,32,1)
+        17: ( 34, 35, 33,255) #222321FF srgba(34,35,33,1)
+        21: ( 35, 35, 34,255) #232322FF srgba(35,35,34,1)
+        10: ( 36, 36, 35,255) #242423FF srgba(36,36,35,1)
+         2: ( 36, 37, 36,255) #242524FF srgba(36,37,36,1)
+         2: ( 37, 38, 36,255) #252624FF srgba(37,38,36,1)
+         8: ( 38, 39, 37,255) #262725FF srgba(38,39,37,1)
+        20: ( 39, 40, 38,255) #272826FF srgba(39,40,38,1)
+        17: ( 40, 40, 39,255) #282827FF srgba(40,40,39,1)
+        17: ( 41, 41, 40,255) #292928FF srgba(41,41,40,1)
+         5: ( 41, 42, 41,255) #292A29FF srgba(41,42,41,1)
+        47: ( 43, 44, 42,255) #2B2C2AFF srgba(43,44,42,1)
+         1: ( 44, 45, 43,255) #2C2D2BFF srgba(44,45,43,1)
+         2: ( 45, 46, 44,255) #2D2E2CFF srgba(45,46,44,1)
+         9: ( 46, 46, 45,255) #2E2E2DFF srgba(46,46,45,1)
+        41: ( 46, 47, 45,255) #2E2F2DFF srgba(46,47,45,1)
+         8: ( 47, 48, 46,255) #2F302EFF srgba(47,48,46,1)
+         2: ( 48, 49, 47,255) #30312FFF srgba(48,49,47,1)
+         5: ( 49, 50, 48,255) #313230FF srgba(49,50,48,1)
+        35: ( 50, 51, 49,255) #323331FF srgba(50,51,49,1)
+        11: ( 51, 52, 50,255) #333432FF srgba(51,52,50,1)
+        24: ( 52, 53, 51,255) #343533FF srgba(52,53,51,1)
+     90468: ( 52,101,164,255) #3465A4FF srgba(52,101,164,1)
+        54: ( 53, 54, 52,255) #353634FF srgba(53,54,52,1)
+        28: ( 53,102,163,255) #3566A3FF srgba(53,102,163,1)
+        22: ( 54, 55, 53,255) #363735FF srgba(54,55,53,1)
+        34: ( 54,102,164,255) #3666A4FF srgba(54,102,164,1)
+        29: ( 54,103,163,255) #3667A3FF srgba(54,103,163,1)
+        28: ( 55, 56, 54,255) #373836FF srgba(55,56,54,1)
+        37: ( 55,103,162,255) #3767A2FF srgba(55,103,162,1)
+        20: ( 56, 57, 55,255) #383937FF srgba(56,57,55,1)
+        32: ( 56,104,162,255) #3868A2FF srgba(56,104,162,1)
+        12: ( 57, 58, 56,255) #393A38FF srgba(57,58,56,1)
+        27: ( 57,104,162,255) #3968A2FF srgba(57,104,162,1)
+        19: ( 58, 59, 57,255) #3A3B39FF srgba(58,59,57,1)
+        15: ( 58,104,161,255) #3A68A1FF srgba(58,104,161,1)
+        34: ( 58,105,161,255) #3A69A1FF srgba(58,105,161,1)
+         9: ( 59, 60, 58,255) #3B3C3AFF srgba(59,60,58,1)
+        17: ( 59,105,161,255) #3B69A1FF srgba(59,105,161,1)
+        11: ( 60, 61, 58,255) #3C3D3AFF srgba(60,61,58,1)
+         5: ( 60, 62, 59,255) #3C3E3BFF srgba(60,62,59,1)
+        23: ( 60,106,161,255) #3C6AA1FF srgba(60,106,161,1)
+         7: ( 61, 62, 60,255) #3D3E3CFF srgba(61,62,60,1)
+        10: ( 61,107,160,255) #3D6BA0FF srgba(61,107,160,1)
+        16: ( 62, 63, 61,255) #3E3F3DFF srgba(62,63,61,1)
+        99: ( 62,107,160,255) #3E6BA0FF srgba(62,107,160,1)
+        15: ( 62,108,160,255) #3E6CA0FF srgba(62,108,160,1)
+        65: ( 63, 64, 62,255) #3F403EFF srgba(63,64,62,1)
+         3: ( 63,108,159,255) #3F6C9FFF srgba(63,108,159,1)
+        20: ( 64, 65, 63,255) #40413FFF srgba(64,65,63,1)
+        42: ( 64, 66, 63,255) #40423FFF srgba(64,66,63,1)
+         1: ( 64,109,159,255) #406D9FFF srgba(64,109,159,1)
+         5: ( 65, 67, 64,255) #414340FF srgba(65,67,64,1)
+        24: ( 65,110,159,255) #416E9FFF srgba(65,110,159,1)
+        33: ( 66, 67, 65,255) #424341FF srgba(66,67,65,1)
+         9: ( 66,110,158,255) #426E9EFF srgba(66,110,158,1)
+         1: ( 67, 68, 66,255) #434442FF srgba(67,68,66,1)
+        22: ( 67,110,158,255) #436E9EFF srgba(67,110,158,1)
+        30: ( 68, 69, 67,255) #444543FF srgba(68,69,67,1)
+        16: ( 68,111,157,255) #446F9DFF srgba(68,111,157,1)
+        13: ( 69, 70, 67,255) #454643FF srgba(69,70,67,1)
+        78: ( 69, 71, 68,255) #454744FF srgba(69,71,68,1)
+        14: ( 69,112,156,255) #45709CFF srgba(69,112,156,1)
+        26: ( 70, 72, 69,255) #464845FF srgba(70,72,69,1)
+         2: ( 70,112,157,255) #46709DFF srgba(70,112,157,1)
+        11: ( 70,113,156,255) #46719CFF srgba(70,113,156,1)
+        17: ( 71, 72, 70,255) #474846FF srgba(71,72,70,1)
+        75: ( 71,113,156,255) #47719CFF srgba(71,113,156,1)
+        15: ( 72, 73, 71,255) #484947FF srgba(72,73,71,1)
+         4: ( 72,114,156,255) #48729CFF srgba(72,114,156,1)
+        28: ( 73, 74, 71,255) #494A47FF srgba(73,74,71,1)
+        20: ( 73,115,155,255) #49739BFF srgba(73,115,155,1)
+        15: ( 74, 75, 72,255) #4A4B48FF srgba(74,75,72,1)
+         3: ( 74, 76, 73,255) #4A4C49FF srgba(74,76,73,1)
+        38: ( 74,116,155,255) #4A749BFF srgba(74,116,155,1)
+         5: ( 75, 77, 74,255) #4B4D4AFF srgba(75,77,74,1)
+         4: ( 75,116,154,255) #4B749AFF srgba(75,116,154,1)
+        23: ( 76, 78, 75,255) #4C4E4BFF srgba(76,78,75,1)
+        13: ( 76,116,154,255) #4C749AFF srgba(76,116,154,1)
+        12: ( 77, 78, 75,255) #4D4E4BFF srgba(77,78,75,1)
+         2: ( 77,117,153,255) #4D7599FF srgba(77,117,153,1)
+        10: ( 77,117,154,255) #4D759AFF srgba(77,117,154,1)
+         5: ( 78, 79, 76,255) #4E4F4CFF srgba(78,79,76,1)
+        13: ( 78,118,153,255) #4E7699FF srgba(78,118,153,1)
+        21: ( 79, 80, 77,255) #4F504DFF srgba(79,80,77,1)
+        54: ( 79, 81, 78,255) #4F514EFF srgba(79,81,78,1)
+         3: ( 79,119,153,255) #4F7799FF srgba(79,119,153,1)
+         6: ( 80, 82, 79,255) #50524FFF srgba(80,82,79,1)
+         8: ( 80,119,152,255) #507798FF srgba(80,119,152,1)
+        17: ( 81, 83, 80,255) #515350FF srgba(81,83,80,1)
+         8: ( 81,120,151,255) #517897FF srgba(81,120,151,1)
+        36: ( 81,120,152,255) #517898FF srgba(81,120,152,1)
+         9: ( 82, 83, 80,255) #525350FF srgba(82,83,80,1)
+        10: ( 82,121,152,255) #527998FF srgba(82,121,152,1)
+        25: ( 83, 84, 81,255) #535451FF srgba(83,84,81,1)
+         8: ( 83,122,150,255) #537A96FF srgba(83,122,150,1)
+         7: ( 83,122,151,255) #537A97FF srgba(83,122,151,1)
+        10: ( 84, 85, 82,255) #545552FF srgba(84,85,82,1)
+         6: ( 84, 86, 83,255) #545653FF srgba(84,86,83,1)
+         3: ( 84,122,150,255) #547A96FF srgba(84,122,150,1)
+         2: ( 84,122,151,255) #547A97FF srgba(84,122,151,1)
+        14: ( 85, 87, 84,255) #555754FF srgba(85,87,84,1)
+         7: ( 85,123,149,255) #557B95FF srgba(85,123,149,1)
+        30: ( 86,124,150,255) #567C96FF srgba(86,124,150,1)
+        11: ( 87, 89, 85,255) #575955FF srgba(87,89,85,1)
+        20: ( 87,124,149,255) #577C95FF srgba(87,124,149,1)
+         4: ( 88, 89, 86,255) #585956FF srgba(88,89,86,1)
+         5: ( 88,125,148,255) #587D94FF srgba(88,125,148,1)
+        11: ( 88,125,149,255) #587D95FF srgba(88,125,149,1)
+        12: ( 89, 90, 87,255) #595A57FF srgba(89,90,87,1)
+       111: ( 89, 91, 88,255) #595B58FF srgba(89,91,88,1)
+        12: ( 89,126,148,255) #597E94FF srgba(89,126,148,1)
+        12: ( 90, 92, 88,255) #5A5C58FF srgba(90,92,88,1)
+        11: ( 90,127,147,255) #5A7F93FF srgba(90,127,147,1)
+        22: ( 91, 93, 89,255) #5B5D59FF srgba(91,93,89,1)
+        14: ( 91,127,147,255) #5B7F93FF srgba(91,127,147,1)
+         2: ( 92, 94, 90,255) #5C5E5AFF srgba(92,94,90,1)
+        33: ( 92,128,147,255) #5C8093FF srgba(92,128,147,1)
+        16: ( 93, 95, 92,255) #5D5F5CFF srgba(93,95,92,1)
+         9: ( 93,128,146,255) #5D8092FF srgba(93,128,146,1)
+         5: ( 94,129,146,255) #5E8192FF srgba(94,129,146,1)
+        31: ( 95, 97, 93,255) #5F615DFF srgba(95,97,93,1)
+         1: ( 95,129,146,255) #5F8192FF srgba(95,129,146,1)
+        24: ( 96, 98, 94,255) #60625EFF srgba(96,98,94,1)
+       156: ( 96,130,145,255) #608291FF srgba(96,130,145,1)
+        30: ( 97, 99, 95,255) #61635FFF srgba(97,99,95,1)
+         7: ( 97,131,145,255) #618391FF srgba(97,131,145,1)
+         2: ( 98, 99, 96,255) #626360FF srgba(98,99,96,1)
+        29: ( 98,100, 97,255) #626461FF srgba(98,100,97,1)
+       134: ( 98,132,144,255) #628490FF srgba(98,132,144,1)
+        20: ( 99,101, 97,255) #636561FF srgba(99,101,97,1)
+        27: ( 99,132,144,255) #638490FF srgba(99,132,144,1)
+         5: (100,102, 98,255) #646662FF srgba(100,102,98,1)
+         7: (100,133,143,255) #64858FFF srgba(100,133,143,1)
+        21: (100,133,144,255) #648590FF srgba(100,133,144,1)
+         5: (101,103, 99,255) #656763FF srgba(101,103,99,1)
+         8: (101,134,142,255) #65868EFF srgba(101,134,142,1)
+         5: (102,104,100,255) #666864FF srgba(102,104,100,1)
+         8: (102,134,143,255) #66868FFF srgba(102,134,143,1)
+        34: (103,105,101,255) #676965FF srgba(103,105,101,1)
+        18: (103,134,142,255) #67868EFF srgba(103,134,142,1)
+        20: (104,106,102,255) #686A66FF srgba(104,106,102,1)
+        19: (104,135,142,255) #68878EFF srgba(104,135,142,1)
+         5: (105,107,103,255) #696B67FF srgba(105,107,103,1)
+        17: (105,136,141,255) #69888DFF srgba(105,136,141,1)
+       110: (106,108,104,255) #6A6C68FF srgba(106,108,104,1)
+        13: (106,137,141,255) #6A898DFF srgba(106,137,141,1)
+         8: (107,109,105,255) #6B6D69FF srgba(107,109,105,1)
+        11: (107,137,141,255) #6B898DFF srgba(107,137,141,1)
+        12: (108,110,106,255) #6C6E6AFF srgba(108,110,106,1)
+       456: (108,138,140,255) #6C8A8CFF srgba(108,138,140,1)
+        24: (109,111,107,255) #6D6F6BFF srgba(109,111,107,1)
+        11: (109,139,140,255) #6D8B8CFF srgba(109,139,140,1)
+        21: (110,112,108,255) #6E706CFF srgba(110,112,108,1)
+         6: (110,140,139,255) #6E8C8BFF srgba(110,140,139,1)
+        14: (111,113,109,255) #6F716DFF srgba(111,113,109,1)
+        12: (111,139,139,255) #6F8B8BFF srgba(111,139,139,1)
+        16: (112,114,110,255) #70726EFF srgba(112,114,110,1)
+        10: (112,115,110,255) #70736EFF srgba(112,115,110,1)
+        27: (112,140,139,255) #708C8BFF srgba(112,140,139,1)
+         1: (112,141,138,255) #708D8AFF srgba(112,141,138,1)
+        15: (113,115,111,255) #71736FFF srgba(113,115,111,1)
+         6: (114,116,112,255) #727470FF srgba(114,116,112,1)
+         5: (114,142,137,255) #728E89FF srgba(114,142,137,1)
+         9: (115,117,113,255) #737571FF srgba(115,117,113,1)
+        24: (115,142,138,255) #738E8AFF srgba(115,142,138,1)
+         7: (115,143,137,255) #738F89FF srgba(115,143,137,1)
+        21: (116,118,114,255) #747672FF srgba(116,118,114,1)
+         4: (116,144,136,255) #749088FF srgba(116,144,136,1)
+         5: (117,119,114,255) #757772FF srgba(117,119,114,1)
+        11: (117,120,115,255) #757873FF srgba(117,120,115,1)
+        13: (117,144,137,255) #759089FF srgba(117,144,137,1)
+         2: (118,121,116,255) #767974FF srgba(118,121,116,1)
+         1: (118,145,136,255) #769188FF srgba(118,145,136,1)
+        62: (119,121,117,255) #777975FF srgba(119,121,117,1)
+         6: (119,145,135,255) #779187FF srgba(119,145,135,1)
+         4: (119,146,136,255) #779288FF srgba(119,146,136,1)
+        14: (120,122,118,255) #787A76FF srgba(120,122,118,1)
+         5: (120,146,135,255) #789287FF srgba(120,146,135,1)
+        15: (121,123,118,255) #797B76FF srgba(121,123,118,1)
+        24: (121,146,134,255) #799286FF srgba(121,146,134,1)
+        30: (122,124,119,255) #7A7C77FF srgba(122,124,119,1)
+       164: (122,125,120,255) #7A7D78FF srgba(122,125,120,1)
+         5: (122,147,135,255) #7A9387FF srgba(122,147,135,1)
+        20: (123,126,121,255) #7B7E79FF srgba(123,126,121,1)
+        12: (123,147,134,255) #7B9386FF srgba(123,147,134,1)
+        12: (123,148,133,255) #7B9485FF srgba(123,148,133,1)
+         2: (124,126,122,255) #7C7E7AFF srgba(124,126,122,1)
+        18: (124,149,133,255) #7C9585FF srgba(124,149,133,1)
+         6: (125,127,123,255) #7D7F7BFF srgba(125,127,123,1)
+        31: (126,128,123,255) #7E807BFF srgba(126,128,123,1)
+        10: (126,150,133,255) #7E9685FF srgba(126,150,133,1)
+        17: (127,129,124,255) #7F817CFF srgba(127,129,124,1)
+        12: (127,130,125,255) #7F827DFF srgba(127,130,125,1)
+        17: (127,150,132,255) #7F9684FF srgba(127,150,132,1)
+        37: (127,151,132,255) #7F9784FF srgba(127,151,132,1)
+         2: (128,131,126,255) #80837EFF srgba(128,131,126,1)
+         5: (128,152,132,255) #809884FF srgba(128,152,132,1)
+        26: (129,131,127,255) #81837FFF srgba(129,131,127,1)
+        11: (129,152,131,255) #819883FF srgba(129,152,131,1)
+        34: (130,132,127,255) #82847FFF srgba(130,132,127,1)
+        14: (130,152,131,255) #829883FF srgba(130,152,131,1)
+        13: (131,133,128,255) #838580FF srgba(131,133,128,1)
+        50: (131,152,131,255) #839883FF srgba(131,152,131,1)
+        21: (132,134,129,255) #848681FF srgba(132,134,129,1)
+        32: (132,135,130,255) #848782FF srgba(132,135,130,1)
+        17: (132,154,130,255) #849A82FF srgba(132,154,130,1)
+         3: (133,136,131,255) #858883FF srgba(133,136,131,1)
+        20: (133,154,130,255) #859A82FF srgba(133,154,130,1)
+         1: (134,137,131,255) #868983FF srgba(134,137,131,1)
+        66: (134,155,129,255) #869B81FF srgba(134,155,129,1)
+        14: (135,137,132,255) #878984FF srgba(135,137,132,1)
+        13: (135,155,128,255) #879B80FF srgba(135,155,128,1)
+         5: (135,156,129,255) #879C81FF srgba(135,156,129,1)
+         9: (136,138,133,255) #888A85FF srgba(136,138,133,1)
+        19: (136,157,128,255) #889D80FF srgba(136,157,128,1)
+         8: (137,139,134,255) #898B86FF srgba(137,139,134,1)
+         8: (137,140,135,255) #898C87FF srgba(137,140,135,1)
+        15: (137,157,128,255) #899D80FF srgba(137,157,128,1)
+         2: (138,141,136,255) #8A8D88FF srgba(138,141,136,1)
+        13: (138,158,128,255) #8A9E80FF srgba(138,158,128,1)
+       100: (139,142,136,255) #8B8E88FF srgba(139,142,136,1)
+        24: (139,157,127,255) #8B9D7FFF srgba(139,157,127,1)
+        11: (139,158,127,255) #8B9E7FFF srgba(139,158,127,1)
+         9: (140,142,137,255) #8C8E89FF srgba(140,142,137,1)
+        20: (140,159,127,255) #8C9F7FFF srgba(140,159,127,1)
+        27: (141,143,138,255) #8D8F8AFF srgba(141,143,138,1)
+        27: (141,144,139,255) #8D908BFF srgba(141,144,139,1)
+         1: (141,159,126,255) #8D9F7EFF srgba(141,159,126,1)
+        20: (142,145,140,255) #8E918CFF srgba(142,145,140,1)
+         9: (142,160,126,255) #8EA07EFF srgba(142,160,126,1)
+        34: (143,146,140,255) #8F928CFF srgba(143,146,140,1)
+         4: (143,160,126,255) #8FA07EFF srgba(143,160,126,1)
+        32: (143,161,125,255) #8FA17DFF srgba(143,161,125,1)
+         9: (144,147,141,255) #90938DFF srgba(144,147,141,1)
+         3: (144,162,125,255) #90A27DFF srgba(144,162,125,1)
+        22: (145,148,142,255) #91948EFF srgba(145,148,142,1)
+        10: (145,162,125,255) #91A27DFF srgba(145,162,125,1)
+        33: (146,148,143,255) #92948FFF srgba(146,148,143,1)
+         3: (146,149,144,255) #929590FF srgba(146,149,144,1)
+         8: (146,163,124,255) #92A37CFF srgba(146,163,124,1)
+        18: (147,150,144,255) #939690FF srgba(147,150,144,1)
+         4: (147,163,124,255) #93A37CFF srgba(147,163,124,1)
+         5: (147,164,123,255) #93A47BFF srgba(147,164,123,1)
+        28: (148,151,145,255) #949791FF srgba(148,151,145,1)
+       104: (149,152,146,255) #959892FF srgba(149,152,146,1)
+         3: (149,164,123,255) #95A47BFF srgba(149,164,123,1)
+        14: (150,153,147,255) #969993FF srgba(150,153,147,1)
+        10: (150,165,122,255) #96A57AFF srgba(150,165,122,1)
+        12: (151,153,148,255) #979994FF srgba(151,153,148,1)
+         9: (151,154,149,255) #979A95FF srgba(151,154,149,1)
+        10: (151,165,123,255) #97A57BFF srgba(151,165,123,1)
+        17: (151,166,122,255) #97A67AFF srgba(151,166,122,1)
+         6: (152,155,149,255) #989B95FF srgba(152,155,149,1)
+        45: (152,167,122,255) #98A77AFF srgba(152,167,122,1)
+         8: (153,156,150,255) #999C96FF srgba(153,156,150,1)
+         5: (153,168,121,255) #99A879FF srgba(153,168,121,1)
+         4: (153,169,120,255) #99A978FF srgba(153,169,120,1)
+         2: (154,157,151,255) #9A9D97FF srgba(154,157,151,1)
+        10: (154,169,121,255) #9AA979FF srgba(154,169,121,1)
+        15: (155,158,152,255) #9B9E98FF srgba(155,158,152,1)
+         6: (155,170,120,255) #9BAA78FF srgba(155,170,120,1)
+        33: (156,159,153,255) #9C9F99FF srgba(156,159,153,1)
+         2: (156,170,119,255) #9CAA77FF srgba(156,170,119,1)
+         8: (157,160,154,255) #9DA09AFF srgba(157,160,154,1)
+         3: (158,161,155,255) #9EA19BFF srgba(158,161,155,1)
+         8: (158,171,119,255) #9EAB77FF srgba(158,171,119,1)
+        61: (159,162,156,255) #9FA29CFF srgba(159,162,156,1)
+         8: (159,172,118,255) #9FAC76FF srgba(159,172,118,1)
+         8: (160,163,157,255) #A0A39DFF srgba(160,163,157,1)
+        50: (160,164,157,255) #A0A49DFF srgba(160,164,157,1)
+         8: (160,172,118,255) #A0AC76FF srgba(160,172,118,1)
+        23: (161,164,158,255) #A1A49EFF srgba(161,164,158,1)
+         1: (161,173,118,255) #A1AD76FF srgba(161,173,118,1)
+         2: (161,174,117,255) #A1AE75FF srgba(161,174,117,1)
+        23: (162,165,159,255) #A2A59FFF srgba(162,165,159,1)
+         7: (162,174,117,255) #A2AE75FF srgba(162,174,117,1)
+         4: (163,166,160,255) #A3A6A0FF srgba(163,166,160,1)
+         7: (164,167,161,255) #A4A7A1FF srgba(164,167,161,1)
+         5: (164,175,116,255) #A4AF74FF srgba(164,175,116,1)
+        10: (165,168,161,255) #A5A8A1FF srgba(165,168,161,1)
+       134: (165,169,162,255) #A5A9A2FF srgba(165,169,162,1)
+        30: (165,176,116,255) #A5B074FF srgba(165,176,116,1)
+        22: (166,169,163,255) #A6A9A3FF srgba(166,169,163,1)
+         5: (166,176,115,255) #A6B073FF srgba(166,176,115,1)
+        26: (167,170,164,255) #A7AAA4FF srgba(167,170,164,1)
+        10: (167,177,115,255) #A7B173FF srgba(167,177,115,1)
+         7: (168,171,165,255) #A8ABA5FF srgba(168,171,165,1)
+         2: (168,177,115,255) #A8B173FF srgba(168,177,115,1)
+        21: (169,172,166,255) #A9ACA6FF srgba(169,172,166,1)
+         1: (169,178,114,255) #A9B272FF srgba(169,178,114,1)
+        11: (169,179,114,255) #A9B372FF srgba(169,179,114,1)
+        13: (170,173,166,255) #AAADA6FF srgba(170,173,166,1)
+         4: (170,179,114,255) #AAB372FF srgba(170,179,114,1)
+         7: (171,175,168,255) #ABAFA8FF srgba(171,175,168,1)
+         9: (171,180,113,255) #ABB471FF srgba(171,180,113,1)
+         8: (172,175,169,255) #ACAFA9FF srgba(172,175,169,1)
+        11: (172,180,113,255) #ACB471FF srgba(172,180,113,1)
+         9: (173,176,170,255) #ADB0AAFF srgba(173,176,170,1)
+         6: (173,181,113,255) #ADB571FF srgba(173,181,113,1)
+        28: (174,177,170,255) #AEB1AAFF srgba(174,177,170,1)
+         7: (174,182,112,255) #AEB670FF srgba(174,182,112,1)
+        16: (175,178,171,255) #AFB2ABFF srgba(175,178,171,1)
+        20: (175,179,172,255) #AFB3ACFF srgba(175,179,172,1)
+         4: (175,182,112,255) #AFB670FF srgba(175,182,112,1)
+        23: (176,180,173,255) #B0B4ADFF srgba(176,180,173,1)
+        14: (176,182,111,255) #B0B66FFF srgba(176,182,111,1)
+        21: (177,180,174,255) #B1B4AEFF srgba(177,180,174,1)
+         4: (177,183,111,255) #B1B76FFF srgba(177,183,111,1)
+        14: (177,184,111,255) #B1B86FFF srgba(177,184,111,1)
+         9: (178,181,175,255) #B2B5AFFF srgba(178,181,175,1)
+        25: (178,184,110,255) #B2B86EFF srgba(178,184,110,1)
+        82: (179,182,175,255) #B3B6AFFF srgba(179,182,175,1)
+         6: (179,185,110,255) #B3B96EFF srgba(179,185,110,1)
+         7: (180,183,176,255) #B4B7B0FF srgba(180,183,176,1)
+        13: (180,184,177,255) #B4B8B1FF srgba(180,184,177,1)
+        13: (180,185,109,255) #B4B96DFF srgba(180,185,109,1)
+        12: (181,185,178,255) #B5B9B2FF srgba(181,185,178,1)
+        21: (181,186,110,255) #B5BA6EFF srgba(181,186,110,1)
+         6: (181,187,109,255) #B5BB6DFF srgba(181,187,109,1)
+        14: (182,185,179,255) #B6B9B3FF srgba(182,185,179,1)
+         7: (182,187,108,255) #B6BB6CFF srgba(182,187,108,1)
+        24: (183,186,179,255) #B7BAB3FF srgba(183,186,179,1)
+         2: (183,188,109,255) #B7BC6DFF srgba(183,188,109,1)
+        31: (184,187,108,255) #B8BB6CFF srgba(184,187,108,1)
+         6: (184,187,180,255) #B8BBB4FF srgba(184,187,180,1)
+        31: (184,188,181,255) #B8BCB5FF srgba(184,188,181,1)
+        16: (185,188,107,255) #B9BC6BFF srgba(185,188,107,1)
+         2: (185,189,108,255) #B9BD6CFF srgba(185,189,108,1)
+         6: (185,189,182,255) #B9BDB6FF srgba(185,189,182,1)
+         2: (186,189,107,255) #BABD6BFF srgba(186,189,107,1)
+        25: (186,190,183,255) #BABEB7FF srgba(186,190,183,1)
+         8: (187,190,106,255) #BBBE6AFF srgba(187,190,106,1)
+        16: (187,191,183,255) #BBBFB7FF srgba(187,191,183,1)
+        10: (188,190,107,255) #BCBE6BFF srgba(188,190,107,1)
+         8: (188,191,184,255) #BCBFB8FF srgba(188,191,184,1)
+         7: (189,191,106,255) #BDBF6AFF srgba(189,191,106,1)
+        10: (189,192,105,255) #BDC069FF srgba(189,192,105,1)
+         8: (189,192,185,255) #BDC0B9FF srgba(189,192,185,1)
+        32: (189,193,186,255) #BDC1BAFF srgba(189,193,186,1)
+        11: (190,192,105,255) #BEC069FF srgba(190,192,105,1)
+        10: (190,194,187,255) #BEC2BBFF srgba(190,194,187,1)
+         5: (191,193,105,255) #BFC169FF srgba(191,193,105,1)
+         3: (191,195,188,255) #BFC3BCFF srgba(191,195,188,1)
+         1: (192,193,105,255) #C0C169FF srgba(192,193,105,1)
+        29: (192,194,104,255) #C0C268FF srgba(192,194,104,1)
+        24: (192,196,188,255) #C0C4BCFF srgba(192,196,188,1)
+         3: (193,194,104,255) #C1C268FF srgba(193,194,104,1)
+         4: (193,196,189,255) #C1C4BDFF srgba(193,196,189,1)
+        18: (194,197,190,255) #C2C5BEFF srgba(194,197,190,1)
+        12: (194,198,191,255) #C2C6BFFF srgba(194,198,191,1)
+        14: (195,195,103,255) #C3C367FF srgba(195,195,103,1)
+        47: (195,199,192,255) #C3C7C0FF srgba(195,199,192,1)
+       105: (196,196,103,255) #C4C467FF srgba(196,196,103,1)
+        18: (196,200,192,255) #C4C8C0FF srgba(196,200,192,1)
+         6: (197,197,102,255) #C5C566FF srgba(197,197,102,1)
+        41: (197,201,193,255) #C5C9C1FF srgba(197,201,193,1)
+        11: (198,197,102,255) #C6C566FF srgba(198,197,102,1)
+         4: (198,201,194,255) #C6C9C2FF srgba(198,201,194,1)
+         9: (199,198,102,255) #C7C666FF srgba(199,198,102,1)
+        36: (199,202,195,255) #C7CAC3FF srgba(199,202,195,1)
+        12: (199,203,196,255) #C7CBC4FF srgba(199,203,196,1)
+       124: (200,199,101,255) #C8C765FF srgba(200,199,101,1)
+        46: (200,204,196,255) #C8CCC4FF srgba(200,204,196,1)
+         7: (201,200,101,255) #C9C865FF srgba(201,200,101,1)
+        23: (201,205,197,255) #C9CDC5FF srgba(201,205,197,1)
+        11: (202,200,100,255) #CAC864FF srgba(202,200,100,1)
+        23: (202,206,198,255) #CACEC6FF srgba(202,206,198,1)
+         9: (203,200,100,255) #CBC864FF srgba(203,200,100,1)
+        37: (203,207,199,255) #CBCFC7FF srgba(203,207,199,1)
+         8: (204,201, 99,255) #CCC963FF srgba(204,201,99,1)
+         2: (204,201,100,255) #CCC964FF srgba(204,201,100,1)
+        60: (204,207,200,255) #CCCFC8FF srgba(204,207,200,1)
+        31: (204,208,200,255) #CCD0C8FF srgba(204,208,200,1)
+        77: (205,209,201,255) #CDD1C9FF srgba(205,209,201,1)
+        93: (206,202, 99,255) #CECA63FF srgba(206,202,99,1)
+        53: (206,210,202,255) #CED2CAFF srgba(206,210,202,1)
+        11: (207,203, 98,255) #CFCB62FF srgba(207,203,98,1)
+        50: (207,211,203,255) #CFD3CBFF srgba(207,211,203,1)
+        22: (208,204, 98,255) #D0CC62FF srgba(208,204,98,1)
+        63: (208,212,204,255) #D0D4CCFF srgba(208,212,204,1)
+        64: (208,212,205,255) #D0D4CDFF srgba(208,212,205,1)
+         5: (209,205, 97,255) #D1CD61FF srgba(209,205,97,1)
+        26: (209,213,205,255) #D1D5CDFF srgba(209,213,205,1)
+        35: (210,205, 97,255) #D2CD61FF srgba(210,205,97,1)
+        61: (210,214,206,255) #D2D6CEFF srgba(210,214,206,1)
+         7: (211,206, 97,255) #D3CE61FF srgba(211,206,97,1)
+      1473: (211,215,207,255) #D3D7CFFF srgba(211,215,207,1)
+       276: (212,206, 96,255) #D4CE60FF srgba(212,206,96,1)
+         8: (213,207, 96,255) #D5CF60FF srgba(213,207,96,1)
+        22: (214,207, 96,255) #D6CF60FF srgba(214,207,96,1)
+        24: (215,208, 95,255) #D7D05FFF srgba(215,208,95,1)
+         4: (216,209, 94,255) #D8D15EFF srgba(216,209,94,1)
+        18: (216,209, 95,255) #D8D15FFF srgba(216,209,95,1)
+         3: (216,210, 94,255) #D8D25EFF srgba(216,210,94,1)
+        11: (217,210, 93,255) #D9D25DFF srgba(217,210,93,1)
+       283: (218,211, 94,255) #DAD35EFF srgba(218,211,94,1)
+        16: (219,211, 92,255) #DBD35CFF srgba(219,211,92,1)
+         5: (219,212, 93,255) #DBD45DFF srgba(219,212,93,1)
+         3: (220,212, 93,255) #DCD45DFF srgba(220,212,93,1)
+        30: (221,212, 92,255) #DDD45CFF srgba(221,212,92,1)
+        12: (222,213, 91,255) #DED55BFF srgba(222,213,91,1)
+        26: (223,214, 91,255) #DFD65BFF srgba(223,214,91,1)
+        76: (224,215, 91,255) #E0D75BFF srgba(224,215,91,1)
+        10: (225,215, 90,255) #E1D75AFF srgba(225,215,90,1)
+        10: (226,216, 90,255) #E2D85AFF srgba(226,216,90,1)
+        44: (227,217, 89,255) #E3D959FF srgba(227,217,89,1)
+         1: (227,217, 90,255) #E3D95AFF srgba(227,217,90,1)
+        22: (228,218, 89,255) #E4DA59FF srgba(228,218,89,1)
+        10: (229,217, 89,255) #E5D959FF srgba(229,217,89,1)
+         7: (230,218, 88,255) #E6DA58FF srgba(230,218,88,1)
+        62: (231,219, 88,255) #E7DB58FF srgba(231,219,88,1)
+         5: (232,220, 87,255) #E8DC57FF srgba(232,220,87,1)
+     69120: (232,232,231,255) #E8E8E7FF srgba(232,232,231,1)
+        11: (233,221, 87,255) #E9DD57FF srgba(233,221,87,1)
+       114: (234,221, 87,255) #EADD57FF srgba(234,221,87,1)
+        35: (234,222, 86,255) #EADE56FF srgba(234,222,86,1)
+        23: (235,222, 86,255) #EBDE56FF srgba(235,222,86,1)
+        24: (236,223, 86,255) #ECDF56FF srgba(236,223,86,1)
+        24: (237,224, 85,255) #EDE055FF srgba(237,224,85,1)
+        69: (238,224, 85,255) #EEE055FF srgba(238,224,85,1)
+        26: (239,224, 84,255) #EFE054FF srgba(239,224,84,1)
+        76: (240,225, 84,255) #F0E154FF srgba(240,225,84,1)
+        39: (241,226, 84,255) #F1E254FF srgba(241,226,84,1)
+        29: (242,226, 83,255) #F2E253FF srgba(242,226,83,1)
+         8: (242,227, 83,255) #F2E353FF srgba(242,227,83,1)
+        24: (243,227, 83,255) #F3E353FF srgba(243,227,83,1)
+        40: (244,228, 82,255) #F4E452FF srgba(244,228,82,1)
+        22: (245,229, 82,255) #F5E552FF srgba(245,229,82,1)
+        31: (246,229, 82,255) #F6E552FF srgba(246,229,82,1)
+        48: (246,230, 82,255) #F6E652FF srgba(246,230,82,1)
+        31: (247,229, 81,255) #F7E551FF srgba(247,229,81,1)
+        36: (248,230, 80,255) #F8E650FF srgba(248,230,80,1)
+        16: (249,231, 81,255) #F9E751FF srgba(249,231,81,1)
+        23: (250,231, 80,255) #FAE750FF srgba(250,231,80,1)
+        11: (250,232, 79,255) #FAE84FFF srgba(250,232,79,1)
+        46: (251,232, 80,255) #FBE850FF srgba(251,232,80,1)
+      2629: (252,233, 79,255) #FCE94FFF srgba(252,233,79,1)
+  Rendering intent: Perceptual
+  Gamma: 0.454545
+  Chromaticity:
+    red primary: (0.64,0.33)
+    green primary: (0.3,0.6)
+    blue primary: (0.15,0.06)
+    white point: (0.3127,0.329)
+  Background color: white
+  Border color: srgba(223,223,223,1)
+  Matte color: grey74
+  Transparent color: none
+  Interlace: None
+  Intensity: Undefined
+  Compose: Over
+  Page geometry: 1920x1080+0+0
+  Dispose: Undefined
+  Iterations: 0
+  Compression: Zip
+  Orientation: Undefined
+  Properties:
+    date:create: 2016-08-28T15:23:13+01:00
+    date:modify: 2016-08-28T15:23:13+01:00
+    png:bKGD: chunk was found (see Background color, above)
+    png:IHDR.bit-depth-orig: 8
+    png:IHDR.bit_depth: 8
+    png:IHDR.color-type-orig: 6
+    png:IHDR.color_type: 6 (RGBA)
+    png:IHDR.interlace_method: 0 (Not interlaced)
+    png:IHDR.width,height: 1920, 1080
+    png:pHYs: x_res=2835, y_res=2835, units=1
+    png:sRGB: intent=0 (Perceptual Intent)
+    png:tIME: 2016-08-08T21:05:17Z
+    signature: 1cb6d25c9949160285c5bb8d7dc13f0a3cc97c568b7cdc54eacb598b00e0de6f
+  Artifacts:
+    filename: /tmp/Mp3D2x_pagerMode.png
+    verbose: true
+  Tainted: False
+  Filesize: 54.4KB
+  Number pixels: 2.074M
+  Pixels per second: 518.4GB
+  User time: 0.000u
+  Elapsed time: 0:01.000
+  Version: ImageMagick 6.9.3-0 Q16 x86_64 2016-02-03 http://www.imagemagick.org
diff --git c/contrib/keybase/pgpdecrypt.sh w/contrib/keybase/pgpdecrypt.sh
new file mode 100755
index 0000000..2a88dff
--- /dev/null
+++ w/contrib/keybase/pgpdecrypt.sh
@@ -0,0 +1,2 @@
+#!/bin/sh
+sed -n '/BEGIN/,$p' | keybase pgp decrypt
diff --git c/contrib/keybase/pgpverify.sh w/contrib/keybase/pgpverify.sh
new file mode 100755
index 0000000..180bdea
--- /dev/null
+++ w/contrib/keybase/pgpverify.sh
@@ -0,0 +1,2 @@
+#!/bin/sh
+gawk '/BEGIN/{y=1}y' | keybase pgp verify
diff --git c/contrib/keybase/verify.sh w/contrib/keybase/verify.sh
new file mode 100755
index 0000000..10e7f01
--- /dev/null
+++ w/contrib/keybase/verify.sh
@@ -0,0 +1,2 @@
+#!/bin/sh
+sed -n 's/^.*BEGIN KEYBASE/BEGIN KEYBASE/p' | keybase verify
diff --git c/contrib/vim-keybindings/README.md w/contrib/vim-keybindings/README.md
new file mode 100644
index 0000000..2beeb08
--- /dev/null
+++ w/contrib/vim-keybindings/README.md
@@ -0,0 +1,13 @@
+# Vim Keybindings
+
+This Mutt config file sets up some keyboard mappings that make Mutt more
+friendly for Vim users.  For example:
+
+- gg  Move to top of Index
+- G   Move to bottom of Index
+- dd  Delete email from Index
+
+## Credits
+
+- Ivan Tham <pickfire@riseup.net>
+
diff --git c/contrib/vim-keybindings/vim-keybindings.rc w/contrib/vim-keybindings/vim-keybindings.rc
new file mode 100644
index 0000000..cb64889
--- /dev/null
+++ w/contrib/vim-keybindings/vim-keybindings.rc
@@ -0,0 +1,35 @@
+#------------------------------------------------------------
+# Vi Key Bindings
+#------------------------------------------------------------
+
+# Moving around
+bind attach,browser,index       gg  first-entry
+bind attach,browser,index       G   last-entry
+bind pager                      gg  top
+bind pager                      G   bottom
+bind pager                      k   previous-line
+bind pager                      j   next-line
+
+# Scrolling
+bind attach,browser,pager,index \CF next-page
+bind attach,browser,pager,index \CB previous-page
+bind attach,browser,pager,index \Cu half-up
+bind attach,browser,pager,index \Cd half-down
+bind browser,pager              \Ce next-line
+bind browser,pager              \Cy previous-line
+bind index                      \Ce next-line
+bind index                      \Cy previous-line
+
+bind pager,index                dd  delete-message
+
+# Mail & Reply
+bind index                      \Cm list-reply # Doesn't work currently
+
+# Threads
+bind browser,pager,index        N   search-opposite
+bind pager,index                dT  delete-thread
+bind pager,index                dt  delete-subthread
+bind pager,index                gt  next-thread
+bind pager,index                gT  previous-thread
+bind index                      za  collapse-thread
+bind index                      zA  collapse-all # Missing :folddisable/foldenable
diff --git c/copy.c w/copy.c
index 1ef441f..bfcd3a5 100644
--- c/copy.c
+++ w/copy.c
@@ -30,6 +30,10 @@
 #include "mutt_idna.h"
 #include "mutt_curses.h"
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include <string.h>
 #include <stdlib.h>
 #include <ctype.h>
@@ -111,6 +115,15 @@ mutt_copy_hdr (FILE *in, FILE *out, LOFF_T off_start, LOFF_T off_end, int flags,
 	ignore = 0;
       }
 
+      if (flags & CH_UPDATE_LABEL)
+      {
+	if ((mutt_strncasecmp ("X-Label:", buf, 8) == 0) ||
+	    (mutt_strncasecmp ("X-Keywords:", buf, 11) == 0) ||
+	    (mutt_strncasecmp ("X-Mozilla-Keys:", buf, 15) == 0) ||
+	    (mutt_strncasecmp ("Keywords:", buf, 9) == 0))
+	  continue;
+      }
+
       if (!ignore && fputs (buf, out) == EOF)
 	return (-1);
     }
@@ -335,6 +348,7 @@ mutt_copy_hdr (FILE *in, FILE *out, LOFF_T off_start, LOFF_T off_end, int flags,
 	CH_NOQFROM      ignore ">From " line
 	CH_UPDATE_IRT	update the In-Reply-To: header
 	CH_UPDATE_REFS	update the References: header
+	CH_VIRTUAL      write virtual header lines too
 
    prefix
    	string to use if CH_PREFIX is set
@@ -348,7 +362,7 @@ mutt_copy_header (FILE *in, HEADER *h, FILE *out, int flags, const char *prefix)
   if (h->env)
     flags |= (h->env->irt_changed ? CH_UPDATE_IRT : 0)
       | (h->env->refs_changed ? CH_UPDATE_REFS : 0);
-  
+
   if (mutt_copy_hdr (in, out, h->offset, h->content->offset, flags, prefix) == -1)
     return -1;
 
@@ -414,6 +428,70 @@ mutt_copy_header (FILE *in, HEADER *h, FILE *out, int flags, const char *prefix)
       fprintf (out, "Lines: %d\n", h->lines);
   }
 
+#ifdef USE_NOTMUCH
+  if ((flags & CH_VIRTUAL) && nm_header_get_tags(h))
+  {
+    fputs ("Tags: ", out);
+    fputs (nm_header_get_tags(h), out);
+    fputc ('\n', out);
+  }
+#endif
+
+  if (flags & CH_UPDATE_LABEL && h->label_changed)
+  {
+    h->label_changed = 0;
+    if (h->env->labels != NULL)
+    {
+      char buf[HUGE_STRING];
+      char *tmp = NULL;
+      int fail = 0;
+
+      if (fail == 0 &&
+          ((h->env->kwtypes & MUTT_X_LABEL) || (h->env->kwtypes == 0)) &&
+          (option(OPTKEYWORDSLEGACY) || option(OPTKEYWORDSSTANDARD) == 0))
+      {
+        mutt_labels(buf, sizeof(buf), h->env, XlabelDelim);
+        tmp = safe_strdup(buf);
+        rfc2047_encode_string(&tmp);
+        fail = fprintf(out, "X-Label: %s\n", tmp) != 10 + strlen(tmp);
+        FREE(&tmp);
+      }
+
+      if (fail == 0 && (h->env->kwtypes & MUTT_X_KEYWORDS) &&
+          (option(OPTKEYWORDSLEGACY) || option(OPTKEYWORDSSTANDARD) == 0))
+      {
+        mutt_labels(buf, sizeof(buf), h->env, " ");
+        tmp = safe_strdup(buf);
+        rfc2047_encode_string(&tmp);
+        fail = fprintf(out, "X-Keywords: %s\n", tmp) != 13 + strlen(tmp);
+        FREE(&tmp);
+      }
+
+      if (fail == 0 && (h->env->kwtypes & MUTT_X_MOZILLA_KEYS) &&
+          (option(OPTKEYWORDSLEGACY) || option(OPTKEYWORDSSTANDARD) == 0))
+      {
+        mutt_labels(buf, sizeof(buf), h->env, " ");
+        tmp = safe_strdup(buf);
+        rfc2047_encode_string(&tmp);
+        fail = fprintf(out, "X-Mozilla-Keys: %s\n", tmp) != 17 + strlen(tmp);
+        FREE(&tmp);
+      }
+
+      if (fail == 0 && ((h->env->kwtypes & MUTT_KEYWORDS) ||
+                        option(OPTKEYWORDSSTANDARD)))
+      {
+        mutt_labels(buf, sizeof(buf), h->env, NULL);
+        tmp = safe_strdup(buf);
+        rfc2047_encode_string(&tmp);
+        fail = fprintf(out, "Keywords: %s\n", tmp) != 11 + strlen(tmp);
+        FREE(&tmp);
+      }
+
+      if (fail)
+        return -1;
+    }
+  }
+
   if ((flags & CH_NONEWLINE) == 0)
   {
     if (flags & CH_PREFIX)
@@ -494,6 +572,9 @@ _mutt_copy_message (FILE *fpout, FILE *fpin, HEADER *hdr, BODY *body,
       _mutt_make_string (prefix, sizeof (prefix), NONULL (Prefix), Context, hdr, 0);
   }
 
+  if (hdr->label_changed)
+    chflags |= CH_UPDATE_LABEL;
+
   if ((flags & MUTT_CM_NOHEADER) == 0)
   {
     if (flags & MUTT_CM_PREFIX)
@@ -683,7 +764,7 @@ mutt_copy_message (FILE *fpout, CONTEXT *src, HEADER *hdr, int flags,
 {
   MESSAGE *msg;
   int r;
-  
+
   if ((msg = mx_open_message (src, hdr->msgno)) == NULL)
     return -1;
   if ((r = _mutt_copy_message (fpout, msg->fp, hdr, hdr->content, flags, chflags)) == 0 
@@ -718,7 +799,7 @@ _mutt_append_message (CONTEXT *dest, FILE *fpin, CONTEXT *src, HEADER *hdr,
   fseeko (fpin, hdr->offset, 0);
   if (fgets (buf, sizeof (buf), fpin) == NULL)
     return -1;
-  
+
   if ((msg = mx_open_new_message (dest, hdr, is_from (buf, NULL, 0, NULL) ? 0 : MUTT_ADD_FROM)) == NULL)
     return -1;
   if (dest->magic == MUTT_MBOX || dest->magic == MUTT_MMDF)
@@ -728,6 +809,11 @@ _mutt_append_message (CONTEXT *dest, FILE *fpin, CONTEXT *src, HEADER *hdr,
   if (mx_commit_message (msg, dest) != 0)
     r = -1;
 
+#ifdef USE_NOTMUCH
+  if (hdr && msg->commited_path && dest->magic == MUTT_MAILDIR && src->magic == MUTT_NOTMUCH)
+	  nm_update_filename(src, NULL, msg->commited_path, hdr);
+#endif
+
   mx_close_message (dest, &msg);
   return r;
 }
diff --git c/copy.h w/copy.h
index 4d6fc54..b47c7fb 100644
--- c/copy.h
+++ w/copy.h
@@ -53,6 +53,8 @@
 #define CH_UPDATE_IRT     (1<<16) /* update In-Reply-To: */
 #define CH_UPDATE_REFS    (1<<17) /* update References: */
 #define CH_DISPLAY        (1<<18) /* display result to user */
+#define CH_UPDATE_LABEL   (1<<19) /* update X-Label: from hdr->env->x_label? */
+#define CH_VIRTUAL	  (1<<20) /* write virtual header lines too */
 
 
 int mutt_copy_hdr (FILE *, FILE *, LOFF_T, LOFF_T, int, const char *);
diff --git c/crypt-gpgme.c w/crypt-gpgme.c
index ff74d68..d5c6f33 100644
--- c/crypt-gpgme.c
+++ w/crypt-gpgme.c
@@ -869,14 +869,12 @@ static void print_time(time_t t, STATE *s)
 {
   char p[STRING];
 
-  setlocale (LC_TIME, "");
 #ifdef HAVE_LANGINFO_D_T_FMT
   strftime (p, sizeof (p), nl_langinfo (D_T_FMT), localtime (&t));
 #else
   strftime (p, sizeof (p), "%c", localtime (&t));
 #endif
-  setlocale (LC_TIME, "C");
-  state_attach_puts (p, s);
+  state_puts (p, s);
 }
 
 /* 
@@ -1141,7 +1139,7 @@ static int show_sig_summary (unsigned long sum,
 
   if ((sum & GPGME_SIGSUM_KEY_REVOKED))
     {
-      state_attach_puts (_("Warning: One of the keys has been revoked\n"),s);
+      state_puts (_("Warning: One of the keys has been revoked\n"),s);
       severe = 1;
     }
 
@@ -1150,13 +1148,13 @@ static int show_sig_summary (unsigned long sum,
       time_t at = key->subkeys->expires ? key->subkeys->expires : 0;
       if (at)
         {
-          state_attach_puts (_("Warning: The key used to create the "
+          state_puts (_("Warning: The key used to create the "
                                "signature expired at: "), s);
           print_time (at , s);
-          state_attach_puts ("\n", s);
+          state_puts ("\n", s);
         }
       else
-        state_attach_puts (_("Warning: At least one certification key "
+        state_puts (_("Warning: At least one certification key "
                              "has expired\n"), s);
     }
 
@@ -1172,29 +1170,29 @@ static int show_sig_summary (unsigned long sum,
            sig = sig->next, i++)
         ;
       
-      state_attach_puts (_("Warning: The signature expired at: "), s);
+      state_puts (_("Warning: The signature expired at: "), s);
       print_time (sig ? sig->exp_timestamp : 0, s);
-      state_attach_puts ("\n", s);
+      state_puts ("\n", s);
     }
 
   if ((sum & GPGME_SIGSUM_KEY_MISSING))
-    state_attach_puts (_("Can't verify due to a missing "
+    state_puts (_("Can't verify due to a missing "
                          "key or certificate\n"), s);
 
   if ((sum & GPGME_SIGSUM_CRL_MISSING))
     {
-      state_attach_puts (_("The CRL is not available\n"), s);
+      state_puts (_("The CRL is not available\n"), s);
       severe = 1;
     }
 
   if ((sum & GPGME_SIGSUM_CRL_TOO_OLD))
     {
-      state_attach_puts (_("Available CRL is too old\n"), s);
+      state_puts (_("Available CRL is too old\n"), s);
       severe = 1;
     }
 
   if ((sum & GPGME_SIGSUM_BAD_POLICY))
-    state_attach_puts (_("A policy requirement was not met\n"), s);
+    state_puts (_("A policy requirement was not met\n"), s);
 
   if ((sum & GPGME_SIGSUM_SYS_ERROR))
     {
@@ -1203,7 +1201,7 @@ static int show_sig_summary (unsigned long sum,
       gpgme_signature_t sig;
       unsigned int i;
 
-      state_attach_puts (_("A system error occurred"), s );
+      state_puts (_("A system error occurred"), s );
 
       /* Try to figure out some more detailed system error information. */
       result = gpgme_op_verify_result (ctx);
@@ -1218,17 +1216,17 @@ static int show_sig_summary (unsigned long sum,
 
       if (t0 || t1)
         {
-          state_attach_puts (": ", s);
+          state_puts (": ", s);
           if (t0)
-              state_attach_puts (t0, s);
+              state_puts (t0, s);
           if (t1 && !(t0 && !strcmp (t0, t1)))
             {
               if (t0)
-                state_attach_puts (",", s);
-              state_attach_puts (t1, s);
+                state_puts (",", s);
+              state_puts (t1, s);
             }
         }
-      state_attach_puts ("\n", s);
+      state_puts ("\n", s);
     }
 
 #ifdef HAVE_GPGME_PKA_TRUST
@@ -1237,16 +1235,16 @@ static int show_sig_summary (unsigned long sum,
     {
       if (sig->pka_trust == 1 && sig->pka_address)
 	{
-	  state_attach_puts (_("WARNING: PKA entry does not match "
+	  state_puts (_("WARNING: PKA entry does not match "
 			       "signer's address: "), s);
-	  state_attach_puts (sig->pka_address, s);
-	  state_attach_puts ("\n", s);
+	  state_puts (sig->pka_address, s);
+	  state_puts ("\n", s);
 	}
       else if (sig->pka_trust == 2 && sig->pka_address)
 	{
-	  state_attach_puts (_("PKA verified signer's address is: "), s);
-	  state_attach_puts (sig->pka_address, s);
-	  state_attach_puts ("\n", s);
+	  state_puts (_("PKA verified signer's address is: "), s);
+	  state_puts (sig->pka_address, s);
+	  state_puts ("\n", s);
 	}
     }
 
@@ -1303,7 +1301,7 @@ static void show_fingerprint (gpgme_key_t key, STATE *state)
     *p++ = *s;
   *p++ = '\n';
   *p = 0;
-  state_attach_puts (buf, state);
+  state_puts (buf, state);
   FREE (&buf);
 }
 
@@ -1341,7 +1339,7 @@ static void show_one_sig_validity (gpgme_ctx_t ctx, int idx, STATE *s)
 	break;
       }
   if (txt)
-    state_attach_puts (txt, s);
+    state_puts (txt, s);
 }
 
 static void print_smime_keyinfo (const char* msg, gpgme_signature_t sig,
@@ -1351,8 +1349,8 @@ static void print_smime_keyinfo (const char* msg, gpgme_signature_t sig,
   gpgme_user_id_t uids = NULL;
   int i, aka = 0;
 
-  state_attach_puts (msg, s);
-  state_attach_puts (" ", s);
+  state_puts (msg, s);
+  state_puts (" ", s);
   /* key is NULL when not present in the user's keyring */
   if (key)
   {
@@ -1366,30 +1364,30 @@ static void print_smime_keyinfo (const char* msg, gpgme_signature_t sig,
          * and "aka" translation length */
 	msglen = mutt_strlen (msg) - 4;
 	for (i = 0; i < msglen; i++)
-	  state_attach_puts(" ", s);
-	state_attach_puts(_("aka: "), s);
+	  state_puts(" ", s);
+	state_puts(_("aka: "), s);
       }
-      state_attach_puts (uids->uid, s);
-      state_attach_puts ("\n", s);
+      state_puts (uids->uid, s);
+      state_puts ("\n", s);
 
       aka = 1;
     }
   }
   else
   {
-    state_attach_puts (_("KeyID "), s);
-    state_attach_puts (sig->fpr, s);
-    state_attach_puts ("\n", s);
+    state_puts (_("KeyID "), s);
+    state_puts (sig->fpr, s);
+    state_puts ("\n", s);
   }
 
   msglen = mutt_strlen (msg) - 8;
   /* TODO: need to account for msg wide characters
    * and "created" translation length */
   for (i = 0; i < msglen; i++)
-    state_attach_puts(" ", s);
-  state_attach_puts (_("created: "), s);
+    state_puts(" ", s);
+  state_puts (_("created: "), s);
   print_time (sig->timestamp, s);
-  state_attach_puts ("\n", s);  
+  state_puts ("\n", s);
 }
 
 /* Show information about one signature.  This function is called with
@@ -1461,7 +1459,7 @@ static int show_one_sig_status (gpgme_ctx_t ctx, int idx, STATE *s)
           snprintf (buf, sizeof (buf),
               _("Error getting key information for KeyID %s: %s\n"),
               fpr, gpgme_strerror (err));
-          state_attach_puts (buf, s);
+          state_puts (buf, s);
           anybad = 1;
 	}
       else if ((sum & GPGME_SIGSUM_GREEN))
@@ -1496,9 +1494,9 @@ static int show_one_sig_status (gpgme_ctx_t ctx, int idx, STATE *s)
           /* L10N:
              This is trying to match the width of the
              "Problem signature from:" translation just above. */
-	  state_attach_puts (_("               expires: "), s);
+	  state_puts (_("               expires: "), s);
 	  print_time (sig->exp_timestamp, s);
-	  state_attach_puts ("\n", s);
+	  state_puts ("\n", s);
 	}
 	show_sig_summary (sum, ctx, key, idx, s, sig);
         anywarn = 1;
@@ -1557,12 +1555,13 @@ static int verify_one (BODY *sigbdy, STATE *s,
       snprintf (buf, sizeof(buf)-1, 
                 _("Error: verification failed: %s\n"),
                 gpgme_strerror (err));
-      state_attach_puts (buf, s);
+      state_puts (buf, s);
     }
   else
     { /* Verification succeeded, see what the result is. */
       int res, idx;
       int anybad = 0;
+      gpgme_verify_result_t verify_result;
 
       if (signature_key)
 	{
@@ -1570,15 +1569,19 @@ static int verify_one (BODY *sigbdy, STATE *s,
 	  signature_key = NULL;
 	}
 
-      for(idx=0; (res = show_one_sig_status (ctx, idx, s)) != -1; idx++)
+      verify_result = gpgme_op_verify_result (ctx);
+      if (verify_result && verify_result->signatures)
+      {
+        for (idx=0; (res = show_one_sig_status (ctx, idx, s)) != -1; idx++)
         {
           if (res == 1)
             anybad = 1;
           else if (res == 2)
             anywarn = 2;
         }
-      if (!anybad)
-        badsig = 0;
+        if (!anybad)
+          badsig = 0;
+      }
     }
 
   if (!badsig)
@@ -1606,7 +1609,7 @@ static int verify_one (BODY *sigbdy, STATE *s,
 	    snprintf (buf, sizeof (buf),
 		      _("*** Begin Notation (signature by: %s) ***\n"),
 		      signature->fpr);
-	    state_attach_puts (buf, s);
+	    state_puts (buf, s);
 	    for (notation = signature->notations; notation;
                  notation = notation->next)
 	    {
@@ -1615,18 +1618,18 @@ static int verify_one (BODY *sigbdy, STATE *s,
 
 	      if (notation->name)
 	      {
-		state_attach_puts (notation->name, s);
-		state_attach_puts ("=", s);
+		state_puts (notation->name, s);
+		state_puts ("=", s);
 	      }
 	      if (notation->value)
 	      {
-		state_attach_puts (notation->value, s);
+		state_puts (notation->value, s);
 		if (!(*notation->value
                       && (notation->value[strlen (notation->value)-1]=='\n')))
-		  state_attach_puts ("\n", s);
+		  state_puts ("\n", s);
 	      }
 	    }
-	    state_attach_puts (_("*** End Notation ***\n"), s);
+	    state_puts (_("*** End Notation ***\n"), s);
 	  }
 	}
       }
@@ -2440,7 +2443,7 @@ int pgp_gpgme_application_handler (BODY *m, STATE *s)
                   snprintf (errbuf, sizeof(errbuf)-1, 
                             _("Error: decryption/verification failed: %s\n"),
                             gpgme_strerror (err));
-                  state_attach_puts (errbuf, s);
+                  state_puts (errbuf, s);
                 }
               else
                 { /* Decryption/Verification succeeded */
@@ -2483,7 +2486,7 @@ int pgp_gpgme_application_handler (BODY *m, STATE *s)
                   if (!tmpfname)
                     {
                       pgpout = NULL;
-                      state_attach_puts (_("Error: copy data failed\n"), s);
+                      state_puts (_("Error: copy data failed\n"), s);
                     }
                   else
                     {
@@ -2815,9 +2818,6 @@ static const char *crypt_entry_fmt (char *dest,
 	}
 	*p = 0;
 
-	if (do_locales && Locale)
-	  setlocale (LC_TIME, Locale);
-        
         {
 	  time_t tt = 0;
 
@@ -2826,11 +2826,13 @@ static const char *crypt_entry_fmt (char *dest,
 
           tm = localtime (&tt);
         }
-	strftime (buf2, sizeof (buf2), dest, tm);
 
-	if (do_locales)
-	  setlocale (LC_TIME, "C");
-        
+        if (!do_locales)
+          setlocale (LC_TIME, "C");
+        strftime (buf2, sizeof (buf2), dest, tm);
+        if (!do_locales)
+          setlocale (LC_TIME, "");
+
 	snprintf (fmt, sizeof (fmt), "%%%ss", prefix);
 	snprintf (dest, destlen, fmt, buf2);
 	if (len > 0)
@@ -3371,9 +3373,6 @@ static void print_key_info (gpgme_key_t key, FILE *fp)
   int i;
   gpgme_user_id_t uid = NULL;
 
-  if (Locale)
-    setlocale (LC_TIME, Locale);
-
   is_pgp = key->protocol == GPGME_PROTOCOL_OpenPGP;
 
   for (idx = 0, uid = key->uids; uid; idx++, uid = uid->next)
@@ -3613,9 +3612,6 @@ static void print_key_info (gpgme_key_t key, FILE *fp)
           putc ('\n', fp);
         }
     }
-
-  if (Locale)
-    setlocale (LC_TIME, "C");
 }
 
 
@@ -3708,7 +3704,7 @@ static char *list_to_pattern (LIST *list)
     {
       for(s = l->data; *s; s++)
         {
-          if (*s == '%')
+          if (*s == '%' || *s == '+')
             n += 2;
           n++;
         }
diff --git c/crypt.c w/crypt.c
index 7659fdc..ba2290a 100644
--- c/crypt.c
+++ w/crypt.c
@@ -64,9 +64,7 @@ void crypt_current_time(STATE *s, char *app_name)
   if (option (OPTCRYPTTIMESTAMP))
   {
     t = time(NULL);
-    setlocale (LC_TIME, "");
     strftime (p, sizeof (p), _(" (current time: %c)"), localtime (&t));
-    setlocale (LC_TIME, "C");
   }
   else
     *p = '\0';
@@ -231,8 +229,21 @@ int mutt_protect (HEADER *msg, char *keylist)
     if ((WithCrypto & APPLICATION_SMIME)
         && (msg->security & APPLICATION_SMIME))
     {
-      if (!(tmp_pbody = crypt_smime_build_smime_entity (tmp_smime_pbody,
-                                                        keylist)))
+      char *new_keylist = keylist;
+
+      if (SmimeDefaultKey && query_quadoption(OPT_SMIMEENCRYPTSELF, _("Encrypt message to S/MIME Default Key also?")) == MUTT_YES)
+      {
+        /* +1 for NULL, +1 for \n */
+        int size = mutt_strlen(keylist) + mutt_strlen(SmimeDefaultKey) + 2;
+        new_keylist = safe_malloc(size);
+        snprintf(new_keylist, size, "%s%s\n", keylist, SmimeDefaultKey);
+      }
+
+      tmp_pbody = crypt_smime_build_smime_entity (tmp_smime_pbody, new_keylist);
+      if (new_keylist != keylist)
+        FREE (&new_keylist);
+
+      if (!tmp_pbody)
       {
 	/* signed ? free it! */
 	return (-1);
@@ -252,10 +263,22 @@ int mutt_protect (HEADER *msg, char *keylist)
     if ((WithCrypto & APPLICATION_PGP)
         && (msg->security & APPLICATION_PGP))
     {
-      if (!(pbody = crypt_pgp_encrypt_message (tmp_pgp_pbody, keylist,
-                                               flags & SIGN)))
+      char *new_keylist = keylist;
+
+      if (PgpSignAs && query_quadoption (OPT_PGPENCRYPTSELF, _("Encrypt message to PGP Default Key also?")) == MUTT_YES)
       {
+        /* +1 for SPACE, +1 for NULL */
+        int size = mutt_strlen (keylist) + mutt_strlen (PgpSignAs) + 2;
+        new_keylist = safe_malloc (size);
+        snprintf (new_keylist, size, "%s %s", keylist, PgpSignAs);
+      }
 
+      pbody = crypt_pgp_encrypt_message (tmp_pgp_pbody, new_keylist,
+                                               flags & SIGN);
+      if (new_keylist != keylist)
+	FREE(&new_keylist);
+      if (!pbody)
+      {
 	/* did we perform a retainable signature? */
 	if (flags != msg->security)
 	{
diff --git c/curs_lib.c w/curs_lib.c
index 8b21c43..e829959 100644
--- c/curs_lib.c
+++ w/curs_lib.c
@@ -44,6 +44,10 @@
 #include <langinfo.h>
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 /* not possible to unget more than one char under some curses libs, and it
  * is impossible to unget function keys in SLang, so roll our own input
  * buffering routines.
@@ -125,9 +129,10 @@ event_t mutt_getch (void)
     return err;
   }
 
-  if(ch == ERR)
+  /* either timeout, a sigwinch (if timeout is set), or the terminal
+   * has been lost */
+  if (ch == ERR)
   {
-    /* either timeout or the terminal has been lost */
     if (!isatty (0))
     {
       endwin ();
@@ -419,6 +424,67 @@ void mutt_progress_init (progress_t* progress, const char *msg,
   mutt_progress_update (progress, 0, 0);
 }
 
+/**
+ * message_bar - Draw a colourful progress bar
+ * @percent: %age complete
+ * @fmt:     printf(1)-like formatting string
+ * @...:     Arguments to formatting string
+ */
+static void
+message_bar (int percent, const char *fmt, ...)
+{
+  va_list ap;
+  char buf[STRING], buf2[STRING];
+  int w = percent * COLS / 100;
+  size_t l;
+
+  va_start (ap, fmt);
+  vsnprintf (buf, sizeof (buf), fmt, ap);
+  l = mutt_strwidth (buf);
+  va_end (ap);
+
+  mutt_format_string (buf2, sizeof (buf2), 0, COLS-2, FMT_LEFT, 0, buf, sizeof (buf), 0);
+
+  move (LINES - 1, 0);
+
+  if (ColorDefs[MT_COLOR_PROGRESS] == 0)
+  {
+    addstr (buf2);
+  }
+  else
+  {
+    if (l < w)
+    {
+      /* The string fits within the colour bar */
+      SETCOLOR(MT_COLOR_PROGRESS);
+      addstr (buf2);
+      w -= l;
+      while (w--)
+      {
+        addch (' ');
+      }
+      SETCOLOR(MT_COLOR_NORMAL);
+    }
+    else
+    {
+      /* The string is too long for the colour bar */
+      char ch;
+      int off = mutt_wstr_trunc (buf2, sizeof (buf2), w, NULL);
+
+      ch = buf2[off];
+      buf2[off] = 0;
+      SETCOLOR(MT_COLOR_PROGRESS);
+      addstr (buf2);
+      buf2[off] = ch;
+      SETCOLOR(MT_COLOR_NORMAL);
+      addstr (&buf2[off]);
+    }
+  }
+
+  clrtoeol();
+  mutt_refresh();
+}
+
 void mutt_progress_update (progress_t* progress, long pos, int percent)
 {
   char posstr[SHORT_STRING];
@@ -469,16 +535,16 @@ void mutt_progress_update (progress_t* progress, long pos, int percent)
 
     if (progress->size > 0)
     {
-      mutt_message ("%s %s/%s (%d%%)", progress->msg, posstr, progress->sizestr,
-		    percent > 0 ? percent :
-		   	(int) (100.0 * (double) progress->pos / progress->size));
+      message_bar ((percent > 0) ? percent : (int) (100.0 * (double) progress->pos / progress->size),
+        "%s %s/%s (%d%%)", progress->msg, posstr, progress->sizestr,
+        (percent > 0) ? percent : (int) (100.0 * (double) progress->pos / progress->size));
     }
     else
     {
       if (percent > 0)
-	mutt_message ("%s %s (%d%%)", progress->msg, posstr, percent);
+        message_bar (percent, "%s %s (%d%%)", progress->msg, posstr, percent);
       else
-	mutt_message ("%s %s", progress->msg, posstr);
+        mutt_message ("%s %s", progress->msg, posstr);
     }
   }
 
@@ -541,9 +607,13 @@ void mutt_reflow_windows (void)
   {
     memcpy (MuttSidebarWindow, MuttIndexWindow, sizeof (mutt_window_t));
     MuttSidebarWindow->cols = SidebarWidth;
-
     MuttIndexWindow->cols -= SidebarWidth;
-    MuttIndexWindow->col_offset += SidebarWidth;
+
+    if (option (OPTSIDEBARONRIGHT)) {
+      MuttSidebarWindow->col_offset = COLS - SidebarWidth;
+    } else {
+      MuttIndexWindow->col_offset += SidebarWidth;
+    }
   }
 #endif
 }
@@ -731,7 +801,9 @@ int mutt_do_pager (const char *banner,
   return rc;
 }
 
-int _mutt_enter_fname (const char *prompt, char *buf, size_t blen, int *redraw, int buffy, int multiple, char ***files, int *numfiles)
+int _mutt_enter_fname (const char *prompt, char *buf, size_t blen,
+		int *redraw, int buffy, int multiple,
+		char ***files, int *numfiles, int flags)
 {
   event_t ch;
 
@@ -754,8 +826,10 @@ int _mutt_enter_fname (const char *prompt, char *buf, size_t blen, int *redraw,
   {
     mutt_refresh ();
     buf[0] = 0;
-    _mutt_select_file (buf, blen, MUTT_SEL_FOLDER | (multiple ? MUTT_SEL_MULTI : 0), 
-		       files, numfiles);
+    if (!flags)
+      flags = MUTT_SEL_FOLDER | (multiple ? MUTT_SEL_MULTI : 0);
+
+    _mutt_select_file (buf, blen, flags, files, numfiles);
     *redraw = REDRAW_FULL;
   }
   else
@@ -769,6 +843,10 @@ int _mutt_enter_fname (const char *prompt, char *buf, size_t blen, int *redraw,
       buf[0] = 0;
     MAYBE_REDRAW (*redraw);
     FREE (&pc);
+#ifdef USE_NOTMUCH
+    if ((flags & MUTT_SEL_VFOLDER) && buf[0] && strncmp(buf, "notmuch://", 10) != 0)
+      nm_description_to_path(buf, buf, blen);
+#endif
   }
 
   return 0;
@@ -933,6 +1011,7 @@ void mutt_format_string (char *dest, size_t destlen,
   size_t k, k2;
   char scratch[MB_LEN_MAX];
   mbstate_t mbstate1, mbstate2;
+  int escaped = 0;
 
   memset(&mbstate1, 0, sizeof (mbstate1));
   memset(&mbstate2, 0, sizeof (mbstate2));
@@ -948,8 +1027,15 @@ void mutt_format_string (char *dest, size_t destlen,
       k = (k == (size_t)(-1)) ? 1 : n;
       wc = replacement_char ();
     }
-    if (arboreal && wc < MUTT_TREE_MAX)
+    if (escaped) {
+      escaped = 0;
+      w = 0;
+    } else if (arboreal && wc == MUTT_SPECIAL_INDEX) {
+      escaped = 1;
+      w = 0;
+    } else if (arboreal && wc < MUTT_TREE_MAX) {
       w = 1; /* hack */
+    }
     else
     {
 #ifdef HAVE_ISWBLANK
@@ -1128,7 +1214,12 @@ size_t mutt_wstr_trunc (const char *src, size_t maxlen, size_t maxwid, size_t *w
     cw = wcwidth (wc);
     /* hack because MUTT_TREE symbols aren't turned into characters
      * until rendered by print_enriched_string (#3364) */
-    if (cw < 0 && cl == 1 && src[0] && src[0] < MUTT_TREE_MAX)
+    if ((cw < 0) && (src[0] == MUTT_SPECIAL_INDEX))
+    {
+      cl = 2; /* skip the index coloring sequence */
+      cw = 0;
+    }
+    else if (cw < 0 && cl == 1 && src[0] && src[0] < MUTT_TREE_MAX)
       cw = 1;
     else if (cw < 0)
       cw = 0;			/* unprintable wchar */
@@ -1186,6 +1277,12 @@ int mutt_strwidth (const char *s)
   memset (&mbstate, 0, sizeof (mbstate));
   for (w=0; n && (k = mbrtowc (&wc, s, n, &mbstate)); s += k, n -= k)
   {
+    if (*s == MUTT_SPECIAL_INDEX) {
+      s += 2; /* skip the index coloring sequence */
+      k = 0;
+      continue;
+    }
+
     if (k == (size_t)(-1) || k == (size_t)(-2))
     {
       if (k == (size_t)(-1))
diff --git c/curs_main.c w/curs_main.c
index 8e0f52a..35bfde1 100644
--- c/curs_main.c
+++ w/curs_main.c
@@ -22,6 +22,7 @@
 
 #include "mutt.h"
 #include "mutt_curses.h"
+#include "mx.h"
 #include "mutt_menu.h"
 #include "mailbox.h"
 #include "mapping.h"
@@ -41,8 +42,16 @@
 #include "imap_private.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include "mutt_crypt.h"
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
+
 
 #include <ctype.h>
 #include <stdlib.h>
@@ -123,7 +132,9 @@ short mutt_ts_capability(void)
 {
   char *term = getenv("TERM");
   char *tcaps;
+#ifdef HAVE_USE_EXTENDED_NAMES
   int tcapi;
+#endif
   char **termp;
   char *known[] = {
     "color-xterm",
@@ -193,6 +204,9 @@ void mutt_ts_icon(char *str)
 
 void index_make_entry (char *s, size_t l, MUTTMENU *menu, int num)
 {
+  if (!Context || !menu)
+    return;
+
   format_flag flag = MUTT_FORMAT_MAKEPRINT | MUTT_FORMAT_ARROWCURSOR | MUTT_FORMAT_INDEX;
   int edgemsgno, reverse = Sort & SORT_REVERSE;
   HEADER *h = Context->hdrs[Context->v2r[num]];
@@ -255,13 +269,19 @@ void index_make_entry (char *s, size_t l, MUTTMENU *menu, int num)
 
 int index_color (int index_no)
 {
+  if (!Context)
+    return 0;
+
   HEADER *h = Context->hdrs[Context->v2r[index_no]];
 
   if (h && h->pair)
     return h->pair;
 
   mutt_set_header_color (Context, h);
-  return h->pair;
+  if (h)
+    return h->pair;
+
+  return 0;
 }
 
 static int ci_next_undeleted (int msgno)
@@ -347,13 +367,16 @@ static int mx_toggle_write (CONTEXT *ctx)
   return 0;
 }
 
-static void update_index (MUTTMENU *menu, CONTEXT *ctx, int check,
+void update_index (MUTTMENU *menu, CONTEXT *ctx, int check,
 			  int oldcount, int index_hint)
 {
   /* store pointers to the newly added messages */
   HEADER  **save_new = NULL;
   int j;
 
+  if (!menu || !ctx)
+    return;
+
   /* take note of the current message */
   if (oldcount)
   {
@@ -482,6 +505,223 @@ static void resort_index (MUTTMENU *menu)
   menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
 }
 
+/**
+ * mutt_draw_statusline - Draw a highlighted status bar
+ * @cols:  Maximum number of screen columns
+ * @buf:   Message to be displayed
+ *
+ * Users configure the highlighting of the status bar, e.g.
+ *     color status red default "[0-9][0-9]:[0-9][0-9]"
+ *
+ * Where regexes overlap, the one nearest the start will be used.
+ * If two regexes start at the same place, the longer match will be used.
+ */
+void
+mutt_draw_statusline (int cols, const char *buf, int buflen)
+{
+  int i      = 0;
+  int offset = 0;
+  int found  = 0;
+  int chunks = 0;
+  int len    = 0;
+
+  struct syntax_t
+  {
+    int color;
+    int first;
+    int last;
+  } *syntax = NULL;
+
+  if (!buf)
+    return;
+
+  do
+  {
+    COLOR_LINE *cl;
+    found = 0;
+
+    if (!buf[offset])
+      break;
+
+    /* loop through each "color status regex" */
+    for (cl = ColorStatusList; cl; cl = cl->next)
+    {
+      regmatch_t pmatch[cl->match + 1];
+
+      if (regexec (&cl->rx, buf + offset, cl->match + 1, pmatch, 0) != 0)
+        continue; /* regex doesn't match the status bar */
+
+      int first = pmatch[cl->match].rm_so + offset;
+      int last  = pmatch[cl->match].rm_eo + offset;
+
+      if (first == last)
+        continue; /* ignore an empty regex */
+
+      if (!found)
+      {
+        chunks++;
+        safe_realloc (&syntax, chunks * sizeof (struct syntax_t));
+      }
+
+      i = chunks - 1;
+      if (!found || (first < syntax[i].first) || ((first == syntax[i].first) && (last > syntax[i].last)))
+      {
+        syntax[i].color = cl->pair;
+        syntax[i].first = first;
+        syntax[i].last  = last;
+      }
+      found = 1;
+    }
+
+    if (syntax)
+    {
+      offset = syntax[i].last;
+    }
+  } while (found);
+
+  /* Only 'len' bytes will fit into 'cols' screen columns */
+  len = mutt_wstr_trunc (buf, buflen, cols, NULL);
+
+  offset = 0;
+
+  if ((chunks > 0) && (syntax[0].first > 0))
+  {
+    /* Text before the first highlight */
+    addnstr (buf, MIN(len, syntax[0].first));
+    attrset (ColorDefs[MT_COLOR_STATUS]);
+    if (len <= syntax[0].first)
+      goto dsl_finish;  /* no more room */
+
+    offset = syntax[0].first;
+  }
+
+  for (i = 0; i < chunks; i++)
+  {
+    /* Highlighted text */
+    attrset (syntax[i].color);
+    addnstr (buf + offset, MIN(len, syntax[i].last) - offset);
+    if (len <= syntax[i].last)
+      goto dsl_finish;  /* no more room */
+
+    int next;
+    if ((i + 1) == chunks)
+    {
+      next = len;
+    }
+    else
+    {
+      next = MIN (len, syntax[i+1].first);
+    }
+
+    attrset (ColorDefs[MT_COLOR_STATUS]);
+    offset = syntax[i].last;
+    addnstr (buf + offset, next - offset);
+
+    offset = next;
+    if (offset >= len)
+      goto dsl_finish;  /* no more room */
+  }
+
+  attrset (ColorDefs[MT_COLOR_STATUS]);
+  if (offset < len)
+  {
+    /* Text after the last highlight */
+    addnstr (buf + offset, len - offset);
+  }
+
+  int width = mutt_strwidth (buf);
+  if (width < cols)
+  {
+    /* Pad the rest of the line with whitespace */
+    mutt_paddstr (cols - width, "");
+  }
+dsl_finish:
+  FREE(&syntax);
+}
+
+static int main_change_folder(MUTTMENU *menu, int op, char *buf, size_t bufsz,
+			  int *oldcount, int *index_hint, int flags)
+{
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    unset_option (OPTNEWS);
+    nntp_expand_path (buf, bufsz, &CurrentNewsSrv->conn->account);
+  }
+  else
+#endif
+  mutt_expand_path (buf, bufsz);
+  if (mx_get_magic (buf) <= 0)
+  {
+    mutt_error (_("%s is not a mailbox."), buf);
+    return -1;
+  }
+  mutt_str_replace (&CurrentFolder, buf);
+
+  /* keepalive failure in mutt_enter_fname may kill connection. #3028 */
+  if (Context && !Context->path)
+    FREE (&Context);
+
+  if (Context)
+  {
+    int check;
+
+#ifdef USE_COMPRESSED
+	  if (Context->compress_info && Context->realpath)
+	    mutt_str_replace (&LastFolder, Context->realpath);
+	  else
+#endif
+    mutt_str_replace (&LastFolder, Context->path);
+    *oldcount = Context ? Context->msgcount : 0;
+
+    if ((check = mx_close_mailbox (Context, index_hint)) != 0)
+    {
+      if (check == MUTT_NEW_MAIL || check == MUTT_REOPENED)
+        update_index (menu, Context, check, *oldcount, *index_hint);
+
+      set_option (OPTSEARCHINVALID);
+      menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
+      return 0;
+    }
+    FREE (&Context);
+  }
+
+  if (Labels)
+    hash_destroy(&Labels, NULL);
+
+  mutt_sleep (0);
+
+  /* Set CurrentMenu to MENU_MAIN before executing any folder
+   * hooks so that all the index menu functions are available to
+   * the exec command.
+   */
+
+  CurrentMenu = MENU_MAIN;
+  mutt_folder_hook (buf);
+
+  if ((Context = mx_open_mailbox (buf,
+		(option (OPTREADONLY) || op == OP_MAIN_CHANGE_FOLDER_READONLY) ?
+		MUTT_READONLY : 0, NULL)) != NULL)
+  {
+    Labels = hash_create(131, 0);
+    mutt_scan_labels(Context);
+    menu->current = ci_first_message ();
+  }
+  else
+    menu->current = 0;
+
+#ifdef USE_SIDEBAR
+        mutt_sb_set_open_buffy ();
+#endif
+
+  mutt_clear_error ();
+  mutt_buffy_check(1); /* force the buffy check after we have changed the folder */
+  menu->redraw = REDRAW_FULL;
+  set_option (OPTSEARCHINVALID);
+
+  return 0;
+}
+
 static const struct mapping_t IndexHelp[] = {
   { N_("Quit"),  OP_QUIT },
   { N_("Del"),   OP_DELETE },
@@ -494,12 +734,27 @@ static const struct mapping_t IndexHelp[] = {
   { NULL,	 0 }
 };
 
+#ifdef USE_NNTP
+struct mapping_t IndexNewsHelp[] = {
+  { N_("Quit"),     OP_QUIT },
+  { N_("Del"),      OP_DELETE },
+  { N_("Undel"),    OP_UNDELETE },
+  { N_("Save"),     OP_SAVE },
+  { N_("Post"),     OP_POST },
+  { N_("Followup"), OP_FOLLOWUP },
+  { N_("Catchup"),  OP_CATCHUP },
+  { N_("Help"),     OP_HELP },
+  { NULL,           0 }
+};
+#endif
+
 /* This function handles the message index window as well as commands returned
  * from the pager (MENU_PAGER).
  */
 int mutt_index_menu (void)
 {
   char buf[LONG_STRING], helpstr[LONG_STRING];
+  int flags;
   int op = OP_NULL;
   int done = 0;                /* controls when to exit the "event" loop */
   int i = 0, j;
@@ -518,7 +773,11 @@ int mutt_index_menu (void)
   menu->make_entry = index_make_entry;
   menu->color = index_color;
   menu->current = ci_first_message ();
-  menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_MAIN, IndexHelp);
+  menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_MAIN,
+#ifdef USE_NNTP
+	(Context && (Context->magic == MUTT_NNTP)) ? IndexNewsHelp :
+#endif
+	IndexHelp);
 
   if (!attach_msg)
     mutt_buffy_check(1); /* force the buffy check after we enter the folder */
@@ -577,6 +836,12 @@ int mutt_index_menu (void)
 	  mutt_message _("New mail in this mailbox.");
 	  if (option (OPTBEEPNEW))
 	    beep ();
+	  if (NewMailCmd)
+	  {
+	    char cmd[LONG_STRING];
+	    menu_status_line(cmd, sizeof(cmd), menu, NONULL(NewMailCmd));
+	    mutt_system(cmd);
+	  }
 	} else if (check == MUTT_FLAGS)
 	  mutt_message _("Mailbox was externally modified.");
 
@@ -603,6 +868,12 @@ int mutt_index_menu (void)
          menu->redraw |= REDRAW_STATUS;
          if (option (OPTBEEPNEW))
            beep();
+         if (NewMailCmd)
+         {
+           char cmd[LONG_STRING];
+           menu_status_line(cmd, sizeof(cmd), menu, NONULL(NewMailCmd));
+           mutt_system(cmd);
+         }
        }
      }
      else
@@ -647,7 +918,7 @@ int mutt_index_menu (void)
 	menu_status_line (buf, sizeof (buf), menu, NONULL (Status));
         mutt_window_move (MuttStatusWindow, 0, 0);
 	SETCOLOR (MT_COLOR_STATUS);
-	mutt_paddstr (MuttStatusWindow->cols, buf);
+	mutt_draw_statusline (MuttStatusWindow->cols, buf, sizeof (buf));
 	NORMAL_COLOR;
 	menu->redraw &= ~REDRAW_STATUS;
 	if (option(OPTTSENABLED) && TSSupported)
@@ -696,8 +967,10 @@ int mutt_index_menu (void)
 
       dprint(4, (debugfile, "mutt_index_menu[%d]: Got op %d\n", __LINE__, op));
 
-      if (op == -1)
+      if (op == -1) {
+        mutt_timeout_hook();
 	continue; /* either user abort or timeout */
+      }
 
       mutt_curs_set (1);
 
@@ -773,6 +1046,15 @@ int mutt_index_menu (void)
       mutt_curs_set (1);	/* fallback from the pager */
     }
 
+#ifdef USE_NNTP
+    unset_option (OPTNEWS);	/* for any case */
+#endif
+
+#ifdef USE_NOTMUCH
+    if (Context)
+      nm_debug_check(Context);
+#endif
+
     switch (op)
     {
 
@@ -823,6 +1105,161 @@ int mutt_index_menu (void)
 	menu_current_bottom (menu);
 	break;
 
+#ifdef USE_NNTP
+      case OP_GET_PARENT:
+	CHECK_MSGCOUNT;
+	CHECK_VISIBLE;
+
+      case OP_GET_MESSAGE:
+	CHECK_IN_MAILBOX;
+	CHECK_READONLY;
+	CHECK_ATTACH;
+	if (Context->magic == MUTT_NNTP)
+	{
+	  HEADER *hdr;
+
+	  if (op == OP_GET_MESSAGE)
+	  {
+	    buf[0] = 0;
+	    if (mutt_get_field (_("Enter Message-Id: "),
+		buf, sizeof (buf), 0) != 0 || !buf[0])
+	      break;
+	  }
+	  else
+	  {
+	    LIST *ref = CURHDR->env->references;
+	    if (!ref)
+	    {
+	      mutt_error _("Article has no parent reference.");
+	      break;
+	    }
+	    strfcpy (buf, ref->data, sizeof (buf));
+	  }
+	  if (!Context->id_hash)
+	    Context->id_hash = mutt_make_id_hash (Context);
+	  hdr = hash_find (Context->id_hash, buf);
+	  if (hdr)
+	  {
+	    if (hdr->virtual != -1)
+	    {
+	      menu->current = hdr->virtual;
+	      menu->redraw = REDRAW_MOTION_RESYNCH;
+	    }
+	    else if (hdr->collapsed)
+	    {
+	      mutt_uncollapse_thread (Context, hdr);
+	      mutt_set_virtual (Context);
+	      menu->current = hdr->virtual;
+	      menu->redraw = REDRAW_MOTION_RESYNCH;
+	    }
+	    else
+	      mutt_error _("Message is not visible in limited view.");
+	  }
+	  else
+	  {
+	    int rc;
+
+	    mutt_message (_("Fetching %s from server..."), buf);
+	    rc = nntp_check_msgid (Context, buf);
+	    if (rc == 0)
+	    {
+	      hdr = Context->hdrs[Context->msgcount - 1];
+	      mutt_sort_headers (Context, 0);
+	      menu->current = hdr->virtual;
+	      menu->redraw = REDRAW_FULL;
+	    }
+	    else if (rc > 0)
+	      mutt_error (_("Article %s not found on the server."), buf);
+	  }
+	}
+	break;
+
+      case OP_GET_CHILDREN:
+      case OP_RECONSTRUCT_THREAD:
+	CHECK_MSGCOUNT;
+	CHECK_VISIBLE;
+	CHECK_READONLY;
+	CHECK_ATTACH;
+	if (Context->magic == MUTT_NNTP)
+	{
+	  int oldmsgcount = Context->msgcount;
+	  int oldindex = CURHDR->index;
+	  int rc = 0;
+
+	  if (!CURHDR->env->message_id)
+	  {
+	    mutt_error _("No Message-Id. Unable to perform operation.");
+	    break;
+	  }
+
+	  mutt_message _("Fetching message headers...");
+	  if (!Context->id_hash)
+	    Context->id_hash = mutt_make_id_hash (Context);
+	  strfcpy (buf, CURHDR->env->message_id, sizeof (buf));
+
+	  /* trying to find msgid of the root message */
+	  if (op == OP_RECONSTRUCT_THREAD)
+	  {
+	    LIST *ref = CURHDR->env->references;
+	    while (ref)
+	    {
+	      if (hash_find (Context->id_hash, ref->data) == NULL)
+	      {
+		rc = nntp_check_msgid (Context, ref->data);
+		if (rc < 0)
+		  break;
+	      }
+
+	      /* the last msgid in References is the root message */
+	      if (!ref->next)
+		strfcpy (buf, ref->data, sizeof (buf));
+	      ref = ref->next;
+	    }
+	  }
+
+	  /* fetching all child messages */
+	  if (rc >= 0)
+	    rc = nntp_check_children (Context, buf);
+
+	  /* at least one message has been loaded */
+	  if (Context->msgcount > oldmsgcount)
+	  {
+	    HEADER *hdr;
+	    int i, quiet = Context->quiet;
+
+	    if (rc < 0)
+	      Context->quiet = 1;
+	    mutt_sort_headers (Context, (op == OP_RECONSTRUCT_THREAD));
+	    Context->quiet = quiet;
+
+	    /* if the root message was retrieved, move to it */
+	    hdr = hash_find (Context->id_hash, buf);
+	    if (hdr)
+	      menu->current = hdr->virtual;
+
+	    /* try to restore old position */
+	    else
+	    {
+	      for (i = 0; i < Context->msgcount; i++)
+	      {
+		if (Context->hdrs[i]->index == oldindex)
+		{
+		  menu->current = Context->hdrs[i]->virtual;
+		  /* as an added courtesy, recenter the menu
+		   * with the current entry at the middle of the screen */
+		  menu_check_recenter (menu);
+		  menu_current_middle (menu);
+		}
+	      }
+	    }
+	    menu->redraw = REDRAW_FULL;
+	  }
+	  else if (rc >= 0)
+	    mutt_error _("No deleted messages found in the thread.");
+	}
+	break;
+#endif
+
       case OP_JUMP:
 
 	CHECK_MSGCOUNT;
@@ -919,12 +1356,35 @@ int mutt_index_menu (void)
 	}
         break;
 
+      case OP_LIMIT_CURRENT_THREAD:
       case OP_MAIN_LIMIT:
+      case OP_TOGGLE_READ:
 
 	CHECK_IN_MAILBOX;
 	menu->oldcurrent = (Context->vcount && menu->current >= 0 && menu->current < Context->vcount) ?
 		CURHDR->index : -1;
-	if (mutt_pattern_func (MUTT_LIMIT, _("Limit to messages matching: ")) == 0)
+	if (op == OP_TOGGLE_READ)
+	{
+	  char buf[LONG_STRING];
+
+	  if (!Context->pattern || strncmp (Context->pattern, "!~R!~D~s", 8) != 0)
+	  {
+	    snprintf (buf, sizeof (buf), "!~R!~D~s%s",
+		      Context->pattern ? Context->pattern : ".*");
+	    set_option (OPTHIDEREAD);
+	  }
+	  else
+	  {
+	    strfcpy (buf, Context->pattern + 8, sizeof(buf));
+	    if (!*buf || strncmp (buf, ".*", 2) == 0)
+	      snprintf (buf, sizeof(buf), "~A");
+	    unset_option (OPTHIDEREAD);
+	  }
+	  FREE (&Context->pattern);
+	  Context->pattern = safe_strdup (buf);
+	}
+	if ((op == OP_TOGGLE_READ && mutt_pattern_func (MUTT_LIMIT, NULL) == 0) ||
+	    mutt_pattern_func (MUTT_LIMIT, _("Limit to messages matching: ")) == 0)
 	{
 	  if (menu->oldcurrent >= 0)
 	  {
@@ -1072,6 +1532,12 @@ int mutt_index_menu (void)
 	  menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
 	break;
 
+      case OP_COMPOSE_TO_SENDER:
+
+	mutt_compose_to_sender (tag ? NULL : CURHDR);
+	menu->redraw = REDRAW_FULL;
+	break;
+
 	/* --------------------------------------------------------------------
 	 * The following operations can be performed inside of the pager.
 	 */
@@ -1165,22 +1631,175 @@ int mutt_index_menu (void)
 	  menu->redraw = REDRAW_FULL;
 	break;
 
+      case OP_MAIN_QUASI_DELETE:
+	CHECK_MSGCOUNT;
+        CHECK_VISIBLE;
+	if (tag) {
+	  for (j = 0; j < Context->vcount; j++) {
+	    if (Context->hdrs[Context->v2r[j]]->tagged) {
+	      Context->hdrs[Context->v2r[j]]->quasi_deleted = TRUE;
+	      Context->changed = TRUE;
+	    }
+	  }
+	} else {
+	  CURHDR->quasi_deleted = TRUE;
+	  Context->changed = 1;
+	}
+	break;
+
+#ifdef USE_NOTMUCH
+      case OP_MAIN_ENTIRE_THREAD:
+      {
+	int oldcount  = Context->msgcount;
+	if (Context->magic != MUTT_NOTMUCH) {
+	  mutt_message _("No virtual folder, aborting.");
+	  break;
+	}
+	CHECK_MSGCOUNT;
+        CHECK_VISIBLE;
+	if (nm_read_entire_thread(Context, CURHDR) < 0) {
+	   mutt_message _("Failed to read thread, aborting.");
+	   break;
+	}
+	if (oldcount < Context->msgcount) {
+		HEADER *oldcur = CURHDR;
+
+		if ((Sort & SORT_MASK) == SORT_THREADS)
+			mutt_sort_headers (Context, 0);
+		menu->current = oldcur->virtual;
+		menu->redraw = REDRAW_STATUS | REDRAW_INDEX;
+
+		if (oldcur->collapsed || Context->collapsed) {
+			menu->current = mutt_uncollapse_thread(Context, CURHDR);
+			mutt_set_virtual(Context);
+		}
+	}
+	if (menu->menu == MENU_PAGER)
+	{
+	  op = OP_DISPLAY_MESSAGE;
+	  continue;
+	}
+	break;
+      }
+
+      case OP_MAIN_MODIFY_LABELS:
+      case OP_MAIN_MODIFY_LABELS_THEN_HIDE:
+      {
+	if (Context->magic != MUTT_NOTMUCH) {
+	  mutt_message _("No virtual folder, aborting.");
+	  break;
+	}
+	CHECK_MSGCOUNT;
+        CHECK_VISIBLE;
+	*buf = '\0';
+	if (mutt_get_field ("Add/remove labels: ", buf, sizeof (buf), MUTT_NM_TAG) || !*buf)
+	{
+          mutt_message _("No label specified, aborting.");
+          break;
+        }
+	if (tag)
+	{
+	  char msgbuf[STRING];
+	  progress_t progress;
+	  int px;
+
+	  if (!Context->quiet) {
+	    snprintf(msgbuf, sizeof (msgbuf), _("Update labels..."));
+	    mutt_progress_init(&progress, msgbuf, MUTT_PROGRESS_MSG,
+				   1, Context->tagged);
+	  }
+	  nm_longrun_init(Context, TRUE);
+	  for (px = 0, j = 0; j < Context->vcount; j++) {
+	    if (Context->hdrs[Context->v2r[j]]->tagged) {
+	      if (!Context->quiet)
+		mutt_progress_update(&progress, ++px, -1);
+	      nm_modify_message_tags(Context, Context->hdrs[Context->v2r[j]], buf);
+	      if (op == OP_MAIN_MODIFY_LABELS_THEN_HIDE)
+	      {
+		Context->hdrs[Context->v2r[j]]->quasi_deleted = TRUE;
+	        Context->changed = TRUE;
+	      }
+	    }
+	  }
+	  nm_longrun_done(Context);
+	  menu->redraw = REDRAW_STATUS | REDRAW_INDEX;
+	}
+	else
+	{
+	  if (nm_modify_message_tags(Context, CURHDR, buf)) {
+	    mutt_message _("Failed to modify labels, aborting.");
+	    break;
+	  }
+	  if (op == OP_MAIN_MODIFY_LABELS_THEN_HIDE)
+	  {
+	    CURHDR->quasi_deleted = TRUE;
+	    Context->changed = TRUE;
+	  }
+	  if (menu->menu == MENU_PAGER)
+	  {
+	    op = OP_DISPLAY_MESSAGE;
+	    continue;
+	  }
+	  if (option (OPTRESOLVE))
+	  {
+	    if ((menu->current = ci_next_undeleted (menu->current)) == -1)
+	    {
+	      menu->current = menu->oldcurrent;
+	      menu->redraw = REDRAW_CURRENT;
+	    }
+	    else
+	      menu->redraw = REDRAW_MOTION_RESYNCH;
+	  }
+	  else
+	    menu->redraw = REDRAW_CURRENT;
+	}
+	menu->redraw |= REDRAW_STATUS;
+	break;
+      }
+
+      case OP_MAIN_VFOLDER_FROM_QUERY:
+	buf[0] = '\0';
+        if (mutt_get_field ("Query: ", buf, sizeof (buf), MUTT_NM_QUERY) != 0 || !buf[0])
+        {
+          mutt_message _("No query, aborting.");
+          break;
+        }
+	if (!nm_uri_from_query(Context, buf, sizeof (buf)))
+	  mutt_message _("Failed to create query, aborting.");
+	else
+	  main_change_folder(menu, op, buf, sizeof (buf), &oldcount, &index_hint, 0);
+	break;
+
+      case OP_MAIN_CHANGE_VFOLDER:
+#endif
+
 #ifdef USE_SIDEBAR
       case OP_SIDEBAR_OPEN:
 #endif
       case OP_MAIN_CHANGE_FOLDER:
       case OP_MAIN_NEXT_UNREAD_MAILBOX:
-
-	if (attach_msg)
-	  op = OP_MAIN_CHANGE_FOLDER_READONLY;
-
-	/* fallback to the readonly case */
-
       case OP_MAIN_CHANGE_FOLDER_READONLY:
+#ifdef USE_NNTP
+      case OP_MAIN_CHANGE_GROUP:
+      case OP_MAIN_CHANGE_GROUP_READONLY:
+	unset_option (OPTNEWS);
+#endif
+	if (attach_msg || option (OPTREADONLY) ||
+#ifdef USE_NNTP
+	    op == OP_MAIN_CHANGE_GROUP_READONLY ||
+#endif
+	    op == OP_MAIN_CHANGE_FOLDER_READONLY)
+	  flags = MUTT_READONLY;
+	else
+	  flags = 0;
 
-        if ((op == OP_MAIN_CHANGE_FOLDER_READONLY) || option (OPTREADONLY))
+	if (flags)
           cp = _("Open mailbox in read-only mode");
-        else
+#ifdef USE_NOTMUCH
+        else if (op == OP_MAIN_CHANGE_VFOLDER)
+	  cp = _("Open virtual folder");
+#endif
+	else
           cp = _("Open mailbox");
 
 	buf[0] = '\0';
@@ -1202,10 +1821,45 @@ int mutt_index_menu (void)
           if (!path || !*path)
             break;
           strncpy (buf, path, sizeof (buf));
+
+          /* Mark the selected dir for the mutt browser */
+          mutt_browser_select_dir (buf);
         }
 #endif
+#ifdef USE_NOTMUCH
+	else if (op == OP_MAIN_CHANGE_VFOLDER) {
+	  if (Context->magic == MUTT_NOTMUCH) {
+		  strfcpy(buf, Context->path, sizeof (buf));
+		  mutt_buffy_vfolder (buf, sizeof (buf));
+	  }
+	  mutt_enter_vfolder (cp, buf, sizeof (buf), &menu->redraw, 1);
+	  if (!buf[0])
+	  {
+            mutt_window_clearline (MuttMessageWindow, 0);
+	    break;
+	  }
+	}
+#endif
 	else
 	{
+#ifdef USE_NNTP
+	  if (op == OP_MAIN_CHANGE_GROUP ||
+	      op == OP_MAIN_CHANGE_GROUP_READONLY)
+	  {
+	    set_option (OPTNEWS);
+	    CurrentNewsSrv = nntp_select_server (NewsServer, 0);
+	    if (!CurrentNewsSrv)
+	      break;
+	    if (flags)
+	      cp = _("Open newsgroup in read-only mode");
+	    else
+	      cp = _("Open newsgroup");
+	    nntp_buffy (buf, sizeof (buf));
+	  }
+	  else
+#endif
+	  /* By default, fill buf with the next mailbox that contains unread
+	   * mail */
 	  mutt_buffy (buf, sizeof (buf));
 
           if (mutt_enter_fname (cp, buf, sizeof (buf), &menu->redraw, 1) == -1)
@@ -1218,6 +1872,10 @@ int mutt_index_menu (void)
             else
               break;
           }
+          
+          /* Selected directory is okay, let's save it.*/
+          mutt_browser_select_dir (buf);
+
 	  if (!buf[0])
 	  {
             mutt_window_clearline (MuttMessageWindow, 0);
@@ -1225,65 +1883,16 @@ int mutt_index_menu (void)
 	  }
 	}
 
+	main_change_folder(menu, op, buf, sizeof (buf), &oldcount, &index_hint, flags);
+#ifdef USE_NNTP
+	/* mutt_buffy_check() must be done with mail-reader mode! */
+	menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_MAIN,
+	  (Context && (Context->magic == MUTT_NNTP)) ? IndexNewsHelp : IndexHelp);
+#endif
 	mutt_expand_path (buf, sizeof (buf));
-	if (mx_get_magic (buf) <= 0)
-	{
-	  mutt_error (_("%s is not a mailbox."), buf);
-	  break;
-	}
-	mutt_str_replace (&CurrentFolder, buf);
-
-	/* keepalive failure in mutt_enter_fname may kill connection. #3028 */
-	if (Context && !Context->path)
-	  FREE (&Context);
-
-        if (Context)
-        {
-	  int check;
-
-	  mutt_str_replace (&LastFolder, Context->path);
-	  oldcount = Context ? Context->msgcount : 0;
-
-	  if ((check = mx_close_mailbox (Context, &index_hint)) != 0)
-	  {
-	    if (check == MUTT_NEW_MAIL || check == MUTT_REOPENED)
-	      update_index (menu, Context, check, oldcount, index_hint);
-
-	    set_option (OPTSEARCHINVALID);
-	    menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
-	    break;
-	  }
-	  FREE (&Context);
-	}
-
-        mutt_sleep (0);
-
-	/* Set CurrentMenu to MENU_MAIN before executing any folder
-	 * hooks so that all the index menu functions are available to
-	 * the exec command.
-	 */
-
-	CurrentMenu = MENU_MAIN;
-	mutt_folder_hook (buf);
-
-	if ((Context = mx_open_mailbox (buf,
-					(option (OPTREADONLY) || op == OP_MAIN_CHANGE_FOLDER_READONLY) ?
-					MUTT_READONLY : 0, NULL)) != NULL)
-	{
-	  menu->current = ci_first_message ();
-	}
-	else
-	  menu->current = 0;
-
 #ifdef USE_SIDEBAR
-        mutt_sb_set_open_buffy ();
+        mutt_sb_set_open_buffy();
 #endif
-
-	mutt_clear_error ();
-	mutt_buffy_check(1); /* force the buffy check after we have changed
-			      the folder */
-	menu->redraw = REDRAW_FULL;
-	set_option (OPTSEARCHINVALID);
 	break;
 
       case OP_DISPLAY_MESSAGE:
@@ -1331,7 +1940,7 @@ int mutt_index_menu (void)
 
 	if ((menu->menu == MENU_MAIN)
 	    && (query_quadoption (OPT_QUIT,
-				  _("Exit Mutt without saving?")) == MUTT_YES))
+				  _("Exit NeoMutt without saving?")) == MUTT_YES))
 	{
 	  if (Context)
 	  {
@@ -1347,6 +1956,7 @@ int mutt_index_menu (void)
 	CHECK_MSGCOUNT;
         CHECK_VISIBLE;
 	CHECK_READONLY;
+	CHECK_ACL(MUTT_ACL_WRITE, _("Cannot break thread"));
 
         if ((Sort & SORT_MASK) != SORT_THREADS)
 	  mutt_error _("Threading is not enabled.");
@@ -1382,7 +1992,7 @@ int mutt_index_menu (void)
         CHECK_VISIBLE;
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(MUTT_ACL_DELETE, _("Cannot link threads"));
+	CHECK_ACL(MUTT_ACL_WRITE, _("Cannot link threads"));
 
         if ((Sort & SORT_MASK) != SORT_THREADS)
 	  mutt_error _("Threading is not enabled.");
@@ -1996,21 +2606,28 @@ int mutt_index_menu (void)
 
       case OP_DELETE_THREAD:
       case OP_DELETE_SUBTHREAD:
+      case OP_PURGE_THREAD:
 
 	CHECK_MSGCOUNT;
-        CHECK_VISIBLE;
+	CHECK_VISIBLE;
 	CHECK_READONLY;
-        /* L10N: CHECK_ACL */
+	/* L10N: CHECK_ACL */
 	CHECK_ACL(MUTT_ACL_DELETE, _("Cannot delete message(s)"));
 
-	rc = mutt_thread_set_flag (CURHDR, MUTT_DELETE, 1,
-				   op == OP_DELETE_THREAD ? 0 : 1);
-
-	if (rc != -1)
 	{
+	  int subthread = (op == OP_DELETE_SUBTHREAD);
+	  rc = mutt_thread_set_flag (CURHDR, MUTT_DELETE, 1, subthread);
+	  if (rc == -1)
+	    break;
+	  if (op == OP_PURGE_THREAD)
+	  {
+	    rc = mutt_thread_set_flag (CURHDR, MUTT_PURGE, 1, subthread);
+	    if (rc == -1)
+	      break;
+	  }
+
 	  if (option (OPTDELETEUNTAG))
-	    mutt_thread_set_flag (CURHDR, MUTT_TAG, 0,
-				  op == OP_DELETE_THREAD ? 0 : 1);
+	    mutt_thread_set_flag (CURHDR, MUTT_TAG, 0, subthread);
 	  if (option (OPTRESOLVE))
 	    if ((menu->current = ci_next_undeleted (menu->current)) == -1)
 	      menu->current = menu->oldcurrent;
@@ -2018,6 +2635,20 @@ int mutt_index_menu (void)
 	}
 	break;
 
+#ifdef USE_NNTP
+      case OP_CATCHUP:
+	CHECK_MSGCOUNT;
+	CHECK_READONLY;
+	CHECK_ATTACH
+	if (Context && Context->magic == MUTT_NNTP)
+	{
+	  NNTP_DATA *nntp_data = Context->data;
+	  if (mutt_newsgroup_catchup (nntp_data->nserv, nntp_data->group))
+	    menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
+	}
+	break;
+#endif
+
       case OP_DISPLAY_ADDRESS:
 
 	CHECK_MSGCOUNT;
@@ -2079,6 +2710,22 @@ int mutt_index_menu (void)
 	menu->redraw = REDRAW_FULL;
 	break;
 
+      case OP_EDIT_LABEL:
+
+	CHECK_MSGCOUNT;
+	CHECK_VISIBLE;
+	CHECK_READONLY;
+	rc = mutt_label_message(tag ? NULL : CURHDR);
+	if (rc > 0) {
+	  Context->changed = 1;
+	  menu->redraw = REDRAW_FULL;
+	  mutt_message ("%d label%s changed.", rc, rc == 1 ? "" : "s");
+	}
+	else {
+	  mutt_message _("No labels changed.");
+	}
+	break;
+
       case OP_LIST_REPLY:
 
 	CHECK_ATTACH;
@@ -2224,6 +2871,39 @@ int mutt_index_menu (void)
         menu->redraw = REDRAW_FULL;
         break;
 
+#ifdef USE_NNTP
+      case OP_FOLLOWUP:
+      case OP_FORWARD_TO_GROUP:
+
+	CHECK_MSGCOUNT;
+	CHECK_VISIBLE;
+
+      case OP_POST:
+
+	CHECK_ATTACH;
+	if (op != OP_FOLLOWUP || !CURHDR->env->followup_to ||
+	    mutt_strcasecmp (CURHDR->env->followup_to, "poster") ||
+	    query_quadoption (OPT_FOLLOWUPTOPOSTER,
+	    _("Reply by mail as poster prefers?")) != MUTT_YES)
+	{
+	  if (Context && Context->magic == MUTT_NNTP &&
+	      !((NNTP_DATA *)Context->data)->allowed &&
+	      query_quadoption (OPT_TOMODERATED,
+	      _("Posting to this group not allowed, may be moderated. Continue?")) != MUTT_YES)
+	    break;
+	  if (op == OP_POST)
+	    ci_send_message (SENDNEWS, NULL, NULL, Context, NULL);
+	  else
+	  {
+	    CHECK_MSGCOUNT;
+	    ci_send_message ((op == OP_FOLLOWUP ? SENDREPLY : SENDFORWARD) |
+			SENDNEWS, NULL, NULL, Context, tag ? NULL : CURHDR);
+	  }
+	  menu->redraw = REDRAW_FULL;
+	  break;
+	}
+#endif
+
       case OP_REPLY:
 
 	CHECK_ATTACH;
@@ -2363,12 +3043,21 @@ int mutt_index_menu (void)
         mutt_reflow_windows();
 	menu->redraw = REDRAW_FULL;
 	break;
+
+      case OP_SIDEBAR_TOGGLE_VIRTUAL:
+	mutt_sb_toggle_virtual();
+	break;
 #endif
       default:
 	if (menu->menu == MENU_MAIN)
 	  km_error_key (MENU_MAIN);
     }
 
+#ifdef USE_NOTMUCH
+    if (Context)
+      nm_debug_check(Context);
+#endif
+
     if (menu->menu == MENU_PAGER)
     {
       mutt_clear_pager_position ();
diff --git c/doc/Makefile.am w/doc/Makefile.am
index bc8f856..a051229 100644
--- c/doc/Makefile.am
+++ w/doc/Makefile.am
@@ -14,7 +14,6 @@ noinst_PROGRAMS = makedoc
 
 EXTRA_DIST = dotlock.man		\
         smime_keys.man                  \
-	muttbug.man			\
 	mutt.man			\
 	pgpewrap.man			\
 	pgpring.man			\
@@ -33,7 +32,22 @@ EXTRA_DIST = dotlock.man		\
 	smime-notes.txt			\
 	Muttrc Muttrc.head stamp-doc-rc \
 	makedoc.c makedoc-defs.h 	\
-	mutt.css mutt.xsl html.xsl chunk.xsl $(BUILT_DISTFILES)
+	mutt.css mutt.xsl html.xsl chunk.xsl \
+	$(BUILT_DISTFILES) $(SAMPLE_MUTTRC) $(SAMPLE_VIMRC) \
+	mutt-1.7.0-syntax.vim neomutt-syntax.vim
+
+SAMPLE_MUTTRC = muttrc.attach-headers-color muttrc.compress muttrc.cond-date \
+	muttrc.encrypt-to-self muttrc.forgotten-attachment muttrc.ifdef \
+	muttrc.index-color muttrc.initials muttrc.keywords \
+	muttrc.limit-current-thread muttrc.nested-if muttrc.new-mail \
+	muttrc.nntp muttrc.notmuch muttrc.progress muttrc.quasi-delete \
+	muttrc.reply-with-xorig muttrc.sidebar muttrc.skip-quoted \
+	muttrc.status-color muttrc.timeout
+
+SAMPLE_VIMRC = vimrc.attach-headers-color vimrc.compress vimrc.encrypt-to-self \
+	vimrc.forgotten-attachment vimrc.ifdef vimrc.index-color vimrc.keywords \
+	vimrc.new-mail vimrc.nntp vimrc.notmuch vimrc.progress \
+	vimrc.quasi-delete vimrc.reply-with-xorig vimrc.sidebar vimrc.timeout
 
 CHUNKED_DOCFILES = index.html intro.html gettingstarted.html \
 	configuration.html mimesupport.html advancedusage.html \
@@ -46,12 +60,12 @@ BUILT_DISTFILES = stamp-doc-xml stamp-doc-chunked manual.txt $(HTML_DOCFILES)
 srcdir_DOCFILES = PGP-Notes.txt applying-patches.txt	\
 	devel-notes.txt patch-notes.txt smime-notes.txt
 
-topsrcdir_DOCFILES = COPYRIGHT GPL INSTALL ChangeLog	\
-	README NEWS TODO README.SECURITY README.SSL 
+topsrcdir_DOCFILES = COPYRIGHT LICENSE.md INSTALL ChangeLog ChangeLog.neomutt	\
+	README NEWS TODO README.SECURITY README.SSL README.neomutt README.notmuch
 
 all: makedoc-all
 
-makedoc-all: mutt.1 smime_keys.1 muttrc.man manual.html stamp-doc-rc stamp-doc-chunked manual.txt pgpewrap.1 pgpring.1
+makedoc-all: mutt.1 smime_keys.1 muttrc.man manual.html stamp-doc-rc stamp-doc-chunked manual.txt pgpewrap.1 pgpring.1 neomutt-syntax.vim
 
 install-data-local: makedoc-all instdoc
 	$(MKDIR_P) $(DESTDIR)$(mandir)/man1
@@ -61,8 +75,6 @@ install-data-local: makedoc-all instdoc
 	./instdoc smime_keys.1 $(DESTDIR)$(mandir)/man1/smime_keys.1
 	./instdoc pgpewrap.1 $(DESTDIR)$(mandir)/man1/pgpewrap.1
 	./instdoc pgpring.1 $(DESTDIR)$(mandir)/man1/pgpring.1
-	./instdoc $(srcdir)/muttbug.man $(DESTDIR)$(mandir)/man1/flea.1
-	./instdoc $(srcdir)/muttbug.man $(DESTDIR)$(mandir)/man1/muttbug.1
 	test x$(DOTLOCK_TARGET) = x || ./instdoc $(srcdir)/dotlock.man \
 		$(DESTDIR)$(mandir)/man1/mutt_dotlock.1
 	./instdoc muttrc.man $(DESTDIR)$(mandir)/man5/muttrc.5
@@ -79,6 +91,9 @@ install-data-local: makedoc-all instdoc
 	-for f in $(HTML_DOCFILES) ; do \
 		$(INSTALL) -m 644 $$f $(DESTDIR)$(docdir) ; \
 	done
+	-for f in $(SAMPLE_MUTTRC) ; do \
+		$(INSTALL) -m 644 $$f $(DESTDIR)$(docdir) ; \
+	done
 	$(INSTALL) -m 644 Muttrc $(DESTDIR)$(sysconfdir)/Muttrc.dist
 	-if [ -f $(DESTDIR)$(pkgdatadir)/Muttrc ] ; then \
 		mv $(DESTDIR)$(pkgdatadir)/Muttrc* $(DESTDIR)$(sysconfdir) ; \
@@ -87,15 +102,16 @@ install-data-local: makedoc-all instdoc
 	elif [ ! -f $(DESTDIR)$(sysconfdir)/Muttrc ] ; then \
 		$(INSTALL) -m 644 Muttrc $(DESTDIR)$(sysconfdir) ; \
 	fi
+	-$(INSTALL) -m 644 neomutt-syntax.vim $(DESTDIR)$(docdir)
 
 uninstall-local:
-	for f in mutt.1 mutt_dotlock.1 flea.1 muttbug.1 smime_keys.1 pgpewrap.1 pgpring.1; do \
+	for f in mutt.1 mutt_dotlock.1 smime_keys.1 pgpewrap.1 pgpring.1; do \
 		rm -f $(DESTDIR)$(mandir)/man1/$$f ; \
 	done
 	for f in muttrc.5 mbox.5 mmdf.5 ; do \
 		rm -f $(DESTDIR)$(mandir)/man5/$$f ; \
 	done
-	for f in $(srcdir_DOCFILES) $(topsrcdir_DOCFILES) $(HTML_DOCFILES) ; \
+	for f in $(srcdir_DOCFILES) $(topsrcdir_DOCFILES) $(HTML_DOCFILES) $(SAMPLE_MUTTRC); \
 	do \
 		rm -f $(DESTDIR)$(docdir)/$$f ; \
 	done
@@ -106,6 +122,7 @@ uninstall-local:
 	  fi ; \
 	  rm $(DESTDIR)$(sysconfdir)/$${i}.dist ; \
 	done
+	rm -f $(DESTDIR)$(docdir)/neomutt-syntax.vim
 
 check:
 manual.txt: manual.html
@@ -139,6 +156,14 @@ manual.tex: stamp-doc-xml
 	  openjade -t tex -D $(DSLROOT) -d print/docbook.dsl dtds/decls/xml.dcl manual.xml; \
 	fi
 
+neomutt-syntax.vim: $(SAMPLE_VIMRC)
+	( \
+		grep -v "vim:" $(srcdir)/mutt-1.7.0-syntax.vim; \
+		echo; \
+		cat $^; \
+		grep "vim:" $(srcdir)/mutt-1.7.0-syntax.vim; \
+	) > $@
+
 validate: stamp-doc-xml
 	xmllint --noout --noblanks --postvalid manual.xml
 
@@ -189,9 +214,9 @@ smime_keys.1: $(srcdir)/smime_keys.man
 
 stamp-doc-xml: makedoc$(EXEEXT) $(top_srcdir)/init.h \
                manual.xml.head $(top_srcdir)/functions.h $(top_srcdir)/OPS* manual.xml.tail \
-               $(srcdir)/gen-map-doc $(top_srcdir)/VERSION $(top_srcdir)/ChangeLog
-	( date=`head -n 1 $(top_srcdir)/ChangeLog | LC_ALL=C cut -d ' ' -f 1` && \
-	  sed -e "s/@VERSION\@/`cat $(top_srcdir)/VERSION` ($$date)/" $(srcdir)/manual.xml.head && \
+               $(srcdir)/gen-map-doc
+	( date=`head -n 1 $(top_srcdir)/ChangeLog.neomutt | LC_ALL=C cut -b 1-10` && \
+	  sed -e "s/@VERSION\@/$(PACKAGE_VERSION) (1.7.0)/" $(srcdir)/manual.xml.head && \
 	  $(MAKEDOC_CPP) $(top_srcdir)/init.h | ./makedoc$(EXEEXT) -s && \
 	  $(MAKEDOC_CPP) $(top_srcdir)/functions.h | \
 	    perl $(srcdir)/gen-map-doc $(srcdir)/manual.xml.tail $(top_srcdir)/OPS* \
diff --git c/doc/Muttrc.head w/doc/Muttrc.head
index 1f7012e..69e27ca 100644
--- c/doc/Muttrc.head
+++ w/doc/Muttrc.head
@@ -29,6 +29,11 @@ macro generic,pager <F1> "<shell-escape> less @docdir@/manual.txt<Enter>" "show
 macro index,pager y "<change-folder>?<toggle-mailboxes>" "show incoming mailboxes list"
 bind browser y exit
 
+# Use folders which match on \\.gz$ as gzipped folders:
+# open-hook \\.gz$ "gzip -cd %f > %t"
+# close-hook \\.gz$ "gzip -c %t > %f"
+# append-hook \\.gz$ "gzip -c %t >> %f"
+
 # If Mutt is unable to determine your site's domain name correctly, you can
 # set the default here.
 #
diff --git c/doc/gen-map-doc w/doc/gen-map-doc
index e2fadac..416ae9e 100644
--- c/doc/gen-map-doc
+++ w/doc/gen-map-doc
@@ -34,7 +34,8 @@ while (<STDIN>) {
     $binding =~ s/^\\(0\d+)$/'^'.chr(64+oct($1))/e;
     $binding =~ s/^\\(0\d+)(.)/'^'.chr(64+oct($1)) ." $2"/e;
     $binding =~ s/\\t/&lt;Tab&gt;/;
-    $binding =~ s/M_ENTER_S/&lt;Return&gt;/;
+    $binding =~ s/\\r/&lt;Return&gt;/;
+    $binding =~ s/\\n/&lt;Enter&gt;/;
     $binding =~ s/NULL//;
     die "unknown key $binding" if $binding =~ /\\[^\\]|<|>/;
     die "unknown OP $op" unless $OPS{$op};
diff --git c/doc/manual.xml.head w/doc/manual.xml.head
index ac22afa..51b5c61 100644
--- c/doc/manual.xml.head
+++ w/doc/manual.xml.head
@@ -412,6 +412,594 @@ <sect2 id="intro-sidebar">
     turned on and off, it can be themed and the list style can be
     configured.
   </para>
+  <para>
+    This part of the manual is suitable for beginners.
+    If you already know Mutt you could skip ahead to the main
+    <link linkend="sidebar">Sidebar guide</link>.
+    If you just want to get started, you could use the sample
+    <link linkend="sidebar-muttrc">Sidebar muttrc</link>.
+  </para>
+  <para>
+    To check if Mutt supports <quote>Sidebar</quote>, look for the string
+    <literal>+USE_SIDEBAR</literal> in the mutt version.
+  </para>
+<screen>
+mutt -v
+</screen>
+  <para>
+    <emphasis role="bold">Let's turn on the Sidebar:</emphasis>
+  </para>
+<screen>
+set sidebar_visible
+set sidebar_format = "%B%?F? [%F]?%* %?N?%N/?%S"
+set mail_check_stats
+</screen>
+  <para>
+    You will see something like this.
+    A list of mailboxes on the left.
+    A list of emails, from the selected mailbox, on the right.
+  </para>
+<screen>
+<emphasis role="indicator">Fruit [1]     3/8</emphasis>|  1    + Jan 24  Rhys Lee         (192)  Yew
+Animals [1]   2/6|  2    + Feb 11  Grace Hall       (167)  Ilama
+Cars            4|  3      Feb 23  Aimee Scott      (450)  Nectarine
+Seas          1/7|  4    ! Feb 28  Summer Jackson   (264)  Lemon
+                 |  5      Mar 07  Callum Harrison  (464)  Raspberry
+                 |<emphasis role="indicator">  6 N  + Mar 24  Samuel Harris    (353)  Tangerine          </emphasis>
+                 |  7 N  + Sep 05  Sofia Graham     (335)  Cherry
+                 |  8 N    Sep 16  Ewan Brown       (105)  Ugli
+                 |
+                 |
+</screen>
+<para>
+  This user has four mailboxes: <quote>Fruit</quote>,
+  <quote>Cars</quote>, <quote>Animals</quote> and
+  <quote>Seas</quote>.
+</para>
+<para>
+  The current, open, mailbox is <quote>Fruit</quote>.  We can
+  also see information about the other mailboxes.  For example:
+  The <quote>Animals</quote> mailbox contains, 1 flagged email, 2
+  new emails out of a total of 6 emails.
+</para>
+  <sect3 id="intro-sidebar-navigation">
+    <title>Navigation</title>
+    <para>
+      The Sidebar adds some new <link linkend="sidebar-functions">functions</link>
+      to Mutt.
+    </para>
+    <para>
+      The user pressed the <quote>c</quote> key to
+      <literal>&lt;change-folder&gt;</literal> to the
+      <quote>Animals</quote> mailbox.  The Sidebar automatically
+      updated the indicator to match.
+    </para>
+<screen>
+Fruit [1]     3/8|  1      Jan 03  Tia Gibson       (362)  Caiman
+<emphasis role="indicator">Animals [1]   2/6</emphasis>|  2    + Jan 22  Rhys Lee         ( 48)  Dolphin
+Cars            4|  3    ! Aug 16  Ewan Brown       (333)  Hummingbird
+Seas          1/7|  4      Sep 25  Grace Hall       ( 27)  Capybara
+                 |<emphasis role="indicator">  5 N  + Nov 12  Evelyn Rogers    (453)  Tapir              </emphasis>
+                 |  6 N  + Nov 16  Callum Harrison  (498)  Hedgehog
+                 |
+                 |
+                 |
+                 |
+</screen>
+    <para>
+      Let's map some functions:
+    </para>
+<screen>
+bind index,pager \CP sidebar-prev       <emphasis role="comment"># Ctrl-Shift-P - Previous Mailbox</emphasis>
+bind index,pager \CN sidebar-next       <emphasis role="comment"># Ctrl-Shift-N - Next Mailbox</emphasis>
+bind index,pager \CO sidebar-open       <emphasis role="comment"># Ctrl-Shift-O - Open Highlighted Mailbox</emphasis>
+</screen>
+    <para>
+      Press <quote>Ctrl-Shift-N</quote> (Next mailbox) twice will
+      move the Sidebar <emphasis role="bold">highlight</emphasis> to
+      down to the <quote>Seas</quote> mailbox.
+    </para>
+<screen>
+Fruit [1]     3/8|  1      Jan 03  Tia Gibson       (362)  Caiman
+<emphasis role="indicator">Animals [1]   2/6</emphasis>|  2    + Jan 22  Rhys Lee         ( 48)  Dolphin
+Cars            4|  3    ! Aug 16  Ewan Brown       (333)  Hummingbird
+<emphasis role="highlight">Seas          1/7</emphasis>|  4      Sep 25  Grace Hall       ( 27)  Capybara
+                 |<emphasis role="indicator">  5 N  + Nov 12  Evelyn Rogers    (453)  Tapir              </emphasis>
+                 |  6 N  + Nov 16  Callum Harrison  (498)  Hedgehog
+                 |
+                 |
+                 |
+                 |
+</screen>
+    <note>
+      <para>
+        Functions <literal>&lt;sidebar-next&gt;</literal> and
+        <literal>&lt;sidebar-prev&gt;</literal> move the Sidebar
+        <emphasis role="bold">highlight</emphasis>.
+        They <emphasis role="bold">do not</emphasis> change the open
+        mailbox.
+      </para>
+    </note>
+    <para>
+      Press <quote>Ctrl-Shift-O</quote>
+      (<literal>&lt;sidebar-open&gt;</literal>)
+      to open the highlighted mailbox.
+    </para>
+<screen>
+Fruit [1]     3/8|  1    ! Mar 07  Finley Jones     (139)  Molucca Sea
+Animals [1]   2/6|  2    + Mar 24  Summer Jackson   ( 25)  Arafura Sea
+Cars            4|  3    + Feb 28  Imogen Baker     (193)  Pechora Sea
+<emphasis role="indicator">Seas          1/7</emphasis>|<emphasis role="indicator">  4 N  + Feb 23  Isla Hussain     (348)  Balearic Sea       </emphasis>
+                 |
+                 |
+                 |
+                 |
+                 |
+                 |
+</screen>
+  </sect3>
+  <sect3 id="intro-sidebar-features">
+    <title>Features</title>
+    <para>
+      The Sidebar shows a list of mailboxes in a panel.
+    </para>
+    <para>
+      Everything about the Sidebar can be configured.
+    </para>
+    <itemizedlist>
+    <title><link linkend="intro-sidebar-basics">State of the Sidebar</link></title>
+      <listitem><para>Visibility</para></listitem>
+      <listitem><para>Width</para></listitem>
+    </itemizedlist>
+    <itemizedlist>
+    <title><link linkend="intro-sidebar-limit">Which mailboxes are displayed</link></title>
+      <listitem><para>Display all</para></listitem>
+      <listitem><para>Limit to mailboxes with new mail</para></listitem>
+      <listitem><para>Whitelist mailboxes to display always</para></listitem>
+    </itemizedlist>
+    <itemizedlist>
+    <title><link linkend="sidebar-sort">The order in which mailboxes are displayed</link></title>
+      <listitem><para>Unsorted (order of mailboxes commands)</para></listitem>
+      <listitem><para>Sorted alphabetically</para></listitem>
+      <listitem><para>Sorted by number of new mails</para></listitem>
+    </itemizedlist>
+    <itemizedlist>
+    <title><link linkend="intro-sidebar-colors">Color</link></title>
+      <listitem><para>Sidebar indicators and divider</para></listitem>
+      <listitem><para>Mailboxes depending on their type</para></listitem>
+      <listitem><para>Mailboxes depending on their contents</para></listitem>
+    </itemizedlist>
+    <itemizedlist>
+    <title><link linkend="sidebar-functions">Key bindings</link></title>
+      <listitem><para>Hide/Unhide the Sidebar</para></listitem>
+      <listitem><para>Select previous/next mailbox</para></listitem>
+      <listitem><para>Select previous/next mailbox with new mail</para></listitem>
+      <listitem><para>Page up/down through a list of mailboxes</para></listitem>
+    </itemizedlist>
+    <itemizedlist>
+    <title>Misc</title>
+      <listitem><para><link linkend="intro-sidebar-format">Formatting string for mailbox</link></para></listitem>
+      <listitem><para><link linkend="sidebar-next-new-wrap">Wraparound searching</link></para></listitem>
+      <listitem><para><link linkend="intro-sidebar-abbrev">Flexible mailbox abbreviations</link></para></listitem>
+      <listitem><para>Support for Unicode mailbox names (utf-8)</para></listitem>
+    </itemizedlist>
+  </sect3>
+  <sect3 id="intro-sidebar-display">
+    <title>Display</title>
+    <para>
+      Everything about the Sidebar can be configured.
+    </para>
+    <itemizedlist>
+      <title>For a quick reference:</title>
+      <listitem><para><link linkend="sidebar-variables">Sidebar variables to set</link> </para></listitem>
+      <listitem><para><link linkend="sidebar-colors">Sidebar colors to apply</link></para></listitem>
+      <listitem><para><link linkend="sidebar-sort">Sidebar sort methods</link></para></listitem>
+    </itemizedlist>
+    <sect4 id="intro-sidebar-basics">
+      <title>Sidebar Basics</title>
+      <para>
+        The most important variable is <literal>$sidebar_visible</literal>.
+        You can set this in your <quote>muttrc</quote>, or bind a key to the
+        function <literal>&lt;sidebar-toggle-visible&gt;</literal>.
+      </para>
+<screen>
+set sidebar_visible                         <emphasis role="comment"># Make the Sidebar visible by default</emphasis>
+bind index,pager B sidebar-toggle-visible   <emphasis role="comment"># Use 'B' to switch the Sidebar on and off</emphasis>
+</screen>
+      <para>
+        Next, decide how wide you want the Sidebar to be.  25
+        characters might be enough for the mailbox name and some numbers.
+    Remember, you can hide/show the Sidebar at the press of button.
+    </para>
+    <para>
+    Finally, you might want to change the divider character.
+    By default, Sidebar draws an ASCII line between it and the Index panel
+        If your terminal supports it, you can use a Unicode line-drawing character.
+      </para>
+<screen>
+set sidebar_width = 25                  <emphasis role="comment"># Plenty of space</emphasis>
+set sidebar_divider_char = '│'          <emphasis role="comment"># Pretty line-drawing character</emphasis>
+</screen>
+    </sect4>
+    <sect4 id="intro-sidebar-format">
+      <title>Sidebar Format String</title>
+      <para>
+        <literal>$sidebar_format</literal> allows you to customize the Sidebar display.
+        For an introduction, read <link linkend="index-format">format strings</link>
+        including the section about <link linkend="formatstrings-conditionals">conditionals</link>.
+      </para>
+      <para>
+        The default value is <literal>%B%*  %n</literal>
+        The default value is <literal>%B%?F? [%F]?%* %?N?%N/?%S</literal>
+      </para>
+      <itemizedlist>
+        <title>Which breaks down as:</title>
+        <listitem><para><literal>%B</literal> - Mailbox name</para></listitem>
+        <listitem><para><literal>%?F? [%F]?</literal> - If flagged emails <literal>[%F]</literal>, otherwise nothing</para></listitem>
+        <listitem><para><literal>%* </literal> - Pad with spaces</para></listitem>
+        <listitem><para><literal>%?N?%N/?</literal> - If new emails <literal>%N/</literal>, otherwise nothing</para></listitem>
+        <listitem><para><literal>%S</literal> - Total number of emails</para></listitem>
+      </itemizedlist>
+      <table>
+        <title>sidebar_format</title>
+        <tgroup cols="3">
+          <thead>
+            <row>
+              <entry>Format</entry>
+              <entry>Notes</entry>
+              <entry>Description</entry>
+            </row>
+          </thead>
+          <tbody>
+            <row>
+              <entry>%B</entry>
+              <entry></entry>
+              <entry>Name of the mailbox</entry>
+            </row>
+            <row>
+              <entry>%S</entry>
+              <entry>* †</entry>
+              <entry>Size of mailbox (total number of messages)</entry>
+            </row>
+            <row>
+              <entry>%F</entry>
+              <entry>* †</entry>
+              <entry>Number of Flagged messages in the mailbox</entry>
+            </row>
+            <row>
+              <entry>%N</entry>
+              <entry>* †</entry>
+              <entry>Number of New messages in the mailbox</entry>
+            </row>
+            <row>
+              <entry>%n</entry>
+              <entry>*</entry>
+              <entry>If there's new mail, display <quote>N</quote>, otherwise nothing</entry>
+            </row>
+            <row>
+              <entry>%!</entry>
+              <entry></entry>
+              <entry>
+                <quote>!</quote>: one flagged message;
+                <quote>!!</quote>: two flagged messages;
+                <quote>n!</quote>: n flagged messages (for n &gt; 2).
+                Otherwise prints nothing.
+              </entry>
+            </row>
+            <row>
+              <entry>%d</entry>
+              <entry>* ‡</entry>
+              <entry>Number of deleted messages</entry>
+            </row>
+            <row>
+              <entry>%L</entry>
+              <entry>* ‡</entry>
+              <entry>Number of messages after limiting</entry>
+            </row>
+            <row>
+              <entry>%t</entry>
+              <entry>* ‡</entry>
+              <entry>Number of tagged messages</entry>
+            </row>
+            <row>
+              <entry>%&gt;X</entry>
+              <entry></entry>
+              <entry>Right justify the rest of the string and pad with <quote>X</quote></entry>
+            </row>
+            <row>
+              <entry>%|X</entry>
+              <entry></entry>
+              <entry>Pad to the end of the line with
+              <quote>X</quote></entry>
+            </row>
+            <row>
+              <entry>%*X</entry>
+              <entry></entry>
+              <entry>Soft-fill with character <quote>X</quote>as pad</entry>
+            </row>
+          </tbody>
+        </tgroup>
+      </table>
+      <para>
+      * = Can be optionally printed if nonzero
+      </para>
+      <para>
+      † = To use this expandos, you must first: <screen>set mail_check_stats</screen>
+      </para>
+      <para>
+      ‡ = Only applicable to the current folder
+      </para>
+      <para>
+        Here are some examples.
+        They show the number of (F)lagged, (N)ew and (S)ize.
+      </para>
+      <table>
+        <title>sidebar_format</title>
+        <tgroup cols="2">
+          <thead>
+            <row>
+              <entry>Format</entry>
+              <entry>Example</entry>
+            </row>
+          </thead>
+          <tbody>
+            <row>
+              <entry><literal>%B%?F? [%F]?%* %?N?%N/?%S</literal></entry>
+              <entry><screen>mailbox [F]            N/S</screen></entry>
+            </row>
+            <row>
+              <entry><literal>%B%* %F:%N:%S</literal></entry>
+              <entry><screen>mailbox              F:N:S</screen></entry>
+            </row>
+            <row>
+              <entry><literal>%B %?N?(%N)?%* %S</literal></entry>
+              <entry><screen>mailbox (N)              S</screen></entry>
+            </row>
+            <row>
+              <entry><literal>%B%* ?F?%F/?%N</literal></entry>
+              <entry><screen>mailbox                F/S</screen></entry>
+            </row>
+          </tbody>
+        </tgroup>
+      </table>
+    </sect4>
+    <sect4 id="intro-sidebar-abbrev">
+      <title>Abbreviating Mailbox Names</title>
+      <para>
+        <literal>$sidebar_delim_chars</literal> tells Sidebar
+        how to split up mailbox paths.  For local directories
+        use <quote>/</quote>; for IMAP folders use <quote>.</quote>
+      </para>
+      <sect5 id="intro-sidebar-abbrev-ex1">
+        <title>Example 1</title>
+        <para>
+          This example works well if your mailboxes have unique names
+          after the last separator.
+        </para>
+        <para>
+          Add some mailboxes of different depths.
+        </para>
+<screen>
+set folder="~/mail"
+mailboxes =fruit/apple          =fruit/banana          =fruit/cherry
+mailboxes =water/sea/sicily     =water/sea/archipelago =water/sea/sibuyan
+mailboxes =water/ocean/atlantic =water/ocean/pacific   =water/ocean/arctic
+</screen>
+        <para>
+          Shorten the names:
+        </para>
+<screen>
+set sidebar_short_path                  <emphasis role="comment"># Shorten mailbox names</emphasis>
+set sidebar_delim_chars="/"             <emphasis role="comment"># Delete everything up to the last / character</emphasis>
+</screen>
+        <para>
+          The screenshot below shows what the Sidebar would look like
+          before and after shortening.
+        </para>
+<screen>
+|fruit/apple                            |apple
+|fruit/banana                           |banana
+|fruit/cherry                           |cherry
+|water/sea/sicily                       |sicily
+|water/sea/archipelago                  |archipelago
+|water/sea/sibuyan                      |sibuyan
+|water/ocean/atlantic                   |atlantic
+|water/ocean/pacific                    |pacific
+|water/ocean/arctic                     |arctic
+</screen>
+      </sect5>
+      <sect5 id="intro-sidebar-abbrev-ex2">
+        <title>Example 2</title>
+        <para>
+          This example works well if you have lots of mailboxes which are arranged
+          in a tree.
+        </para>
+        <para>
+          Add some mailboxes of different depths.
+        </para>
+<screen>
+set folder="~/mail"
+mailboxes =fruit
+mailboxes =fruit/apple =fruit/banana =fruit/cherry
+mailboxes =water
+mailboxes =water/sea
+mailboxes =water/sea/sicily =water/sea/archipelago =water/sea/sibuyan
+mailboxes =water/ocean
+mailboxes =water/ocean/atlantic =water/ocean/pacific =water/ocean/arctic
+</screen>
+        <para>
+          Shorten the names:
+        </para>
+<screen>
+set sidebar_short_path                  <emphasis role="comment"># Shorten mailbox names</emphasis>
+set sidebar_delim_chars="/"             <emphasis role="comment"># Delete everything up to the last / character</emphasis>
+set sidebar_folder_indent               <emphasis role="comment"># Indent folders whose names we've shortened</emphasis>
+set sidebar_indent_string="  "          <emphasis role="comment"># Indent with two spaces</emphasis>
+</screen>
+        <para>
+          The screenshot below shows what the Sidebar would look like
+          before and after shortening.
+        </para>
+<screen>
+|fruit                                  |fruit
+|fruit/apple                            |  apple
+|fruit/banana                           |  banana
+|fruit/cherry                           |  cherry
+|water                                  |water
+|water/sea                              |  sea
+|water/sea/sicily                       |    sicily
+|water/sea/archipelago                  |    archipelago
+|water/sea/sibuyan                      |    sibuyan
+|water/ocean                            |  ocean
+|water/ocean/atlantic                   |    atlantic
+|water/ocean/pacific                    |    pacific
+|water/ocean/arctic                     |    arctic
+</screen>
+        <para>
+          Sometimes, it will be necessary to add mailboxes, that you
+          don't use, to fill in part of the tree.  This will trade
+          vertical space for horizontal space (but it looks good).
+        </para>
+      </sect5>
+    </sect4>
+    <sect4 id="intro-sidebar-limit">
+      <title>Limiting the Number of Mailboxes</title>
+      <para>
+        If you have a lot of mailboxes, sometimes it can be useful to hide
+        the ones you aren't using.  <literal>$sidebar_new_mail_only</literal>
+        tells Sidebar to only show mailboxes that contain new, or flagged, email.
+      </para>
+      <para>
+        If you want some mailboxes to be always visible, then use the
+        <literal>sidebar_whitelist</literal> command.  It takes a list of
+        mailboxes as parameters.
+      </para>
+<screen>
+set sidebar_new_mail_only               <emphasis role="comment"># Only mailboxes with new/flagged email</emphasis>
+sidebar_whitelist fruit fruit/apple     <emphasis role="comment"># Always display these two mailboxes</emphasis>
+</screen>
+    </sect4>
+  </sect3>
+  <sect3 id="intro-sidebar-colors">
+    <title>Colors</title>
+    <para>
+      Here is a sample color scheme:
+    </para>
+<screen>
+color sidebar_indicator default color17         <emphasis role="comment"># Dark blue background</emphasis>
+color sidebar_highlight white   color238        <emphasis role="comment"># Grey background</emphasis>
+color sidebar_spoolfile yellow  default         <emphasis role="comment"># Yellow</emphasis>
+color sidebar_new       green   default         <emphasis role="comment"># Green</emphasis>
+color sidebar_ordinary  default default         <emphasis role="comment"># Default colors</emphasis>
+color sidebar_flagged   red     default         <emphasis role="comment"># Red</emphasis>
+color sidebar_divider   color8  default         <emphasis role="comment"># Dark grey</emphasis>
+</screen>
+    <para>
+      There is a priority order when coloring Sidebar mailboxes.
+      e.g.  If a mailbox has new mail it will have the
+      <literal>sidebar_new</literal> color, even if it also contains
+      flagged mails.
+    </para>
+    <table id="table-intro-sidebar-colors">
+      <title>Sidebar Color Priority</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Priority</entry>
+            <entry>Color</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>Highest</entry>
+            <entry><literal>sidebar_indicator</literal></entry>
+            <entry>Mailbox is open</entry>
+          </row>
+          <row>
+            <entry></entry>
+            <entry><literal>sidebar_highlight</literal></entry>
+            <entry>Mailbox is highlighted</entry>
+          </row>
+          <row>
+            <entry></entry>
+            <entry><literal>sidebar_spoolfile</literal></entry>
+            <entry>Mailbox is the spoolfile (receives incoming mail)</entry>
+          </row>
+          <row>
+            <entry></entry>
+            <entry><literal>sidebar_new</literal></entry>
+            <entry>Mailbox contains new mail</entry>
+          </row>
+          <row>
+            <entry></entry>
+            <entry><literal>sidebar_flagged</literal></entry>
+            <entry>Mailbox contains flagged mail</entry>
+          </row>
+          <row>
+            <entry>Lowest</entry>
+            <entry><literal>sidebar_ordinary</literal></entry>
+            <entry>Mailbox does not match above</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect3>
+  <sect3 id="intro-sidebar-config-changes">
+    <title>Config Changes</title>
+    <para>
+      If you haven't used Sidebar before, you can ignore this section.
+    </para>
+    <para>
+      Some of the Sidebar config has been changed to make its meaning clearer.
+      These changes have been made since the previous Sidebar release: 2015-11-11.
+    </para>
+    <table id="table-intro-sidebar-config-changes">
+      <title>Config Changes</title>
+      <tgroup cols="2">
+        <thead>
+          <row>
+            <entry>Old Name</entry>
+            <entry>New Name</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>$sidebar_delim</literal></entry>
+            <entry><literal>$sidebar_divider_char</literal></entry>
+          </row>
+          <row>
+            <entry><literal>$sidebar_folderindent</literal></entry>
+            <entry><literal>$sidebar_folder_indent</literal></entry>
+          </row>
+          <row>
+            <entry><literal>$sidebar_indentstr</literal></entry>
+            <entry><literal>$sidebar_indent_string</literal></entry>
+          </row>
+          <row>
+            <entry><literal>$sidebar_newmail_only</literal></entry>
+            <entry><literal>$sidebar_new_mail_only</literal></entry>
+          </row>
+          <row>
+            <entry><literal>$sidebar_shortpath</literal></entry>
+            <entry><literal>$sidebar_short_path</literal></entry>
+          </row>
+          <row>
+            <entry><literal>$sidebar_sort</literal></entry>
+            <entry><literal>$sidebar_sort_method</literal></entry>
+          </row>
+          <row>
+            <entry><literal>&lt;sidebar-scroll-down&gt;</literal></entry>
+            <entry><literal>&lt;sidebar-page-down&gt;</literal></entry>
+          </row>
+          <row>
+            <entry><literal>&lt;sidebar-scroll-up&gt;</literal></entry>
+            <entry><literal>&lt;sidebar-page-up&gt;</literal></entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect3>
 </sect2>
 
 <sect2 id="intro-help">
@@ -548,7 +1136,7 @@ <table id="tab-keys-editor">
 <row><entry>^E or &lt;End&gt;</entry><entry><literal>&lt;eol&gt;</literal></entry><entry>move to the end of the line</entry></row>
 <row><entry>^F or &lt;Right&gt;</entry><entry><literal>&lt;forward-char&gt;</literal></entry><entry>move forward one char</entry></row>
 <row><entry>Esc F</entry><entry><literal>&lt;forward-word&gt;</literal></entry><entry>move forward one word</entry></row>
-<row><entry>&lt;Tab&gt;</entry><entry><literal>&lt;complete&gt;</literal></entry><entry>complete filename or alias</entry></row>
+<row><entry>&lt;Tab&gt;</entry><entry><literal>&lt;complete&gt;</literal></entry><entry>complete filename, alias, or label</entry></row>
 <row><entry>^T</entry><entry><literal>&lt;complete-query&gt;</literal></entry><entry>complete address with query</entry></row>
 <row><entry>^K</entry><entry><literal>&lt;kill-eol&gt;</literal></entry><entry>delete to the end of the line</entry></row>
 <row><entry>Esc d</entry><entry><literal>&lt;kill-eow&gt;</literal></entry><entry>delete to the end of the word</entry></row>
@@ -1752,38 +2340,73 @@ <sect1 id="configuration-files">
 <title>Location of Initialization Files</title>
 
 <para>
-While the default configuration (or <quote>preferences</quote>) make
-Mutt usable right out of the box, it is often desirable to tailor Mutt
-to suit your own tastes. When Mutt is first invoked, it will attempt to
-read the <quote>system</quote> configuration file (defaults set by your
-local system administrator), unless the <quote>-n</quote> <link
-linkend="commandline">command line</link> option is specified.  This
-file is typically <literal>/usr/local/share/mutt/Muttrc</literal> or
-<literal>/etc/Muttrc</literal>. Mutt will next look for a file named
-<literal>.muttrc</literal> in your home directory.  If this file does
-not exist and your home directory has a subdirectory named
-<literal>.mutt</literal>, Mutt tries to load a file named
-<literal>.mutt/muttrc</literal>.
+  When Mutt starts up it looks for two configuration files -- a
+  <quote>system</quote> file and a <quote>user</quote> file.
+</para>
+
+<para>
+  Mutt will search for a system config file in several places.  The filenames
+  may depend on the version number of Mutt.  Mutt will read just one file, the
+  first file it finds, from the list below.
+</para>
+
+<para>
+  The system config file will not be read if the <quote>-n</quote>
+  option is used on the <link linkend="commandline">command line</link>.
+</para>
+
+<table id="system-muttrc">
+  <title>Mutt system config file locations</title>
+  <tgroup cols="1">
+    <thead>
+      <row><entry>File Location</entry></row>
+    </thead>
+    <tbody>
+      <row><entry>$XDG_CONFIG_DIRS/neomutt/config</entry></row>
+      <row><entry>/etc/NeoMuttrc</entry></row>
+      <row><entry>/etc/Muttrc-1.7.0-neo</entry></row>
+      <row><entry>/etc/Muttrc</entry></row>
+      <row><entry>/share/mutt/Muttrc-1.7.0-neo</entry></row>
+      <row><entry>/share/mutt/Muttrc</entry></row>
+    </tbody>
+  </tgroup>
+</table>
+
+<para>
+  <emphasis>($XDG_CONFIG_DIRS defaults to "/etc/xdg".)</emphasis>
+</para>
+
+<para>
+  Mutt will search for a user config file in several places in your home
+  directory.  The filenames may depend on the version number of Mutt.  Mutt
+  will read just one file, the first file it finds, from the list below.
 </para>
 
 <para>
-<literal>.muttrc</literal> is the file where you will usually place your
-<link linkend="commands">commands</link> to configure Mutt.
+  You may specify your own location for the user config file using the
+  <quote>-F</quote> option on the <link linkend="commandline">command line</link>.
 </para>
 
+<table id="user-muttrc">
+  <title>Mutt user config file locations</title>
+  <tgroup cols="1">
+    <thead>
+      <row><entry>File Location</entry></row>
+    </thead>
+    <tbody>
+      <row><entry>$XDG_CONFIG_HOME/neomutt/config</entry></row>
+      <row><entry>~/.neomuttrc</entry></row>
+      <row><entry>~/.mutt/neomuttrc</entry></row>
+      <row><entry>~/.muttrc-1.7.0-neo</entry></row>
+      <row><entry>~/.muttrc</entry></row>
+      <row><entry>~/.mutt/muttrc-1.7.0-neo</entry></row>
+      <row><entry>~/.mutt/muttrc</entry></row>
+    </tbody>
+  </tgroup>
+</table>
+
 <para>
-In addition, Mutt supports version specific configuration files that are
-parsed instead of the default files as explained above.  For instance,
-if your system has a <literal>Muttrc-0.88</literal> file in the system
-configuration directory, and you are running version 0.88 of Mutt, this
-file will be sourced instead of the <literal>Muttrc</literal> file.  The
-same is true of the user configuration file, if you have a file
-<literal>.muttrc-0.88.6</literal> in your home directory, when you run
-Mutt version 0.88.6, it will source this file instead of the default
-<literal>.muttrc</literal> file.  The version number is the same which
-is visible using the <quote>-v</quote> <link
-linkend="commandline">command line</link> switch or using the
-<literal>show-version</literal> key (default: V) from the index menu.
+  <emphasis>($XDG_CONFIG_HOME defaults to "$HOME/.config".)</emphasis>
 </para>
 
 </sect1>
@@ -2651,7 +3274,7 @@ <sect1 id="color">
 
 <command>color</command>
 <arg choice="plain">
-<option>index</option>
+<option>index-object</option>
 </arg>
 <arg choice="plain">
 <replaceable class="parameter">foreground</replaceable>
@@ -2666,7 +3289,7 @@ <sect1 id="color">
 <command>uncolor</command>
 <group choice="req">
 <arg choice="plain">
-<option>index</option>
+<option>index-object</option>
 </arg>
 <arg choice="plain">
 <option>header</option>
@@ -2696,8 +3319,8 @@ <sect1 id="color">
 <para>
 <emphasis>header</emphasis> and <emphasis>body</emphasis> match
 <emphasis>regexp</emphasis> in the header/body of a message,
-<emphasis>index</emphasis> matches <emphasis>pattern</emphasis> (see
-<xref linkend="patterns"/>) in the message index.  Note that IMAP
+<emphasis>index-object</emphasis> can match <emphasis>pattern</emphasis>
+(see <xref linkend="patterns"/>) in the message index. Note that IMAP
 server-side searches (=b, =B, =h) are not supported for color index
 patterns.
 </para>
@@ -2711,10 +3334,19 @@ <sect1 id="color">
 <listitem><para>bold (highlighting bold patterns in the body of messages)</para></listitem>
 <listitem><para>error (error messages printed by Mutt)</para></listitem>
 <listitem><para>hdrdefault (default color of the message header in the pager)</para></listitem>
+<listitem><para>index_author (color of the author name in the index, uses <emphasis>pattern</emphasis>)</para></listitem>
+<listitem><para>index_collapsed (the number of messages in a collapsed thread in the index)</para></listitem>
+<listitem><para>index_date (color of the date field in the index)</para></listitem>
+<listitem><para>index_flags (color of the message flags in the index)</para></listitem>
+<listitem><para>index_label (color of the message label in the index)</para></listitem>
+<listitem><para>index_number (color of the message number in the index)</para></listitem>
+<listitem><para>index_size (color of the message size and line number in the index)</para></listitem>
+<listitem><para>index_subject (color of the subject in the index, uses <emphasis>pattern</emphasis>)</para></listitem>
 <listitem><para>indicator (arrow or bar used to indicate the current item in a menu)</para></listitem>
 <listitem><para>markers (the <quote>+</quote> markers at the beginning of wrapped lines in the pager)</para></listitem>
 <listitem><para>message (informational messages)</para></listitem>
 <listitem><para>normal</para></listitem>
+<listitem><para><link linkend="progress">progress</link> (visual progress bar)</para></listitem>
 <listitem><para>prompt</para></listitem>
 <listitem><para>quoted (text matching <link linkend="quote-regexp">$quote_regexp</link> in the body of a message)</para></listitem>
 <listitem><para>quoted1, quoted2, ..., quoted<emphasis>N</emphasis> (higher levels of quoting)</para></listitem>
@@ -2726,6 +3358,24 @@ <sect1 id="color">
 </itemizedlist>
 
 <para>
+<emphasis>index-object</emphasis> can be one of the following:
+</para>
+
+<itemizedlist>
+<listitem><para>index (default highlighting of the entire index line, uses <emphasis>pattern</emphasis>)</para></listitem>
+<listitem><para>index_date (the date field)</para></listitem>
+<listitem><para>index_flags (the message flags, %S %Z, uses <emphasis>pattern</emphasis>)</para></listitem>
+<listitem><para>index_number (the message number, %C)</para></listitem>
+<listitem><para>index_collapsed (the number of messages in a collapsed thread, %M)</para></listitem>
+<listitem><para>index_author (the author name, %A %a %F %L %n, uses <emphasis>pattern</emphasis>)</para></listitem>
+<listitem><para>index_subject (the subject, %s, uses <emphasis>pattern</emphasis>)</para></listitem>
+<listitem><para>index_size (the message size, %c %l)</para></listitem>
+<listitem><para>index_label (the message label, %y %Y)</para></listitem>
+<listitem><para>index_tags (the transformed message tags, %g)</para></listitem>
+<listitem><para>index_tag (an individual message tag, %G, uses <emphasis>pattern / tag name</emphasis>)</para></listitem>
+</itemizedlist>
+
+<para>
 <emphasis>foreground</emphasis> and <emphasis>background</emphasis> can
 be one of the following:
 </para>
@@ -2842,7 +3492,7 @@ <sect1 id="color">
 <command>unmono</command>
 <group choice="req">
 <arg choice="plain">
-<option>index</option>
+<option>index-object</option>
 </arg>
 <arg choice="plain">
 <option>header</option>
@@ -3624,8 +4274,8 @@ <sect1 id="send-hook">
 <para>
 Another typical use for this command is to change the values of the
 <link linkend="attribution">$attribution</link>, <link
-linkend="signature">$signature</link> and <link
-linkend="locale">$locale</link> variables in order to change the
+linkend="attribution-locale">$attribution_locale</link>, and <link
+linkend="signature">$signature</link> variables in order to change the
 language of the attributions and signatures based upon the recipients.
 </para>
 
@@ -3837,8 +4487,8 @@ <sect1 id="score-command">
 <emphasis>pattern</emphasis> is a string in the format described in the
 <link linkend="patterns">patterns</link> section (note: For efficiency
 reasons, patterns which scan information not available in the index,
-such as <literal>~b</literal>, <literal>~B</literal> or
-<literal>~h</literal>, may not be used).  <emphasis>value</emphasis> is
+such as <literal>~b</literal>, <literal>~B</literal>, <literal>~h</literal>,
+or <literal>~X</literal> may not be used).  <emphasis>value</emphasis> is
 a positive or negative integer.  A message's final score is the sum
 total of all matching <command>score</command> entries.  However, you
 may optionally prefix <emphasis>value</emphasis> with an equal sign
@@ -4541,8 +5191,8 @@ <sect2 id="formatstrings-basics">
 symbol (<literal>=</literal>) as a numeric prefix (like the minus
 above), it will force the string to be centered within its minimum space
 range. For example, <literal>%=14y</literal> will reserve 14 characters
-for the %y expansion &mdash; that's the X-Label: header, in <link
-linkend="index-format">$index_format</link>. If the expansion results in
+for the %y expansion &mdash; that's the set of message keywords (formerly
+X-Label).  If the expansion results in
 a string less than 14 characters, it will be centered in a 14-character
 space.  If the X-Label for a message were <quote>test</quote>, that
 expansion would look like
@@ -4604,6 +5254,18 @@ <sect2 id="formatstrings-conditionals">
 <emphasis>else_string</emphasis> will be expanded.
 </para>
 
+<para>
+The conditional sequences can also be nested by using the %&lt; and &gt;
+operators. The %? notation can still be used but requires quoting. For example:
+</para>
+
+<screen>
+%&lt;x?true&amp;false&gt;
+%&lt;x?%&lt;y?%&lt;z?xyz&amp;xy&gt;&amp;x&gt;&amp;none&gt;
+</screen>
+
+<para>For more examples, see <xref linkend="nested-if"/></para>
+
 </sect2>
 
 <sect2 id="formatstrings-filters">
@@ -4710,6 +5372,27 @@ <sect2 id="formatstrings-padding">
 
 </sect2>
 
+<sect2 id="formatstrings-conditional-dates">
+<title>Conditional Dates</title>
+<para>
+This patch allows the format of dates in the index to vary based on how recent
+the message is. This is especially useful in combination with David Champion's
+patch to allow if-else sequences to be nested.
+</para>
+
+<para>
+For example, using
+<literal>%&lt;[y?%&lt;[d?%[%H:%M]&amp;%[%m/%d]&gt;&amp;%[%y.%m]&gt;</literal>
+for the date in the <literal>$index_format</literal> will produce a display like:
+</para>
+
+<screen>
+   1   + 14.12 Grace Hall      (   13) Gulliver's Travels
+   2   + 10/02 Callum Harrison (   48) Huckleberry Finn
+   3     12:17 Rhys Lee        (   42) The Lord Of The Rings
+</screen>
+</sect2>
+
 </sect1>
 
 <sect1 id="mailto-allow">
@@ -5135,7 +5818,7 @@ <table id="tab-patterns">
 <row><entry>~V</entry><entry>cryptographically verified messages</entry></row>
 <row><entry>~x <emphasis>EXPR</emphasis></entry><entry>messages which contain <emphasis>EXPR</emphasis> in the <quote>References</quote> or <quote>In-Reply-To</quote> field</entry></row>
 <row><entry>~X [<emphasis>MIN</emphasis>]-[<emphasis>MAX</emphasis>]</entry><entry>messages with <emphasis>MIN</emphasis> to <emphasis>MAX</emphasis> attachments *)</entry></row>
-<row><entry>~y <emphasis>EXPR</emphasis></entry><entry>messages which contain <emphasis>EXPR</emphasis> in the <quote>X-Label</quote> field</entry></row>
+<row><entry>~y <emphasis>EXPR</emphasis></entry><entry>messages which contain <emphasis>EXPR</emphasis> in their keywords</entry></row>
 <row><entry>~z [<emphasis>MIN</emphasis>]-[<emphasis>MAX</emphasis>]</entry><entry>messages with a size in the range <emphasis>MIN</emphasis> to <emphasis>MAX</emphasis> *) **)</entry></row>
 <row><entry>~=</entry><entry>duplicated messages (see <link linkend="duplicate-threads">$duplicate_threads</link>)</entry></row>
 <row><entry>~$</entry><entry>unreferenced messages (requires threaded view)</entry></row>
@@ -5530,12 +6213,24 @@ <sect1 id="hooks">
 
 <listitem>
 <para>
+<link linkend="append-hook"><command>append-hook</command></link>
+</para>
+</listitem>
+
+<listitem>
+<para>
 <link linkend="charset-hook"><command>charset-hook</command></link>
 </para>
 </listitem>
 
 <listitem>
 <para>
+<link linkend="close-hook"><command>close-hook</command></link>
+</para>
+</listitem>
+
+<listitem>
+<para>
 <link linkend="crypt-hook"><command>crypt-hook</command></link>
 </para>
 </listitem>
@@ -5578,6 +6273,12 @@ <sect1 id="hooks">
 
 <listitem>
 <para>
+<link linkend="open-hook"><command>open-hook</command></link>
+</para>
+</listitem>
+
+<listitem>
+<para>
 <link linkend="reply-hook"><command>reply-hook</command></link>
 </para>
 </listitem>
@@ -5987,18 +6688,6 @@ <sect1 id="using-lists">
 </para>
 
 <para>
-The <quote>X-Label:</quote> header field can be used to further identify
-mailing lists or list subject matter (or just to annotate messages
-individually).  The <link linkend="index-format">$index_format</link>
-variable's <quote>%y</quote> and <quote>%Y</quote> expandos can be used
-to expand <quote>X-Label:</quote> fields in the index, and Mutt's
-pattern-matcher can match regular expressions to <quote>X-Label:</quote>
-fields with the <quote>~y</quote> selector.  <quote>X-Label:</quote> is
-not a standard message header field, but it can easily be inserted by
-procmail and other mail filtering agents.
-</para>
-
-<para>
 Lastly, Mutt has the ability to <link linkend="sort">sort</link> the
 mailbox into <link linkend="threads">threads</link>.  A thread is a
 group of messages which all relate to the same subject.  This is usually
@@ -6011,6 +6700,121 @@ <sect1 id="using-lists">
 
 </sect1>
 
+<sect1 id="using-keywords">
+<title>Keyword Management</title>
+
+<para>
+Mutt has supported textual labels (usually known as X-Labels after
+the header that we use to store them) for many years.  Since we
+initially added support for X-Labels, however, the larger community
+has evolved more common ways of using and managing such labels, often
+known as <quote>keywords</quote> or <quote>tags</quote>.
+</para>
+
+<para>
+If you are new to Mutt or to using keywords in Mutt, you only need
+to know that the &lt;edit-label&gt; binding (<literal>y</literal> by
+default) will edit keywords, and that you can search for keywords
+using the <literal>~y</literal> pattern, and use the <literal>%y</literal>
+expando to display it in your <literal>$index_format</literal>.  You also
+can sort by keyword.  Keywords that you set will be stored to the
+<literal>X-Label:</literal> header by default.
+</para>
+
+<para>
+If you've been using X-Labels for a while, things have grown slightly.
+Mutt still supports X-Labels much as it has since 2000, but the scope
+of this support has expanded to support three additional header-based
+techniques for storing keyword metadata on messages:
+</para>
+
+<variablelist>
+
+<varlistentry>
+<term>X-Keywords</term>
+<listitem>
+<para>
+Informal design; space-delimited keywords
+</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>X-Mozilla-Keys</term>
+<listitem>
+<para>
+Informal design used by Mozilla-based agents; space-delimited keywords
+</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>Keywords</term>
+<listitem>
+<para>
+Standardized in RFC2822 (2001); comma-space-delimited keywords
+</para>
+</listitem>
+</varlistentry>
+
+<varlistentry>
+<term>X-Label</term>
+<listitem>
+<para>
+Mutt-specific design; freeform text (but see <link linkend="xlabel-delimiter">$xlabel_delimiter</link>)
+</para>
+</listitem>
+</varlistentry>
+
+</variablelist>
+
+<para>
+With X-Label, mutt's only notion of a message keyword was the literal
+string value of the X-Label header.  Under the new, integrated support,
+each message may have a list of distinct message keywords.  When reading
+keywords from one of the headers in the list above, the header value is
+split on the indicated delimiter (space or comma-space) for X-Keywords:,
+X-Mozilla-Keys:, and Keywords:.  By default, X-Label: is parsed as a
+single keyword.  By setting $xlabel_delimiter, you can force splitting
+of X-Label: as well.
+</para>
+
+<para>
+Two boolean variables control how keywords are saved when writing
+messages to a mailbox.  The default settings preserve backward
+compatibility within mutt completely, but by changing these
+values you can transition to more standard keyword storage. <link
+linkend="keywords-legacy">$keywords_legacy</link>, if set, will tell
+mutt to use only "legacy" headers -- i.e., <literal>X-Keywords:</literal>,
+<literal>X-Mozilla-Keys</literal>, <literal>Keywords</literal>, or
+<literal>X-Label:</literal>.  Keywords will be saved to whichever
+header was in use by the message the keyword was read from.  If
+<link linkend="keywords-standard">$keywords_standard</link> is
+set, keywords will be saved without exception to the standard
+<literal>Keywords:</literal> header.  (If both are set, both will be used;
+if both are unset, legacy headers are used.)  Additionally, <link
+linkend="xlabel-delimiter">$xlabel_delimiter</link> is used to format
+the X-Label: header on saves.
+</para>
+
+<para>
+To migrate completely to the new standard,
+unset <literal>$keywords_legacy</literal> and set
+<literal>$keywords_standard</literal>, and set
+<literal>$xlabel_delimiter</literal> either to what you currently use to
+delimit keywords in X-Labels, or to <quote>,&nbsp;</quote> (comma
+space).
+</para>
+
+<para>
+Note that it is common practice to insert <literal>X-Label:</literal> or
+other keyword headers from proxmail or other mail filters.  This is
+a useful trick for categorizing messages en masse as they are delivered
+to your inbox, and it is fully compatible with the new keywords code.
+</para>
+
+</sect1>
+
 <sect1 id="new-mail">
 <title>New Mail Detection</title>
 
@@ -6056,7 +6860,10 @@ <sect2 id="new-mail-formats">
 <link linkend="maildir-trash">$maildir_trash</link>). For MH folders, a
 mailbox is considered having new mail if there's at least one message in
 the <quote>unseen</quote> sequence as specified by <link
-linkend="mh-seq-unseen">$mh_seq_unseen</link>.
+linkend="mh-seq-unseen">$mh_seq_unseen</link>. Optionally, <link
+linkend="new-mail-command">$new_mail_command</link> can be configured to
+execute an external program every time new mail is detected in the current
+inbox.
 </para>
 
 <para>
@@ -7515,6 +8322,16 @@ <sect2 id="compile-time-features">
 
 </sect2>
 
+<sect2 id="mutt-patches">
+<title>Mutt Patches</title>
+<para>
+Mutt may also be <quote>patched</quote> to support smaller features.
+These patches should add a free-form string to the end Mutt's version string.
+Running <literal>mutt -v</literal> might show:
+<screen>patch-1.7.0.sidebar.20160709</screen>
+</para>
+</sect2>
+
 <sect2 id="url-syntax">
 <title>URL Syntax</title>
 
@@ -7972,7 +8789,7 @@ <sect2 id="header-caching">
 Header caching can be enabled via the configure script and the
 <emphasis>--enable-hcache</emphasis> option. It's not turned on by
 default because external database libraries are required: one of
-tokyocabinet, qdbm, gdbm or bdb must be present.
+tokyocabinet, kyotocabinet, qdbm, gdbm, lmdb or bdb must be present.
 </para>
 
 <para>
@@ -8129,286 +8946,4889 @@ <sect1 id="sending-mixmaster">
 
 </sect1>
 
-<sect1 id="sidebar">
-  <title>Sidebar</title>
-  <subtitle>Overview of mailboxes</subtitle>
+<sect1 id="attach-headers-color">
+  <title>attach-headers-color Feature</title>
+  <subtitle>Color attachment headers using regexp, just like mail bodies</subtitle>
 
-  <sect2 id="sidebar-intro">
-    <title>Introduction</title>
+  <sect2 id="attach-headers-color-support">
+    <title>Support</title>
 
     <para>
-      The Sidebar shows a list of all your mailboxes.  The list can be
-      turned on and off, it can be themed and the list style can be
-      configured.
+      To check if NeoMutt supports <quote>attach-headers-color</quote>, look for
+      <quote>patch-attach-headers-color</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
     </para>
-  </sect2>
 
-  <sect2 id="sidebar-variables">
-    <title>Variables</title>
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
 
-    <table id="table-sidebar-variables">
-      <title>Sidebar Variables</title>
-      <tgroup cols="3">
-	<thead>
-	  <row>
-	    <entry>Name</entry>
-	    <entry>Type</entry>
-	    <entry>Default</entry>
-	  </row>
-	</thead>
-	<tbody>
-	  <row>
-	    <entry><literal>sidebar_delim_chars</literal></entry>
-	    <entry>string</entry>
-	    <entry><literal>/.</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_divider_char</literal></entry>
-	    <entry>string</entry>
-	    <entry><literal>|</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_folder_indent</literal></entry>
-	    <entry>boolean</entry>
-	    <entry><literal>no</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_format</literal></entry>
-	    <entry>string</entry>
-	    <entry><literal>%B%*  %n</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_indent_string</literal></entry>
-	    <entry>string</entry>
-	    <entry><literal>&nbsp;&nbsp;</literal> (two spaces)</entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_new_mail_only</literal></entry>
-	    <entry>boolean</entry>
-	    <entry><literal>no</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_next_new_wrap</literal></entry>
-	    <entry>boolean</entry>
-	    <entry><literal>no</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_short_path</literal></entry>
-	    <entry>boolean</entry>
-	    <entry><literal>no</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_sort_method</literal></entry>
-	    <entry>enum</entry>
-	    <entry><literal>unsorted</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_visible</literal></entry>
-	    <entry>boolean</entry>
-	    <entry><literal>no</literal></entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_whitelist</literal></entry>
-	    <entry>list</entry>
-	    <entry>(empty)</entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_width</literal></entry>
-	    <entry>number</entry>
-	    <entry><literal>20</literal></entry>
-	  </row>
-	</tbody>
-      </tgroup>
-    </table>
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
   </sect2>
 
-  <sect2 id="sidebar-functions">
-    <title>Functions</title>
+  <sect2 id="attach-headers-color-intro">
+    <title>Introduction</title>
 
     <para>
-      Sidebar adds the following functions to Mutt.
-      By default, none of them are bound to keys.
+      This feature allows specifying regexps to color attachment headers just like the mail body would.
+      The headers are the parts colored by the <literal>attachment</literal> color. Coloring them is
+      useful to highlight the results of GPGME's signature checks or simply the mimetype or size of
+      the attachment. Only the part matched by the regexp is colored.
     </para>
 
-    <table id="table-sidebar-functions">
-      <title>Sidebar Functions</title>
-      <tgroup cols="3">
-	<thead>
-	  <row>
-	    <entry>Menus</entry>
-	    <entry>Function</entry>
-	    <entry>Description</entry>
-	  </row>
-	</thead>
-	<tbody>
-	  <row>
-	    <entry>index,pager</entry>
-	    <entry><literal>&lt;sidebar-next&gt;</literal></entry>
-	    <entry>Move the highlight to next mailbox</entry>
-	  </row>
-	  <row>
-	    <entry>index,pager</entry>
-	    <entry><literal>&lt;sidebar-next-new&gt;</literal></entry>
-	    <entry>Move the highlight to next mailbox with new mail</entry>
-	  </row>
-	  <row>
-	    <entry>index,pager</entry>
-	    <entry><literal>&lt;sidebar-open&gt;</literal></entry>
-	    <entry>Open highlighted mailbox</entry>
-	  </row>
-	  <row>
-	    <entry>index,pager</entry>
-	    <entry><literal>&lt;sidebar-page-down&gt;</literal></entry>
-	    <entry>Scroll the Sidebar down 1 page</entry>
-	  </row>
-	  <row>
-	    <entry>index,pager</entry>
-	    <entry><literal>&lt;sidebar-page-up&gt;</literal></entry>
-	    <entry>Scroll the Sidebar up 1 page</entry>
-	  </row>
-	  <row>
-	    <entry>index,pager</entry>
-	    <entry><literal>&lt;sidebar-prev&gt;</literal></entry>
-	    <entry>Move the highlight to previous mailbox</entry>
-	  </row>
-	  <row>
-	    <entry>index,pager</entry>
-	    <entry><literal>&lt;sidebar-prev-new&gt;</literal></entry>
-	    <entry>Move the highlight to previous mailbox with new mail</entry>
-	  </row>
-	  <row>
-	    <entry>index,pager</entry>
-	    <entry><literal>&lt;sidebar-toggle-visible&gt;</literal></entry>
-	    <entry>Make the Sidebar (in)visible</entry>
-	  </row>
-	</tbody>
-      </tgroup>
-    </table>
   </sect2>
 
-  <sect2 id="sidebar-commands">
-    <title>Commands</title>
-    <cmdsynopsis>
-      <command>sidebar_whitelist<anchor id="sidebar-whitelist"/></command>
-      <arg choice="plain">
-	<replaceable class="parameter">mailbox</replaceable>
-      </arg>
-      <arg choice="opt" rep="repeat">
-	<replaceable class="parameter">mailbox</replaceable>
-      </arg>
-    </cmdsynopsis>
-  </sect2>
+  <sect2 id="attach-headers-color-usage">
+    <title>Usage</title>
 
-  <sect2 id="sidebar-colors">
-    <title>Colors</title>
+    <para>
+        The <literal>attach_headers</literal> color should be used just like the <literal>body</literal>
+        color.
+    </para>
+
+<screen>
+color attach_headers foreground background pattern
+</screen>
+  </sect2>
+
+  <sect2 id="attach-headers-color-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the attach-headers-color feature.
+
+# Color if the attachment is autoviewed</emphasis>
+color   attach_headers     brightgreen     default        &quot;Autoview&quot;
+
+<emphasis role="comment"># Color only the brackets around the headers</emphasis>
+color   attach_headers     brightyellow    default        &quot;^\\[--&quot;
+color   attach_headers     brightyellow    default        &quot;--]$&quot;
+
+<emphasis role="comment"># Color the mime type and the size</emphasis>
+color   attach_headers     green           default        &quot;Type: [a-z]+/[a-z0-9\-]+&quot;
+color   attach_headers     green           default        &quot;Size: [0-9\.]+[KM]&quot;
+
+<emphasis role="comment"># Color GPGME signature checks</emphasis>
+color   attach_headers     brightgreen     default        &quot;Good signature from.*&quot;
+color   attach_headers     brightred       default        &quot;Bad signature from.*&quot;
+color   attach_headers     brightred       default        &quot;BAD signature from.*&quot;
+color   attach_headers     brightred       default        &quot;Note: This key has expired!&quot;
+color   attach_headers     brightmagenta   default        &quot;Problem signature from.*&quot;
+color   attach_headers     brightmagenta   default        &quot;WARNING: This key is not certified with a trusted signature!&quot;
+color   attach_headers     brightmagenta   default        &quot;         There is no indication that the signature belongs to the owner.&quot;
+color   attach_headers     brightmagenta   default        &quot;can't handle these multiple signatures&quot;
+color   attach_headers     brightmagenta   default        &quot;signature verification suppressed&quot;
+color   attach_headers     brightmagenta   default        &quot;invalid node with packet of type&quot;
+
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="attach-headers-color-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="color">Color command</link></para></listitem>
+      <listitem><para><link linkend="regexp">Regular Expressions</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="attach-headers-color-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="attach-headers-color-credits">
+    <title>Credits</title>
+    <itemizedlist>
+      <listitem><para>Guillaume Brogi <email>gui-gui@netcourrier.com</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="compose-to-sender">
+  <title>compose-to-sender Feature</title>
+  <subtitle>Send new mail to the sender of the current mail</subtitle>
+
+  <sect2 id="compose-to-sender-support">
+    <title>Support</title>
+
+    <para>
+      To check if Mutt supports <quote>compose-to-sender</quote>, look for
+      <quote>patch-compose-to-sender</quote> in the mutt version.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="compose-to-sender-intro">
+    <title>Introduction</title>
+
+    <para>
+      The compose-to-sender patch adds a new command to start composing a new
+      email to the sender of the current message.  This is not a reply, but a
+      new, separate, message.
+    </para>
+
+    <para>
+      It works on tagged messages too, sending one email to all of the senders
+      of the tagged messages.
+    </para>
+  </sect2>
+
+  <sect2 id="compose-to-sender-functions">
+    <title>Functions</title>
+
+    <para>
+      compose-to-sender adds the following function to Mutt.
+      By default, it is not bound to a key.
+    </para>
+
+    <table id="table-compose-to-sender-functions">
+      <title>compose-to-sender Functions</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Menus</entry>
+            <entry>Function</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;compose-to-sender&gt;</literal></entry>
+            <entry>compose a new email to the sender of the current email</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="compose-to-sender-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the compose-to-sender feature.
+
+# --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# Compose a new email (not a reply) to the sender</emphasis>
+bind index,pager @ compose-to-sender
+
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="compose-to-sender-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="compose-to-sender-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Brian Medley</para></listitem>
+    <listitem><para>Guillaume Brogi <email>gui-gui@netcourrier.com</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="compress">
+  <title>Compressed Folders Feature</title>
+  <subtitle>Read from/write to compressed mailboxes</subtitle>
+
+  <sect2 id="compress-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>Compress Folders</quote>, look for
+      <quote>+USE_COMPRESSED</quote> in the version info.
+      See: <xref linkend="compile-time-features"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="compress-intro">
+    <title>Introduction</title>
+
+    <para>
+      The Compressed Folder patch allows Mutt to read mailbox files that are
+      compressed.  But it isn't limited to compressed files.  It works well
+      with encrypted files, too.  In fact, if you can create a program/script
+      to convert to and from your format, then Mutt can read it.
+    </para>
+
+    <para>
+      The patch adds three hooks to Mutt: <literal>open-hook</literal>,
+      <literal>close-hook</literal> and <literal>append-hook</literal>.  They
+      define commands to: uncompress a file; compress a file; append
+      messages to an already compressed file.
+    </para>
+
+    <para>
+      There are some examples of both compressed and encrypted files,
+      later.  For now, the documentation will just concentrate on
+      compressed files.
+    </para>
+
+  </sect2>
+
+  <sect2 id="compress-commands">
+    <title>Commands</title>
+    <cmdsynopsis>
+      <command>open-hook</command>
+      <arg choice="plain">
+        <replaceable class="parameter">pattern</replaceable>
+      </arg>
+      <arg choice="plain">
+        <replaceable class="parameter">shell-command</replaceable>
+      </arg>
+      <command>close-hook</command>
+      <arg choice="plain">
+        <replaceable class="parameter">pattern</replaceable>
+      </arg>
+      <arg choice="plain">
+        <replaceable class="parameter">shell-command</replaceable>
+      </arg>
+      <command>append-hook</command>
+      <arg choice="plain">
+        <replaceable class="parameter">pattern</replaceable>
+      </arg>
+      <arg choice="plain">
+        <replaceable class="parameter">shell-command</replaceable>
+      </arg>
+    </cmdsynopsis>
+
+    <para>
+      The shell-command must contain two placeholders for filenames:
+      <literal>%f</literal> and <literal>%t</literal>.  These represent
+      <quote>from</quote> and <quote>to</quote> filenames.  It's a good idea to
+      put quotes around these placeholders.
+    </para>
+
+    <para>
+      If you need the exact string <quote>%f</quote> or <quote>%t</quote> in your
+      command, simply double up the <quote>%</quote> character, e.g.
+      <quote>%%f</quote> or <quote>%%t</quote>.
+    </para>
+
+    <table id="table-compress-optional">
+      <title>Not all Hooks are Required</title>
+      <tgroup cols="5">
+        <thead>
+          <row>
+            <entry>Open</entry>
+            <entry>Close</entry>
+            <entry>Append</entry>
+            <entry>Effect</entry>
+            <entry>Useful if</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>Open</entry>
+            <entry>-</entry>
+            <entry>-</entry>
+            <entry>Folder is readonly</entry>
+            <entry>The folder is just a backup</entry>
+          </row>
+          <row>
+            <entry>Open</entry>
+            <entry>Close</entry>
+            <entry>-</entry>
+            <entry>Folder is read/write, but the entire folder must be
+              written if anything is changed</entry>
+            <entry>Your compression format doesn't support appending</entry>
+          </row>
+          <row>
+            <entry>Open</entry>
+            <entry>Close</entry>
+            <entry>Append</entry>
+            <entry>Folder is read/write and emails can be efficiently added
+              to the end</entry>
+            <entry>Your compression format supports appending</entry>
+          </row>
+          <row>
+            <entry>Open</entry>
+            <entry>-</entry>
+            <entry>Append</entry>
+            <entry>Folder is readonly, but can be appended to</entry>
+            <entry>You want to store emails, but never change them</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+
+    <note>
+      <para>The command:</para>
+      <itemizedlist>
+        <listitem><para>should return a non-zero exit status on failure</para></listitem>
+        <listitem><para>should not delete any files</para></listitem>
+      </itemizedlist>
+    </note>
+
+    <sect3 id="open-hook">
+      <title>Read from compressed mailbox</title>
+
+      <screen>open-hook regexp shell-command</screen>
+
+      <para>
+        If Mutt is unable to open a file, it then looks for
+        <literal>open-hook</literal> that matches the filename.
+      </para>
+
+      <para>
+        If your compression program doesn't have a well-defined extension,
+        then you can use <literal>.</literal> as the regexp.
+      </para>
+
+      <sect4 id="compress-open-hook-example">
+        <title>Example of open-hook</title>
+
+        <screen>open-hook '\.gz$' &quot;gzip -cd '%f' &gt; '%t'&quot;</screen>
+
+        <itemizedlist>
+          <listitem><para>Mutt finds a file, <quote>example.gz</quote>,
+              that it can't read</para></listitem>
+          <listitem><para>Mutt has an <literal>open-hook</literal>
+              whose regexp matches the filename:
+              <literal>\.gz$</literal></para></listitem>
+          <listitem><para>Mutt uses the command <literal>gzip -cd</literal>
+              to create a temporary file that it <emphasis>can</emphasis>
+              read</para></listitem>
+        </itemizedlist>
+      </sect4>
+    </sect3>
+
+    <sect3 id="close-hook">
+      <title>Write to a compressed mailbox</title>
+
+      <screen>close-hook regexp shell-command</screen>
+
+      <para>
+        When Mutt has finished with a compressed mail folder, it will look
+        for a matching <literal>close-hook</literal> to recompress the file.
+        This hook is <link linkend="table-compress-optional">optional</link>.
+      </para>
+
+      <note>
+        <para>
+          If the folder has not been modified, the
+          <literal>close-hook</literal> will not be called.
+        </para>
+      </note>
+
+      <sect4 id="compress-close-hook-example">
+        <title>Example of close-hook</title>
+
+        <screen>close-hook '\.gz$' &quot;gzip -c '%t' &gt; '%f'&quot;</screen>
+
+        <itemizedlist>
+          <listitem><para>Mutt has finished with a folder, <quote>example.gz</quote>,
+              that it opened with <literal>open-hook</literal></para></listitem>
+          <listitem><para>The folder has been modified</para></listitem>
+          <listitem><para>Mutt has a <literal>close-hook</literal> whose regexp
+              matches the filename: <literal>\.gz$</literal></para></listitem>
+          <listitem><para>Mutt uses the command <literal>gzip -c</literal>
+              to create a new compressed file</para></listitem>
+        </itemizedlist>
+      </sect4>
+    </sect3>
+
+    <sect3 id="append-hook">
+      <title>Append to a compressed mailbox</title>
+
+      <screen>append-hook regexp shell-command</screen>
+
+      <para>
+        When Mutt wants to append an email to a compressed mail folder, it
+        will look for a matching <literal>append-hook</literal>.
+        This hook is <link linkend="table-compress-optional">optional</link>.
+      </para>
+
+      <para>
+        Using the <literal>append-hook</literal> will save time, but
+        Mutt won't be able to determine the type of the mail folder
+        inside the compressed file.
+      </para>
+
+      <para>
+        Mutt will <emphasis>assume</emphasis> the type to be that of
+        the <literal>$mbox_type</literal> variable.  Mutt also uses
+        this type for temporary files.
+      </para>
+
+      <para>
+        Mutt will only use the <literal>append-hook</literal> for existing files.
+        The <literal>close-hook</literal> will be used for empty, or missing files.
+      </para>
+
+      <note>
+        <para>
+          If your command writes to stdout, it is vital that you use
+          <literal>&gt;&gt;</literal> in the <quote>append-hook</quote>.
+          If not, data will be lost.
+        </para>
+      </note>
+
+      <sect4 id="compress-append-hook-example">
+        <title>Example of append-hook</title>
+
+        <screen>append-hook '\.gz$' &quot;gzip -c '%t' &gt;&gt; '%f'&quot;</screen>
+
+        <itemizedlist>
+          <listitem><para>Mutt wants to append an email to a folder, <quote>example.gz</quote>,
+              that it opened with <literal>open-hook</literal></para></listitem>
+          <listitem><para>Mutt has an <literal>append-hook</literal> whose regexp matches
+              the filename: <literal>\.gz$</literal></para></listitem>
+          <listitem><para>Mutt knows the mailbox type from the <literal>$mbox</literal>
+              variable</para></listitem>
+          <listitem><para>Mutt uses the command <literal>gzip -c</literal>
+              to append to an existing compressed file</para></listitem>
+        </itemizedlist>
+      </sect4>
+
+    </sect3>
+
+    <sect3 id="compress-empty">
+      <title>Empty Files</title>
+
+      <para>
+        Mutt assumes that an empty file is not compressed.  In this
+        situation, unset <link linkend="save-empty">$save_empty</link>, so
+        that the compressed file will be removed if you delete all of the
+        messages.
+      </para>
+    </sect3>
+
+    <sect3 id="compress-security">
+      <title>Security</title>
+
+      <para>
+        Encrypted files are decrypted into temporary files which are
+        stored in the <link linkend="tmpdir">$tmpdir</link> directory.
+        This could be a security risk.
+      </para>
+    </sect3>
+  </sect2>
+
+  <sect2 id="compress-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the compress feature.
+
+# This feature adds three hooks to Mutt which allow it to
+# work with compressed, or encrypted, mailboxes.
+
+# The hooks are of the form:
+#       open-hook   regexp &quot;shell-command&quot;
+#       close-hook  regexp &quot;shell-command&quot;
+#       append-hook regexp &quot;shell-command&quot;
+
+# The 'append-hook' is optional.
+
+# Handler for gzip compressed mailboxes</emphasis>
+open-hook   '\.gz$'  &quot;gzip -cd  '%f' &gt;  '%t'&quot;
+close-hook  '\.gz$'  &quot;gzip -c   '%t' &gt;  '%f'&quot;
+append-hook '\.gz$'  &quot;gzip -c   '%t' &gt;&gt; '%f'&quot;
+
+<emphasis role="comment"># Handler for bzip2 compressed mailboxes</emphasis>
+open-hook   '\.bz2$' &quot;bzip2 -cd '%f' &gt;  '%t'&quot;
+close-hook  '\.bz2$' &quot;bzip2 -c  '%t' &gt;  '%f'&quot;
+append-hook '\.bz2$' &quot;bzip2 -c  '%t' &gt;&gt; '%f'&quot;
+
+<emphasis role="comment"># Handler for xz compressed mailboxes</emphasis>
+open-hook   '\.xz$'  &quot;xz    -cd '%f' &gt;  '%t'&quot;
+close-hook  '\.xz$'  &quot;xz    -c  '%t' &gt;  '%f'&quot;
+append-hook '\.xz$'  &quot;xz    -c  '%t' &gt;&gt; '%f'&quot;
+
+<emphasis role="comment"># Handler for pgp encrypted mailboxes
+# PGP does not support appending to an encrypted file</emphasis>
+open-hook   '\.pgp$' &quot;pgp -f &lt; '%f' &gt; '%t'&quot;
+close-hook  '\.pgp$' &quot;pgp -fe YourPgpUserIdOrKeyId &lt; '%t' &gt; '%f'&quot;
+
+<emphasis role="comment"># Handler for gpg encrypted mailboxes
+# gpg does not support appending to an encrypted file</emphasis>
+open-hook   '\.gpg$' &quot;gpg --decrypt &lt; '%f' &gt; '%t'&quot;
+close-hook  '\.gpg$' &quot;gpg --encrypt --recipient YourGpgUserIdOrKeyId &lt; '%t' &gt; '%f'&quot;
+
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="compress-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="compile-time-features">Compile-Time Features</link></para></listitem>
+      <listitem><para><link linkend="regexp">Regular Expressions</link></para></listitem>
+      <listitem><para><link linkend="tmpdir">$tmpdir</link></para></listitem>
+      <listitem><para><link linkend="mbox-type">$mbox_type</link></para></listitem>
+      <listitem><para><link linkend="save-empty">$save_empty</link></para></listitem>
+      <listitem><para><link linkend="folder-hook">folder-hook</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="compress-known-bugs">
+    <title>Known Bugs</title>
+
+    <itemizedlist>
+      <listitem><para>The Compressed Folder hooks cannot deal with filenames that contains quotes/apostrophes.</para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="compress-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Roland Rosenfeld <email>roland@spinnaker.de</email></para></listitem>
+    <listitem><para>Alain Penders <email>Alain@Finale-Dev.com</email></para></listitem>
+    <listitem><para>Christoph <quote>Myon</quote> Berg <email>myon@debian.org</email></para></listitem>
+    <listitem><para>Evgeni Golov <email>evgeni@debian.org</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="cond-date">
+  <title>Conditional Dates Feature</title>
+  <subtitle>Use rules to choose date format</subtitle>
+
+  <sect2 id="cond-date-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>Conditional Dates</quote>, look for
+      <quote>patch-cond-date</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+      <listitem><para><link linkend="nested-if">nested-if patch</link></para></listitem>
+    </itemizedlist>
+
+    <para>
+      This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.
+    </para>
+  </sect2>
+
+  <sect2 id="cond-date-intro">
+    <title>Introduction</title>
+
+    <para>
+    The <quote>cond-date</quote> patch allows you to construct
+    <link linkend="index-format">$index_format</link> expressions based on the age of the email.
+    </para>
+
+    <para>
+    Mutt's default <literal>$index_format</literal> displays email dates in the
+    form: abbreviated-month day-of-month &mdash; <quote>Jan 14</quote>.
+    </para>
+
+    <para>
+    The format is configurable but only per-mailbox.  This feature allows you
+    to configure the display depending on the age of the email.
+    </para>
+
+    <table id="table-cond-date-scheme">
+      <title>Potential Formatting Scheme</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Email Sent</entry>
+            <entry>Format</entry>
+            <entry>Example</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>Today</entry>
+            <entry><literal>%H:%M</literal></entry>
+            <entry>13:23</entry>
+          </row>
+          <row>
+            <entry>This Month</entry>
+            <entry><literal>%a %d</literal></entry>
+            <entry>Thu 17</entry>
+          </row>
+          <row>
+            <entry>This Year</entry>
+            <entry><literal>%b %d</literal></entry>
+            <entry>Dec 10</entry>
+          </row>
+          <row>
+            <entry>Older than 1 Year</entry>
+            <entry><literal>%m/%y</literal></entry>
+            <entry>06/14</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+
+    <para>
+        For an explanation of the date formatting strings, see
+        <literal>strftime(3).</literal>
+    </para>
+
+    <para>
+        By carefully picking your formats, the dates can remain
+        unambiguous and compact.
+    </para>
+
+    <para>
+    Mutt's conditional format strings have the form:
+    (whitespace introduced for clarity)
+    </para>
+
+    <screen>%? TEST ? TRUE &amp; FALSE ?</screen>
+
+    <para>
+    The examples below use the test <quote>%[</quote> &mdash; the date
+    of the message in the local timezone.  They will also work with
+    <quote>%(</quote> &mdash; the local time that the message arrived.
+    </para>
+
+    <para>
+    The date tests are of the form:
+    </para>
+
+    <screen>%[nX? TRUE &amp; FALSE ?</screen>
+
+    <itemizedlist>
+    <listitem><para><quote>n</quote> is an optional count (defaults to 1 if missing)</para></listitem>
+    <listitem><para><quote>X</quote> is the time period</para></listitem>
+    </itemizedlist>
+
+    <table id="table-cond-date-format-codes">
+      <title>Date Formatting Codes</title>
+      <tgroup cols="2">
+        <thead>
+          <row>
+            <entry>Letter</entry>
+            <entry>Time Period</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>y</entry>
+            <entry>Years</entry>
+          </row>
+          <row>
+            <entry>m</entry>
+            <entry>Months</entry>
+          </row>
+          <row>
+            <entry>w</entry>
+            <entry>Weeks</entry>
+          </row>
+          <row>
+            <entry>d</entry>
+            <entry>Days</entry>
+          </row>
+          <row>
+            <entry>H</entry>
+            <entry>Hours</entry>
+          </row>
+          <row>
+            <entry>M</entry>
+            <entry>Minutes</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+
+    <table id="table-cond-date-example-tests">
+      <title>Example Date Tests</title>
+      <tgroup cols="2">
+        <thead>
+          <row>
+            <entry>Test</entry>
+            <entry>Meaning</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>%[y</literal></entry>
+            <entry>This year</entry>
+          </row>
+          <row>
+            <entry><literal>%[1y</literal></entry>
+            <entry>This year</entry>
+          </row>
+          <row>
+            <entry><literal>%[6m</literal></entry>
+            <entry>In the last 6 months</entry>
+          </row>
+          <row>
+            <entry><literal>%[w</literal></entry>
+            <entry>This week</entry>
+          </row>
+          <row>
+            <entry><literal>%[d</literal></entry>
+            <entry>Today</entry>
+          </row>
+          <row>
+            <entry><literal>%[4H</literal></entry>
+            <entry>In the last 4 hours</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+
+    <sect3 id="cond-date-example1">
+      <title>Example 1</title>
+
+      <para>We start with a one-condition test.</para>
+
+      <table id="table-cond-date-example1">
+        <title>Example 1</title>
+        <tgroup cols="4">
+          <thead>
+            <row>
+              <entry>Test</entry>
+              <entry>Date Range</entry>
+              <entry>Format String</entry>
+              <entry>Example</entry>
+            </row>
+          </thead>
+          <tbody>
+            <row>
+              <entry><literal>%[1m</literal></entry>
+              <entry>This month</entry>
+              <entry><literal>%[%b %d]</literal></entry>
+              <entry>Dec 10</entry>
+            </row>
+            <row>
+              <entry></entry>
+              <entry>Older</entry>
+              <entry><literal>%[%Y-%m-%d]</literal></entry>
+              <entry>2015-04-23</entry>
+            </row>
+          </tbody>
+        </tgroup>
+      </table>
+
+      <para>The $index_format string would contain:</para>
+<screen>
+%?[1m?%[%b %d]&amp;%[%Y-%m-%d]?
+</screen>
+
+      <para>
+        Reparsed a little, for clarity, you can see the
+        test condition and the two format strings.
+      </para>
+
+<screen>
+%?[1m?        &amp;           ?
+      %[%b %d] %[%Y-%m-%d]
+</screen>
+
+    </sect3>
+
+    <sect3 id="cond-date-example2">
+      <title>Example 2</title>
+
+      <para>
+      This example contains three test conditions and four date formats.
+      </para>
+
+      <table id="table-cond-date-example2">
+        <title>Example 2</title>
+        <tgroup cols="4">
+          <thead>
+            <row>
+              <entry>Test</entry>
+              <entry>Date Range</entry>
+              <entry>Format String</entry>
+              <entry>Example</entry>
+            </row>
+          </thead>
+          <tbody>
+            <row>
+              <entry><literal>%[d</literal></entry>
+              <entry>Today</entry>
+              <entry><literal>%[%H:%M ] </literal></entry>
+              <entry>12:34</entry>
+            </row>
+            <row>
+              <entry><literal>%[m</literal></entry>
+              <entry>This month</entry>
+              <entry><literal>%[%a %d]</literal></entry>
+              <entry>Thu 12</entry>
+            </row>
+            <row>
+              <entry><literal>%[y</literal></entry>
+              <entry>This year</entry>
+              <entry><literal>%[%b %d]</literal></entry>
+              <entry>Dec 10</entry>
+            </row>
+            <row>
+              <entry></entry>
+              <entry>Older</entry>
+              <entry><literal>%[%m/%y ]</literal></entry>
+              <entry>06/15</entry>
+            </row>
+          </tbody>
+        </tgroup>
+      </table>
+
+      <para>The $index_format string would contain:</para>
+
+<screen>
+%&lt;[y?%&lt;[m?%&lt;[d?%[%H:%M ]&amp;%[%a %d]&gt;&amp;%[%b %d]&gt;&amp;%[%m/%y ]&gt;
+</screen>
+
+      <para>
+        Reparsed a little, for clarity, you can see the
+        test conditions and the four format strings.
+      </para>
+
+<screen>
+%&lt;[y?                                       &amp;%[%m/%y ]&gt;  Older
+     %&lt;[m?                        &amp;%[%b %d]&gt;             This year
+          %&lt;[d?         &amp;%[%a %d]&gt;                       This month
+               %[%H:%M ]                                 Today
+</screen>
+
+      <para>
+      This a another view of the same example, with some whitespace
+      for clarity.
+      </para>
+
+<screen>
+%&lt;[y? %&lt;[m? %&lt;[d? AAA &amp; BBB &gt; &amp; CCC &gt; &amp; DDD &gt;
+</screen>
+
+      <literallayout>
+AAA = %[%H:%M ]
+BBB = %[%a %d]
+CCC = %[%b %d]
+DDD = %[%m/%y ]
+      </literallayout>
+    </sect3>
+  </sect2>
+
+  <sect2 id="cond-date-variables">
+    <title>Variables</title>
+
+        <para>
+    The <quote>cond-date</quote> patch doesn't have any config of its own.
+    It modifies the behavior of the format strings.
+        </para>
+  </sect2>
+
+  <sect2 id="cond-date-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the cond-date feature.
+#
+# The default index_format is:
+#       '%4C %Z %{%b %d} %-15.15L (%?l?%4l&amp;%4c?) %s'
+#
+# We replace the date field '%{%b %d}', giving:</emphasis>
+set index_format='%4C %Z %&lt;[y?%&lt;[m?%&lt;[d?%[%H:%M ]&amp;%[%a %d]&gt;&amp;%[%b %d]&gt;&amp;%[%m/%y ]&gt; %-15.15L (%?l?%4l&amp;%4c?) %s'
+
+<emphasis role="comment"># Test  Date Range  Format String  Example
+# --------------------------------------------
+# %[d   Today       %[%H:%M ]      12:34
+# %[m   This month  %[%a %d]       Thu 12
+# %[y   This year   %[%b %d]       Dec 10
+# -     Older       %[%m/%y ]      06/15
+
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="cond-date-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="index-format">$index_format</link></para></listitem>
+      <listitem><para><link linkend="nested-if">nested-if patch</link></para></listitem>
+      <listitem><para><literal>strftime(3)</literal></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="cond-date-known-bugs">
+    <title>Known Bugs</title>
+
+    <para>
+      Date parsing doesn't quite do what you expect.
+      <quote>1w</quote> doesn't mean the <quote>in the last 7 days</quote>, but
+      <quote><emphasis>this</emphasis> week</quote>.  This doesn't match
+      the normal Mutt behavior: for example <literal>~d>1w</literal>
+      means emails dated in the last 7 days.
+    </para>
+
+  </sect2>
+
+  <sect2 id="cond-date-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Aaron Schrab <email>aaron@schrab.com</email></para></listitem>
+    <listitem><para>Eric Davis <email>edavis@insanum.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="encrypt-to-self">
+  <title>Encrypt-to-Self Feature</title>
+  <subtitle>Save a self-encrypted copy of emails</subtitle>
+
+  <sect2 id="encrypt-to-self-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>encrypt-to-self</quote>, look for
+      <quote>patch-encrypt-to-self</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="encrypt-to-self-intro">
+    <title>Introduction</title>
+
+    <para>
+      Once you encrypt an email to someone you cannot read it.  This is good
+      for security, but bad for record-keeping.  If you wanted to keep a copy
+      of an encrypted email you could set <link linkend="fcc-clear">$fcc_clear</link>.
+    </para>
+
+    <para>
+      A better option is to enable
+      <link linkend="smime-encrypt-self">$smime_encrypt_self</link>, then set
+      <link linkend="smime-default-key">$smime_default_key</link> to your
+      personal S/MIME key id.
+    </para>
+
+<screen>
+set smime_encrypt_self = yes
+set smime_default_key  = bb345e23.0
+</screen>
+
+    <para>
+      Or, if you use PGP,
+      <link linkend="pgp-encrypt-self">$pgp_encrypt_self</link>, then set
+      <link linkend="pgp-sign-as">$pgp_sign_as</link> to your
+      personal PGP key id.
+    </para>
+
+<screen>
+set pgp_encrypt_self = yes
+set pgp_sign_as      = A4AF18C5582473BD35A1E9CE78BB3D480042198E
+</screen>
+
+  </sect2>
+
+  <sect2 id="encrypt-to-self-variables">
+    <title>Variables</title>
+
+    <table id="table-encrypt-self-variables">
+      <title>encrypt-self Variables</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>smime_encrypt_self</literal></entry>
+            <entry>quad</entry>
+            <entry>No</entry>
+          </row>
+          <row>
+            <entry><literal>pgp_encrypt_self</literal></entry>
+            <entry>quad</entry>
+            <entry>No</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="encrypt-to-self-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the encrypt-to-self feature.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# Save a copy of outgoing email, encrypted to yourself</emphasis>
+set smime_encrypt_self = &quot;no&quot;
+
+<emphasis role="comment"># Save a copy of outgoing email, encrypted to yourself</emphasis>
+set pgp_encrypt_self = &quot;no&quot;
+
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="encrypt-to-self-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="encrypt-to-self-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="encrypt-to-self-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Omen Wild <email>omen@mandarb.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    <listitem><para>Guillaume Brogi <email>gui-gui@netcourrier.com</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="fmemopen">
+  <title>Fmemopen Feature</title>
+  <subtitle>Replace some temporary files with memory buffers</subtitle>
+
+  <sect2 id="fmemopen-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>fmemopen</quote>, look for
+      <quote>patch-fmemopen</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+      <listitem><para><literal>open_memstream()</literal>, <literal>fmemopen()</literal> from glibc</para></listitem>
+    </itemizedlist>
+
+    <para>
+      This feature can be disabled by running <literal>configure</literal> with
+      the option <literal>--disable-fmemopen</literal>
+    </para>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="fmemopen-intro">
+    <title>Introduction</title>
+
+        <para>
+    The <quote>fmemopen</quote> patch speeds up some searches.
+        </para>
+
+        <para>
+    This feature changes a few places where Mutt creates temporary files.
+    It replaces them with in-memory buffers.  This should improve the
+    performance when searching the header or body using the
+    <link linkend="thorough-search">$thorough_search</link> option.
+        </para>
+
+        <para>
+    There are no user-configurable parts.
+        </para>
+
+        <para>
+    This feature depends on <literal>open_memstream()</literal> and
+    <literal>fmemopen()</literal>.  They are provided by glibc.  Without
+    them, Mutt will simply create temporary files.
+        </para>
+  </sect2>
+
+  <sect2 id="fmemopen-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="compile-time-features">Compile-Time Features</link></para></listitem>
+      <listitem><para><literal>fmemopen(3)</literal></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="fmemopen-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="fmemopen-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Julius Plenz <email>plenz@cis.fu-berlin.de</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="forgotten-attachment">
+  <title>forgotten-attachment Feature</title>
+  <subtitle>Alert user when (s)he forgets to attach a file to an outgoing email.</subtitle>
+
+  <sect2 id="forgotten-attachment-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>forgotten-attachment</quote>, look for
+      <quote>patch-forgotten-attachment</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="forgotten-attachment-intro">
+    <title>Introduction</title>
+
+    <para>
+      The 'forgotten-attachment' patch provides a new setting for Mutt that
+      alerts the user if the message body contains a certain keyword but there are
+      no attachments added. This is meant to ensure that the user does not forget
+      to attach a file after promising to do so in the mail.
+    </para>
+  </sect2>
+
+  <sect2 id="forgotten-attachment-variables">
+    <title>Variables</title>
+
+    <table id="table-forgotten-attachment-variables">
+      <title>forgotten-attachment Variables</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>attach_keyword</literal></entry>
+            <entry>regular expression</entry>
+            <entry><literal>\\&lt;attach(|ed|ments?)\\&gt;</literal></entry>
+          </row>
+          <row>
+            <entry><literal>abort_noattach</literal></entry>
+            <entry>quadoption</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="forgotten-attachment-muttrc">
+<title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the forgotten-attachment feature.
+
+# The 'forgotten-attachment' feature provides a new setting for Mutt that
+# alerts the user if the message body contains a certain regular expression but there are
+# no attachments added. This is meant to ensure that the user does not forget
+# to attach a file after promising to do so in the mail.
+
+# Ask if the user wishes to abort sending if $attach_keyword is found in the
+# body, but no attachments have been added
+# It can be set to:
+#    "yes"     : always abort
+#    "ask-yes" : ask whether to abort
+#    "no"      : send the mail</emphasis>
+set abort_noattach = no
+
+<emphasis role="comment"># Search for the following regular expression in the body of the email
+
+# English: attach, attached, attachment, attachments</emphasis>
+set attach_keyword = &quot;\\&lt;attach(|ed|ments?)\\&gt;&quot;
+
+<emphasis role="comment"># Nederlands:
+# set attach_keyword = &quot;\\&lt;(bijvoegen|bijgevoegd|bijlage|bijlagen)\\&gt;&quot;
+
+# Deutsch:
+# set attach_keyword = &quot;\\&lt;(anhängen|angehängt|anhang|anhänge|hängt an)\\&gt;&quot;
+
+# Français:
+# set attach_keyword = &quot;\\&lt;(attaché|attachés|attache|attachons|joint|jointe|joints|jointes|joins|joignons)\\&gt;&quot;
+
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="forgotten-attachment-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="attach-menu">The Attachment Menu</link></para></listitem>
+      <listitem><para><link linkend="attachment-map">The Attachment Menu key mappings</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="forgotten-attachment-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="forgotten-attachment-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Darshit Shah <email>darnir@gmail.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    <listitem><para>Johannes Wei&szlig;l <email>jargon@molb.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="ifdef">
+  <title>Ifdef Feature</title>
+  <subtitle>Conditional config options</subtitle>
+
+  <sect2 id="ifdef-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>ifdef</quote>, look for
+      <quote>patch-ifdef</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="ifdef-intro">
+    <title>Introduction</title>
+
+    <para>
+      The <quote>ifdef</quote> patch introduces three new commands to
+      Mutt and allow you to share one config file between versions of Mutt
+      that may have different features compiled in.
+    </para>
+
+<screen>
+ifdef  symbol config-command [args...]  <emphasis role="comment"># If a symbol is defined</emphasis>
+ifndef symbol config-command [args...]  <emphasis role="comment"># If a symbol is not defined</emphasis>
+finish                                  <emphasis role="comment"># Finish reading the current file</emphasis>
+</screen>
+
+    <para>
+      Here a symbol can be a <link linkend="variables">$variable</link>,
+      <link linkend="functions">&lt;function&gt;</link>,
+      <link linkend="commands">command</link> or compile-time symbol, such
+      as <quote>USE_IMAP</quote>.
+    </para>
+
+        <para>
+            <literal>finish</literal> is particularly useful when combined with
+            <literal>ifndef</literal>. e.g.
+        </para>
+
+<screen>
+<emphasis role="comment"># Sidebar config file</emphasis>
+ifndef USE_SIDEBAR finish
+</screen>
+
+  </sect2>
+
+  <sect2 id="ifdef-commands">
+    <title>Commands</title>
+    <cmdsynopsis>
+      <command>ifdef</command>
+      <arg choice="plain">
+        <replaceable class="parameter">symbol</replaceable>
+      </arg>
+      <arg choice="plain">
+        <replaceable class="parameter">"config-command [args]"</replaceable>
+      </arg>
+      <command>ifndef</command>
+      <arg choice="plain">
+        <replaceable class="parameter">symbol</replaceable>
+      </arg>
+      <arg choice="plain">
+        <replaceable class="parameter">"config-command [args]"</replaceable>
+      </arg>
+      <command>finish</command>
+    </cmdsynopsis>
+  </sect2>
+
+  <sect2 id="ifdef-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the ifdef feature.
+
+# This feature introduces three useful commands which allow you to share
+# one config file between versions of Mutt that may have different
+# features compiled in.
+
+#   ifdef  symbol config-command [args...]
+#   ifndef symbol config-command [args...]
+#   finish
+
+# The 'ifdef' command tests whether Mutt understands the name of
+# a variable, function, command or compile-time symbol.
+# If it does, then it executes a config command.
+
+# The 'ifndef' command tests whether a symbol does NOT exist.
+
+# The 'finish' command tells Mutt to stop reading current config file.
+
+# If the 'trash' variable exists, set it.</emphasis>
+ifdef trash 'set trash=~/Mail/trash'
+
+<emphasis role="comment"># If the 'tag-pattern' function exists, bind a key to it.</emphasis>
+ifdef tag-pattern 'bind index &lt;F6&gt; tag-pattern'
+
+<emphasis role="comment"># If the 'imap-fetch-mail' command exists, read my IMAP config.</emphasis>
+ifdef imap-fetch-mail 'source ~/.mutt/imap.rc'
+
+<emphasis role="comment"># If the compile-time symbol 'USE_SIDEBAR' does not exist, then
+# stop reading the current config file.</emphasis>
+ifndef USE_SIDEBAR finish
+
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="ifdef-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="ifdef-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="ifdef-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Cedric Duval <email>cedricduval@free.fr</email></para></listitem>
+    <listitem><para>Matteo F. Vescovi <email>mfvescovi@gmail.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="index-color">
+  <title>Index Color Feature</title>
+  <subtitle>Custom rules for theming the email index</subtitle>
+
+  <sect2 id="index-color-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>Index Color</quote>, look for
+      <quote>patch-index-color</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+      <listitem><para><link linkend="status-color">status-color patch</link></para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="index-color-intro">
+    <title>Introduction</title>
+
+        <para>
+    The <quote>index-color</quote> patch allows you to specify colors for
+    individual parts of the email index. e.g. Subject, Author, Flags.
+        </para>
+
+        <para>
+    First choose which part of the index you'd like to color.
+    Then, if needed, pick a pattern to match.
+        </para>
+
+    <para>
+    Note: The pattern does not have to refer to the object you wish to
+    color.  e.g.
+    </para>
+
+<screen>
+color index_author red default &quot;~smutt&quot;
+</screen>
+
+        <para>
+    The author appears red when the subject (~s) contains <quote>mutt</quote>.
+        </para>
+  </sect2>
+
+  <sect2 id="index-color-colors">
+    <title>Colors</title>
+
+        <para>
+    All the colors default to <literal>default</literal>, i.e. unset.
+        </para>
+
+        <para>
+    The index objects can be themed using the <literal>color</literal> command.
+    Some objects require a pattern.
+        </para>
+
+<screen>
+color index-object foreground background
+color index-object foreground background pattern
+</screen>
+
+    <table id="table-index-color-colors">
+      <title>Index Colors</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Object</entry>
+            <entry>Pattern</entry>
+            <entry>Highlights</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>index</literal></entry>
+            <entry>yes</entry>
+            <entry>Entire index line</entry>
+          </row>
+          <row>
+            <entry><literal>index_author</literal></entry>
+            <entry>yes</entry>
+            <entry>Author name, %A %a %F %L %n</entry>
+          </row>
+          <row>
+            <entry><literal>index_collapsed</literal></entry>
+            <entry>no</entry>
+            <entry>Number of messages in a collapsed thread, %M</entry>
+          </row>
+          <row>
+            <entry><literal>index_date</literal></entry>
+            <entry>no</entry>
+            <entry>Date field</entry>
+          </row>
+          <row>
+            <entry><literal>index_flags</literal></entry>
+            <entry>yes</entry>
+            <entry>Message flags, %S %Z</entry>
+          </row>
+          <row>
+            <entry><literal>index_label</literal></entry>
+            <entry>no</entry>
+            <entry>Message label, %y %Y</entry>
+          </row>
+          <row>
+            <entry><literal>index_number</literal></entry>
+            <entry>no</entry>
+            <entry>Message number, %C</entry>
+          </row>
+          <row>
+            <entry><literal>index_size</literal></entry>
+            <entry>no</entry>
+            <entry>Message size, %c %l</entry>
+          </row>
+          <row>
+            <entry><literal>index_subject</literal></entry>
+            <entry>yes</entry>
+            <entry>Subject, %s</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="index-color-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the index-color feature.
+
+# Entire index line</emphasis>
+color index white black '.*'
+
+<emphasis role="comment"># Author name, %A %a %F %L %n
+
+# Give the author column a dark grey background</emphasis>
+color index_author default color234 '.*'
+
+<emphasis role="comment"># Highlight a particular from (~f)</emphasis>
+color index_author brightyellow color234 '~fRay Charles'
+
+<emphasis role="comment"># Message flags, %S %Z
+# Highlight the flags for flagged (~F) emails</emphasis>
+color index_flags default red '~F'
+
+<emphasis role="comment"># Subject, %s
+# Look for a particular subject (~s)</emphasis>
+color index_subject brightcyan default '~s\(closes #[0-9]+\)'
+
+<emphasis role="comment"># Number of messages in a collapsed thread, %M</emphasis>
+color index_collapsed default brightblue
+
+<emphasis role="comment"># Date field</emphasis>
+color index_date green default
+
+<emphasis role="comment"># Message label, %y %Y</emphasis>
+color index_label default brightgreen
+
+<emphasis role="comment"># Message number, %C</emphasis>
+color index_number red default
+
+<emphasis role="comment"># Message size, %c %l</emphasis>
+color index_size cyan default
+
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="index-color-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="regexp">Regular Expressions</link></para></listitem>
+      <listitem><para><link linkend="patterns">Patterns</link></para></listitem>
+      <listitem><para><link linkend="index-format">$index_format</link></para></listitem>
+      <listitem><para><link linkend="color">Color command</link></para></listitem>
+      <listitem><para><link linkend="status-color">Status-Color patch</link></para></listitem>
+      <listitem><para><link linkend="keywords">Keywords patch</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="index-color-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="index-color-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Christian Aichinger <email>Greek0@gmx.net</email></para></listitem>
+    <listitem><para>Christoph <quote>Myon</quote> Berg <email>myon@debian.org</email></para></listitem>
+    <listitem><para>Elimar Riesebieter <email>riesebie@lxtec.de</email></para></listitem>
+    <listitem><para>Eric Davis <email>edavis@insanum.com</email></para></listitem>
+    <listitem><para>Vladimir Marek <email>Vladimir.Marek@oracle.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="initials">
+  <title>Initials Expando Feature</title>
+  <subtitle>Expando for author's initials</subtitle>
+
+  <sect2 id="initials-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>Initials</quote>, look for
+      <quote>patch-initials</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="initials-intro">
+    <title>Introduction</title>
+
+        <para>
+    The <quote>initials</quote> patch adds an expando (%I) for an author's
+    initials.
+        </para>
+
+    <para>
+    The index panel displays a list of emails.  Its layout is controlled by
+    the <link linkend="index-format">$index_format</link> variable.  Using
+    this expando saves space in the index panel.  This can be useful if you
+    are regularly working with a small set of people.
+    </para>
+  </sect2>
+
+  <sect2 id="initials-variables">
+    <title>Variables</title>
+
+        <para>
+        This feature has no config of its own.  It adds an expando which can be
+    used in the <link linkend="index-format">$index_format</link> variable.
+        </para>
+  </sect2>
+
+  <sect2 id="initials-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the initials feature.
+
+# The 'initials' feature has no config of its own.
+# It adds an expando for an author's initials,
+# which can be used in the 'index_format' variable.
+
+# The default 'index_format' is:</emphasis>
+set index_format='%4C %Z %{%b %d} %-15.15L (%?l?%4l&amp;%4c?) %s'
+
+<emphasis role="comment"># Where %L represents the author/recipient
+
+# This might look like:
+#       1   + Nov 17 David Bowie   Changesbowie    ( 689)
+#       2   ! Nov 17 Stevie Nicks  Rumours         ( 555)
+#       3   + Nov 16 Jimi Hendrix  Voodoo Child    ( 263)
+#       4   + Nov 16 Debbie Harry  Parallel Lines  ( 540)
+
+# Using the %I expando:</emphasis>
+set index_format='%4C %Z %{%b %d} %I (%?l?%4l&amp;%4c?) %s'
+
+<emphasis role="comment"># This might look like:
+#       1   + Nov 17 DB Changesbowie    ( 689)
+#       2   ! Nov 17 SN Rumours         ( 555)
+#       3   + Nov 16 JH Voodoo Child    ( 263)
+#       4   + Nov 16 DH Parallel Lines  ( 540)
+
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="initials-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="index-format">$index_format</link></para></listitem>
+      <listitem><para><link linkend="index-color">index-color patch</link></para></listitem>
+      <listitem><para><link linkend="folder-hook">folder-hook</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="initials-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="initials-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Vsevolod Volkov <email>vvv@mutt.org.ua</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="keywords">
+  <title>Keywords Feature</title>
+  <subtitle>Labels/Tagging for emails</subtitle>
+
+  <sect2 id="keywords-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>Keywords</quote>, look for
+      <quote>patch-keywords</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="keywords-intro">
+    <title>Introduction</title>
+
+    <para>
+    Unify label/keyword handling.
+    </para>
+
+    <para>
+    Since x-labels were added to mutt in 2000, a number of other approaches
+    to what we now call <quote>tagging</quote> have also emerged.
+    One of them was even made standard in RFC 2822.
+    This update unifies the handling of all these strategies.
+    </para>
+
+    <para>
+    We start by changing mutt's internal keyword storage from a single
+    string which may contain whitespace to a list of discrete keywords.
+    This has advantages for keyword completion as well as for portability
+    among varying "standards" for keyword storage.  This may represent
+    a significant change for existing mutt users who have set x-labels
+    containing spaces, and should be regarded with suspicion.  The
+    advantages are significant, though.
+    </para>
+
+    <para>
+    Next we allow mutt to parse keywords into this internal list from
+    any of the following headers: X-Label (freeform), X-Keywords
+    (space-delimited), X-Mozilla-Keys (space-delimited), and Keywords (RFC
+    2822, comma-space-delimited).  Mutt remembers which headers it sourced
+    keywords from, and can rewrite those headers when saving messages for
+    compatibility with the mailer of origin.
+    </para>
+
+    <para>
+    (X-Label was specified as freeform text by mutt, its only known
+    implementation.  X-Labels have been used both as a
+    <quote>tagging</quote> device, probably with space delimiting, and as a
+    <quote>memo</quote> field, where space-delimited parsing would ruin the
+    semantics of the memo.  By default mutt will not split X-Labels at all.
+    Set $xlabel_delimiter if your needs vary.)
+    </para>
+
+    <para>
+    Finally we add two booleans: $keywords_legacy=true and
+    $keywords_standard=FALSE.  When $keywords_legacy is true, mutt will
+    always save keyword to whatever original header it came from.  When
+    $keywords_standard=true, mutt will save to the Keywords: header.  If
+    both are true mutt saves to both; if neither is true, mutt saves only
+    to legacy headers to avoid complete loss of keywords.
+    </para>
+
+    <para>
+    Overall this represents convergence path for all competing
+    labelling/tagging/keywording systems toward one that is specified by
+    RFC.
+    </para>
+
+    <para>
+    You can change or delete the X-Label: field within
+    Mutt using the edit-label command.
+    This works for tagged messages, too.
+    </para>
+  </sect2>
+
+  <sect2 id="keywords-variables">
+    <title>Variables</title>
+
+    <table id="table-keywords-variables">
+      <title>Keywords Variables</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>keywords_legacy</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>yes</literal></entry>
+          </row>
+          <row>
+            <entry><literal>keywords_standard</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>xlabel_delimiter</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="keywords-functions">
+    <title>Functions</title>
+
+    <para>
+      Keywords adds the following function to Mutt.
+      By default, it is not bound to a key.
+    </para>
+
+    <table id="table-keywords-funcions">
+      <title>Keyword Functions</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Menus</entry>
+            <entry>Function</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;edit-label&gt;</literal></entry>
+            <entry>add, change, or delete a message's label</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="keywords-sort">
+    <title>Sort</title>
+    <table id="table-keywords-sort">
+      <title>Keywords Sort</title>
+      <tgroup cols="2">
+        <thead>
+          <row>
+            <entry>Sort</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>label</literal></entry>
+            <entry>Sort by label</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="keywords-muttrc">
+    <title>Muttrc</title>
+
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the keywords feature.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# Should Mutt save the keywords to whatever keyword it came from?</emphasis>
+set keywords_legacy = yes
+
+<emphasis role="comment"># Should Mutt use the &quot;Keywords:&quot; header?</emphasis>
+set keywords_standard = no
+
+<emphasis role="comment"># How should the keywords be separated?</emphasis>
+set xlabel_delimiter = &quot;&quot;
+
+<emphasis role="comment"># --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# Bind 'y' to edit labels/keywords</emphasis>
+bind index,pager y edit-label
+
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="keywords-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="index-format">$index_format</link></para></listitem>
+      <listitem><para><link linkend="index-color">index-color patch</link></para></listitem>
+      <listitem><para><link linkend="folder-hook">folder-hook</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="keywords-known-bugs">
+    <title>Known Bugs</title>
+    <para>
+      None
+    </para>
+  </sect2>
+
+  <sect2 id="keywords-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>David Champion <email>dgc@uchicago.edu</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="kyoto-cabinet">
+  <title>Kyoto Cabinet Feature</title>
+  <subtitle>Kyoto Cabinet backend for the header cache</subtitle>
+
+  <sect2 id="kyoto-cabinet-support">
+    <title>Support</title>
+
+    <para>
+      To check if Mutt supports Kyoto Cabinet, look for
+
+      <itemizedlist>
+        <listitem><para><quote>patch-kyoto</quote> in the mutt version. See: <xref linkend="mutt-patches"/>.</para></listitem>
+        <listitem><para><quote>+USE_HCACHE</quote> in the compile options</para></listitem>
+        <listitem><para><quote>hcache backend: kyotocabinet</quote> in the mutt version</para></listitem>
+      </itemizedlist>
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+      <listitem><para><ulink url="http://fallabs.com/kyotocabinet/">Kyoto Cabinet libraries</ulink></para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="kyoto-cabinet-intro">
+    <title>Introduction</title>
+
+    <para>
+      This feature adds support for using Kyoto Cabinet, the successor to Tokyo
+      Cabinet, as a storage backend for Mutt's header cache (hcache). It is
+      enabled at configure time with the
+      <emphasis>--with-kyotocabinet=&lt;path&gt;</emphasis> switch.
+    </para>
+  </sect2>
+
+  <sect2 id="kyoto-cabinet-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="caching">Local Caching</link></para></listitem>
+      <listitem><para><ulink url="http://fallabs.com/kyotocabinet/">Kyoto Cabinet</ulink></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="kyoto-cabinet-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="kyoto-cabinet-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Clemens Lang <email>neverpanic@gmail.com</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="limit-current-thread">
+  <title>Limit-Current-Thread Feature</title>
+  <subtitle>Focus on one Email Thread</subtitle>
+
+  <sect2 id="limit-current-thread-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>limit-current-thread</quote>, look for
+      <quote>patch-limit-current-thread</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="limit-current-thread-intro">
+    <title>Introduction</title>
+
+    <para>
+      This feature adds a new way of using the
+      <link linkend="tuning-search">Limit Command</link>.
+      The <literal>&lt;limit-current-thread&gt;</literal>
+      function restricts the view to just the current thread.
+      Setting the limit (the <literal>l</literal> key) to
+      <quote>all</quote> will restore the full email list.
+    </para>
+
+  </sect2>
+
+  <sect2 id="limit-current-thread-functions">
+    <title>Functions</title>
+
+    <para>
+      Limit-current-thread adds the following function to Mutt.
+      By default, it is not bound to a key.
+    </para>
+
+    <table id="table-limit-current-thread-functions">
+      <title>Limit-Current-Thread Functions</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Menus</entry>
+            <entry>Function</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>index</entry>
+            <entry><literal>&lt;limit-current-thread&gt;</literal></entry>
+            <entry>Limit view to current thread</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+
+  </sect2>
+
+  <sect2 id="limit-current-thread-muttrc">
+    <title>Muttrc</title>
+
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the limit-current-thread feature.
+
+# Limit view to current thread</emphasis>
+bind index &lt;esc&gt;L limit-current-thread
+
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="limit-current-thread-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="limit-current-thread-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="limit-current-thread-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>David Sterba <email>dsterba@suse.cz</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="lmdb">
+  <title>LMDB Feature</title>
+  <subtitle>LMDB backend for the header cache</subtitle>
+
+  <sect2 id="lmdb-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>lmdb</quote>, look for
+      <quote>patch-lmdb</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="lmdb-intro">
+    <title>Introduction</title>
+
+    <para>
+      This feature adds support for using LMDB as a storage backend for
+      Mutt's header cache (hcache). It is enabled at configure time with
+      the <emphasis>--with-lmdb=&lt;path&gt;</emphasis> switch.
+    </para>
+
+    <note>
+      <para>
+        It is not recommended to store the lmdb database on a shared drive.
+      </para>
+    </note>
+  </sect2>
+
+  <sect2 id="lmdb-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="caching">Local Caching</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="lmdb-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="lmdb-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Pietro Cerutti <email>gahr@gahr.ch</email></para></listitem>
+    <listitem><para>Jan-Piet Mens <email>jp@mens.de</email></para></listitem>
+    <listitem><para>Clemens Lang <email>neverpanic@gmail.com</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="multiple-fcc">
+  <title>multiple-fcc Feature</title>
+  <subtitle>Save multiple copies of outgoing mail</subtitle>
+
+  <sect2 id="multiple-fcc-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>multiple-fcc</quote>, look for
+      <quote>patch-multiple-fcc</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="multiple-fcc-intro">
+    <title>Introduction</title>
+
+    <para>
+      This feature allows the user to save outgoing emails in multiple folders.
+    </para>
+
+    <para>
+      Folders should be listed separated by commas, <emphasis role="bold">but no spaces</emphasis>.
+    </para>
+
+    <para>
+      The <quote>fcc</quote> field of an email can be set in two ways:
+    </para>
+
+    <itemizedlist>
+      <listitem><para>The &lt;edit-fcc&gt; command in the compose menu (default key: <quote>f</quote>)</para></listitem>
+      <listitem><para>Creating a <literal>fcc-hook</literal> in your <literal>.muttrc</literal></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="multiple-fcc-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="record">$record</link></para></listitem>
+      <listitem><para><link linkend="fcc-hook">fcc-hook</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="multiple-fcc-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="multiple-fcc-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Omen Wild <email>omen@mandarb.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="nested-if">
+  <title>Nested If Feature</title>
+  <subtitle>Allow complex nested conditions in format strings</subtitle>
+
+  <sect2 id="nested-if-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>Nested If</quote>, look for
+      <quote>patch-nested-if</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="nested-if-intro">
+    <title>Introduction</title>
+
+    <para>
+      Mutt's format strings can contain embedded if-then-else conditions.
+      They are of the form:
+    </para>
+
+<screen>
+%?VAR?TRUE&amp;FALSE?
+</screen>
+
+    <para>
+      If the variable <quote>VAR</quote> has a value greater than zero,
+      print the <quote>TRUE</quote> string, otherwise print the
+      <quote>FALSE</quote> string.
+    </para>
+
+    <para>
+      e.g.  <literal>%?S?Size: %S&amp;Empty?</literal>
+    </para>
+
+    <para>Which can be read as:</para>
+
+    <literallayout>
+if (%S &gt; 0) {
+    print &quot;Size: %S&quot;
+} else {
+    print &quot;Empty&quot;
+}
+    </literallayout>
+
+    <para>
+      These conditions are useful, but in Mutt they cannot be nested
+      within one another.  This feature uses the notation
+      <literal>%&lt;VAR?TRUE&amp;FALSE&gt;</literal> and allows them to be nested.
+    </para>
+
+    <para>
+      The <literal>%&lt;...&gt;</literal> notation was used to format the
+      current local time.  but that's not really very useful since mutt
+      has no means of refreshing the screen periodically.
+    </para>
+
+    <para>
+      A simple nested condition might be:
+      (Some whitespace has been introduced for clarity)
+    </para>
+
+<screen>
+%&lt;x? %&lt;y? XY &amp; X &gt; &amp; %&lt;y? Y &amp; NONE &gt; &gt;  Conditions
+     %&lt;y? XY &amp; X &gt;                      x&gt;0
+          XY                            x&gt;0,y&gt;0
+               X                        x&gt;0,y=0
+</screen>
+
+<screen>
+%&lt;x? %&lt;y? XY &amp; X &gt; &amp; %&lt;y? Y &amp; NONE &gt; &gt;  Conditions
+                     %&lt;y? Y &amp; NONE &gt;    x=0
+                          Y             x=0,y&gt;0
+                              NONE      x=0,y=0
+</screen>
+
+    <para>Equivalent to:</para>
+
+    <literallayout>
+if (x &gt; 0) {
+    if (y &gt; 0) {
+        print 'XY'
+    } else {
+        print 'X'
+    }
+} else {
+    if (y &gt; 0) {
+        print 'Y'
+    } else {
+        print 'NONE'
+    }
+}
+    </literallayout>
+
+    <para>Examples:</para>
+
+<screen>
+set index_format='%4C %Z %{%b %d} %-25.25n %s%&gt; %&lt;M?%M Msgs &amp;%&lt;l?%l Lines&amp;%c Bytes&gt;&gt;'
+</screen>
+
+    <literallayout>
+if a thread is folded
+    display the number of messages (%M)
+else if we know how many lines in the message
+    display lines in message (%l)
+else
+    display the size of the message in bytes (%c)
+    </literallayout>
+
+<screen>
+set index_format='%4C %Z %{%b %d} %-25.25n %&lt;M?[%M] %s&amp;%s%* %&lt;l?%l&amp;%c&gt;&gt;'
+</screen>
+
+    <literallayout>
+if a thread is folded
+    display the number of messages (%M)
+    display the subject (%s)
+else if we know how many lines in the message
+    display lines in message (%l)
+else
+    display the size of the message in bytes (%c)
+    </literallayout>
+
+  </sect2>
+
+  <sect2 id="nested-if-variables">
+    <title>Variables</title>
+    <para>
+      The <quote>nested-if</quote> patch doesn't have any config of its own.
+      It modifies the behavior of the format strings.
+    </para>
+  </sect2>
+
+  <sect2 id="nested-if-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the nested-if feature.
+
+# This feature uses the format: '%&lt;VAR?TRUE&amp;FALSE&gt;' for conditional
+# format strings that can be nested.
+
+# Example 1
+# if a thread is folded
+#       display the number of messages (%M)
+# else if we know how many lines in the message
+#       display lines in message (%l)
+# else display the size of the message in bytes (%c)</emphasis>
+set index_format='%4C %Z %{%b %d} %-25.25n %s%&gt; %&lt;M?%M Msgs &amp;%&lt;l?%l Lines&amp;%c Bytes&gt;&gt;'
+
+<emphasis role="comment"># Example 2
+# if a thread is folded
+#       display the number of messages (%M)
+#       display the subject (%s)
+# else if we know how many lines in the message
+#       display lines in message (%l)
+# else
+#       display the size of the message in bytes (%c)</emphasis>
+set index_format='%4C %Z %{%b %d} %-25.25n %&lt;M?[%M] %s&amp;%s%* %&lt;l?%l&amp;%c&gt;&gt;'
+
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="nested-if-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="cond-date">cond-date patch</link></para></listitem>
+      <listitem><para><link linkend="index-format">$index_format</link></para></listitem>
+      <listitem><para><link linkend="status-format">$status_format</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="nested-if-known-bugs">
+    <title>Known Bugs</title>
+    <para>
+      Patch overwrites $&lt;fmt&gt; handler in <literal>$index_format</literal>
+    </para>
+  </sect2>
+
+  <sect2 id="nested-if-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>David Champion <email>dgc@uchicago.edu</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="new-mail-hook">
+  <title>new-mail Feature</title>
+  <subtitle>Execute a command upon the receipt of new mail.</subtitle>
+
+  <sect2 id="new-mail-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>new-mail</quote>, look for
+      <quote>patch-new-mail</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="new-mail-intro">
+    <title>Introduction</title>
+
+    <para>
+      This feature enables the new_mail_command setting, which can be used to
+      execute a custom script (e.g., a notification handler) upon receiving a
+      new mail.
+    </para>
+
+    <para>
+      The command string can contain expandos, such as <literal>%f</literal>
+      for the folder name.  For a complete list, see:
+      <link linkend="status-format">$status_format</link>.
+    </para>
+
+    <para>
+      For example in Linux you can use (most distributions already provide notify-send):
+    </para>
+
+<screen>
+set new_mail_command="notify-send --icon='/home/santiago/Pictures/mutt.png' 'New Email in %f' '%n new messages, %u unread.' &amp;"
+</screen>
+
+    <para>
+      And in OS X you will need to install a command line interface for
+      Notification Center, for example
+      <ulink url="https://github.com/julienXX/terminal-notifier">terminal-notifier</ulink>:
+    </para>
+
+<screen>
+set new_mail_command="terminal-notifier -title '%v' -subtitle 'New Mail in %f' -message '%n new messages, %u unread.' -activate 'com.apple.Terminal'"
+</screen>
+
+  </sect2>
+
+  <sect2 id="new-mail-variables">
+    <title>Variables</title>
+
+    <table id="table-new-mail-variables">
+      <title>New Mail Command Variables</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>new_mail_command</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="new-mail-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the new-mail feature.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# Set the command you want mutt to execute upon the receipt of a new email</emphasis>
+set new_mail_command = &quot;&quot;
+
+<emphasis role="comment"># Linux example:
+# set new_command=&quot;notify-send --icon='/home/santiago/Pictures/mutt.png' 'New Email in %f' '%n new messages, %u unread.' &amp;&quot;
+
+# OS X example:
+# set new_mail_command=&quot;terminal-notifier -title '%v' -subtitle 'New Mail in %f' -message '%n new messages, %u unread.' -activate 'com.apple.Terminal'&quot;
+
+# --------------------------------------------------------------------------
+
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="new-mail-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="folder-hook">folder-hook</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="new-mail-known-bugs">
+    <title>Known Bugs</title>
+    <itemizedlist>
+      <listitem>
+        <para>
+          Notifies about spurious <emphasis role="bold">new email</emphasis>
+          when an email is saved, see
+          <ulink url="https://github.com/neomutt/neomutt/issues/20">Issue #20</ulink>
+        </para>
+    </listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="new-mail-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Yoshiki Vazquez-Baeza <email>yoshiki@ucsd.edu</email></para></listitem>
+    <listitem><para>Santiago Torres-Arias <email>santiago@nyu.edu</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="nntp">
+  <title>NNTP Feature</title>
+  <subtitle>Talk to a Usenet news server</subtitle>
+
+  <sect2 id="nntp-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>NNTP</quote>, look for
+      <quote>+USE_NNTP</quote> in the version info.
+      See: <xref linkend="compile-time-features"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="nntp-intro">
+    <title>Introduction</title>
+
+    <para>Reading news via NNTP</para>
+    <para>
+    If compiled with <emphasis>--enable-nntp</emphasis> option, Mutt can
+    read news from news server via NNTP.  You can open a newsgroup with
+    function ``change-newsgroup'' (default: ``i'').  Default news server
+    can be obtained from <literal>$NNTPSERVER</literal> environment
+    variable or from <literal>/etc/nntpserver</literal> file.  Like other
+    news readers, info about subscribed newsgroups is saved in file by
+    <link linkend="newsrc">$newsrc</link> variable.  The variable <link
+    linkend="news-cache-dir">$news_cache_dir</link> can be used to point
+    to a directory.  Mutt will create a hierarchy of subdirectories named
+    like the account and newsgroup the cache is for.  Also the hierarchy
+    is used to store header cache if Mutt was compiled with <link
+    linkend="header-caching">header cache</link> support.
+    </para>
+  </sect2>
+
+  <sect2 id="nntp-variables">
+    <title>Variables</title>
+
+    <table id="table-nntp-variables">
+      <title>NNTP Variables</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>ask_follow_up</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>ask_x_comment_to</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>catchup_newsgroup</literal></entry>
+            <entry>quad</entry>
+            <entry><literal>ask-yes</literal></entry>
+          </row>
+          <row>
+            <entry><literal>followup_to_poster</literal></entry>
+            <entry>quad</entry>
+            <entry><literal>ask-yes</literal></entry>
+          </row>
+          <row>
+            <entry><literal>group_index_format</literal></entry>
+            <entry>string</entry>
+            <entry><literal>%4C %M%N %5s  %-45.45f %d</literal></entry>
+          </row>
+          <row>
+            <entry><literal>inews</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>mime_subject</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>yes</literal></entry>
+          </row>
+          <row>
+            <entry><literal>newsgroups_charset</literal></entry>
+            <entry>string</entry>
+            <entry><literal>utf-8</literal></entry>
+          </row>
+          <row>
+            <entry><literal>newsrc</literal></entry>
+            <entry>string</entry>
+            <entry><literal>~/.newsrc</literal></entry>
+          </row>
+          <row>
+            <entry><literal>news_cache_dir</literal></entry>
+            <entry>string</entry>
+            <entry><literal>~/.mutt</literal></entry>
+          </row>
+          <row>
+            <entry><literal>news_server</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>nntp_authenticators</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>nntp_context</literal></entry>
+            <entry>number</entry>
+            <entry><literal>1000</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nntp_listgroup</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>yes</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nntp_load_description</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>yes</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nntp_pass</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>nntp_poll</literal></entry>
+            <entry>number</entry>
+            <entry><literal>60</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nntp_user</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>post_moderated</literal></entry>
+            <entry>quad</entry>
+            <entry><literal>ask-yes</literal></entry>
+          </row>
+          <row>
+            <entry><literal>save_unsubscribed</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>show_new_news</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>yes</literal></entry>
+          </row>
+          <row>
+            <entry><literal>show_only_unread</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>x_comment_to</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="nntp-functions">
+    <title>Functions</title>
+
+    <para>
+      NNTP adds the following functions to Mutt.
+      By default, none of them are bound to keys.
+    </para>
+
+    <table id="table-nntp-functions">
+      <title>NNTP Functions</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Menus</entry>
+            <entry>Function</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>browser,index</entry>
+            <entry><literal>&lt;catchup&gt;</literal></entry>
+            <entry>mark all articles in newsgroup as read</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;change-newsgroup&gt;</literal></entry>
+            <entry>open a different newsgroup</entry>
+          </row>
+          <row>
+            <entry>compose</entry>
+            <entry><literal>&lt;edit-followup-to&gt;</literal></entry>
+            <entry>edit the Followup-To field</entry>
+          </row>
+          <row>
+            <entry>compose</entry>
+            <entry><literal>&lt;edit-newsgroups&gt;</literal></entry>
+            <entry>edit the newsgroups list</entry>
+          </row>
+          <row>
+            <entry>compose</entry>
+            <entry><literal>&lt;edit-x-comment-to&gt;</literal></entry>
+            <entry>edit the X-Comment-To field</entry>
+          </row>
+          <row>
+            <entry>attach,index,pager</entry>
+            <entry><literal>&lt;followup-message&gt;</literal></entry>
+            <entry>followup to newsgroup</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;post-message&gt;</literal></entry>
+            <entry>post message to newsgroup</entry>
+          </row>
+          <row>
+            <entry>browser</entry>
+            <entry><literal>&lt;reload-active&gt;</literal></entry>
+            <entry>load list of all newsgroups from NNTP server</entry>
+          </row>
+          <row>
+            <entry>browser</entry>
+            <entry><literal>&lt;subscribe&gt;</literal></entry>
+            <entry>subscribe to current mbox (IMAP/NNTP only)</entry>
+          </row>
+          <row>
+            <entry>browser</entry>
+            <entry><literal>&lt;subscribe-pattern&gt;</literal></entry>
+            <entry>subscribe to newsgroups matching a pattern</entry>
+          </row>
+          <row>
+            <entry>browser</entry>
+            <entry><literal>&lt;uncatchup&gt;</literal></entry>
+            <entry>mark all articles in newsgroup as unread</entry>
+          </row>
+          <row>
+            <entry>browser</entry>
+            <entry><literal>&lt;unsubscribe&gt;</literal></entry>
+            <entry>unsubscribe from current mbox (IMAP/NNTP only)</entry>
+          </row>
+          <row>
+            <entry>browser</entry>
+            <entry><literal>&lt;unsubscribe-pattern&gt;</literal></entry>
+            <entry>unsubscribe from newsgroups matching a pattern</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;change-newsgroup-readonly&gt;</literal></entry>
+            <entry>open a different newsgroup in read only mode</entry>
+          </row>
+          <row>
+            <entry>attach,index,pager</entry>
+            <entry><literal>&lt;forward-to-group&gt;</literal></entry>
+            <entry>forward to newsgroup</entry>
+          </row>
+          <row>
+            <entry>index</entry>
+            <entry><literal>&lt;get-children&gt;</literal></entry>
+            <entry>get all children of the current message</entry>
+          </row>
+          <row>
+            <entry>index</entry>
+            <entry><literal>&lt;get-parent&gt;</literal></entry>
+            <entry>get parent of the current message</entry>
+          </row>
+          <row>
+            <entry>index</entry>
+            <entry><literal>&lt;reconstruct-thread&gt;</literal></entry>
+            <entry>reconstruct thread containing current message</entry>
+          </row>
+          <row>
+            <entry>index</entry>
+            <entry><literal>&lt;get-message&gt;</literal></entry>
+            <entry>get message with Message-Id</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="nntp-muttrc">
+    <title>Muttrc</title>
+
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the nntp feature.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------</emphasis>
+
+set ask_follow_up = no
+set ask_x_comment_to = no
+set catchup_newsgroup = ask-yes
+set followup_to_poster = ask-yes
+set group_index_format = '%4C %M%N %5s  %-45.45f %d'
+set inews = ''
+set mime_subject = yes
+set newsgroups_charset = utf-8
+set newsrc = '~/.newsrc'
+set news_cache_dir = '~/.mutt'
+set news_server = ''
+set nntp_authenticators = ''
+set nntp_context = 1000
+set nntp_listgroup = yes
+set nntp_load_description = yes
+set nntp_pass = ''
+set nntp_poll = 60
+set nntp_user = ''
+set post_moderated = ask-yes
+set save_unsubscribed = no
+set show_new_news = yes
+set show_only_unread = no
+set x_comment_to = no
+
+<emphasis role="comment"># --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# mark all articles in newsgroup as read</emphasis>
+bind browser,index y catchup
+
+<emphasis role="comment"># open a different newsgroup</emphasis>
+bind index,pager i change-newsgroup
+
+<emphasis role="comment"># edit the Followup-To field</emphasis>
+bind compose o edit-followup-to
+
+<emphasis role="comment"># edit the newsgroups list</emphasis>
+bind compose N edit-newsgroups
+
+<emphasis role="comment"># edit the X-Comment-To field</emphasis>
+bind compose x edit-x-comment-to
+
+<emphasis role="comment"># followup to newsgroup</emphasis>
+bind attach,index,pager F followup-message
+
+<emphasis role="comment"># post message to newsgroup</emphasis>
+bind index,pager P post-message
+
+<emphasis role="comment"># load list of all newsgroups from NNTP server</emphasis>
+bind browser g reload-active
+
+<emphasis role="comment"># subscribe to current mbox (IMAP/NNTP only)</emphasis>
+bind browser s subscribe
+
+<emphasis role="comment"># subscribe to newsgroups matching a pattern</emphasis>
+bind browser S subscribe-pattern
+
+<emphasis role="comment"># mark all articles in newsgroup as unread</emphasis>
+bind browser Y uncatchup
+
+<emphasis role="comment"># unsubscribe from current mbox (IMAP/NNTP only)</emphasis>
+bind browser u unsubscribe
+
+<emphasis role="comment"># unsubscribe from newsgroups matching a pattern</emphasis>
+bind browser U unsubscribe-pattern
+
+<emphasis role="comment"># open a different newsgroup in read only mode</emphasis>
+bind index,pager \ei change-newsgroup-readonly
+
+<emphasis role="comment"># forward to newsgroup</emphasis>
+bind attach,index,pager \eF forward-to-group
+
+<emphasis role="comment"># get all children of the current message
+# bind index ??? get-children
+
+# get parent of the current message</emphasis>
+bind index \eG get-parent
+
+<emphasis role="comment"># reconstruct thread containing current message
+# bind index ??? reconstruct-thread
+
+# get message with Message-Id</emphasis>
+bind index \CG get-message
+
+<emphasis role="comment"># --------------------------------------------------------------------------
+
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="nntp-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="compile-time-features">Compile-Time Features</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="nntp-known-bugs">
+    <title>Known Bugs</title>
+    <para>
+      None
+    </para>
+  </sect2>
+
+  <sect2 id="nntp-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Vsevolod Volkov <email>vvv@mutt.org.ua</email></para></listitem>
+    <listitem><para>Felix von Leitner <email>leitner@fefe.de</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="notmuch">
+  <title>Notmuch Feature</title>
+  <subtitle>Email search engine</subtitle>
+
+  <sect2 id="notmuch-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>Notmuch</quote>, look for
+      <quote>+USE_NOTMUCH</quote> in the version info.
+      See: <xref linkend="compile-time-features"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+      <listitem><para><link linkend="quasi-delete">quasi-delete patch</link></para></listitem>
+      <listitem><para><link linkend="index-color">index-color patch</link></para></listitem>
+      <listitem><para>Notmuch libraries</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="notmuch-intro">
+    <title>Introduction</title>
+
+    <para>
+      Notmuch is an email fulltext indexing and tagging engine.
+    </para>
+
+    <itemizedlist>
+      <listitem><para>For more information, see:
+      <ulink url="http://notmuchmail.org/">http://notmuchmail.org/</ulink>
+      </para></listitem>
+      <listitem><para>Home page (wiki) and git:
+      <ulink url="https://github.com/karelzak/mutt-kz">https://github.com/karelzak/mutt-kz</ulink>
+      </para></listitem>
+      <listitem><para>Mailing list:
+      <ulink url="https://admin.fedoraproject.org/mailman/listinfo/mutt-kz">https://admin.fedoraproject.org/mailman/listinfo/mutt-kz</ulink>
+      </para></listitem>
+
+      <listitem><para>More examples:
+      <ulink url="http://notmuchmail.org/mutttips/">http://notmuchmail.org/mutttips/</ulink>
+      </para></listitem>
+    </itemizedlist>
+
+  </sect2>
+
+  <sect2 id="notmuch-using">
+    <title>Using NotMuch</title>
+
+    <sect3 id="notmuch-folder-uri">
+      <title>Folders URI</title>
+
+      <para>
+        <emphasis role="bold">notmuch://[&lt;path&gt;][?&lt;item&gt;=&lt;name&gt;[&amp; ...]]</emphasis>
+      </para>
+
+      <para>
+        The &lt;path&gt; is an absolute path to the directory where the notmuch database
+        is found as returned by <quote>notmuch config get database.path</quote> command. Note that
+        the &lt;path&gt; should NOT include <literal>.notmuch</literal> directory name.
+      </para>
+
+      <para>
+        If the &quot;&lt;path&gt;&quot; is not defined then
+        <literal>$nm_default_uri</literal> or <literal>$folder</literal> is
+        used, for example:
+      </para>
+
+<screen>
+set nm_default_uri = "notmuch:///home/foo/maildir"
+virtual-mailboxes "My INBOX" "notmuch://?query=tag:inbox"
+</screen>
+    </sect3>
+
+    <sect3 id="notmuch-items">
+      <title>Items</title>
+
+      <para>
+        <emphasis role="bold">query=&lt;string&gt;</emphasis>
+      </para>
+
+      <para>
+        See SEARCH SYNTAX in notmuch man page. Don't forget to use
+        <quote>and</quote> and <quote>or</quote> operators in your queries.
+      </para>
+
+      <para>
+        Note that proper URI should not contain blank space and all
+        <quote>bad</quote> chars should be encoded, for example
+      </para>
+
+      <para>
+        <literal>tag:AAA and tag:BBB</literal> --encoding-&gt; <literal>tag:AAA%20and%20tag:BBB</literal>
+      </para>
+
+      <para>
+        but mutt config file parser is smart enough to accept space in quoted
+        strings. It means that you can use
+      </para>
+
+      <para>
+        <literal>notmuch:///foo?query=tag:AAA and tag:BBB</literal>
+      </para>
+
+      <para>
+        in your config files to keep things readable.
+      </para>
+
+      <para>
+        For more details about Xapian queries, see:
+        <ulink url="http://xapian.org/docs/queryparser.html">http://xapian.org/docs/queryparser.html</ulink>
+      </para>
+
+      <para>
+        <emphasis role="bold">limit=&lt;number&gt;</emphasis>
+      </para>
+
+      <para>
+         Restricts number of messages/threads in the result. The default limit
+         is nm_db_limit.
+      </para>
+
+      <para>
+        <emphasis role="bold">type=&lt;threads|messages&gt;</emphasis>
+      </para>
+
+      <para>
+         Reads all matching messages or whole-threads. The default is 'messages'
+         or nm_query_type.
+      </para>
+    </sect3>
+
+    <sect3 id="notmuch-vfolder-format">
+      <title>Format String for the NotMuch Browser</title>
+
+        <para>
+          Default: <literallayout><literal>%2C %?n?%4n/&amp;     ?%4m %f</literal></literallayout>
+        </para>
+
+        <para>
+          This variable allows you to customize the browser display to your personal taste.
+          This string is similar to <link linkend="index-format">$index_format</link>, but has
+          its own set of <literal>printf(3)</literal>-like sequences:
+        </para>
+
+        <informaltable>
+          <tgroup cols="2">
+            <tbody>
+              <row>
+                <entry>%C</entry>
+                <entry>current file number</entry>
+              </row>
+              <row>
+                <entry>%f</entry>
+                <entry>folder name (description)</entry>
+              </row>
+              <row>
+                <entry>%m</entry>
+                <entry>number of messages in the mailbox *</entry>
+              </row>
+              <row>
+                <entry>%n</entry>
+                <entry>number of unread messages in the mailbox *</entry>
+              </row>
+              <row>
+                <entry>%N</entry>
+                <entry>N if mailbox has new mail, blank otherwise</entry>
+              </row>
+              <row>
+                <entry>%&gt;X</entry>
+                <entry>right justify the rest of the string and pad with character
+                <quote>X</quote></entry>
+              </row>
+              <row>
+                <entry>%|X</entry>
+                <entry>pad to the end of the line with character
+                <quote>X</quote></entry>
+              </row>
+              <row>
+                <entry>%*X</entry>
+                <entry>soft-fill with character
+                <quote>X</quote>as pad</entry>
+              </row>
+            </tbody>
+          </tgroup>
+        </informaltable>
+
+        <para>
+        For an explanation of <quote>soft-fill</quote>, see the <link linkend="index-format">$index_format</link> documentation.
+        </para>
+
+        <para>
+        * = can be optionally printed if nonzero
+        </para>
+    </sect3>
+  </sect2>
+
+  <sect2 id="notmuch-variables">
+    <title>Variables</title>
+
+    <table id="table-notmuch-variables">
+      <title>Notmuch Variables</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>nm_db_limit</literal></entry>
+            <entry>number</entry>
+            <entry><literal>0</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nm_default_uri</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>nm_exclude_tags</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>nm_hidden_tags</literal></entry>
+            <entry>string</entry>
+            <entry><literal>unread,draft,flagged,passed,replied,attachment,signed,encrypted</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nm_open_timeout</literal></entry>
+            <entry>number</entry>
+            <entry><literal>5</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nm_query_type</literal></entry>
+            <entry>string</entry>
+            <entry><literal>messages</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nm_record</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nm_record_tags</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>nm_unread_tag</literal></entry>
+            <entry>string</entry>
+            <entry><literal>unread</literal></entry>
+          </row>
+          <row>
+            <entry><literal>vfolder_format</literal></entry>
+            <entry>string</entry>
+            <entry><literal>%6n(%6N) %f</literal></entry>
+          </row>
+          <row>
+            <entry><literal>virtual_spoolfile</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="notmuch-functions">
+    <title>Functions</title>
+
+    <para>
+      Notmuch adds the following functions to Mutt.
+      By default, none of them are bound to keys.
+    </para>
+
+    <table id="table-notmuch-functions">
+      <title>Notmuch Functions</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Menus</entry>
+            <entry>Function</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;change-vfolder&gt;</literal></entry>
+            <entry>open a different virtual folder</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;entire-thread&gt;</literal></entry>
+            <entry>read entire thread of the current message</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;modify-labels&gt;</literal></entry>
+            <entry>modify (notmuch) tags</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;modify-labels-then-hide&gt;</literal></entry>
+            <entry>modify labels and then hide message</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-toggle-virtual&gt;</literal></entry>
+            <entry>toggle between mailboxes and virtual mailboxes</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;vfolder-from-query&gt;</literal></entry>
+            <entry>generate virtual folder from query</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="notmuch-commands">
+    <title>Commands</title>
+    <cmdsynopsis>
+
+      <command>virtual-mailboxes</command>
+      <arg choice="plain">
+        <replaceable class="parameter">description</replaceable>
+        <arg choice="plain">
+          <replaceable class="parameter">notmuch-URI</replaceable>
+        </arg>
+      </arg>
+      <group choice="req" rep="repeat">
+        <arg choice="plain">
+          <replaceable class="parameter">description</replaceable>
+          <arg choice="plain">
+            <replaceable class="parameter">notmuch-URI</replaceable>
+          </arg>
+        </arg>
+      </group>
+
+      <command>tag-transforms</command>
+      <arg choice="plain">
+        <replaceable class="parameter">tag</replaceable>
+        <arg choice="plain">
+          <replaceable class="parameter">transformed-string</replaceable>
+        </arg>
+      </arg>
+      <group choice="req" rep="repeat">
+        <arg choice="plain">
+          <replaceable class="parameter">tag</replaceable>
+          <arg choice="plain">
+            <replaceable class="parameter">transformed-string</replaceable>
+          </arg>
+        </arg>
+      </group>
+
+      <command>tag-formats</command>
+      <arg choice="plain">
+        <replaceable class="parameter">tag</replaceable>
+        <arg choice="plain">
+          <replaceable class="parameter">format-string</replaceable>
+        </arg>
+      </arg>
+      <group choice="req" rep="repeat">
+        <arg choice="plain">
+          <replaceable class="parameter">tag</replaceable>
+          <arg choice="plain">
+            <replaceable class="parameter">format-string</replaceable>
+          </arg>
+        </arg>
+      </group>
+
+    </cmdsynopsis>
+  </sect2>
+
+  <sect2 id="notmuch-colors">
+    <title>Colors</title>
+
+    <para>Adds these to index-color patch:</para>
+
+    <table id="table-notmuch-colors">
+      <title>Index Colors</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Object</entry>
+            <entry>Pattern</entry>
+            <entry>Highlights</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>index_tag</literal></entry>
+            <entry>yes</entry>
+            <entry>an individual message tag, %G, uses tag name</entry>
+          </row>
+          <row>
+            <entry><literal>index_tags</literal></entry>
+            <entry>no</entry>
+            <entry>the transformed message tags, %g</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="notmuch-muttrc">
+    <title>Muttrc</title>
+
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the notmuch feature.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# This variable specifies notmuch query limit.</emphasis>
+set nm_db_limit = 0
+
+<emphasis role="comment"># This variable specifies the default Notmuch database in format:
+# notmuch://&lt;absolute path&gt;</emphasis>
+set nm_default_uri = &quot;&quot;
+
+<emphasis role="comment"># The messages tagged with these tags are excluded and not loaded
+# from notmuch DB to mutt unless specified explicitly.</emphasis>
+set nm_exclude_tags = &quot;&quot;
+
+<emphasis role="comment"># This variable specifies private notmuch tags which should not be printed
+# on screen (index, pager).</emphasis>
+set nm_hidden_tags = &quot;unread,draft,flagged,passed,replied,attachment,signed,encrypted&quot;
+
+<emphasis role="comment"># This option specifies timeout for Notmuch database. Default is 5 seconds.</emphasis>
+set nm_open_timeout = 5
+
+<emphasis role="comment"># This variable specifies notmuch query type, supported types: 'threads' and
+# 'messages'.</emphasis>
+set nm_query_type = messages
+
+<emphasis role="comment"># Add messages stored to the mutt record (see $record in the mutt docs)
+# also to notmuch DB.</emphasis>
+set nm_record = no
+
+<emphasis role="comment"># Tags that should be removed or added to the to the messages stored in the mutt record.</emphasis>
+set nm_record_tags = &quot;&quot;
+
+<emphasis role="comment"># This variable specifies notmuch tag which is used for unread messages.</emphasis>
+set nm_unread_tag = unread
+
+<emphasis role="comment"># This variable allows you to customize the file browser display for virtual
+# folders to your personal taste.</emphasis>
+set vfolder_format = &quot;%6n(%6N) %f&quot;
+
+<emphasis role="comment"># When set, mutt will use the first virtual mailbox (see virtual-mailboxes)
+# as a spoolfile.</emphasis>
+set virtual_spoolfile = no
+
+<emphasis role="comment"># --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# open a different virtual folder</emphasis>
+bind index,pager X change-vfolder
+
+<emphasis role="comment"># read entire thread of the current message</emphasis>
+bind index,pager + entire-thread
+
+<emphasis role="comment"># modify (notmuch) tags</emphasis>
+bind index,pager \` modify-labels
+
+<emphasis role="comment"># generate virtual folder from query</emphasis>
+bind index,pager \eX vfolder-from-query
+
+<emphasis role="comment"># modify labels and then hide message
+# bind index,pager ??? modify-labels-then-hide
+
+# toggle between mailboxes and virtual mailboxes
+# bind index,pager ??? sidebar-toggle-virtual
+
+# --------------------------------------------------------------------------
+# COMMANDS - shown with an example
+# --------------------------------------------------------------------------
+
+# virtual-mailboxes description notmuch-URI { description notmuch-URI ...}
+# virtual-mailboxes &quot;Climbing&quot; &quot;notmuch://?query=climbing&quot;
+
+# Replace some tags with icons
+# tag-transforms tag transformed-string { tag transformed-string ...}
+# tag-transforms &quot;inbox&quot;   &quot;i&quot;   \
+#                &quot;unread&quot;  &quot;u&quot;   \
+#                &quot;replied&quot; &quot;↻ &quot;  \
+#                &quot;sent&quot;    &quot;➥ &quot;  \
+#                &quot;todo&quot;    &quot;T&quot;   \
+#                &quot;deleted&quot; &quot;DEL&quot; \
+#                &quot;invites&quot; &quot;CAL&quot;
+
+# See README.notmuch for an explanation
+# tag-formats tag format-string { tag format-string ...}
+# tag-formats &quot;inbox&quot;   &quot;GI&quot; \
+#              &quot;unread&quot;  &quot;GU&quot; \
+#              &quot;replied&quot; &quot;GR&quot; \
+#              &quot;sent&quot;    &quot;GS&quot; \
+#              &quot;todo&quot;    &quot;Gt&quot; \
+#              &quot;deleted&quot; &quot;GD&quot; \
+#              &quot;invites&quot; &quot;Gi&quot;
+
+# set index_format='4C %S %[%y.%m.%d] %-18.18n %?GU?%GU&amp; ? %?GR?%GR&amp; ? %?GI?%GI&amp; ? %s'
+
+# --------------------------------------------------------------------------
+# COLORS - some unpleasant examples are given
+# --------------------------------------------------------------------------
+
+# These symbols are added to the index-color feature:
+
+# an individual message tag, %G, uses tag name
+# this symbol uses a pattern</emphasis>
+color index_tag red white &quot;inbox&quot;
+
+<emphasis role="comment"># the transformed message tags, %g
+# this symbol does not use a pattern</emphasis>
+color index_tags green default
+
+<emphasis role="comment"># --------------------------------------------------------------------------
+
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="notmuch-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="compile-time-features">Compile-Time Features</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="notmuch-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="notmuch-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Karel Zak <email>kzak@redhat.com</email></para></listitem>
+    <listitem><para>Chris Mason <email>clm@fb.com</email></para></listitem>
+    <listitem><para>Christoph Rissner <email>cri@visotech.at</email></para></listitem>
+    <listitem><para>David Riebenbauer <email>davrieb@liegesta.at</email></para></listitem>
+    <listitem><para>David Sterba <email>dsterba@suse.cz</email></para></listitem>
+    <listitem><para>David Wilson <email>dw@botanicus.net</email></para></listitem>
+    <listitem><para>Don Zickus <email>dzickus@redhat.com</email></para></listitem>
+    <listitem><para>Eric Davis <email>edavis@insanum.com</email></para></listitem>
+    <listitem><para>Jan Synacek <email>jsynacek@redhat.com</email></para></listitem>
+    <listitem><para>Jeremiah C. Foster <email>jeremiah@jeremiahfoster.com</email></para></listitem>
+    <listitem><para>Josh Poimboeuf <email>jpoimboe@redhat.com</email></para></listitem>
+    <listitem><para>Kirill A. Shutemov <email>kirill@shutemov.name</email></para></listitem>
+    <listitem><para>Luke Macken <email>lmacken@redhat.com</email></para></listitem>
+    <listitem><para>Mantas Mikulėnas <email>grawity@gmail.com</email></para></listitem>
+    <listitem><para>Patrick Brisbin <email>pbrisbin@gmail.com</email></para></listitem>
+    <listitem><para>Philippe Le Brouster <email>plb@nebkha.net</email></para></listitem>
+    <listitem><para>Raghavendra D Prabhu <email>rprabhu@wnohang.net</email></para></listitem>
+    <listitem><para>Sami Farin <email>hvtaifwkbgefbaei@gmail.com</email></para></listitem>
+    <listitem><para>Stefan Assmann <email>sassmann@kpanic.de</email></para></listitem>
+    <listitem><para>Stefan Kuhn <email>p_regius@gmx.ch</email></para></listitem>
+    <listitem><para>Tim Stoakes <email>tim@stoakes.net</email></para></listitem>
+    <listitem><para>Vladimir Marek <email>Vladimir.Marek@oracle.com</email></para></listitem>
+    <listitem><para>Víctor Manuel Jáquez Leal <email>vjaquez@igalia.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="progress">
+  <title>Progress Bar Feature</title>
+  <subtitle>Show a visual progress bar on slow operations</subtitle>
+
+  <sect2 id="progress-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>Progress Bar</quote>, look for
+      <quote>patch-progress</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="progress-intro">
+    <title>Introduction</title>
+
+        <para>
+    The <quote>progress</quote> patch shows a visual progress bar on slow
+    tasks, such as indexing a large folder over the net.
+        </para>
+  </sect2>
+
+  <sect2 id="progress-colors">
+    <title>Colors</title>
+    <table id="table-progress-colors">
+      <title>Progress Colors</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Default Color</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>progress</literal></entry>
+            <entry>default</entry>
+            <entry>Visual progress bar</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="progress-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the progress feature.
+
+# The 'progress' feature provides clear visual feedback for
+# slow tasks, such as indexing a large folder over the net.
+
+# Set the color of the progress bar
+# White text on a red background</emphasis>
+color progress white red
+
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="progress-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="color">Color command</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="progress-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="progress-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Rocco Rutte <email>pdmef@gmx.net</email></para></listitem>
+    <listitem><para>Vincent Lefevre <email>vincent@vinc17.org</email></para></listitem>
+    <listitem><para>Stefan Kuhn <email>wuodan@hispeed.ch</email></para></listitem>
+    <listitem><para>Karel Zak <email>kzak@redhat.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="quasi-delete">
+  <title>Quasi-Delete Feature</title>
+  <subtitle>Mark emails that should be hidden, but not deleted</subtitle>
+
+  <sect2 id="quasi-delete-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>Quasi-Delete</quote>, look for
+      <quote>patch-quasi-delete</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="quasi-delete-intro">
+    <title>Introduction</title>
+
+    <para>
+    The <quote>quasi-delete</quote> function marks an email that should be
+    hidden from the index, but NOT deleted.
+    </para>
+
+    <para>
+    On its own, this feature isn't very useful.  It forms a useful part of
+    the notmuch plugin.
+    </para>
+  </sect2>
+
+  <sect2 id="quasi-delete-functions">
+    <title>Functions</title>
+    <table id="table-quasi-delete-functions">
+      <title>Quasi-Delete Functions</title>
+      <tgroup cols="4">
+        <thead>
+          <row>
+            <entry>Menus</entry>
+            <entry>Default Key</entry>
+            <entry>Function</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>index,pager</entry>
+            <entry>(none)</entry>
+            <entry><literal>&lt;quasi-delete&gt;</literal></entry>
+            <entry>delete from mutt, don't touch on disk</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="quasi-delete-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the quasi-delete feature.
+
+# The 'quasi-delete' function marks an email that should be hidden
+# from the index, but NOT deleted.</emphasis>
+bind index,pager Q quasi-delete
+
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="quasi-delete-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="notmuch">notmuch patch</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="quasi-delete-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="quasi-delete-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Karel Zak <email>kzak@redhat.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="reply-with-xorig-patch">
+  <title>Reply With X-Original-To Feature</title>
+  <subtitle>Adds a configuration variable to allow direct reply to a mail using X-Original-To header
+      as a From: in the answer.
+  </subtitle>
+
+  <sect2 id="reply-with-xorig-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>Reply With X-Original-To</quote>, look for
+      <quote>patch-reply-with-xorig</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="reply-with-xorig-intro">
+    <title>Introduction</title>
+
+    <para>
+        Adds a reply_with_xorig for mutt configuration files. If enabled,
+        allows to reply to an email using the email address in the first X-Original-To:
+        header of a mail as the From: header of the answer.
+    </para>
+  </sect2>
+
+  <sect2 id="reply-with-xorig-variables">
+    <title>Variables</title>
+
+    <table id="table-reply-with-xorig-variables">
+      <title>Reply With X-Original-To Variables</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>reply_with_xorig</literal></entry>
+            <entry>Boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="reply-with-xorig-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the reply-with-xorig feature.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# Use X-Original-To header to reply when reverse is disabled or no alternate
+# is found.</emphasis>
+set reply_with_xorig = &quot;yes&quot;
+
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="reply-with-xorig-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Pierre-Elliott Bécue <email>becue@crans.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="sensible-browser">
+  <title>Sensible-Browser Feature</title>
+  <subtitle>Make the file browser behave</subtitle>
+
+  <sect2 id="sensible-browser-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>sensible-browser</quote>, look for
+      <quote>patch-sensible-browser</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="sensible-browser-intro">
+    <title>Introduction</title>
+
+    <para>
+      The <quote>sensible browser</quote> is a set of small changes to NeoMutt's
+      mailbox browser which make the browser behave in a more predictable way.
+    </para>
+
+    <para>
+      The behavior is divided into two use cases: Fixed Order; Variable Order.
+    </para>
+
+    <sect3 id="sensible-browser-sort-fixed">
+      <title>A Fixed Order of Mailboxes</title>
+
+      <para>
+        This is for users who like their mailboxes in a fixed order, e.g.
+        alphabetical, or unsorted (in the order of the config file).
+      </para>
+
+<screen>
+<emphasis role="comment"># Fixed order</emphasis>
+set sort_browser="alpha"
+set sort_browser="unsorted"
+</screen>
+
+      <para>
+        When you first start the browser, e.g. <literal>c?</literal> your current
+        mailbox will be highlighted.
+      </para>
+
+      <para>
+        When you navigate to a parent mailbox (<quote>..</quote>) your old mailbox
+        will be highlighted.
+      </para>
+
+      <para>
+        <quote>..</quote> will always be listed at the top, however the rest of
+        the list is sorted.
+      </para>
+
+    </sect3>
+
+    <sect3 id="sensible-browser-sort-variable">
+      <title>A Variable Order of Mailboxes</title>
+
+      <para>
+        This is for users who like their mailboxes sorted by a characteristic
+        that changes, e.g. count of new mail, or the size of mailbox.
+      </para>
+
+<screen>
+<emphasis role="comment"># Variable order</emphasis>
+set sort_browser="reverse-count"
+set sort_browser="reverse-size"
+</screen>
+
+      <para>
+        When you first start the browser, e.g. <literal>c?</literal> the
+        highlight will be on the first mailbox, e.g. the one with the most new
+        mail.
+      </para>
+
+      <para>
+        When you navigate to a parent mailbox (<quote>..</quote>) your old mailbox
+        will be highlighted.
+      </para>
+
+      <para>
+        <quote>..</quote> will always be listed at the top, however the rest of
+        the list is sorted.
+      </para>
+
+    </sect3>
+
+  </sect2>
+
+  <sect2 id="sensible-browser-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="folder-format">$folder_format</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="sensible-browser-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="sensible-browser-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Pierre-Elliott Bécue <email>becue@crans.org</email></para></listitem>
+    <listitem><para>Haakon Riiser <email>haakon.riiser@fys.uio.no</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="sidebar">
+  <title>Sidebar Feature</title>
+  <subtitle>Overview of mailboxes</subtitle>
+
+  <sect2 id="sidebar-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>Sidebar</quote>, look for
+      <quote>+USE_SIDEBAR</quote> in the version info.
+      See: <xref linkend="compile-time-features"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="sidebar-intro">
+    <title>Introduction</title>
+
+    <para>
+      The Sidebar shows a list of all your mailboxes.  The list can be
+      turned on and off, it can be themed and the list style can be
+      configured.
+    </para>
+
+    <para>
+      This part of the manual is a reference guide.
+      If you want a simple introduction with examples see the
+      <link linkend="intro-sidebar">Sidebar Howto</link>.
+      If you just want to get started, you could use the sample
+      <link linkend="sidebar-muttrc">Sidebar muttrc</link>.
+    </para>
+  </sect2>
+
+  <sect2 id="sidebar-variables">
+    <title>Variables</title>
+
+    <table id="table-sidebar-variables">
+      <title>Sidebar Variables</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>sidebar_delim_chars</literal></entry>
+            <entry>string</entry>
+            <entry><literal>/.</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_divider_char</literal></entry>
+            <entry>string</entry>
+            <entry><literal>|</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_folder_indent</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_format</literal></entry>
+            <entry>string</entry>
+            <entry><literal>%B%*  %n</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_indent_string</literal></entry>
+            <entry>string</entry>
+            <entry><literal>&nbsp;&nbsp;</literal> (two spaces)</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_new_mail_only</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_next_new_wrap</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_on_right</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_short_path</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_sort_method</literal></entry>
+            <entry>enum</entry>
+            <entry><literal>unsorted</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_visible</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_width</literal></entry>
+            <entry>number</entry>
+            <entry><literal>20</literal></entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  <para>
+    For more details, and examples, about the <literal>$sidebar_format</literal>,
+    see the <link linkend="intro-sidebar-format">Sidebar Intro</link>.
+  </para>
+
+  </sect2>
+
+  <sect2 id="sidebar-functions">
+    <title>Functions</title>
+
+    <para>
+      Sidebar adds the following functions to Mutt.
+      By default, none of them are bound to keys.
+    </para>
+
+    <table id="table-sidebar-functions">
+      <title>Sidebar Functions</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Menus</entry>
+            <entry>Function</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-next&gt;</literal></entry>
+            <entry>Move the highlight to next mailbox</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-next-new&gt;</literal></entry>
+            <entry>Move the highlight to next mailbox with new mail</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-open&gt;</literal></entry>
+            <entry>Open highlighted mailbox</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-page-down&gt;</literal></entry>
+            <entry>Scroll the Sidebar down 1 page</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-page-up&gt;</literal></entry>
+            <entry>Scroll the Sidebar up 1 page</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-prev&gt;</literal></entry>
+            <entry>Move the highlight to previous mailbox</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-prev-new&gt;</literal></entry>
+            <entry>Move the highlight to previous mailbox with new mail</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-toggle-visible&gt;</literal></entry>
+            <entry>Make the Sidebar (in)visible</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="sidebar-commands">
+    <title>Commands</title>
+    <cmdsynopsis>
+      <command>sidebar_whitelist<anchor id="sidebar-whitelist"/></command>
+      <arg choice="plain">
+        <replaceable class="parameter">mailbox</replaceable>
+      </arg>
+      <arg choice="opt" rep="repeat">
+        <replaceable class="parameter">mailbox</replaceable>
+      </arg>
+
+      <command>unsidebar_whitelist<anchor id="unsidebar-whitelist"/></command>
+      <arg choice="plain">
+	<replaceable class="parameter">*</replaceable>
+      </arg>
+      <arg choice="plain" rep="repeat">
+	<replaceable class="parameter">mailbox</replaceable>
+      </arg>
+    </cmdsynopsis>
+
+    <para>
+      This command specifies mailboxes that will always be displayed
+      in the sidebar, even if <link
+      linkend="sidebar-new-mail-only">$sidebar_new_mail_only</link>
+      is set and the mailbox does not contain new mail.
+    </para>
+
+    <para>
+      The <quote>unsidebar_whitelist</quote> command is used to remove a mailbox from
+      the list of whitelisted mailboxes. Use <quote>unsidebar_whitelist *</quote>
+      to remove all mailboxes.
+    </para>
+  </sect2>
+
+  <sect2 id="sidebar-colors">
+    <title>Colors</title>
+
+    <table id="table-sidebar-colors">
+      <title>Sidebar Colors</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Default Color</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>sidebar_divider</literal></entry>
+            <entry>default</entry>
+            <entry>The dividing line between the Sidebar and the Index/Pager panels</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_flagged</literal></entry>
+            <entry>default</entry>
+            <entry>Mailboxes containing flagged mail</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_highlight</literal></entry>
+            <entry>underline</entry>
+            <entry>Cursor to select a mailbox</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_indicator</literal></entry>
+            <entry>mutt <literal>indicator</literal></entry>
+            <entry>The mailbox open in the Index panel</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_new</literal></entry>
+            <entry>default</entry>
+            <entry>Mailboxes containing new mail</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_ordinary</literal></entry>
+            <entry>default</entry>
+            <entry>Mailboxes that have no new/flagged mails, etc</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_spoolfile</literal></entry>
+            <entry>default</entry>
+            <entry>Mailbox that receives incoming mail</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+
+    <para>
+    If the <literal>sidebar_indicator</literal> color isn't set, then the default Mutt
+    indicator color will be used (the color used in the index panel).
+    </para>
+  </sect2>
+
+  <sect2 id="sidebar-sort">
+    <title>Sort</title>
+
+    <table id="table-sidebar-sort">
+      <title>Sidebar Sort</title>
+      <tgroup cols="2">
+        <thead>
+          <row>
+            <entry>Sort</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>alpha</literal></entry>
+            <entry>Alphabetically by path</entry>
+          </row>
+          <row>
+            <entry><literal>count</literal></entry>
+            <entry>Total number of messages</entry>
+          </row>
+          <row>
+            <entry><literal>flagged</literal></entry>
+            <entry>Number of flagged messages</entry>
+          </row>
+          <row>
+            <entry><literal>name</literal></entry>
+            <entry>Alphabetically by path</entry>
+          </row>
+          <row>
+            <entry><literal>new</literal></entry>
+            <entry>Number of new messages</entry>
+          </row>
+          <row>
+            <entry><literal>path</literal></entry>
+            <entry>Alphabetically by path</entry>
+          </row>
+          <row>
+            <entry><literal>unsorted</literal></entry>
+            <entry>Order of the <literal>mailboxes</literal> command</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="sidebar-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the sidebar feature.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# Should the Sidebar be shown?</emphasis>
+set sidebar_visible = no
+
+<emphasis role="comment"># How wide should the Sidebar be in screen columns?
+# Note: Some characters, e.g. Chinese, take up two columns each.</emphasis>
+set sidebar_width = 20
+
+<emphasis role="comment"># Should the mailbox paths be abbreviated?</emphasis>
+set sidebar_short_path = no
+
+<emphasis role="comment"># When abbreviating mailbox path names, use any of these characters as path
+# separators.  Only the part after the last separators will be shown.
+# For file folders '/' is good.  For IMAP folders, often '.' is useful.</emphasis>
+set sidebar_delim_chars = '/.'
+
+<emphasis role="comment"># If the mailbox path is abbreviated, should it be indented?</emphasis>
+set sidebar_folder_indent = no
+
+<emphasis role="comment"># Indent mailbox paths with this string.</emphasis>
+set sidebar_indent_string = '  '
+
+<emphasis role="comment"># Make the Sidebar only display mailboxes that contain new, or flagged,
+# mail.</emphasis>
+set sidebar_new_mail_only = no
+
+<emphasis role="comment"># Any mailboxes that are whitelisted will always be visible, even if the
+# sidebar_new_mail_only option is enabled.</emphasis>
+sidebar_whitelist '/home/user/mailbox1'
+sidebar_whitelist '/home/user/mailbox2'
+
+<emphasis role="comment"># When searching for mailboxes containing new mail, should the search wrap
+# around when it reaches the end of the list?</emphasis>
+set sidebar_next_new_wrap = no
+
+<emphasis role="comment"># Show the Sidebar on the right-hand side of the screen</emphasis>
+set sidebar_on_right = no
+
+<emphasis role="comment"># The character to use as the divider between the Sidebar and the other Mutt
+# panels.
+# Note: Only the first character of this string is used.</emphasis>
+set sidebar_divider_char = '|'
+
+<emphasis role="comment"># Enable extended buffy mode to calculate total, new, and flagged
+# message counts for each mailbox.</emphasis>
+set mail_check_stats
+
+<emphasis role="comment"># Display the Sidebar mailboxes using this format string.</emphasis>
+set sidebar_format = '%B%?F? [%F]?%* %?N?%N/?%S'
+
+<emphasis role="comment"># Sort the mailboxes in the Sidebar using this method:
+#       count    - total number of messages
+#       flagged  - number of flagged messages
+#       new      - number of new messages
+#       path     - mailbox path
+#       unsorted - do not sort the mailboxes</emphasis>
+set sidebar_sort_method = 'unsorted'
+
+<emphasis role="comment"># --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# Move the highlight to the previous mailbox</emphasis>
+bind index,pager \Cp sidebar-prev
+
+<emphasis role="comment"># Move the highlight to the next mailbox</emphasis>
+bind index,pager \Cn sidebar-next
+
+<emphasis role="comment"># Open the highlighted mailbox</emphasis>
+bind index,pager \Co sidebar-open
+
+<emphasis role="comment"># Move the highlight to the previous page
+# This is useful if you have a LOT of mailboxes.</emphasis>
+bind index,pager &lt;F3&gt; sidebar-page-up
+
+<emphasis role="comment"># Move the highlight to the next page
+# This is useful if you have a LOT of mailboxes.</emphasis>
+bind index,pager &lt;F4&gt; sidebar-page-down
+
+<emphasis role="comment"># Move the highlight to the previous mailbox containing new, or flagged,
+# mail.</emphasis>
+bind index,pager &lt;F5&gt; sidebar-prev-new
+
+<emphasis role="comment"># Move the highlight to the next mailbox containing new, or flagged, mail.</emphasis>
+bind index,pager &lt;F6&gt; sidebar-next-new
+
+<emphasis role="comment"># Toggle the visibility of the Sidebar.</emphasis>
+bind index,pager B sidebar-toggle-visible
+
+<emphasis role="comment"># --------------------------------------------------------------------------
+# COLORS - some unpleasant examples are given
+# --------------------------------------------------------------------------
+# Note: All color operations are of the form:
+#       color OBJECT FOREGROUND BACKGROUND
+
+# Color of the current, open, mailbox
+# Note: This is a general Mutt option which colors all selected items.</emphasis>
+color indicator cyan black
+
+<emphasis role="comment"># Color of the highlighted, but not open, mailbox.</emphasis>
+color sidebar_highlight black color8
+
+<emphasis role="comment"># Color of the divider separating the Sidebar from Mutt panels</emphasis>
+color sidebar_divider color8 black
+
+<emphasis role="comment"># Color to give mailboxes containing flagged mail</emphasis>
+color sidebar_flagged red black
+
+<emphasis role="comment"># Color to give mailboxes containing new mail</emphasis>
+color sidebar_new green black
+
+<emphasis role="comment"># Color to give mailboxes containing no new/flagged mail, etc</emphasis>
+color sidebar_ordinary color245 default
+
+<emphasis role="comment"># --------------------------------------------------------------------------
+
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="sidebar-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><link linkend="regexp">Regular Expressions</link></para></listitem>
+      <listitem><para><link linkend="patterns">Patterns</link></para></listitem>
+      <listitem><para><link linkend="color">Color command</link></para></listitem>
+      <listitem><para><link linkend="notmuch">notmuch patch</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="sidebar-known-bugs">
+    <title>Known Bugs</title>
+    <para>
+      None
+    </para>
+  </sect2>
 
-    <table id="table-sidebar-colors">
-      <title>Sidebar Colors</title>
+  <sect2 id="sidebar-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Justin Hibbits <email>jrh29@po.cwru.edu</email></para></listitem>
+    <listitem><para>Thomer M. Gil <email>mutt@thomer.com</email></para></listitem>
+    <listitem><para>David Sterba <email>dsterba@suse.cz</email></para></listitem>
+    <listitem><para>Evgeni Golov <email>evgeni@debian.org</email></para></listitem>
+    <listitem><para>Fabian Groffen <email>grobian@gentoo.org</email></para></listitem>
+    <listitem><para>Jason DeTiberus <email>jdetiber@redhat.com</email></para></listitem>
+    <listitem><para>Stefan Assmann <email>sassmann@kpanic.de</email></para></listitem>
+    <listitem><para>Steve Kemp <email>steve@steve.org.uk</email></para></listitem>
+    <listitem><para>Terry Chan <email>tchan@lunar-linux.org</email></para></listitem>
+    <listitem><para>Tyler Earnest <email>tylere@rne.st</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="skip-quoted-patch">
+  <title>Skip-Quoted Feature</title>
+  <subtitle>Leave some context visible</subtitle>
+
+  <sect2 id="skip-quoted-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>skip-quoted</quote>, look for
+      <quote>patch-skip-quoted</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="skip-quoted-intro">
+    <title>Introduction</title>
+
+    <para>
+      When viewing an email, the
+      <literal>&lt;skip-to-quoted&gt;</literal> function (by default the
+      <literal>S</literal> key) will scroll past any quoted text.
+      Sometimes, a little context is useful.
+    </para>
+
+    <para>
+      By setting the <literal>$skip_quoted_offset</literal> variable, you
+      can select how much of the quoted text is left visible.
+    </para>
+  </sect2>
+
+  <sect2 id="skip-quoted-variables">
+    <title>Variables</title>
+    <table id="table-skip-quoted-variables">
+      <title>Skip-Quoted Variables</title>
       <tgroup cols="3">
-	<thead>
-	  <row>
-	    <entry>Name</entry>
-	    <entry>Default Color</entry>
-	    <entry>Description</entry>
-	  </row>
-	</thead>
-	<tbody>
-	  <row>
-	    <entry><literal>sidebar_divider</literal></entry>
-	    <entry>default</entry>
-	    <entry>The dividing line between the Sidebar and the Index/Pager panels</entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_flagged</literal></entry>
-	    <entry>default</entry>
-	    <entry>Mailboxes containing flagged mail</entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_highlight</literal></entry>
-	    <entry>underline</entry>
-	    <entry>Cursor to select a mailbox</entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_indicator</literal></entry>
-	    <entry>mutt <literal>indicator</literal></entry>
-	    <entry>The mailbox open in the Index panel</entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_new</literal></entry>
-	    <entry>default</entry>
-	    <entry>Mailboxes containing new mail</entry>
-	  </row>
-	  <row>
-	    <entry><literal>sidebar_spoolfile</literal></entry>
-	    <entry>default</entry>
-	    <entry>Mailbox that receives incoming mail</entry>
-	  </row>
-	</tbody>
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>skip_quoted_offset</literal></entry>
+            <entry>number</entry>
+            <entry>0</entry>
+          </row>
+        </tbody>
       </tgroup>
     </table>
+  </sect2>
+
+  <sect2 id="skip-quoted-muttrc">
+    <title>Muttrc</title>
+
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the skip-quoted feature.
+
+# The 'S' (skip-quoted) command scrolls the pager past the quoted text (usually
+# indented with '&gt; '.  Setting 'skip_quoted_offset' leaves some lines of quoted
+# text on screen for context.
+
+# Show three quoted lines before the reply</emphasis>
+set skip_quoted_offset = 3
+
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="skip-quoted-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="skip-quoted-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="skip-quoted-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>David Sterba <email>dsterba@suse.cz</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="status-color">
+  <title>Status Color Feature</title>
+  <subtitle>Custom rules for theming the status bar</subtitle>
+
+  <sect2 id="status-color-support">
+    <title>Support</title>
 
     <para>
-    If the <literal>sidebar_indicator</literal> color isn't set, then the default Mutt
-    indicator color will be used (the color used in the index panel).
+      To check if NeoMutt supports <quote>Status Color</quote>, look for
+      <quote>patch-status-color</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
     </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
   </sect2>
 
-  <sect2 id="sidebar-sort">
-    <title>Sort</title>
+  <sect2 id="status-color-intro">
+    <title>Introduction</title>
 
-    <table id="table-sidebar-sort">
-      <title>Sidebar Sort</title>
-      <tgroup cols="2">
-	<thead>
-	  <row>
-	    <entry>Sort</entry>
-	    <entry>Description</entry>
-	  </row>
-	</thead>
-	<tbody>
-	  <row>
-	    <entry><literal>alpha</literal></entry>
-	    <entry>Alphabetically by path</entry>
-	  </row>
-	  <row>
-	    <entry><literal>count</literal></entry>
-	    <entry>Total number of messages</entry>
-	  </row>
-	  <row>
-	    <entry><literal>flagged</literal></entry>
-	    <entry>Number of flagged messages</entry>
-	  </row>
-	  <row>
-	    <entry><literal>name</literal></entry>
-	    <entry>Alphabetically by path</entry>
-	  </row>
-	  <row>
-	    <entry><literal>new</literal></entry>
-	    <entry>Number of new messages</entry>
-	  </row>
-	  <row>
-	    <entry><literal>path</literal></entry>
-	    <entry>Alphabetically by path</entry>
-	  </row>
-	  <row>
-	    <entry><literal>unsorted</literal></entry>
-	    <entry>Do not resort the paths</entry>
-	  </row>
-	</tbody>
+        <para>
+    The <quote>status-color</quote> patch allows you to theme different
+    parts of the status bar (also when it's used by the index).
+        </para>
+
+        <para>
+    Unlike normal color commands, <literal>color status</literal> can now
+    take up to 2 extra parameters (regex, num).
+        </para>
+  </sect2>
+
+  <sect2 id="status-color-commands">
+    <title>Commands</title>
+    <cmdsynopsis>
+      <command>color</command>
+      <arg choice="plain">
+        <option>status</option>
+      </arg>
+      <arg choice="plain">
+        <replaceable class="parameter">foreground</replaceable>
+      </arg>
+      <arg choice="plain">
+        <replaceable class="parameter">background</replaceable>
+      </arg>
+      <group choice="opt">
+        <arg choice="plain">
+          <replaceable class="parameter">regex</replaceable>
+        </arg>
+        <group choice="opt">
+          <arg choice="plain">
+            <replaceable class="parameter">num</replaceable>
+          </arg>
+        </group>
+      </group>
+    </cmdsynopsis>
+
+    <para>
+      With zero parameters, Mutt will set the default color for the entire
+      status bar.
+    </para>
+
+    <para>
+      With one parameter, Mutt will only color the parts matching the
+      regex.
+    </para>
+
+    <para>
+      With two parameters, Mutt will only color the num'th sub-match of
+      the regex.
+    </para>
+  </sect2>
+
+  <sect2 id="status-color-colors">
+    <title>Colors</title>
+
+    <table id="table-status-color-colors">
+      <title>Status Colors</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Default Color</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>status</entry>
+            <entry><literal>reverse</literal></entry>
+            <entry>Status bar</entry>
+          </row>
+        </tbody>
       </tgroup>
     </table>
   </sect2>
 
+  <sect2 id="status-color-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the status-color feature.
+
+# The 'status-color' feature allows you to theme different parts of
+# the status bar (also when it's used by the index).
 
-  <sect2 id="sidebar-see-also">
+# For the examples below, set some defaults</emphasis>
+set status_format='-%r-Mutt: %f [Msgs:%?M?%M/?%m%?n? New:%n?%?o? Old:%o?%?d? Del:%d?%?F? Flag:%F?%?t? Tag:%t?%?p? Post:%p?%?b? Inc:%b?%?l? %l?]---(%s/%S)-%&gt;-(%P)---'
+set index_format='%4C %Z %{%b %d} %-15.15L (%?l?%4l&amp;%4c?) %s'
+set sort=threads
+set sort_aux=last-date-received
+
+<emphasis role="comment"># 'status color' can take up to 2 extra parameters
+
+# color status foreground background [ regex [ num ]]
+
+# 0 extra parameters
+# Set the default color for the entire status line</emphasis>
+color status blue white
+
+<emphasis role="comment"># 1 extra parameter
+# Set the color for a matching pattern
+# color status foreground background regexp
+
+# Highlight New, Deleted, or Flagged emails</emphasis>
+color status brightred white '(New|Del|Flag):[0-9]+'
+
+<emphasis role="comment"># Highlight mailbox ordering if it's different from the default
+# First, highlight anything (*/*)</emphasis>
+color status brightred default '\([^)]+/[^)]+\)'
+
+<emphasis role="comment"># Then override the color for one specific case</emphasis>
+color status default   default '\(threads/last-date-received\)'
+
+<emphasis role="comment"># 2 extra parameters
+# Set the color for the nth submatch of a pattern
+# color status foreground background regexp num
+
+# Highlight the contents of the []s but not the [] themselves</emphasis>
+color status red default '\[([^]]+)\]' 1
+
+<emphasis role="comment"># The '1' refers to the first regex submatch, which is the inner
+# part in ()s
+
+# Highlight the mailbox</emphasis>
+color status brightwhite default 'Mutt: ([^ ]+)' 1
+
+<emphasis role="comment"># Search for 'Mutt: ' but only highlight what comes after it
+
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="status-color-see-also">
     <title>See Also</title>
 
     <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="compile-time-features">Compile-Time Features</link></para></listitem>
       <listitem><para><link linkend="regexp">Regular Expressions</link></para></listitem>
       <listitem><para><link linkend="patterns">Patterns</link></para></listitem>
+      <listitem><para><link linkend="index-color">index-color patch</link></para></listitem>
       <listitem><para><link linkend="color">Color command</link></para></listitem>
     </itemizedlist>
   </sect2>
+
+  <sect2 id="status-color-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="status-color-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>David Sterba <email>dsterba@suse.cz</email></para></listitem>
+    <listitem><para>Thomas Glanzmann <email>thomas@glanzmann.de</email></para></listitem>
+    <listitem><para>Kirill A. Shutemov <email>kirill@shutemov.name</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="timeout-hook">
+  <title>Timeout Feature</title>
+  <subtitle>Run a command periodically</subtitle>
+
+  <sect2 id="timeout-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>timeout</quote>, look for
+      <quote>patch-timeout</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="timeout-intro">
+    <title>Introduction</title>
+
+    <para>
+      This feature implements a new hook that is called periodically when Mutt
+      checks for new mail. This hook is called every <literal>$timeout</literal> seconds.
+    </para>
+  </sect2>
+
+  <sect2 id="timeout-commands">
+    <title>Commands</title>
+    <cmdsynopsis>
+      <command>timeout-hook</command>
+      <arg choice="plain">
+        <replaceable class="parameter">.</replaceable>
+      </arg>
+      <arg choice="plain">
+        <replaceable class="parameter">MUTT-COMMAND</replaceable>
+      </arg>
+    </cmdsynopsis>
+  </sect2>
+
+  <sect2 id="timeout-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># Example NeoMutt config file for the timeout feature.
+
+# --------------------------------------------------------------------------
+# COMMANDS - shown with an example arguments
+# --------------------------------------------------------------------------
+
+# After $timeout seconds of inactivity, run this mutt command</emphasis>
+timeout-hook . 'exec sync-mailbox'
+
+<emphasis role="comment"># vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="timeout-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="timeout">$timeout</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="timeout-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="timeout-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Armin Wolfermann <email>armin@wolfermann.org</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
+<sect1 id="tls-sni">
+  <title>TLS-SNI Feature</title>
+  <subtitle>Negotiate with a server for a TSL/SSL certificate</subtitle>
+
+  <sect2 id="tls-sni-support">
+    <title>Support</title>
+
+    <para>
+      To check if NeoMutt supports <quote>TLS-SNI</quote>, look for
+      <quote>patch-tls-sni</quote> in the version info.
+      See: <xref linkend="mutt-patches"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.7.0</para></listitem>
+      <listitem><para>OpenSSL</para></listitem>
+    </itemizedlist>
+
+    <para>This feature is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="tls-sni-intro">
+    <title>Introduction</title>
+
+    <para>
+    The <quote>TLS-SNI</quote> patch adds support for TLS virtual hosting.
+    If your mail server doesn't support this everything will still work
+    normally.
+    </para>
+
+    <para>
+    TLS supports sending the expected server hostname during the
+    handshake, via the SNI extension.  This can be used to select a
+    server certificate to issue to the client, permitting
+    virtual-hosting without requiring multiple IP addresses.
+    </para>
+
+    <para>
+    This has been tested against Exim 4.80, which optionally logs SNI
+    and can perform vhosting.
+    </para>
+
+    <para>
+    To verify TLS SNI support by a server, you can use:
+    </para>
+
+<screen>
+openssl s_client -host &lt;imap server&gt; -port &lt;port&gt; -tls1 -servername &lt;imap server&gt;
+</screen>
+  </sect2>
+
+  <sect2 id="tls-sni-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="tls-sni-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="tls-sni-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Jeremy Katz <email>katzj@linuxpower.org</email></para></listitem>
+    <listitem><para>Phil Pennock <email>mutt-dev@spodhuis.demon.nl</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
 </sect1>
 
 </chapter>
@@ -8953,6 +14373,18 @@ <sect1 id="commands">
 
 <listitem>
 <cmdsynopsis>
+<command><link linkend="append-hook">append-hook</link></command>
+<arg choice="plain">
+<replaceable class="parameter">pattern</replaceable>
+</arg>
+<arg choice="plain">
+<replaceable class="parameter">shell-command</replaceable>
+</arg>
+</cmdsynopsis>
+</listitem>
+
+<listitem>
+<cmdsynopsis>
 <command><link linkend="auto-view">auto_view</link></command>
 <arg choice="plain">
 <replaceable>mimetype</replaceable>
@@ -9014,6 +14446,18 @@ <sect1 id="commands">
 
 <listitem>
 <cmdsynopsis>
+<command><link linkend="close-hook">close-hook</link></command>
+<arg choice="plain">
+<replaceable class="parameter">pattern</replaceable>
+</arg>
+<arg choice="plain">
+<replaceable class="parameter">shell-command</replaceable>
+</arg>
+</cmdsynopsis>
+</listitem>
+
+<listitem>
+<cmdsynopsis>
 <command><link linkend="color">color</link></command>
 <arg choice="plain">
 <replaceable class="parameter">object</replaceable>
@@ -9083,6 +14527,18 @@ <sect1 id="commands">
 
 <listitem>
 <cmdsynopsis>
+<command><link linkend="open-hook">open-hook</link></command>
+<arg choice="plain">
+<replaceable class="parameter">pattern</replaceable>
+</arg>
+<arg choice="plain">
+<replaceable class="parameter">shell-command</replaceable>
+</arg>
+</cmdsynopsis>
+</listitem>
+
+<listitem>
+<cmdsynopsis>
 <command><link linkend="crypt-hook">crypt-hook</link></command>
 <arg choice="plain">
 <replaceable class="parameter">regexp</replaceable>
@@ -9204,6 +14660,18 @@ <sect1 id="commands">
 
 <listitem>
 <cmdsynopsis>
+<command>ifdef</command>
+<arg choice="plain">
+<replaceable class="parameter">item</replaceable>
+</arg>
+<arg choice="plain">
+<replaceable class="parameter">"config-command [args]"</replaceable>
+</arg>
+</cmdsynopsis>
+</listitem>
+
+<listitem>
+<cmdsynopsis>
 <command><link linkend="ignore">ignore</link></command>
 <arg choice="plain">
 <replaceable class="parameter">pattern</replaceable>
@@ -9569,13 +15037,24 @@ <sect1 id="commands">
 <cmdsynopsis>
 <command><link linkend="sidebar-whitelist">sidebar_whitelist</link></command>
 <arg choice="plain">
-<replaceable class="parameter">item</replaceable>
+<replaceable class="parameter">mailbox</replaceable>
 </arg>
+<arg choice="opt" rep="repeat">
+<replaceable class="parameter">mailbox</replaceable>
+</arg>
+
+<command><link linkend="unsidebar-whitelist">unsidebar_whitelist</link></command>
+<group choice="req">
 <arg choice="plain">
-<replaceable class="parameter">command</replaceable>
+<replaceable class="parameter">*</replaceable>
+</arg>
+<arg choice="plain" rep="repeat">
+<replaceable class="parameter">mailbox</replaceable>
 </arg>
+</group>
 </cmdsynopsis>
 </listitem>
+
 <listitem>
 <cmdsynopsis>
 <command><link linkend="source">source</link></command>
diff --git c/doc/mutt-1.7.0-syntax.vim w/doc/mutt-1.7.0-syntax.vim
new file mode 100644
index 0000000..e4395fd
--- /dev/null
+++ w/doc/mutt-1.7.0-syntax.vim
@@ -0,0 +1,781 @@
+" Vim syntax file
+" Language:	Mutt setup files
+" Original:	Preben 'Peppe' Guldberg <peppe-vim@wielders.org>
+" Maintainer:	Kyle Wheeler <kyle-muttrc.vim@memoryhole.net>
+" Last Change:	18 August 2016
+
+" This file covers mutt version 1.7.0
+
+" quit when a syntax file was already loaded
+if exists("b:current_syntax")
+  finish
+endif
+
+let s:cpo_save = &cpo
+set cpo&vim
+
+" Set the keyword characters
+setlocal isk=@,48-57,_,-
+
+" handling optional variables
+if !exists("use_mutt_sidebar")
+  let use_mutt_sidebar=0
+endif
+
+syn match muttrcComment		"^# .*$" contains=@Spell
+syn match muttrcComment		"^#[^ ].*$"
+syn match muttrcComment		"^#$"
+syn match muttrcComment		"[^\\]#.*$"lc=1
+
+" Escape sequences (back-tick and pipe goes here too)
+syn match muttrcEscape		+\\[#tnr"'Cc ]+
+syn match muttrcEscape		+[`|]+
+syn match muttrcEscape		+\\$+
+
+" The variables takes the following arguments
+"syn match  muttrcString		contained "=\s*[^ #"'`]\+"lc=1 contains=muttrcEscape
+syn region muttrcString		contained keepend start=+"+ms=e skip=+\\"+ end=+"+ contains=muttrcEscape,muttrcCommand,muttrcAction,muttrcShellString
+syn region muttrcString		contained keepend start=+'+ms=e skip=+\\'+ end=+'+ contains=muttrcEscape,muttrcCommand,muttrcAction
+syn match muttrcStringNL	contained skipwhite skipnl "\s*\\$" nextgroup=muttrcString,muttrcStringNL
+
+syn region muttrcShellString	matchgroup=muttrcEscape keepend start=+`+ skip=+\\`+ end=+`+ contains=muttrcVarStr,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcCommand
+
+syn match  muttrcRXChars	contained /[^\\][][.*?+]\+/hs=s+1
+syn match  muttrcRXChars	contained /[][|()][.*?+]*/
+syn match  muttrcRXChars	contained /['"]^/ms=s+1
+syn match  muttrcRXChars	contained /$['"]/me=e-1
+syn match  muttrcRXChars	contained /\\/
+" Why does muttrcRXString2 work with one \ when muttrcRXString requires two?
+syn region muttrcRXString	contained skipwhite start=+'+ skip=+\\'+ end=+'+ contains=muttrcRXChars
+syn region muttrcRXString	contained skipwhite start=+"+ skip=+\\"+ end=+"+ contains=muttrcRXChars
+syn region muttrcRXString	contained skipwhite start=+[^ 	"'^]+ skip=+\\\s+ end=+\s+re=e-1 contains=muttrcRXChars
+" For some reason, skip refuses to match backslashes here...
+syn region muttrcRXString	contained matchgroup=muttrcRXChars skipwhite start=+\^+ end=+[^\\]\s+re=e-1 contains=muttrcRXChars
+syn region muttrcRXString	contained matchgroup=muttrcRXChars skipwhite start=+\^+ end=+$\s+ contains=muttrcRXChars
+syn region muttrcRXString2	contained skipwhite start=+'+ skip=+\'+ end=+'+ contains=muttrcRXChars
+syn region muttrcRXString2	contained skipwhite start=+"+ skip=+\"+ end=+"+ contains=muttrcRXChars
+
+" these must be kept synchronized with muttrcRXString, but are intended for
+" muttrcRXHooks
+syn region muttrcRXHookString	contained keepend skipwhite start=+'+ skip=+\\'+ end=+'+ contains=muttrcRXString nextgroup=muttrcString,muttrcStringNL
+syn region muttrcRXHookString	contained keepend skipwhite start=+"+ skip=+\\"+ end=+"+ contains=muttrcRXString nextgroup=muttrcString,muttrcStringNL
+syn region muttrcRXHookString	contained keepend skipwhite start=+[^ 	"'^]+ skip=+\\\s+ end=+\s+re=e-1 contains=muttrcRXString nextgroup=muttrcString,muttrcStringNL
+syn region muttrcRXHookString	contained keepend skipwhite start=+\^+ end=+[^\\]\s+re=e-1 contains=muttrcRXString nextgroup=muttrcString,muttrcStringNL
+syn region muttrcRXHookString	contained keepend matchgroup=muttrcRXChars skipwhite start=+\^+ end=+$\s+ contains=muttrcRXString nextgroup=muttrcString,muttrcStringNL
+syn match muttrcRXHookStringNL contained skipwhite skipnl "\s*\\$" nextgroup=muttrcRXHookString,muttrcRXHookStringNL
+
+" these are exclusively for args lists (e.g. -rx pat pat pat ...)
+syn region muttrcRXPat		contained keepend skipwhite start=+'+ skip=+\\'+ end=+'\s*+ contains=muttrcRXString nextgroup=muttrcRXPat
+syn region muttrcRXPat		contained keepend skipwhite start=+"+ skip=+\\"+ end=+"\s*+ contains=muttrcRXString nextgroup=muttrcRXPat
+syn match muttrcRXPat		contained /[^-'"#!]\S\+/ skipwhite contains=muttrcRXChars nextgroup=muttrcRXPat
+syn match muttrcRXDef 		contained "-rx\s\+" skipwhite nextgroup=muttrcRXPat
+
+syn match muttrcSpecial		+\(['"]\)!\1+
+
+syn match muttrcSetStrAssignment contained skipwhite /=\s*\%(\\\?\$\)\?[0-9A-Za-z_-]\+/hs=s+1 nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr contains=muttrcVariable,muttrcEscapedVariable
+syn region muttrcSetStrAssignment contained skipwhite keepend start=+=\s*"+hs=s+1 end=+"+ skip=+\\"+ nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr contains=muttrcString
+syn region muttrcSetStrAssignment contained skipwhite keepend start=+=\s*'+hs=s+1 end=+'+ skip=+\\'+ nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr contains=muttrcString
+syn match muttrcSetBoolAssignment contained skipwhite /=\s*\\\?\$\w\+/hs=s+1 nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr contains=muttrcVariable,muttrcEscapedVariable
+syn match muttrcSetBoolAssignment contained skipwhite /=\s*\%(yes\|no\)/hs=s+1 nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn match muttrcSetBoolAssignment contained skipwhite /=\s*"\%(yes\|no\)"/hs=s+1 nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn match muttrcSetBoolAssignment contained skipwhite /=\s*'\%(yes\|no\)'/hs=s+1 nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn match muttrcSetQuadAssignment contained skipwhite /=\s*\\\?\$\w\+/hs=s+1 nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr contains=muttrcVariable,muttrcEscapedVariable
+syn match muttrcSetQuadAssignment contained skipwhite /=\s*\%(ask-\)\?\%(yes\|no\)/hs=s+1 nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn match muttrcSetQuadAssignment contained skipwhite /=\s*"\%(ask-\)\?\%(yes\|no\)"/hs=s+1 nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn match muttrcSetQuadAssignment contained skipwhite /=\s*'\%(ask-\)\?\%(yes\|no\)'/hs=s+1 nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn match muttrcSetNumAssignment contained skipwhite /=\s*\\\?\$\w\+/hs=s+1 nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr contains=muttrcVariable,muttrcEscapedVariable
+syn match muttrcSetNumAssignment contained skipwhite /=\s*\d\+/hs=s+1 nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn match muttrcSetNumAssignment contained skipwhite /=\s*"\d\+"/hs=s+1 nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn match muttrcSetNumAssignment contained skipwhite /=\s*'\d\+'/hs=s+1 nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+" Now catch some email addresses and headers (purified version from mail.vim)
+syn match muttrcEmail		"[a-zA-Z0-9._-]\+@[a-zA-Z0-9./-]\+"
+syn match muttrcHeader		"\<\c\%(From\|To\|C[Cc]\|B[Cc][Cc]\|Reply-To\|Subject\|Return-Path\|Received\|Date\|Replied\|Attach\)\>:\="
+
+syn match   muttrcKeySpecial	contained +\%(\\[Cc'"]\|\^\|\\[01]\d\{2}\)+
+syn match   muttrcKey		contained "\S\+"			contains=muttrcKeySpecial,muttrcKeyName
+syn region  muttrcKey		contained start=+"+ skip=+\\\\\|\\"+ end=+"+	contains=muttrcKeySpecial,muttrcKeyName
+syn region  muttrcKey		contained start=+'+ skip=+\\\\\|\\'+ end=+'+	contains=muttrcKeySpecial,muttrcKeyName
+syn match   muttrcKeyName	contained "\<f\%(\d\|10\)\>"
+syn match   muttrcKeyName	contained "\\[trne]"
+syn match   muttrcKeyName	contained "\c<\%(BackSpace\|BackTab\|Delete\|Down\|End\|Enter\|Esc\|Home\|Insert\|Left\|PageDown\|PageUp\|Return\|Right\|Space\|Tab\|Up\)>"
+syn match   muttrcKeyName	contained "<F[0-9]\+>"
+
+syn keyword muttrcVarBool	skipwhite contained 
+			\ allow_8bit allow_ansi arrow_cursor ascii_chars askbcc askcc attach_split
+			\ auto_tag autoedit beep beep_new bounce_delivered braille_friendly
+			\ check_mbox_size check_new collapse_unread confirmappend confirmcreate
+			\ crypt_autoencrypt crypt_autopgp crypt_autosign crypt_autosmime
+			\ crypt_confirmhook crypt_opportunistic_encrypt crypt_replyencrypt
+			\ crypt_replysign crypt_replysignencrypted crypt_timestamp crypt_use_gpgme
+			\ crypt_use_pka delete_untag digest_collapse duplicate_threads edit_hdrs
+			\ edit_headers encode_from envelope_from fast_reply fcc_clear followup_to
+			\ force_name forw_decode forw_decrypt forw_quote forward_decode forward_decrypt
+			\ forward_quote hdrs header help hidden_host hide_limited hide_missing
+			\ hide_thread_subject hide_top_limited hide_top_missing honor_disposition
+			\ idn_decode idn_encode ignore_linear_white_space ignore_list_reply_to
+			\ imap_check_subscribed imap_list_subscribed imap_passive imap_peek
+			\ imap_servernoise implicit_autoview include_onlyfirst keep_flagged
+			\ mail_check_recent mail_check_stats mailcap_sanitize maildir_check_cur
+			\ maildir_header_cache_verify maildir_trash mark_old markers menu_move_off
+			\ menu_scroll message_cache_clean meta_key metoo mh_purge mime_forward_decode
+			\ narrow_tree pager_stop pgp_auto_decode pgp_auto_traditional pgp_autoencrypt
+			\ pgp_autoinline pgp_autosign pgp_check_exit pgp_create_traditional
+			\ pgp_ignore_subkeys pgp_long_ids pgp_replyencrypt pgp_replyinline pgp_replysign
+			\ pgp_replysignencrypted pgp_retainable_sigs pgp_show_unusable pgp_strict_enc
+			\ pgp_use_gpg_agent pipe_decode pipe_split pop_auth_try_all pop_last
+			\ postpone_encrypt postpone_encrypt_as print_decode print_split prompt_after
+			\ read_only reflow_space_quotes reflow_text reflow_wrap reply_self resolve
+			\ resume_draft_files resume_edited_draft_files reverse_alias reverse_name
+			\ reverse_realname rfc2047_parameters save_address save_empty save_name score
+			\ sidebar_folder_indent sidebar_new_mail_only sidebar_next_new_wrap
+			\ sidebar_short_path sidebar_sort sidebar_visible sig_dashes sig_on_top
+			\ smart_wrap smime_ask_cert_label smime_decrypt_use_default_key smime_is_default
+			\ sort_re ssl_force_tls ssl_use_sslv2 ssl_use_sslv3 ssl_use_tlsv1
+			\ ssl_usesystemcerts ssl_verify_dates ssl_verify_host status_on_top strict_mime
+			\ strict_threads suspend text_flowed thorough_search thread_received tilde
+			\ ts_enabled uncollapse_jump use_8bitmime use_domain use_envelope_from use_from
+			\ use_idn use_ipv6 user_agent wait_key weed wrap_search write_bcc
+			\ nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syn keyword muttrcVarBool	skipwhite contained 
+			\ noallow_8bit noallow_ansi noarrow_cursor noascii_chars noaskbcc noaskcc noattach_split
+			\ noauto_tag noautoedit nobeep nobeep_new nobounce_delivered nobraille_friendly
+			\ nocheck_mbox_size nocheck_new nocollapse_unread noconfirmappend noconfirmcreate
+			\ nocrypt_autoencrypt nocrypt_autopgp nocrypt_autosign nocrypt_autosmime
+			\ nocrypt_confirmhook nocrypt_opportunistic_encrypt nocrypt_replyencrypt
+			\ nocrypt_replysign nocrypt_replysignencrypted nocrypt_timestamp nocrypt_use_gpgme
+			\ nocrypt_use_pka nodelete_untag nodigest_collapse noduplicate_threads noedit_hdrs
+			\ noedit_headers noencode_from noenvelope_from nofast_reply nofcc_clear nofollowup_to
+			\ noforce_name noforw_decode noforw_decrypt noforw_quote noforward_decode noforward_decrypt
+			\ noforward_quote nohdrs noheader nohelp nohidden_host nohide_limited nohide_missing
+			\ nohide_thread_subject nohide_top_limited nohide_top_missing nohonor_disposition
+			\ noidn_decode noidn_encode noignore_linear_white_space noignore_list_reply_to
+			\ noimap_check_subscribed noimap_list_subscribed noimap_passive noimap_peek
+			\ noimap_servernoise noimplicit_autoview noinclude_onlyfirst nokeep_flagged
+			\ nomail_check_recent nomail_check_stats nomailcap_sanitize nomaildir_check_cur
+			\ nomaildir_header_cache_verify nomaildir_trash nomark_old nomarkers nomenu_move_off
+			\ nomenu_scroll nomessage_cache_clean nometa_key nometoo nomh_purge nomime_forward_decode
+			\ nonarrow_tree nopager_stop nopgp_auto_decode nopgp_auto_traditional nopgp_autoencrypt
+			\ nopgp_autoinline nopgp_autosign nopgp_check_exit nopgp_create_traditional
+			\ nopgp_ignore_subkeys nopgp_long_ids nopgp_replyencrypt nopgp_replyinline nopgp_replysign
+			\ nopgp_replysignencrypted nopgp_retainable_sigs nopgp_show_unusable nopgp_strict_enc
+			\ nopgp_use_gpg_agent nopipe_decode nopipe_split nopop_auth_try_all nopop_last
+			\ nopostpone_encrypt nopostpone_encrypt_as noprint_decode noprint_split noprompt_after
+			\ noread_only noreflow_space_quotes noreflow_text noreflow_wrap noreply_self noresolve
+			\ noresume_draft_files noresume_edited_draft_files noreverse_alias noreverse_name
+			\ noreverse_realname norfc2047_parameters nosave_address nosave_empty nosave_name noscore
+			\ nosidebar_folder_indent nosidebar_new_mail_only nosidebar_next_new_wrap
+			\ nosidebar_short_path nosidebar_sort nosidebar_visible nosig_dashes nosig_on_top
+			\ nosmart_wrap nosmime_ask_cert_label nosmime_decrypt_use_default_key nosmime_is_default
+			\ nosort_re nossl_force_tls nossl_use_sslv2 nossl_use_sslv3 nossl_use_tlsv1
+			\ nossl_usesystemcerts nossl_verify_dates nossl_verify_host nostatus_on_top nostrict_mime
+			\ nostrict_threads nosuspend notext_flowed nothorough_search nothread_received notilde
+			\ nots_enabled nouncollapse_jump nouse_8bitmime nouse_domain nouse_envelope_from nouse_from
+			\ nouse_idn nouse_ipv6 nouser_agent nowait_key noweed nowrap_search nowrite_bcc
+			\ nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syn keyword muttrcVarBool	skipwhite contained
+			\ invallow_8bit invallow_ansi invarrow_cursor invascii_chars invaskbcc invaskcc invattach_split
+			\ invauto_tag invautoedit invbeep invbeep_new invbounce_delivered invbraille_friendly
+			\ invcheck_mbox_size invcheck_new invcollapse_unread invconfirmappend invconfirmcreate
+			\ invcrypt_autoencrypt invcrypt_autopgp invcrypt_autosign invcrypt_autosmime
+			\ invcrypt_confirmhook invcrypt_opportunistic_encrypt invcrypt_replyencrypt
+			\ invcrypt_replysign invcrypt_replysignencrypted invcrypt_timestamp invcrypt_use_gpgme
+			\ invcrypt_use_pka invdelete_untag invdigest_collapse invduplicate_threads invedit_hdrs
+			\ invedit_headers invencode_from invenvelope_from invfast_reply invfcc_clear invfollowup_to
+			\ invforce_name invforw_decode invforw_decrypt invforw_quote invforward_decode invforward_decrypt
+			\ invforward_quote invhdrs invheader invhelp invhidden_host invhide_limited invhide_missing
+			\ invhide_thread_subject invhide_top_limited invhide_top_missing invhonor_disposition
+			\ invidn_decode invidn_encode invignore_linear_white_space invignore_list_reply_to
+			\ invimap_check_subscribed invimap_list_subscribed invimap_passive invimap_peek
+			\ invimap_servernoise invimplicit_autoview invinclude_onlyfirst invkeep_flagged
+			\ invmail_check_recent invmail_check_stats invmailcap_sanitize invmaildir_check_cur
+			\ invmaildir_header_cache_verify invmaildir_trash invmark_old invmarkers invmenu_move_off
+			\ invmenu_scroll invmessage_cache_clean invmeta_key invmetoo invmh_purge invmime_forward_decode
+			\ invnarrow_tree invpager_stop invpgp_auto_decode invpgp_auto_traditional invpgp_autoencrypt
+			\ invpgp_autoinline invpgp_autosign invpgp_check_exit invpgp_create_traditional
+			\ invpgp_ignore_subkeys invpgp_long_ids invpgp_replyencrypt invpgp_replyinline invpgp_replysign
+			\ invpgp_replysignencrypted invpgp_retainable_sigs invpgp_show_unusable invpgp_strict_enc
+			\ invpgp_use_gpg_agent invpipe_decode invpipe_split invpop_auth_try_all invpop_last
+			\ invpostpone_encrypt invpostpone_encrypt_as invprint_decode invprint_split invprompt_after
+			\ invread_only invreflow_space_quotes invreflow_text invreflow_wrap invreply_self invresolve
+			\ invresume_draft_files invresume_edited_draft_files invreverse_alias invreverse_name
+			\ invreverse_realname invrfc2047_parameters invsave_address invsave_empty invsave_name invscore
+			\ invsidebar_folder_indent invsidebar_new_mail_only invsidebar_next_new_wrap
+			\ invsidebar_short_path invsidebar_sort invsidebar_visible invsig_dashes invsig_on_top
+			\ invsmart_wrap invsmime_ask_cert_label invsmime_decrypt_use_default_key invsmime_is_default
+			\ invsort_re invssl_force_tls invssl_use_sslv2 invssl_use_sslv3 invssl_use_tlsv1
+			\ invssl_usesystemcerts invssl_verify_dates invssl_verify_host invstatus_on_top invstrict_mime
+			\ invstrict_threads invsuspend invtext_flowed invthorough_search invthread_received invtilde
+			\ invts_enabled invuncollapse_jump invuse_8bitmime invuse_domain invuse_envelope_from invuse_from
+			\ invuse_idn invuse_ipv6 invuser_agent invwait_key invweed invwrap_search invwrite_bcc
+			\ nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syn keyword muttrcVarQuad	skipwhite contained
+			\ abort_nosubject abort_unmodified bounce copy crypt_verify_sig delete
+			\ fcc_attach forward_edit honor_followup_to include mime_forward
+			\ mime_forward_rest mime_fwd move pgp_mime_auto pgp_verify_sig pop_delete
+			\ pop_reconnect postpone print quit recall reply_to ssl_starttls
+			\ nextgroup=muttrcSetQuadAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syn keyword muttrcVarQuad	skipwhite contained
+			\ noabort_nosubject noabort_unmodified nobounce nocopy nocrypt_verify_sig nodelete
+			\ nofcc_attach noforward_edit nohonor_followup_to noinclude nomime_forward
+			\ nomime_forward_rest nomime_fwd nomove nopgp_mime_auto nopgp_verify_sig nopop_delete
+			\ nopop_reconnect nopostpone noprint noquit norecall noreply_to nossl_starttls
+			\ nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syn keyword muttrcVarQuad	skipwhite contained
+			\ invabort_nosubject invabort_unmodified invbounce invcopy invcrypt_verify_sig invdelete
+			\ invfcc_attach invforward_edit invhonor_followup_to invinclude invmime_forward
+			\ invmime_forward_rest invmime_fwd invmove invpgp_mime_auto invpgp_verify_sig invpop_delete
+			\ invpop_reconnect invpostpone invprint invquit invrecall invreply_to invssl_starttls
+			\ nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syn keyword muttrcVarNum	skipwhite contained
+			\ connect_timeout history imap_keepalive imap_pipeline_depth mail_check
+			\ mail_check_stats_interval menu_context net_inc pager_context pager_index_lines
+			\ pgp_timeout pop_checkinterval read_inc save_history score_threshold_delete
+			\ score_threshold_flag score_threshold_read search_context sendmail_wait
+			\ sidebar_width sleep_time smime_timeout ssl_min_dh_prime_bits time_inc timeout
+			\ wrap wrap_headers wrapmargin write_inc
+			\ nextgroup=muttrcSetNumAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syn match muttrcFormatErrors contained /%./
+
+syn match muttrcStrftimeEscapes contained /%[AaBbCcDdeFGgHhIjklMmnpRrSsTtUuVvWwXxYyZz+%]/
+syn match muttrcStrftimeEscapes contained /%E[cCxXyY]/
+syn match muttrcStrftimeEscapes contained /%O[BdeHImMSuUVwWy]/
+
+syn region muttrcIndexFormatStr	contained skipwhite keepend start=+"+ skip=+\\"+ end=+"+ contains=muttrcIndexFormatEscapes,muttrcIndexFormatConditionals,muttrcFormatErrors,muttrcTimeEscapes nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcIndexFormatStr	contained skipwhite keepend start=+'+ skip=+\\'+ end=+'+ contains=muttrcIndexFormatEscapes,muttrcIndexFormatConditionals,muttrcFormatErrors,muttrcTimeEscapes nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcQueryFormatStr contained skipwhite keepend start=+"+ skip=+\\"+ end=+"+ contains=muttrcQueryFormatEscapes,muttrcQueryFormatConditionals,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcAliasFormatStr	contained skipwhite keepend start=+"+ skip=+\\"+ end=+"+ contains=muttrcAliasFormatEscapes,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcAliasFormatStr	contained skipwhite keepend start=+'+ skip=+\\'+ end=+'+ contains=muttrcAliasFormatEscapes,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcAttachFormatStr	contained skipwhite keepend start=+"+ skip=+\\"+ end=+"+ contains=muttrcAttachFormatEscapes,muttrcAttachFormatConditionals,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcAttachFormatStr	contained skipwhite keepend start=+'+ skip=+\\'+ end=+'+ contains=muttrcAttachFormatEscapes,muttrcAttachFormatConditionals,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcComposeFormatStr	contained skipwhite keepend start=+"+ skip=+\\"+ end=+"+ contains=muttrcComposeFormatEscapes,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcComposeFormatStr	contained skipwhite keepend start=+'+ skip=+\\'+ end=+'+ contains=muttrcComposeFormatEscapes,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcFolderFormatStr	contained skipwhite keepend start=+"+ skip=+\\"+ end=+"+ contains=muttrcFolderFormatEscapes,muttrcFolderFormatConditionals,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcFolderFormatStr	contained skipwhite keepend start=+'+ skip=+\\'+ end=+'+ contains=muttrcFolderFormatEscapes,muttrcFolderFormatConditionals,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcMixFormatStr	contained skipwhite keepend start=+"+ skip=+\\"+ end=+"+ contains=muttrcMixFormatEscapes,muttrcMixFormatConditionals,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcMixFormatStr	contained skipwhite keepend start=+'+ skip=+\\'+ end=+'+ contains=muttrcMixFormatEscapes,muttrcMixFormatConditionals,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcPGPFormatStr	contained skipwhite keepend start=+"+ skip=+\\"+ end=+"+ contains=muttrcPGPFormatEscapes,muttrcPGPFormatConditionals,muttrcFormatErrors,muttrcPGPTimeEscapes nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcPGPFormatStr	contained skipwhite keepend start=+'+ skip=+\\'+ end=+'+ contains=muttrcPGPFormatEscapes,muttrcPGPFormatConditionals,muttrcFormatErrors,muttrcPGPTimeEscapes nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcPGPCmdFormatStr	contained skipwhite keepend start=+"+ skip=+\\"+ end=+"+ contains=muttrcPGPCmdFormatEscapes,muttrcPGPCmdFormatConditionals,muttrcVariable,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcPGPCmdFormatStr	contained skipwhite keepend start=+'+ skip=+\\'+ end=+'+ contains=muttrcPGPCmdFormatEscapes,muttrcPGPCmdFormatConditionals,muttrcVariable,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcStatusFormatStr	contained skipwhite keepend start=+"+ skip=+\\"+ end=+"+ contains=muttrcStatusFormatEscapes,muttrcStatusFormatConditionals,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcStatusFormatStr	contained skipwhite keepend start=+'+ skip=+\\'+ end=+'+ contains=muttrcStatusFormatEscapes,muttrcStatusFormatConditionals,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcPGPGetKeysFormatStr	contained skipwhite keepend start=+"+ skip=+\\"+ end=+"+ contains=muttrcPGPGetKeysFormatEscapes,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcPGPGetKeysFormatStr	contained skipwhite keepend start=+'+ skip=+\\'+ end=+'+ contains=muttrcPGPGetKeysFormatEscapes,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcSmimeFormatStr	contained skipwhite keepend start=+"+ skip=+\\"+ end=+"+ contains=muttrcSmimeFormatEscapes,muttrcSmimeFormatConditionals,muttrcVariable,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcSmimeFormatStr	contained skipwhite keepend start=+'+ skip=+\\'+ end=+'+ contains=muttrcSmimeFormatEscapes,muttrcSmimeFormatConditionals,muttrcVariable,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcStrftimeFormatStr contained skipwhite keepend start=+"+ skip=+\\"+ end=+"+ contains=muttrcStrftimeEscapes,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn region muttrcStrftimeFormatStr contained skipwhite keepend start=+'+ skip=+\\'+ end=+'+ contains=muttrcStrftimeEscapes,muttrcFormatErrors nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+" The following info was pulled from hdr_format_str in hdrline.c
+syn match muttrcIndexFormatEscapes contained /%\%(\%(-\?[0-9]\+\)\?\%(\.[0-9]\+\)\?\)\?[:_]\?[aAbBcCdDeEfFHilLmMnNOPsStTuvXyYZ%]/
+syn match muttrcIndexFormatEscapes contained /%[>|*]./
+syn match muttrcIndexFormatConditionals contained /%?[EFHlLMNOXyY]?/ nextgroup=muttrcFormatConditionals2
+" The following info was pulled from alias_format_str in addrbook.c
+syn match muttrcAliasFormatEscapes contained /%\%(\%(-\?[0-9]\+\)\?\%(\.[0-9]\+\)\?\)\?[:_]\?[afnrt%]/
+" The following info was pulled from query_format_str in query.c
+syn match muttrcQueryFormatEscapes contained /%\%(\%(-\?[0-9]\+\)\?\%(\.[0-9]\+\)\?\)\?[:_]\?[acent%]/
+syn match muttrcQueryFormatConditionals contained /%?[e]?/ nextgroup=muttrcFormatConditionals2
+" The following info was pulled from mutt_attach_fmt in recvattach.c
+syn match muttrcAttachFormatEscapes contained /%\%(\%(-\?[0-9]\+\)\?\%(\.[0-9]\+\)\?\)\?[:_]\?[CcDdefImMnQstTuX%]/
+syn match muttrcAttachFormatEscapes contained /%[>|*]./
+syn match muttrcAttachFormatConditionals contained /%?[CcdDefInmMQstTuX]?/ nextgroup=muttrcFormatConditionals2
+syn match muttrcFormatConditionals2 contained /[^?]*?/
+" The following info was pulled from compose_format_str in compose.c
+syn match muttrcComposeFormatEscapes contained /%\%(\%(-\?[0-9]\+\)\?\%(\.[0-9]\+\)\?\)\?[:_]\?[ahlv%]/
+syn match muttrcComposeFormatEscapes contained /%[>|*]./
+" The following info was pulled from folder_format_str in browser.c
+syn match muttrcFolderFormatEscapes contained /%\%(\%(-\?[0-9]\+\)\?\%(\.[0-9]\+\)\?\)\?[:_]\?[CDdfFglNstu%]/
+syn match muttrcFolderFormatEscapes contained /%[>|*]./
+syn match muttrcFolderFormatConditionals contained /%?[N]?/
+" The following info was pulled from mix_entry_fmt in remailer.c
+syn match muttrcMixFormatEscapes contained /%\%(\%(-\?[0-9]\+\)\?\%(\.[0-9]\+\)\?\)\?[:_]\?[ncsa%]/
+syn match muttrcMixFormatConditionals contained /%?[ncsa]?/
+" The following info was pulled from crypt_entry_fmt in crypt-gpgme.c 
+" and pgp_entry_fmt in pgpkey.c (note that crypt_entry_fmt supports 
+" 'p', but pgp_entry_fmt does not).
+syn match muttrcPGPFormatEscapes contained /%\%(\%(-\?[0-9]\+\)\?\%(\.[0-9]\+\)\?\)\?[:_]\?[nkualfctp%]/
+syn match muttrcPGPFormatConditionals contained /%?[nkualfct]?/
+" The following info was pulled from _mutt_fmt_pgp_command in 
+" pgpinvoke.c
+syn match muttrcPGPCmdFormatEscapes contained /%\%(\%(-\?[0-9]\+\)\?\%(\.[0-9]\+\)\?\)\?[:_]\?[pfsar%]/
+syn match muttrcPGPCmdFormatConditionals contained /%?[pfsar]?/ nextgroup=muttrcFormatConditionals2
+" The following info was pulled from status_format_str in status.c
+syn match muttrcStatusFormatEscapes contained /%\%(\%(-\?[0-9]\+\)\?\%(\.[0-9]\+\)\?\)\?[:_]\?[bdfFhlLmMnopPrsStuvV%]/
+syn match muttrcStatusFormatEscapes contained /%[>|*]./
+syn match muttrcStatusFormatConditionals contained /%?[bdFlLmMnoptuV]?/ nextgroup=muttrcFormatConditionals2
+" This matches the documentation, but directly contradicts the code 
+" (according to the code, this should be identical to the 
+" muttrcPGPCmdFormatEscapes
+syn match muttrcPGPGetKeysFormatEscapes contained /%\%(\%(-\?[0-9]\+\)\?\%(\.[0-9]\+\)\?\)\?[:_]\?[r%]/
+" The following info was pulled from _mutt_fmt_smime_command in 
+" smime.c
+syn match muttrcSmimeFormatEscapes contained /%\%(\%(-\?[0-9]\+\)\?\%(\.[0-9]\+\)\?\)\?[:_]\?[Cciskaf%]/
+syn match muttrcSmimeFormatConditionals contained /%?[Cciskaf]?/ nextgroup=muttrcFormatConditionals2
+
+syn region muttrcTimeEscapes contained start=+%{+ end=+}+ contains=muttrcStrftimeEscapes
+syn region muttrcTimeEscapes contained start=+%\[+ end=+\]+ contains=muttrcStrftimeEscapes
+syn region muttrcTimeEscapes contained start=+%(+ end=+)+ contains=muttrcStrftimeEscapes
+syn region muttrcTimeEscapes contained start=+%<+ end=+>+ contains=muttrcStrftimeEscapes
+syn region muttrcPGPTimeEscapes contained start=+%\[+ end=+\]+ contains=muttrcStrftimeEscapes
+
+syn keyword muttrcVarStr	contained skipwhite attribution index_format message_format pager_format nextgroup=muttrcVarEqualsIdxFmt
+syn match muttrcVarEqualsIdxFmt contained skipwhite "=" nextgroup=muttrcIndexFormatStr
+syn keyword muttrcVarStr	contained skipwhite alias_format nextgroup=muttrcVarEqualsAliasFmt
+syn match muttrcVarEqualsAliasFmt contained skipwhite "=" nextgroup=muttrcAliasFormatStr
+syn keyword muttrcVarStr	contained skipwhite attach_format nextgroup=muttrcVarEqualsAttachFmt
+syn match muttrcVarEqualsAttachFmt contained skipwhite "=" nextgroup=muttrcAttachFormatStr
+syn keyword muttrcVarStr	contained skipwhite compose_format nextgroup=muttrcVarEqualsComposeFmt
+syn match muttrcVarEqualsComposeFmt contained skipwhite "=" nextgroup=muttrcComposeFormatStr
+syn keyword muttrcVarStr	contained skipwhite folder_format nextgroup=muttrcVarEqualsFolderFmt
+syn match muttrcVarEqualsFolderFmt contained skipwhite "=" nextgroup=muttrcFolderFormatStr
+syn keyword muttrcVarStr	contained skipwhite mix_entry_format nextgroup=muttrcVarEqualsMixFmt
+syn match muttrcVarEqualsMixFmt contained skipwhite "=" nextgroup=muttrcMixFormatStr
+syn keyword muttrcVarStr	contained skipwhite pgp_entry_format nextgroup=muttrcVarEqualsPGPFmt
+syn match muttrcVarEqualsPGPFmt contained skipwhite "=" nextgroup=muttrcPGPFormatStr
+syn keyword muttrcVarStr	contained skipwhite query_format nextgroup=muttrcVarEqualsQueryFmt
+syn match muttrcVarEqualsQueryFmt contained skipwhite "=" nextgroup=muttrcQueryFormatStr
+syn keyword muttrcVarStr	contained skipwhite pgp_decode_command pgp_verify_command pgp_decrypt_command pgp_clearsign_command pgp_sign_command pgp_encrypt_sign_command pgp_encrypt_only_command pgp_import_command pgp_export_command pgp_verify_key_command pgp_list_secring_command pgp_list_pubring_command nextgroup=muttrcVarEqualsPGPCmdFmt
+syn match muttrcVarEqualsPGPCmdFmt contained skipwhite "=" nextgroup=muttrcPGPCmdFormatStr
+syn keyword muttrcVarStr	contained skipwhite ts_icon_format ts_status_format status_format nextgroup=muttrcVarEqualsStatusFmt
+syn match muttrcVarEqualsStatusFmt contained skipwhite "=" nextgroup=muttrcStatusFormatStr
+syn keyword muttrcVarStr	contained skipwhite pgp_getkeys_command nextgroup=muttrcVarEqualsPGPGetKeysFmt
+syn match muttrcVarEqualsPGPGetKeysFmt contained skipwhite "=" nextgroup=muttrcPGPGetKeysFormatStr
+syn keyword muttrcVarStr	contained skipwhite smime_decrypt_command smime_verify_command smime_verify_opaque_command smime_sign_command smime_sign_opaque_command smime_encrypt_command smime_pk7out_command smime_get_cert_command smime_get_signer_cert_command smime_import_cert_command smime_get_cert_email_command nextgroup=muttrcVarEqualsSmimeFmt
+syn match muttrcVarEqualsSmimeFmt contained skipwhite "=" nextgroup=muttrcSmimeFormatStr
+syn keyword muttrcVarStr	contained skipwhite date_format nextgroup=muttrcVarEqualsStrftimeFmt
+syn match muttrcVarEqualsStrftimeFmt contained skipwhite "=" nextgroup=muttrcStrftimeFormatStr
+
+syn match muttrcVPrefix		contained /[?&]/ nextgroup=muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syn match muttrcVarStr		contained skipwhite 'my_[a-zA-Z0-9_]\+' nextgroup=muttrcSetStrAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn keyword muttrcVarStr	contained skipwhite
+			\ alias_file assumed_charset attach_charset attach_sep certificate_file charset
+			\ config_charset content_type default_hook display_filter dotlock_program
+			\ dsn_notify dsn_return editor entropy_file envelope_from_address escape folder
+			\ forw_format forward_format from gecos_mask hdr_format header_cache
+			\ header_cache_compress header_cache_pagesize history_file hostname
+			\ imap_authenticators imap_delim_chars imap_headers imap_idle imap_login
+			\ imap_pass imap_user indent_str indent_string ispell locale mailcap_path mask
+			\ mbox mbox_type message_cachedir mh_seq_flagged mh_seq_replied mh_seq_unseen
+			\ mixmaster msg_format pager pgp_decryption_okay pgp_good_sign
+			\ pgp_mime_signature_description pgp_mime_signature_filename pgp_sign_as
+			\ pgp_sort_keys pipe_sep pop_authenticators pop_host pop_pass pop_user
+			\ post_indent_str post_indent_string postpone_encrypt_as postponed preconnect
+			\ print_cmd print_command query_command quote_regexp realname record
+			\ reply_regexp send_charset sendmail shell sidebar_delim sidebar_delim_chars
+			\ sidebar_divider_char sidebar_format sidebar_indent_string sidebar_sort_method
+			\ signature simple_search smileys smime_ca_location smime_certificates
+			\ smime_default_key smime_encrypt_with smime_keys smime_sign_as
+			\ smime_sign_digest_alg smtp_authenticators smtp_pass smtp_url sort sort_alias
+			\ sort_aux sort_browser spam_separator spoolfile ssl_ca_certificates_file
+			\ ssl_ciphers ssl_client_cert status_chars tmpdir to_chars trash ts_icon_format
+			\ ts_status_format tunnel visual
+			\ nextgroup=muttrcSetStrAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+" Present in 1.4.2.1 (pgp_create_traditional was a bool then)
+syn keyword muttrcVarBool	contained skipwhite imap_force_ssl noimap_force_ssl invimap_force_ssl nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+"syn keyword muttrcVarQuad	contained pgp_create_traditional nopgp_create_traditional invpgp_create_traditional
+syn keyword muttrcVarStr	contained skipwhite alternates nextgroup=muttrcSetStrAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syn keyword muttrcMenu		contained alias attach browser compose editor index pager postpone pgp mix query generic
+syn match muttrcMenuList "\S\+" contained contains=muttrcMenu
+syn match muttrcMenuCommas /,/ contained
+
+syn keyword muttrcHooks		contained skipwhite account-hook charset-hook iconv-hook message-hook folder-hook mbox-hook save-hook fcc-hook fcc-save-hook send-hook send2-hook reply-hook crypt-hook
+
+syn keyword muttrcCommand	skipwhite
+			\ alternative_order auto_view exec hdr_order iconv-hook ignore mailboxes
+			\ mailto_allow mime_lookup my_hdr pgp-hook push score sidebar_whitelist source
+			\ unalternative_order unalternative_order unauto_view ungroup unhdr_order
+			\ unignore unmailboxes unmailto_allow unmime_lookup unmono unmy_hdr unscore
+syn keyword muttrcCommand	skipwhite charset-hook nextgroup=muttrcRXString
+syn keyword muttrcCommand	skipwhite unhook nextgroup=muttrcHooks
+
+syn keyword muttrcCommand 	skipwhite spam nextgroup=muttrcSpamPattern
+syn region muttrcSpamPattern	contained skipwhite keepend start=+'+ skip=+\\'+ end=+'+ contains=muttrcPattern nextgroup=muttrcString,muttrcStringNL
+syn region muttrcSpamPattern	contained skipwhite keepend start=+"+ skip=+\\"+ end=+"+ contains=muttrcPattern nextgroup=muttrcString,muttrcStringNL
+
+syn keyword muttrcCommand 	skipwhite nospam nextgroup=muttrcNoSpamPattern
+syn region muttrcNoSpamPattern	contained skipwhite keepend start=+'+ skip=+\\'+ end=+'+ contains=muttrcPattern
+syn region muttrcNoSpamPattern	contained skipwhite keepend start=+"+ skip=+\\"+ end=+"+ contains=muttrcPattern
+
+syn match muttrcAttachmentsMimeType contained "[*a-z0-9_-]\+/[*a-z0-9._-]\+\s*" skipwhite nextgroup=muttrcAttachmentsMimeType
+syn match muttrcAttachmentsFlag contained "[+-]\%([AI]\|inline\|attachment\)\s\+" skipwhite nextgroup=muttrcAttachmentsMimeType
+syn match muttrcAttachmentsLine "^\s*\%(un\)\?attachments\s\+" skipwhite nextgroup=muttrcAttachmentsFlag
+
+syn match muttrcUnHighlightSpace contained "\%(\s\+\|\\$\)"
+
+syn keyword muttrcAsterisk	contained *
+syn keyword muttrcListsKeyword	lists skipwhite nextgroup=muttrcGroupDef,muttrcComment
+syn keyword muttrcListsKeyword	unlists skipwhite nextgroup=muttrcAsterisk,muttrcComment
+
+syn keyword muttrcSubscribeKeyword	subscribe nextgroup=muttrcGroupDef,muttrcComment
+syn keyword muttrcSubscribeKeyword	unsubscribe nextgroup=muttrcAsterisk,muttrcComment
+
+syn keyword muttrcAlternateKeyword contained alternates unalternates
+syn region muttrcAlternatesLine keepend start=+^\s*\%(un\)\?alternates\s+ skip=+\\$+ end=+$+ contains=muttrcAlternateKeyword,muttrcGroupDef,muttrcRXPat,muttrcUnHighlightSpace,muttrcComment
+
+" muttrcVariable includes a prefix because partial strings are considered
+" valid.
+syn match muttrcVariable	contained "\\\@<![a-zA-Z_-]*\$[a-zA-Z_-]\+" contains=muttrcVariableInner
+syn match muttrcVariableInner	contained "\$[a-zA-Z_-]\+"
+syn match muttrcEscapedVariable	contained "\\\$[a-zA-Z_-]\+"
+
+syn match muttrcBadAction	contained "[^<>]\+" contains=muttrcEmail
+syn match muttrcFunction	contained "\<\%(attach\|bounce\|copy\|delete\|display\|flag\|forward\|parent\|pipe\|postpone\|print\|purge\|recall\|resend\|save\|send\|tag\|undelete\)-message\>"
+syn match muttrcFunction	contained "\<\%(delete\|next\|previous\|read\|tag\|break\|undelete\)-thread\>"
+syn match muttrcFunction	contained "\<link-threads\>"
+syn match muttrcFunction	contained "\<\%(backward\|capitalize\|downcase\|forward\|kill\|upcase\)-word\>"
+syn match muttrcFunction	contained "\<\%(delete\|filter\|first\|last\|next\|pipe\|previous\|print\|save\|select\|tag\|undelete\)-entry\>"
+syn match muttrcFunction	contained "\<attach-\%(file\|key\)\>"
+syn match muttrcFunction	contained "\<change-\%(dir\|folder\|folder-readonly\)\>"
+syn match muttrcFunction	contained "\<check-\%(new\|traditional-pgp\)\>"
+syn match muttrcFunction	contained "\<current-\%(bottom\|middle\|top\)\>"
+syn match muttrcFunction	contained "\<decode-\%(copy\|save\)\>"
+syn match muttrcFunction	contained "\<delete-\%(char\|pattern\|subthread\)\>"
+syn match muttrcFunction	contained "\<display-\%(address\|toggle-weed\)\>"
+syn match muttrcFunction	contained "\<edit\%(-\%(bcc\|cc\|description\|encoding\|fcc\|file\|from\|headers\|mime\|reply-to\|subject\|to\|type\)\)\?\>"
+syn match muttrcFunction	contained "\<enter-\%(command\|mask\)\>"
+syn match muttrcFunction	contained "\<half-\%(up\|down\)\>"
+syn match muttrcFunction	contained "\<history-\%(up\|down\)\>"
+syn match muttrcFunction	contained "\<kill-\%(eol\|eow\|line\)\>"
+syn match muttrcFunction	contained "\<next-\%(line\|new\%(-then-unread\)\?\|page\|subthread\|undeleted\|unread\|unread-mailbox\)\>"
+syn match muttrcFunction	contained "\<previous-\%(line\|new\%(-then-unread\)\?\|page\|subthread\|undeleted\|unread\)\>"
+syn match muttrcFunction	contained "\<search\%(-\%(next\|opposite\|reverse\|toggle\)\)\?\>"
+syn match muttrcFunction	contained "\<show-\%(limit\|version\)\>"
+syn match muttrcFunction	contained "\<sort-\%(mailbox\|reverse\)\>"
+syn match muttrcFunction	contained "\<tag-\%(pattern\|\%(sub\)\?thread\|prefix\%(-cond\)\?\)\>"
+syn match muttrcFunction	contained "\<end-cond\>"
+syn match muttrcFunction	contained "\<sidebar-\%(next\|next-new\|open\|page-down\|page-up\|prev\|prev-new\|toggle-visible\)\>"
+syn match muttrcFunction	contained "\<toggle-\%(mailboxes\|new\|quoted\|subscribed\|unlink\|write\)\>"
+syn match muttrcFunction	contained "\<undelete-\%(pattern\|subthread\)\>"
+syn match muttrcFunction	contained "\<collapse-\%(parts\|thread\|all\)\>"
+syn match muttrcFunction	contained "\<view-\%(attach\|attachments\|file\|mailcap\|name\|text\)\>"
+syn match muttrcFunction	contained "\<\%(backspace\|backward-char\|bol\|bottom\|bottom-page\|buffy-cycle\|clear-flag\|complete\%(-query\)\?\|copy-file\|create-alias\|detach-file\|eol\|exit\|extract-keys\|\%(imap-\)\?fetch-mail\|forget-passphrase\|forward-char\|group-reply\|help\|ispell\|jump\|limit\|list-reply\|mail\|mail-key\|mark-as-new\|middle-page\|new-mime\|noop\|pgp-menu\|query\|query-append\|quit\|quote-char\|read-subthread\|redraw-screen\|refresh\|rename-file\|reply\|select-new\|set-flag\|shell-escape\|skip-quoted\|sort\|subscribe\|sync-mailbox\|top\|top-page\|transpose-chars\|unsubscribe\|untag-pattern\|verify-key\|what-key\|write-fcc\)\>"
+syn keyword muttrcFunction	contained imap-logout-all
+if use_mutt_sidebar == 1
+    syn match muttrcFunction    contained "\<sidebar-\%(prev\|next\|open\|scroll-up\|scroll-down\)"
+endif
+syn match muttrcAction		contained "<[^>]\{-}>" contains=muttrcBadAction,muttrcFunction,muttrcKeyName
+
+syn keyword muttrcCommand	set     skipwhite nextgroup=muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn keyword muttrcCommand	unset   skipwhite nextgroup=muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn keyword muttrcCommand	reset   skipwhite nextgroup=muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syn keyword muttrcCommand	toggle  skipwhite nextgroup=muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+" First, functions that take regular expressions:
+syn match  muttrcRXHookNot	contained /!\s*/ skipwhite nextgroup=muttrcRXHookString,muttrcRXHookStringNL
+syn match  muttrcRXHooks	/\<\%(account\|folder\)-hook\>/ skipwhite nextgroup=muttrcRXHookNot,muttrcRXHookString,muttrcRXHookStringNL
+
+" Now, functions that take patterns
+syn match muttrcPatHookNot	contained /!\s*/ skipwhite nextgroup=muttrcPattern
+syn match muttrcPatHooks	/\<\%(mbox\|crypt\)-hook\>/ skipwhite nextgroup=muttrcPatHookNot,muttrcPattern
+syn match muttrcPatHooks	/\<\%(message\|reply\|send\|send2\|save\|\|fcc\%(-save\)\?\)-hook\>/ skipwhite nextgroup=muttrcPatHookNot,muttrcOptPattern
+
+syn match muttrcBindFunction	contained /\S\+\>/ skipwhite contains=muttrcFunction
+syn match muttrcBindFunctionNL	contained /\s*\\$/ skipwhite skipnl nextgroup=muttrcBindFunction,muttrcBindFunctionNL
+syn match muttrcBindKey		contained /\S\+/ skipwhite contains=muttrcKey nextgroup=muttrcBindFunction,muttrcBindFunctionNL
+syn match muttrcBindKeyNL	contained /\s*\\$/ skipwhite skipnl nextgroup=muttrcBindKey,muttrcBindKeyNL
+syn match muttrcBindMenuList	contained /\S\+/ skipwhite contains=muttrcMenu,muttrcMenuCommas nextgroup=muttrcBindKey,muttrcBindKeyNL
+syn match muttrcBindMenuListNL	contained /\s*\\$/ skipwhite skipnl nextgroup=muttrcBindMenuList,muttrcBindMenuListNL
+syn keyword muttrcCommand	skipwhite bind nextgroup=muttrcBindMenuList,muttrcBindMenuListNL
+
+syn region muttrcMacroDescr	contained keepend skipwhite start=+\s*\S+ms=e skip=+\\ + end=+ \|$+me=s
+syn region muttrcMacroDescr	contained keepend skipwhite start=+'+ms=e skip=+\\'+ end=+'+me=s
+syn region muttrcMacroDescr	contained keepend skipwhite start=+"+ms=e skip=+\\"+ end=+"+me=s
+syn match muttrcMacroDescrNL	contained /\s*\\$/ skipwhite skipnl nextgroup=muttrcMacroDescr,muttrcMacroDescrNL
+syn region muttrcMacroBody	contained skipwhite start="\S" skip='\\ \|\\$' end=' \|$' contains=muttrcEscape,muttrcSet,muttrcUnset,muttrcReset,muttrcToggle,muttrcCommand,muttrcAction nextgroup=muttrcMacroDescr,muttrcMacroDescrNL
+syn region muttrcMacroBody matchgroup=Type contained skipwhite start=+'+ms=e skip=+\\'+ end=+'\|\%(\%(\\\\\)\@<!$\)+me=s contains=muttrcEscape,muttrcSet,muttrcUnset,muttrcReset,muttrcToggle,muttrcSpam,muttrcNoSpam,muttrcCommand,muttrcAction,muttrcVariable nextgroup=muttrcMacroDescr,muttrcMacroDescrNL
+syn region muttrcMacroBody matchgroup=Type contained skipwhite start=+"+ms=e skip=+\\"+ end=+"\|\%(\%(\\\\\)\@<!$\)+me=s contains=muttrcEscape,muttrcSet,muttrcUnset,muttrcReset,muttrcToggle,muttrcSpam,muttrcNoSpam,muttrcCommand,muttrcAction,muttrcVariable nextgroup=muttrcMacroDescr,muttrcMacroDescrNL
+syn match muttrcMacroBodyNL	contained /\s*\\$/ skipwhite skipnl nextgroup=muttrcMacroBody,muttrcMacroBodyNL
+syn match muttrcMacroKey	contained /\S\+/ skipwhite contains=muttrcKey nextgroup=muttrcMacroBody,muttrcMacroBodyNL
+syn match muttrcMacroKeyNL	contained /\s*\\$/ skipwhite skipnl nextgroup=muttrcMacroKey,muttrcMacroKeyNL
+syn match muttrcMacroMenuList	contained /\S\+/ skipwhite contains=muttrcMenu,muttrcMenuCommas nextgroup=muttrcMacroKey,muttrcMacroKeyNL
+syn match muttrcMacroMenuListNL	contained /\s*\\$/ skipwhite skipnl nextgroup=muttrcMacroMenuList,muttrcMacroMenuListNL
+syn keyword muttrcCommand	skipwhite macro	nextgroup=muttrcMacroMenuList,muttrcMacroMenuListNL
+
+syn match muttrcAddrContent	contained "[a-zA-Z0-9._-]\+@[a-zA-Z0-9./-]\+\s*" skipwhite contains=muttrcEmail nextgroup=muttrcAddrContent
+syn region muttrcAddrContent	contained start=+'+ end=+'\s*+ skip=+\\'+ skipwhite contains=muttrcEmail nextgroup=muttrcAddrContent
+syn region muttrcAddrContent	contained start=+"+ end=+"\s*+ skip=+\\"+ skipwhite contains=muttrcEmail nextgroup=muttrcAddrContent
+syn match muttrcAddrDef 	contained "-addr\s\+" skipwhite nextgroup=muttrcAddrContent
+
+syn match muttrcGroupFlag	contained "-group"
+syn region muttrcGroupDef	contained start="-group\s\+" skip="\\$" end="\s" skipwhite keepend contains=muttrcGroupFlag,muttrcUnHighlightSpace
+
+syn keyword muttrcGroupKeyword	contained group ungroup
+syn region muttrcGroupLine	keepend start=+^\s*\%(un\)\?group\s+ skip=+\\$+ end=+$+ contains=muttrcGroupKeyword,muttrcGroupDef,muttrcAddrDef,muttrcRXDef,muttrcUnHighlightSpace,muttrcComment
+
+syn match muttrcAliasGroupName	contained /\w\+/ skipwhite nextgroup=muttrcAliasGroupDef,muttrcAliasKey,muttrcAliasNL
+syn match muttrcAliasGroupDefNL	contained /\s*\\$/ skipwhite skipnl nextgroup=muttrcAliasGroupName,muttrcAliasGroupDefNL
+syn match muttrcAliasGroupDef	contained /\s*-group/ skipwhite nextgroup=muttrcAliasGroupName,muttrcAliasGroupDefNL contains=muttrcGroupFlag
+syn match muttrcAliasComma	contained /,/ skipwhite nextgroup=muttrcAliasEmail,muttrcAliasEncEmail,muttrcAliasNameNoParens,muttrcAliasENNL
+syn match muttrcAliasEmail	contained /\S\+@\S\+/ contains=muttrcEmail nextgroup=muttrcAliasName,muttrcAliasNameNL skipwhite
+syn match muttrcAliasEncEmail	contained /<[^>]\+>/ contains=muttrcEmail nextgroup=muttrcAliasComma
+syn match muttrcAliasEncEmailNL	contained /\s*\\$/ skipwhite skipnl nextgroup=muttrcAliasEncEmail,muttrcAliasEncEmailNL
+syn match muttrcAliasNameNoParens contained /[^<(@]\+\s\+/ nextgroup=muttrcAliasEncEmail,muttrcAliasEncEmailNL
+syn region muttrcAliasName	contained matchgroup=Type start=/(/ end=/)/ skipwhite
+syn match muttrcAliasNameNL	contained /\s*\\$/ skipwhite skipnl nextgroup=muttrcAliasName,muttrcAliasNameNL
+syn match muttrcAliasENNL	contained /\s*\\$/ skipwhite skipnl nextgroup=muttrcAliasEmail,muttrcAliasEncEmail,muttrcAliasNameNoParens,muttrcAliasENNL
+syn match muttrcAliasKey	contained /\s*[^- \t]\S\+/ skipwhite nextgroup=muttrcAliasEmail,muttrcAliasEncEmail,muttrcAliasNameNoParens,muttrcAliasENNL
+syn match muttrcAliasNL		contained /\s*\\$/ skipwhite skipnl nextgroup=muttrcAliasGroupDef,muttrcAliasKey,muttrcAliasNL
+syn keyword muttrcCommand	skipwhite alias nextgroup=muttrcAliasGroupDef,muttrcAliasKey,muttrcAliasNL
+
+syn match muttrcUnAliasKey	contained "\s*\w\+\s*" skipwhite nextgroup=muttrcUnAliasKey,muttrcUnAliasNL
+syn match muttrcUnAliasNL	contained /\s*\\$/ skipwhite skipnl nextgroup=muttrcUnAliasKey,muttrcUnAliasNL
+syn keyword muttrcCommand	skipwhite unalias nextgroup=muttrcUnAliasKey,muttrcUnAliasNL
+
+syn match muttrcSimplePat contained "!\?\^\?[~][ADEFgGklNOpPQRSTuUvV=$]"
+syn match muttrcSimplePat contained "!\?\^\?[~][mnXz]\s*\%([<>-][0-9]\+[kM]\?\|[0-9]\+[kM]\?[-]\%([0-9]\+[kM]\?\)\?\)"
+syn match muttrcSimplePat contained "!\?\^\?[~][dr]\s*\%(\%(-\?[0-9]\{1,2}\%(/[0-9]\{1,2}\%(/[0-9]\{2}\%([0-9]\{2}\)\?\)\?\)\?\%([+*-][0-9]\+[ymwd]\)*\)\|\%(\%([0-9]\{1,2}\%(/[0-9]\{1,2}\%(/[0-9]\{2}\%([0-9]\{2}\)\?\)\?\)\?\%([+*-][0-9]\+[ymwd]\)*\)-\%([0-9]\{1,2}\%(/[0-9]\{1,2}\%(/[0-9]\{2}\%([0-9]\{2}\)\?\)\?\)\?\%([+*-][0-9]\+[ymwd]\)\?\)\?\)\|\%([<>=][0-9]\+[ymwd]\)\|\%(`[^`]\+`\)\|\%(\$[a-zA-Z0-9_-]\+\)\)" contains=muttrcShellString,muttrcVariable
+syn match muttrcSimplePat contained "!\?\^\?[~][bBcCefhHiLstxy]\s*" nextgroup=muttrcSimplePatRXContainer
+syn match muttrcSimplePat contained "!\?\^\?[%][bBcCefhHiLstxy]\s*" nextgroup=muttrcSimplePatString
+syn match muttrcSimplePat contained "!\?\^\?[=][bcCefhHiLstxy]\s*" nextgroup=muttrcSimplePatString
+syn region muttrcSimplePat contained keepend start=+!\?\^\?[~](+ end=+)+ contains=muttrcSimplePat
+"syn match muttrcSimplePat contained /'[^~=%][^']*/ contains=muttrcRXString
+syn region muttrcSimplePatString contained keepend start=+"+ end=+"+ skip=+\\"+
+syn region muttrcSimplePatString contained keepend start=+'+ end=+'+ skip=+\\'+
+syn region muttrcSimplePatString contained keepend start=+[^ 	"']+ skip=+\\ + end=+\s+re=e-1
+syn region muttrcSimplePatRXContainer contained keepend start=+"+ end=+"+ skip=+\\"+ contains=muttrcRXString
+syn region muttrcSimplePatRXContainer contained keepend start=+'+ end=+'+ skip=+\\'+ contains=muttrcRXString
+syn region muttrcSimplePatRXContainer contained keepend start=+[^ 	"']+ skip=+\\ + end=+\s+re=e-1 contains=muttrcRXString
+syn match muttrcSimplePatMetas contained /[(|)]/
+
+syn match muttrcOptSimplePat contained skipwhite /[~=%!(^].*/ contains=muttrcSimplePat,muttrcSimplePatMetas
+syn match muttrcOptSimplePat contained skipwhite /[^~=%!(^].*/ contains=muttrcRXString
+syn region muttrcOptPattern contained matchgroup=Type keepend start=+"+ skip=+\\"+ end=+"+ contains=muttrcOptSimplePat,muttrcUnHighlightSpace nextgroup=muttrcString,muttrcStringNL
+syn region muttrcOptPattern contained matchgroup=Type keepend skipwhite start=+'+ skip=+\\'+ end=+'+ contains=muttrcOptSimplePat,muttrcUnHighlightSpace nextgroup=muttrcString,muttrcStringNL
+syn region muttrcOptPattern contained keepend skipwhite start=+[~](+ end=+)+ skip=+\\)+ contains=muttrcSimplePat nextgroup=muttrcString,muttrcStringNL
+syn match muttrcOptPattern contained skipwhite /[~][A-Za-z]/ contains=muttrcSimplePat nextgroup=muttrcString,muttrcStringNL
+syn match muttrcOptPattern contained skipwhite /[.]/ nextgroup=muttrcString,muttrcStringNL
+" Keep muttrcPattern and muttrcOptPattern synchronized
+syn region muttrcPattern contained matchgroup=Type keepend skipwhite start=+"+ skip=+\\"+ end=+"+ contains=muttrcSimplePat,muttrcUnHighlightSpace,muttrcSimplePatMetas
+syn region muttrcPattern contained matchgroup=Type keepend skipwhite start=+'+ skip=+\\'+ end=+'+ contains=muttrcSimplePat,muttrcUnHighlightSpace,muttrcSimplePatMetas
+syn region muttrcPattern contained keepend skipwhite start=+[~](+ end=+)+ skip=+\\)+ contains=muttrcSimplePat
+syn match muttrcPattern contained skipwhite /[~][A-Za-z]/ contains=muttrcSimplePat
+syn match muttrcPattern contained skipwhite /[.]/
+syn region muttrcPatternInner contained keepend start=+"[~=%!(^]+ms=s+1 skip=+\\"+ end=+"+me=e-1 contains=muttrcSimplePat,muttrcUnHighlightSpace,muttrcSimplePatMetas
+syn region muttrcPatternInner contained keepend start=+'[~=%!(^]+ms=s+1 skip=+\\'+ end=+'+me=e-1 contains=muttrcSimplePat,muttrcUnHighlightSpace,muttrcSimplePatMetas
+
+" Colour definitions takes object, foreground and background arguments (regexps excluded).
+syn match muttrcColorMatchCount	contained "[0-9]\+"
+syn match muttrcColorMatchCountNL contained skipwhite skipnl "\s*\\$" nextgroup=muttrcColorMatchCount,muttrcColorMatchCountNL
+syn region muttrcColorRXPat	contained start=+\s*'+ skip=+\\'+ end=+'\s*+ keepend skipwhite contains=muttrcRXString2 nextgroup=muttrcColorMatchCount,muttrcColorMatchCountNL
+syn region muttrcColorRXPat	contained start=+\s*"+ skip=+\\"+ end=+"\s*+ keepend skipwhite contains=muttrcRXString2 nextgroup=muttrcColorMatchCount,muttrcColorMatchCountNL
+syn keyword muttrcColorField	skipwhite contained
+			\ attachment body bold error hdrdefault header index indicator markers message
+			\ normal prompt quoted search sidebar-divider sidebar-flagged sidebar-highlight
+			\ sidebar-indicator sidebar-new sidebar-spoolfile signature status tilde tree
+			\ underline
+syn match   muttrcColorField	contained "\<quoted\d\=\>"
+if use_mutt_sidebar == 1
+    syn keyword muttrcColorField contained sidebar_new
+endif
+syn keyword muttrcColor	contained black blue cyan default green magenta red white yellow
+syn keyword muttrcColor	contained brightblack brightblue brightcyan brightdefault brightgreen brightmagenta brightred brightwhite brightyellow
+syn match   muttrcColor	contained "\<\%(bright\)\=color\d\{1,3}\>"
+" Now for the structure of the color line
+syn match muttrcColorRXNL	contained skipnl "\s*\\$" nextgroup=muttrcColorRXPat,muttrcColorRXNL
+syn match muttrcColorBG 	contained /\s*[$]\?\w\+/ contains=muttrcColor,muttrcVariable,muttrcUnHighlightSpace nextgroup=muttrcColorRXPat,muttrcColorRXNL
+syn match muttrcColorBGNL	contained skipnl "\s*\\$" nextgroup=muttrcColorBG,muttrcColorBGNL
+syn match muttrcColorFG 	contained /\s*[$]\?\w\+/ contains=muttrcColor,muttrcVariable,muttrcUnHighlightSpace nextgroup=muttrcColorBG,muttrcColorBGNL
+syn match muttrcColorFGNL	contained skipnl "\s*\\$" nextgroup=muttrcColorFG,muttrcColorFGNL
+syn match muttrcColorContext 	contained /\s*[$]\?\w\+/ contains=muttrcColorField,muttrcVariable,muttrcUnHighlightSpace nextgroup=muttrcColorFG,muttrcColorFGNL
+syn match muttrcColorNL 	contained skipnl "\s*\\$" nextgroup=muttrcColorContext,muttrcColorNL
+syn match muttrcColorKeyword	contained /^\s*color\s\+/ nextgroup=muttrcColorContext,muttrcColorNL
+syn region muttrcColorLine keepend start=/^\s*color\s\+\%(index\|header\)\@!/ skip=+\\$+ end=+$+ contains=muttrcColorKeyword,muttrcComment,muttrcUnHighlightSpace
+" Now for the structure of the color index line
+syn match muttrcPatternNL	contained skipnl "\s*\\$" nextgroup=muttrcPattern,muttrcPatternNL
+syn match muttrcColorBGI	contained /\s*[$]\?\w\+\s*/ contains=muttrcColor,muttrcVariable,muttrcUnHighlightSpace nextgroup=muttrcPattern,muttrcPatternNL
+syn match muttrcColorBGNLI	contained skipnl "\s*\\$" nextgroup=muttrcColorBGI,muttrcColorBGNLI
+syn match muttrcColorFGI	contained /\s*[$]\?\w\+/ contains=muttrcColor,muttrcVariable,muttrcUnHighlightSpace nextgroup=muttrcColorBGI,muttrcColorBGNLI
+syn match muttrcColorFGNLI	contained skipnl "\s*\\$" nextgroup=muttrcColorFGI,muttrcColorFGNLI
+syn match muttrcColorContextI	contained /\s*\<index\>/ contains=muttrcUnHighlightSpace nextgroup=muttrcColorFGI,muttrcColorFGNLI
+syn match muttrcColorNLI	contained skipnl "\s*\\$" nextgroup=muttrcColorContextI,muttrcColorNLI
+syn match muttrcColorKeywordI	contained skipwhite /\<color\>/ nextgroup=muttrcColorContextI,muttrcColorNLI
+syn region muttrcColorLine keepend skipwhite start=/\<color\s\+index\>/ skip=+\\$+ end=+$+ contains=muttrcColorKeywordI,muttrcComment,muttrcUnHighlightSpace
+" Now for the structure of the color header line
+syn match muttrcRXPatternNL	contained skipnl "\s*\\$" nextgroup=muttrcRXString,muttrcRXPatternNL
+syn match muttrcColorBGH	contained /\s*[$]\?\w\+\s*/ contains=muttrcColor,muttrcVariable,muttrcUnHighlightSpace nextgroup=muttrcRXString,muttrcRXPatternNL
+syn match muttrcColorBGNLH	contained skipnl "\s*\\$" nextgroup=muttrcColorBGH,muttrcColorBGNLH
+syn match muttrcColorFGH	contained /\s*[$]\?\w\+/ contains=muttrcColor,muttrcVariable,muttrcUnHighlightSpace nextgroup=muttrcColorBGH,muttrcColorBGNLH
+syn match muttrcColorFGNLH	contained skipnl "\s*\\$" nextgroup=muttrcColorFGH,muttrcColorFGNLH
+syn match muttrcColorContextH	contained /\s*\<header\>/ contains=muttrcUnHighlightSpace nextgroup=muttrcColorFGH,muttrcColorFGNLH
+syn match muttrcColorNLH	contained skipnl "\s*\\$" nextgroup=muttrcColorContextH,muttrcColorNLH
+syn match muttrcColorKeywordH	contained skipwhite /\<color\>/ nextgroup=muttrcColorContextH,muttrcColorNLH
+syn region muttrcColorLine keepend skipwhite start=/\<color\s\+header\>/ skip=+\\$+ end=+$+ contains=muttrcColorKeywordH,muttrcComment,muttrcUnHighlightSpace
+" And now color's brother:
+syn region muttrcUnColorPatterns contained skipwhite start=+\s*'+ end=+'+ skip=+\\'+ contains=muttrcPattern nextgroup=muttrcUnColorPatterns,muttrcUnColorPatNL
+syn region muttrcUnColorPatterns contained skipwhite start=+\s*"+ end=+"+ skip=+\\"+ contains=muttrcPattern nextgroup=muttrcUnColorPatterns,muttrcUnColorPatNL
+syn match muttrcUnColorPatterns contained skipwhite /\s*[^'"\s]\S\*/ contains=muttrcPattern nextgroup=muttrcUnColorPatterns,muttrcUnColorPatNL
+syn match muttrcUnColorPatNL	contained skipwhite skipnl /\s*\\$/ nextgroup=muttrcUnColorPatterns,muttrcUnColorPatNL
+syn match muttrcUnColorAll	contained skipwhite /[*]/
+syn match muttrcUnColorAPNL	contained skipwhite skipnl /\s*\\$/ nextgroup=muttrcUnColorPatterns,muttrcUnColorAll,muttrcUnColorAPNL
+syn match muttrcUnColorIndex	contained skipwhite /\s*index\s\+/ nextgroup=muttrcUnColorPatterns,muttrcUnColorAll,muttrcUnColorAPNL
+syn match muttrcUnColorIndexNL	contained skipwhite skipnl /\s*\\$/ nextgroup=muttrcUnColorIndex,muttrcUnColorIndexNL
+syn match muttrcUnColorKeyword	contained skipwhite /^\s*uncolor\s\+/ nextgroup=muttrcUnColorIndex,muttrcUnColorIndexNL
+syn region muttrcUnColorLine keepend start=+^\s*uncolor\s+ skip=+\\$+ end=+$+ contains=muttrcUnColorKeyword,muttrcComment,muttrcUnHighlightSpace
+
+" Mono are almost like color (ojects inherited from color)
+syn keyword muttrcMonoAttrib	contained bold none normal reverse standout underline
+syn keyword muttrcMono		contained mono		skipwhite nextgroup=muttrcColorField
+syn match   muttrcMonoLine	"^\s*mono\s\+\S\+"	skipwhite nextgroup=muttrcMonoAttrib contains=muttrcMono
+
+" Define the default highlighting.
+" Only when an item doesn't have highlighting yet
+
+hi def link muttrcComment		Comment
+hi def link muttrcEscape		SpecialChar
+hi def link muttrcRXChars		SpecialChar
+hi def link muttrcString		String
+hi def link muttrcRXString		String
+hi def link muttrcRXString2	String
+hi def link muttrcSpecial		Special
+hi def link muttrcHooks		Type
+hi def link muttrcGroupFlag	Type
+hi def link muttrcGroupDef		Macro
+hi def link muttrcAddrDef		muttrcGroupFlag
+hi def link muttrcRXDef		muttrcGroupFlag
+hi def link muttrcRXPat		String
+hi def link muttrcAliasGroupName	Macro
+hi def link muttrcAliasKey	        Identifier
+hi def link muttrcUnAliasKey	Identifier
+hi def link muttrcAliasEncEmail	Identifier
+hi def link muttrcAliasParens	Type
+hi def link muttrcSetNumAssignment	Number
+hi def link muttrcSetBoolAssignment	Boolean
+hi def link muttrcSetQuadAssignment	Boolean
+hi def link muttrcSetStrAssignment	String
+hi def link muttrcEmail		Special
+hi def link muttrcVariableInner	Special
+hi def link muttrcEscapedVariable	String
+hi def link muttrcHeader		Type
+hi def link muttrcKeySpecial	SpecialChar
+hi def link muttrcKey		Type
+hi def link muttrcKeyName		SpecialChar
+hi def link muttrcVarBool		Identifier
+hi def link muttrcVarQuad		Identifier
+hi def link muttrcVarNum		Identifier
+hi def link muttrcVarStr		Identifier
+hi def link muttrcMenu		Identifier
+hi def link muttrcCommand		Keyword
+hi def link muttrcMacroDescr	String
+hi def link muttrcAction		Macro
+hi def link muttrcBadAction	Error
+hi def link muttrcBindFunction	Error
+hi def link muttrcBindMenuList	Error
+hi def link muttrcFunction		Macro
+hi def link muttrcGroupKeyword	muttrcCommand
+hi def link muttrcGroupLine	Error
+hi def link muttrcSubscribeKeyword	muttrcCommand
+hi def link muttrcSubscribeLine	Error
+hi def link muttrcListsKeyword	muttrcCommand
+hi def link muttrcListsLine	Error
+hi def link muttrcAlternateKeyword	muttrcCommand
+hi def link muttrcAlternatesLine	Error
+hi def link muttrcAttachmentsLine	muttrcCommand
+hi def link muttrcAttachmentsFlag	Type
+hi def link muttrcAttachmentsMimeType	String
+hi def link muttrcColorLine	Error
+hi def link muttrcColorContext	Error
+hi def link muttrcColorContextI	Identifier
+hi def link muttrcColorContextH	Identifier
+hi def link muttrcColorKeyword	muttrcCommand
+hi def link muttrcColorKeywordI	muttrcColorKeyword
+hi def link muttrcColorKeywordH	muttrcColorKeyword
+hi def link muttrcColorField	Identifier
+hi def link muttrcColor		Type
+hi def link muttrcColorFG		Error
+hi def link muttrcColorFGI		Error
+hi def link muttrcColorFGH		Error
+hi def link muttrcColorBG		Error
+hi def link muttrcColorBGI		Error
+hi def link muttrcColorBGH		Error
+hi def link muttrcMonoAttrib	muttrcColor
+hi def link muttrcMono		muttrcCommand
+hi def link muttrcSimplePat	Identifier
+hi def link muttrcSimplePatString	Macro
+hi def link muttrcSimplePatMetas	Special
+hi def link muttrcPattern		Error
+hi def link muttrcUnColorLine	Error
+hi def link muttrcUnColorKeyword	muttrcCommand
+hi def link muttrcUnColorIndex	Identifier
+hi def link muttrcShellString	muttrcEscape
+hi def link muttrcRXHooks		muttrcCommand
+hi def link muttrcRXHookNot	Type
+hi def link muttrcPatHooks		muttrcCommand
+hi def link muttrcPatHookNot	Type
+hi def link muttrcFormatConditionals2 Type
+hi def link muttrcIndexFormatStr	muttrcString
+hi def link muttrcIndexFormatEscapes muttrcEscape
+hi def link muttrcIndexFormatConditionals muttrcFormatConditionals2
+hi def link muttrcAliasFormatStr	muttrcString
+hi def link muttrcAliasFormatEscapes muttrcEscape
+hi def link muttrcAttachFormatStr	muttrcString
+hi def link muttrcAttachFormatEscapes muttrcEscape
+hi def link muttrcAttachFormatConditionals muttrcFormatConditionals2
+hi def link muttrcComposeFormatStr	muttrcString
+hi def link muttrcComposeFormatEscapes muttrcEscape
+hi def link muttrcFolderFormatStr	muttrcString
+hi def link muttrcFolderFormatEscapes muttrcEscape
+hi def link muttrcFolderFormatConditionals muttrcFormatConditionals2
+hi def link muttrcMixFormatStr	muttrcString
+hi def link muttrcMixFormatEscapes muttrcEscape
+hi def link muttrcMixFormatConditionals muttrcFormatConditionals2
+hi def link muttrcPGPFormatStr	muttrcString
+hi def link muttrcPGPFormatEscapes muttrcEscape
+hi def link muttrcPGPFormatConditionals muttrcFormatConditionals2
+hi def link muttrcPGPCmdFormatStr	muttrcString
+hi def link muttrcPGPCmdFormatEscapes muttrcEscape
+hi def link muttrcPGPCmdFormatConditionals muttrcFormatConditionals2
+hi def link muttrcStatusFormatStr	muttrcString
+hi def link muttrcStatusFormatEscapes muttrcEscape
+hi def link muttrcStatusFormatConditionals muttrcFormatConditionals2
+hi def link muttrcPGPGetKeysFormatStr	muttrcString
+hi def link muttrcPGPGetKeysFormatEscapes muttrcEscape
+hi def link muttrcSmimeFormatStr	muttrcString
+hi def link muttrcSmimeFormatEscapes muttrcEscape
+hi def link muttrcSmimeFormatConditionals muttrcFormatConditionals2
+hi def link muttrcTimeEscapes	muttrcEscape
+hi def link muttrcPGPTimeEscapes	muttrcEscape
+hi def link muttrcStrftimeEscapes	Type
+hi def link muttrcStrftimeFormatStr muttrcString
+hi def link muttrcFormatErrors Error
+
+hi def link muttrcBindFunctionNL	SpecialChar
+hi def link muttrcBindKeyNL	SpecialChar
+hi def link muttrcBindMenuListNL	SpecialChar
+hi def link muttrcMacroDescrNL	SpecialChar
+hi def link muttrcMacroBodyNL	SpecialChar
+hi def link muttrcMacroKeyNL	SpecialChar
+hi def link muttrcMacroMenuListNL	SpecialChar
+hi def link muttrcColorMatchCountNL SpecialChar
+hi def link muttrcColorNL		SpecialChar
+hi def link muttrcColorRXNL	SpecialChar
+hi def link muttrcColorBGNL	SpecialChar
+hi def link muttrcColorFGNL	SpecialChar
+hi def link muttrcAliasNameNL	SpecialChar
+hi def link muttrcAliasENNL	SpecialChar
+hi def link muttrcAliasNL		SpecialChar
+hi def link muttrcUnAliasNL	SpecialChar
+hi def link muttrcAliasGroupDefNL	SpecialChar
+hi def link muttrcAliasEncEmailNL	SpecialChar
+hi def link muttrcPatternNL	SpecialChar
+hi def link muttrcUnColorPatNL	SpecialChar
+hi def link muttrcUnColorAPNL	SpecialChar
+hi def link muttrcUnColorIndexNL	SpecialChar
+hi def link muttrcStringNL		SpecialChar
+
+
+let b:current_syntax = "muttrc"
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
+"EOF	vim: ts=8 noet tw=100 sw=8 sts=0 ft=vim
diff --git c/doc/mutt.css w/doc/mutt.css
index 5a37b3c..d7ff017 100644
--- c/doc/mutt.css
+++ w/doc/mutt.css
@@ -9,17 +9,24 @@ div.table-contents table td, div.informaltable td, div.table-contents table th,
 div.table-contents table th, div.informaltable table th {
     font-family:sans-serif;
     background:#d0d0d0;
-    font-weight:normal;
+    font-weight:bold;
     vertical-align:top;
 }
-div.cmdsynopsis { border-left:1px solid #707070; padding-left:5px; }
+div.cmdsynopsis { border-left:1px solid #707070; padding-left: 1em; }
 li div.cmdsynopsis { border-left:none; padding-left:0px; }
-pre.screen, div.note { background:#f0f0f0; border:1px solid #c0c0c0; padding:5px; margin-left:2%; margin-right:2%; }
+li p { margin: 0; }
+pre.screen, div.note { border:1px solid #c0c0c0; margin-left:2%; margin-right:2%; }
+pre.screen { color: #ffffff; background:#000000; padding: 0.5em; }
+div.note { background:#ffff80; padding: 0.5em; }
 div.example p.title { margin-left:2%; }
 div.note h3 { font-size:small; font-style:italic; font-variant: small-caps; }
 div.note h3:after { content: ":" }
 div.note { margin-bottom: 5px; }
-.command { font-family: monospace; font-weight: normal; }
+div.literallayout, .command { font-family: monospace; font-weight: normal; }
 .command strong { font-weight: normal; }
 tr { vertical-align: top; }
-.comment { color:#707070; }
+.comment { color:#00c000; }
+code.literal { background: #f0f0f0; color: #000000; }
+span.indicator { background: #000060; color: #ffffff; }
+span.highlight { background: #404040; color: #ffffff; }
+span.reverse { background: #ffffff; color: #000000; }
diff --git c/doc/mutt.man w/doc/mutt.man
index d29294f..b5b7337 100644
--- c/doc/mutt.man
+++ w/doc/mutt.man
@@ -23,8 +23,8 @@ mutt \- The Mutt Mail User Agent
 .SH SYNOPSIS
 .PP
 .B mutt
-[\-nRyzZ]
-[\-e \fIcmd\fP] [\-F \fIfile\fP] [\-m \fItype\fP] [\-f \fIfile\fP]
+[\-GnRyzZ]
+[\-e \fIcmd\fP] [\-F \fIfile\fP] [\-g \fIserver\fP] [\-m \fItype\fP] [\-f \fIfile\fP]
 .PP
 .B mutt 
 [\-Enx] 
@@ -104,6 +104,10 @@ files.
 Specify which mailbox to load.
 .IP "-F \fImuttrc\fP"
 Specify an initialization file to read instead of ~/.muttrc
+.IP "-g \fIserver\fP"
+Start Mutt with a listing of subscribed newsgroups at specified news server.
+.IP "-G"
+Start Mutt with a listing of subscribed newsgroups.
 .IP "-h"
 Display help.
 .IP "-H \fIdraft\fP"
diff --git c/doc/muttbug.man w/doc/muttbug.man
deleted file mode 100644
index 6b71c99..0000000
--- c/doc/muttbug.man
+++ /dev/null
@@ -1,200 +0,0 @@
-.\" -*-nroff-*-
-.\"
-.\"
-.\"     Copyright (C) 1996-2000 Thomas Roessler <roessler@does-not-exist.org>
-.\" 
-.\"     This program is free software; you can redistribute it and/or modify
-.\"     it under the terms of the GNU General Public License as published by
-.\"     the Free Software Foundation; either version 2 of the License, or
-.\"     (at your option) any later version.
-.\" 
-.\"     This program is distributed in the hope that it will be useful,
-.\"     but WITHOUT ANY WARRANTY; without even the implied warranty of
-.\"     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-.\"     GNU General Public License for more details.
-.\" 
-.\"     You should have received a copy of the GNU General Public License
-.\"     along with this program; if not, write to the Free Software
-.\"     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
-.\"
-.TH flea 1 "July 2000" Unix "User Manuals"
-.SH NAME
-flea \- Report a bug (or rather a flea) in mutt.
-.SH SYNOPSIS
-.PP
-.B flea
-.SH DESCRIPTION
-.PP
-.B flea
-is a shell script which helps you to submit a bug report against the 
-.BR mutt (1)
-mail user agent.
-.PP
-If you invoke 
-.BR flea , 
-you'll first be prompted for a short
-description of the problem you experience.  This will be used as the
-bug report's subject line, so it should be concise, but informative.
-.PP
-You are then asked to assign an initial severity level to the
-problem you observe; 
-.B flea
-will give you a description which severity level is appropriate or
-not.
-.PP
-Then, you are asked for the location of a core dump (normally named
-.BR core )
-which may have been left over by a crash of your 
-.BR mutt (1).
-You can just type \(lqno\(rq here, or you can enter the path leading 
-to a core dump.
-.B flea
-will try to use either
-.BR sdb (1),
-.BR dbx (1),
-or
-.BR gdb (1)
-to extract some information from this core dump which may be helpful
-to developers in order to determine the reason for the crash.
-.PP
-Finally, you are asked whether or not you want to include personal
-and system 
-.BR mutt (1)
-configuration files with the bug report.  If at all possible, we
-urge you to answer these questions with \(lqyes\(rq, since a
-reference configuration makes it incredibly easier to track down a
-problem.
-.PP
-If you are using Debian GNU/Linux,
-.B flea
-will now check whether or not 
-.B mutt
-has been installed as a Debian
-package on your system, and suggest to file the bug against the
-.BR mutt (1)
-and Debian bug tracking systems.  This option was added since the 
-.BR mutt (1)
-project uses another instantiation of the Debian bug tracking
-system, so submitting bugs against both systems in one pass is
-simple.
-.PP
-You are then dropped into your favorite editor as determined by the 
-.B EDITOR
-and
-.B VISUAL
-environment variables.  
-.PP
-Please give us details about the problem in the empty space below
-the line reading \(lqPlease type your report below this line\(rq.
-We are most interested in precise information on what symptoms you
-observe and what steps may be used to reproduce the bug.  Chances
-are that problems which can easily be reproduced will be fixed
-quickly.  So please take some time when filling out this part of the
-template.
-.PP
-The remainder of the template contains various kinds of information
-gathered from your system, including output of the
-.BR uname (1)
-command, output from
-.BR mutt (1)
-itself, and your system's 
-.BR mutt (1)
-configuration files.  You may wish to browse through this part of
-the bug report form in order to avoid leaking confidential
-information to the public.
-.PP
-If you leave the editor, 
-.B flea
-will give you the option to review, re-edit, submit, or abandon your
-bug report.  If you decide to submit it, a mail message containing
-your report will be sent to <fleas@mutt.org>.  You'll receive a
-copy of this message.
-.PP
-While your bug report is being processed by the bug tracking system,
-you will receive various e-mail messages from the bug tracking
-system informing you about what's going on: Once your bug report has
-been entered into the bug tracking system, it will be assigned a
-unique serial number about which you are informed via e-mail.  If
-you wish to submit additional information about the bug, you can
-just send it to the address
-.BR fleas@mutt.org
-with #\fIserial\fP in the subject.
-.PP
-Later, you will most likely receive questions from the developers
-about the problem you observed, and you will eventually be informed
-that your bug report has been closed.  This means that the bug has
-been fixed at least in the
-.BR hg (1)
-repository.  If the answers you receive don't satisfy you, don't
-hesitate to contact the developers directly under
-.BR mutt-dev@mutt.org.
-.PP
-You can also browse your bug report and all additional information
-and replies connected to it using the bug tracking system's Web
-interface under the following URL:
-http://bugs.mutt.org/
-.SH
-ENVIRONMENT
-.PP
-.B flea
-will use the following environment variables:
-.IP "EMAIL"
-Your electronic mail address.  Will be used to set the bug report's
-From header, and to send you a copy of the report.
-.IP "LOGNAME"
-Your login name.  If the
-.B EMAIL
-environment variable isn't set, this will be used instead to send
-you a copy of the report.  Setting the sender will be left to 
-.BR sendmail (1)
-on your system.
-.IP "REPLYTO"
-If set, the bug report will contain a Reply-To header with the
-e-mail address contained in this environment variable.
-.IP "ORGANIZATION"
-If set, the bug report will contain an Organization header with the
-contents of this environment variable.
-.IP "PAGER"
-If set, this environment variable will be expected to contain the
-path to your favorite pager for viewing the bug report.  If unset, 
-.BR more (1)
-will be used.
-.IP "VISUAL"
-If set, this environment variable will be expected to contain the
-path to your favorite visual editor.
-.IP "EDITOR"
-If set, this environment variable will be expected to contain the
-path to your favorite editor.  This variable is examined if and only
-if the 
-.B VISUAL
-environment variable is unset.  If
-.B EDITOR
-is unset, 
-.BR vi (1)
-will be used to edit the bug report.
-.SH
-FILES
-.PP
-.IP "core"
-If present, this file may contain a post-mortem memory dump of mutt.
-It will be inspected using the debugger installed on your system.
-.SH 
-SEE ALSO
-.PP
-.BR dbx (1),
-.BR gdb (1),
-.BR lynx (1),
-.BR mutt (1),
-.BR muttrc (5),
-.BR sdb (1),
-.BR sendmail (1),
-.BR uname (1),
-.BR vi (1)
-.PP
-The mutt bug tracking system: http://bugs.mutt.org/
-.SH
-AUTHOR
-.PP
-.B flea
-and this manual page were written by Thomas Roessler
-<roessler@does-not-exist.org>.
diff --git c/doc/muttrc.attach-headers-color w/doc/muttrc.attach-headers-color
new file mode 100644
index 0000000..71fa278
--- /dev/null
+++ w/doc/muttrc.attach-headers-color
@@ -0,0 +1,26 @@
+# Example NeoMutt config file for the attach-headers-color feature.
+
+# Color if the attachment is autoviewed
+color   attach_headers     brightgreen     default        "Autoview"
+
+# Color only the brackets around the headers
+color   attach_headers     brightyellow    default        "^\\[--"
+color   attach_headers     brightyellow    default        "--]$"
+
+# Color the mime type and the size
+color   attach_headers     green           default        "Type: [a-z]+/[a-z0-9\-]+"
+color   attach_headers     green           default        "Size: [0-9\.]+[KM]"
+
+# Color GPGME signature checks
+color   attach_headers     brightgreen     default        "Good signature from.*"
+color   attach_headers     brightred       default        "Bad signature from.*"
+color   attach_headers     brightred       default        "BAD signature from.*"
+color   attach_headers     brightred       default        "Note: This key has expired!"
+color   attach_headers     brightmagenta   default        "Problem signature from.*"
+color   attach_headers     brightmagenta   default        "WARNING: This key is not certified with a trusted signature!"
+color   attach_headers     brightmagenta   default        "         There is no indication that the signature belongs to the owner."
+color   attach_headers     brightmagenta   default        "can't handle these multiple signatures"
+color   attach_headers     brightmagenta   default        "signature verification suppressed"
+color   attach_headers     brightmagenta   default        "invalid node with packet of type"
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.compose-to-sender w/doc/muttrc.compose-to-sender
new file mode 100644
index 0000000..bbc4324
--- /dev/null
+++ w/doc/muttrc.compose-to-sender
@@ -0,0 +1,10 @@
+# Example NeoMutt config file for the compose-to-sender feature.
+
+# --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# Compose a new email (not a reply) to the sender
+bind index,pager @ compose-to-sender
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.compress w/doc/muttrc.compress
new file mode 100644
index 0000000..7e0a0c3
--- /dev/null
+++ w/doc/muttrc.compress
@@ -0,0 +1,38 @@
+# Example NeoMutt config file for the compress feature.
+
+# This feature adds three hooks to Mutt which allow it to
+# work with compressed, or encrypted, mailboxes.
+
+# The hooks are of the form:
+#       open-hook   regexp "shell-command"
+#       close-hook  regexp "shell-command"
+#       append-hook regexp "shell-command"
+
+# The 'append-hook' is optional.
+
+# Handler for gzip compressed mailboxes
+open-hook   '\.gz$'  "gzip -cd  '%f' >  '%t'"
+close-hook  '\.gz$'  "gzip -c   '%t' >  '%f'"
+append-hook '\.gz$'  "gzip -c   '%t' >> '%f'"
+
+# Handler for bzip2 compressed mailboxes
+open-hook   '\.bz2$' "bzip2 -cd '%f' >  '%t'"
+close-hook  '\.bz2$' "bzip2 -c  '%t' >  '%f'"
+append-hook '\.bz2$' "bzip2 -c  '%t' >> '%f'"
+
+# Handler for xz compressed mailboxes
+open-hook   '\.xz$'  "xz    -cd '%f' >  '%t'"
+close-hook  '\.xz$'  "xz    -c  '%t' >  '%f'"
+append-hook '\.xz$'  "xz    -c  '%t' >> '%f'"
+
+# Handler for pgp encrypted mailboxes
+# PGP does not support appending to an encrypted file
+open-hook   '\.pgp$' "pgp -f < '%f' > '%t'"
+close-hook  '\.pgp$' "pgp -fe YourPgpUserIdOrKeyId < '%t' > '%f'"
+
+# Handler for gpg encrypted mailboxes
+# gpg does not support appending to an encrypted file
+open-hook   '\.gpg$' "gpg --decrypt < '%f' > '%t'"
+close-hook  '\.gpg$' "gpg --encrypt --recipient YourGpgUserIdOrKeyId < '%t' > '%f'"
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.cond-date w/doc/muttrc.cond-date
new file mode 100644
index 0000000..d9fe937
--- /dev/null
+++ w/doc/muttrc.cond-date
@@ -0,0 +1,16 @@
+# Example NeoMutt config file for the cond-date feature.
+#
+# The default index_format is:
+#       '%4C %Z %{%b %d} %-15.15L (%?l?%4l&%4c?) %s'
+#
+# We replace the date field '%{%b %d}', giving:
+set index_format='%4C %Z %<[y?%<[m?%<[d?%[%H:%M ]&%[%a %d]>&%[%b %d]>&%[%m/%y ]> %-15.15L (%?l?%4l&%4c?) %s'
+
+# Test  Date Range  Format String  Example
+# --------------------------------------------
+# %[d   Today       %[%H:%M ]      12:34
+# %[m   This month  %[%a %d]       Thu 12
+# %[y   This year   %[%b %d]       Dec 10
+# -     Older       %[%m/%y ]      06/15
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.encrypt-to-self w/doc/muttrc.encrypt-to-self
new file mode 100644
index 0000000..887dbe2
--- /dev/null
+++ w/doc/muttrc.encrypt-to-self
@@ -0,0 +1,13 @@
+# Example NeoMutt config file for the encrypt-to-self feature.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# Save a copy of outgoing email, encrypted to yourself
+set smime_encrypt_self = "no"
+
+# Save a copy of outgoing email, encrypted to yourself
+set pgp_encrypt_self = "no"
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.forgotten-attachment w/doc/muttrc.forgotten-attachment
new file mode 100644
index 0000000..270118b
--- /dev/null
+++ w/doc/muttrc.forgotten-attachment
@@ -0,0 +1,30 @@
+# Example NeoMutt config file for the forgotten-attachment feature.
+
+# The 'forgotten-attachment' feature provides a new setting for Mutt that
+# alerts the user if the message body contains a certain regular expression but there are
+# no attachments added. This is meant to ensure that the user does not forget
+# to attach a file after promising to do so in the mail.
+
+# Ask if the user wishes to abort sending if $attach_keyword is found in the
+# body, but no attachments have been added
+# It can be set to:
+#    "yes"     : always abort
+#    "ask-yes" : ask whether to abort
+#    "no"      : send the mail
+set abort_noattach = no
+
+# Search for the following regular expression in the body of the email
+
+# English: attach, attached, attachment, attachments
+set attach_keyword = "\\<attach(|ed|ments?)\\>"
+
+# Nederlands:
+# set attach_keyword = "\\<(bijvoegen|bijgevoegd|bijlage|bijlagen)\\>"
+
+# Deutsch:
+# set attach_keyword = "\\<(anhängen|angehängt|anhang|anhänge|hängt an)\\>"
+
+# Français:
+# set attach_keyword = "\\<(attaché|attachés|attache|attachons|joint|jointe|joints|jointes|joins|joignons)\\>"
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.ifdef w/doc/muttrc.ifdef
new file mode 100644
index 0000000..9dfc04e
--- /dev/null
+++ w/doc/muttrc.ifdef
@@ -0,0 +1,32 @@
+# Example NeoMutt config file for the ifdef feature.
+
+# This feature introduces three useful commands which allow you to share
+# one config file between versions of Mutt that may have different
+# features compiled in.
+
+#   ifdef  symbol config-command [args...]
+#   ifndef symbol config-command [args...]
+#   finish
+
+# The 'ifdef' command tests whether Mutt understands the name of
+# a variable, function, command or compile-time symbol.
+# If it does, then it executes a config command.
+
+# The 'ifndef' command tests whether a symbol does NOT exist.
+
+# The 'finish' command tells Mutt to stop reading current config file.
+
+# If the 'trash' variable exists, set it.
+ifdef trash 'set trash=~/Mail/trash'
+
+# If the 'tag-pattern' function exists, bind a key to it.
+ifdef tag-pattern 'bind index <F6> tag-pattern'
+
+# If the 'imap-fetch-mail' command exists, read my IMAP config.
+ifdef imap-fetch-mail 'source ~/.mutt/imap.rc'
+
+# If the compile-time symbol 'USE_SIDEBAR' does not exist, then
+# stop reading the current config file.
+ifndef USE_SIDEBAR finish
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.index-color w/doc/muttrc.index-color
new file mode 100644
index 0000000..aaacf2e
--- /dev/null
+++ w/doc/muttrc.index-color
@@ -0,0 +1,37 @@
+# Example NeoMutt config file for the index-color feature.
+
+# Entire index line
+color index white black '.*'
+
+# Author name, %A %a %F %L %n
+
+# Give the author column a dark grey background
+color index_author default color234 '.*'
+
+# Highlight a particular from (~f)
+color index_author brightyellow color234 '~fRay Charles'
+
+# Message flags, %S %Z
+# Highlight the flags for flagged (~F) emails
+color index_flags default red '~F'
+
+# Subject, %s
+# Look for a particular subject (~s)
+color index_subject brightcyan default '~s\(closes #[0-9]+\)'
+
+# Number of messages in a collapsed thread, %M
+color index_collapsed default brightblue
+
+# Date field
+color index_date green default
+
+# Message label, %y %Y
+color index_label default brightgreen
+
+# Message number, %C
+color index_number red default
+
+# Message size, %c %l
+color index_size cyan default
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.initials w/doc/muttrc.initials
new file mode 100644
index 0000000..c5c8f30
--- /dev/null
+++ w/doc/muttrc.initials
@@ -0,0 +1,27 @@
+# Example NeoMutt config file for the initials feature.
+
+# The 'initials' feature has no config of its own.
+# It adds an expando for an author's initials,
+# which can be used in the 'index_format' variable.
+
+# The default 'index_format' is:
+set index_format='%4C %Z %{%b %d} %-15.15L (%?l?%4l&%4c?) %s'
+
+# Where %L represents the author/recipient
+
+# This might look like:
+#       1   + Nov 17 David Bowie   Changesbowie    ( 689)
+#       2   ! Nov 17 Stevie Nicks  Rumours         ( 555)
+#       3   + Nov 16 Jimi Hendrix  Voodoo Child    ( 263)
+#       4   + Nov 16 Debbie Harry  Parallel Lines  ( 540)
+
+# Using the %I expando:
+set index_format='%4C %Z %{%b %d} %I (%?l?%4l&%4c?) %s'
+
+# This might look like:
+#       1   + Nov 17 DB Changesbowie    ( 689)
+#       2   ! Nov 17 SN Rumours         ( 555)
+#       3   + Nov 16 JH Voodoo Child    ( 263)
+#       4   + Nov 16 DH Parallel Lines  ( 540)
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.keywords w/doc/muttrc.keywords
new file mode 100644
index 0000000..76b229f
--- /dev/null
+++ w/doc/muttrc.keywords
@@ -0,0 +1,23 @@
+# Example NeoMutt config file for the keywords feature.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# Should Mutt save the keywords to whatever keyword it came from?
+set keywords_legacy = yes
+
+# Should Mutt use the "Keywords:" header?
+set keywords_standard = no
+
+# How should the keywords be separated?
+set xlabel_delimiter = ""
+
+# --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# Bind 'y' to edit labels/keywords
+bind index,pager y edit-label
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.limit-current-thread w/doc/muttrc.limit-current-thread
new file mode 100644
index 0000000..9888d77
--- /dev/null
+++ w/doc/muttrc.limit-current-thread
@@ -0,0 +1,6 @@
+# Example NeoMutt config file for the limit-current-thread feature.
+
+# Limit view to current thread
+bind index <esc>L limit-current-thread
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.man.head w/doc/muttrc.man.head
index b237c5a..6ab69a7 100644
--- c/doc/muttrc.man.head
+++ w/doc/muttrc.man.head
@@ -358,7 +358,24 @@ You may use multiple
 \fBcrypt-hook\fPs with the same \fIregexp\fP; multiple matching
 \fBcrypt-hook\fPs result in the use of multiple \fIkey-id\fPs for
 a recipient.
-
+.PP
+.nf
+\fBopen-hook\fP \fIregexp\fP "\fIcommand\fP"
+\fBclose-hook\fP \fIregexp\fP "\fIcommand\fP"
+\fBappend-hook\fP \fIregexp\fP "\fIcommand\fP"
+.fi
+.IP
+These commands provide a way to handle compressed folders. The given
+\fBregexp\fP specifies which folders are taken as compressed (e.g.
+"\fI\\\\.gz$\fP"). The commands tell Mutt how to uncompress a folder
+(\fBopen-hook\fP), compress a folder (\fBclose-hook\fP) or append a
+compressed mail to a compressed folder (\fBappend-hook\fP). The
+\fIcommand\fP string is the
+.BR printf (3)
+like format string, and it should accept two parameters: \fB%f\fP,
+which is replaced with the (compressed) folder name, and \fB%t\fP
+which is replaced with the name of the temporary folder to which to
+write.
 .TP
 \fBpush\fP \fIstring\fP
 This command adds the named \fIstring\fP to the keyboard buffer.
diff --git c/doc/muttrc.nested-if w/doc/muttrc.nested-if
new file mode 100644
index 0000000..8ce172f
--- /dev/null
+++ w/doc/muttrc.nested-if
@@ -0,0 +1,24 @@
+# Example NeoMutt config file for the nested-if feature.
+
+# This feature uses the format: '%<VAR?TRUE&FALSE>' for conditional
+# format strings that can be nested.
+
+# Example 1
+# if a thread is folded
+#       display the number of messages (%M)
+# else if we know how many lines in the message
+#       display lines in message (%l)
+# else display the size of the message in bytes (%c)
+set index_format='%4C %Z %{%b %d} %-25.25n %s%> %<M?%M Msgs &%<l?%l Lines&%c Bytes>>'
+
+# Example 2
+# if a thread is folded
+#       display the number of messages (%M)
+#       display the subject (%s)
+# else if we know how many lines in the message
+#       display lines in message (%l)
+# else
+#       display the size of the message in bytes (%c)
+set index_format='%4C %Z %{%b %d} %-25.25n %<M?[%M] %s&%s%* %<l?%l&%c>>'
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.new-mail w/doc/muttrc.new-mail
new file mode 100644
index 0000000..c615e37
--- /dev/null
+++ w/doc/muttrc.new-mail
@@ -0,0 +1,18 @@
+# Example NeoMutt config file for the new-mail feature.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# Set the command you want mutt to execute upon the receipt of a new email
+set new_mail_command = ""
+
+# Linux example:
+# set new_command="notify-send --icon='/home/santiago/Pictures/mutt.png' 'New Email in %f' '%n new messages, %u unread.' &"
+
+# OS X example:
+# set new_mail_command="terminal-notifier -title '%v' -subtitle 'New Mail in %f' -message '%n new messages, %u unread.' -activate 'com.apple.Terminal'"
+
+# --------------------------------------------------------------------------
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.nntp w/doc/muttrc.nntp
new file mode 100644
index 0000000..45498e2
--- /dev/null
+++ w/doc/muttrc.nntp
@@ -0,0 +1,94 @@
+# Example NeoMutt config file for the nntp feature.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+set ask_follow_up = no
+set ask_x_comment_to = no
+set catchup_newsgroup = ask-yes
+set followup_to_poster = ask-yes
+set group_index_format = '%4C %M%N %5s  %-45.45f %d'
+set inews = ''
+set mime_subject = yes
+set newsgroups_charset = utf-8
+set newsrc = '~/.newsrc'
+set news_cache_dir = '~/.mutt'
+set news_server = ''
+set nntp_authenticators = ''
+set nntp_context = 1000
+set nntp_listgroup = yes
+set nntp_load_description = yes
+set nntp_pass = ''
+set nntp_poll = 60
+set nntp_user = ''
+set post_moderated = ask-yes
+set save_unsubscribed = no
+set show_new_news = yes
+set show_only_unread = no
+set x_comment_to = no
+
+# --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# mark all articles in newsgroup as read
+bind browser,index y catchup
+
+# open a different newsgroup
+bind index,pager i change-newsgroup
+
+# edit the Followup-To field
+bind compose o edit-followup-to
+
+# edit the newsgroups list
+bind compose N edit-newsgroups
+
+# edit the X-Comment-To field
+bind compose x edit-x-comment-to
+
+# followup to newsgroup
+bind attach,index,pager F followup-message
+
+# post message to newsgroup
+bind index,pager P post-message
+
+# load list of all newsgroups from NNTP server
+bind browser g reload-active
+
+# subscribe to current mbox (IMAP/NNTP only)
+bind browser s subscribe
+
+# subscribe to newsgroups matching a pattern
+bind browser S subscribe-pattern
+
+# mark all articles in newsgroup as unread
+bind browser Y uncatchup
+
+# unsubscribe from current mbox (IMAP/NNTP only)
+bind browser u unsubscribe
+
+# unsubscribe from newsgroups matching a pattern
+bind browser U unsubscribe-pattern
+
+# open a different newsgroup in read only mode
+bind index,pager \ei change-newsgroup-readonly
+
+# forward to newsgroup
+bind attach,index,pager \eF forward-to-group
+
+# get all children of the current message
+# bind index ??? get-children
+
+# get parent of the current message
+bind index \eG get-parent
+
+# reconstruct thread containing current message
+# bind index ??? reconstruct-thread
+
+# get message with Message-Id
+bind index \CG get-message
+
+# --------------------------------------------------------------------------
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.notmuch w/doc/muttrc.notmuch
new file mode 100644
index 0000000..d11f768
--- /dev/null
+++ w/doc/muttrc.notmuch
@@ -0,0 +1,114 @@
+# Example NeoMutt config file for the notmuch feature.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# This variable specifies notmuch query limit.
+set nm_db_limit = 0
+
+# This variable specifies the default Notmuch database in format:
+# notmuch://<absolute path>
+set nm_default_uri = ""
+
+# The messages tagged with these tags are excluded and not loaded
+# from notmuch DB to mutt unless specified explicitly.
+set nm_exclude_tags = ""
+
+# This variable specifies private notmuch tags which should not be printed
+# on screen (index, pager).
+set nm_hidden_tags = "unread,draft,flagged,passed,replied,attachment,signed,encrypted"
+
+# This option specifies timeout for Notmuch database. Default is 5 seconds.
+set nm_open_timeout = 5
+
+# This variable specifies notmuch query type, supported types: 'threads' and
+# 'messages'.
+set nm_query_type = messages
+
+# Add messages stored to the mutt record (see $record in the mutt docs)
+# also to notmuch DB.
+set nm_record = no
+
+# Tags that should be removed or added to the to the messages stored in the mutt record.
+set nm_record_tags = ""
+
+# This variable specifies notmuch tag which is used for unread messages.
+set nm_unread_tag = unread
+
+# This variable allows you to customize the file browser display for virtual
+# folders to your personal taste.
+set vfolder_format = "%6n(%6N) %f"
+
+# When set, mutt will use the first virtual mailbox (see virtual-mailboxes)
+# as a spoolfile.
+set virtual_spoolfile = no
+
+# --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# open a different virtual folder
+bind index,pager X change-vfolder
+
+# read entire thread of the current message
+bind index,pager + entire-thread
+
+# modify (notmuch) tags
+bind index,pager \` modify-labels
+
+# generate virtual folder from query
+bind index,pager \eX vfolder-from-query
+
+# modify labels and then hide message
+# bind index,pager ??? modify-labels-then-hide
+
+# toggle between mailboxes and virtual mailboxes
+# bind index,pager ??? sidebar-toggle-virtual
+
+# --------------------------------------------------------------------------
+# COMMANDS - shown with an example
+# --------------------------------------------------------------------------
+
+# virtual-mailboxes description notmuch-URI { description notmuch-URI ...}
+# virtual-mailboxes "Climbing" "notmuch://?query=climbing"
+
+# Replace some tags with icons
+# tag-transforms tag transformed-string { tag transformed-string ...}
+# tag-transforms "inbox"   "i"   \
+#                "unread"  "u"   \
+#                "replied" "↻ "  \
+#                "sent"    "➥ "  \
+#                "todo"    "T"   \
+#                "deleted" "DEL" \
+#                "invites" "CAL"
+
+# See README.notmuch for an explanation
+# tag-formats tag format-string { tag format-string ...}
+# tag-formats "inbox"   "GI" \
+#              "unread"  "GU" \
+#              "replied" "GR" \
+#              "sent"    "GS" \
+#              "todo"    "Gt" \
+#              "deleted" "GD" \
+#              "invites" "Gi"
+
+# set index_format='4C %S %[%y.%m.%d] %-18.18n %?GU?%GU& ? %?GR?%GR& ? %?GI?%GI& ? %s'
+
+# --------------------------------------------------------------------------
+# COLORS - some unpleasant examples are given
+# --------------------------------------------------------------------------
+
+# These symbols are added to the index-color feature:
+
+# an individual message tag, %G, uses tag name
+# this symbol uses a pattern
+color index_tag red white "inbox"
+
+# the transformed message tags, %g
+# this symbol does not use a pattern
+color index_tags green default
+
+# --------------------------------------------------------------------------
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.progress w/doc/muttrc.progress
new file mode 100644
index 0000000..9544423
--- /dev/null
+++ w/doc/muttrc.progress
@@ -0,0 +1,10 @@
+# Example NeoMutt config file for the progress feature.
+
+# The 'progress' feature provides clear visual feedback for
+# slow tasks, such as indexing a large folder over the net.
+
+# Set the color of the progress bar
+# White text on a red background
+color progress white red
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.quasi-delete w/doc/muttrc.quasi-delete
new file mode 100644
index 0000000..03afeba
--- /dev/null
+++ w/doc/muttrc.quasi-delete
@@ -0,0 +1,7 @@
+# Example NeoMutt config file for the quasi-delete feature.
+
+# The 'quasi-delete' function marks an email that should be hidden
+# from the index, but NOT deleted.
+bind index,pager Q quasi-delete
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.reply-with-xorig w/doc/muttrc.reply-with-xorig
new file mode 100644
index 0000000..31a76c8
--- /dev/null
+++ w/doc/muttrc.reply-with-xorig
@@ -0,0 +1,11 @@
+# Example NeoMutt config file for the reply-with-xorig feature.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# Use X-Original-To header to reply when reverse is disabled or no alternate
+# is found.
+set reply_with_xorig = "yes"
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.sidebar w/doc/muttrc.sidebar
new file mode 100644
index 0000000..6cace56
--- /dev/null
+++ w/doc/muttrc.sidebar
@@ -0,0 +1,122 @@
+# Example NeoMutt config file for the sidebar feature.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# Should the Sidebar be shown?
+set sidebar_visible = no
+
+# How wide should the Sidebar be in screen columns?
+# Note: Some characters, e.g. Chinese, take up two columns each.
+set sidebar_width = 20
+
+# Should the mailbox paths be abbreviated?
+set sidebar_short_path = no
+
+# When abbreviating mailbox path names, use any of these characters as path
+# separators.  Only the part after the last separators will be shown.
+# For file folders '/' is good.  For IMAP folders, often '.' is useful.
+set sidebar_delim_chars = '/.'
+
+# If the mailbox path is abbreviated, should it be indented?
+set sidebar_folder_indent = no
+
+# Indent mailbox paths with this string.
+set sidebar_indent_string = '  '
+
+# Make the Sidebar only display mailboxes that contain new, or flagged,
+# mail.
+set sidebar_new_mail_only = no
+
+# Any mailboxes that are whitelisted will always be visible, even if the
+# sidebar_new_mail_only option is enabled.
+sidebar_whitelist '/home/user/mailbox1'
+sidebar_whitelist '/home/user/mailbox2'
+
+# When searching for mailboxes containing new mail, should the search wrap
+# around when it reaches the end of the list?
+set sidebar_next_new_wrap = no
+
+# Show the Sidebar on the right-hand side of the screen
+set sidebar_on_right = no
+
+# The character to use as the divider between the Sidebar and the other Mutt
+# panels.
+# Note: Only the first character of this string is used.
+set sidebar_divider_char = '|'
+
+# Enable extended buffy mode to calculate total, new, and flagged
+# message counts for each mailbox.
+set mail_check_stats
+
+# Display the Sidebar mailboxes using this format string.
+set sidebar_format = '%B%?F? [%F]?%* %?N?%N/?%S'
+
+# Sort the mailboxes in the Sidebar using this method:
+#       count    - total number of messages
+#       flagged  - number of flagged messages
+#       new      - number of new messages
+#       path     - mailbox path
+#       unsorted - do not sort the mailboxes
+set sidebar_sort_method = 'unsorted'
+
+# --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# Move the highlight to the previous mailbox
+bind index,pager \Cp sidebar-prev
+
+# Move the highlight to the next mailbox
+bind index,pager \Cn sidebar-next
+
+# Open the highlighted mailbox
+bind index,pager \Co sidebar-open
+
+# Move the highlight to the previous page
+# This is useful if you have a LOT of mailboxes.
+bind index,pager <F3> sidebar-page-up
+
+# Move the highlight to the next page
+# This is useful if you have a LOT of mailboxes.
+bind index,pager <F4> sidebar-page-down
+
+# Move the highlight to the previous mailbox containing new, or flagged,
+# mail.
+bind index,pager <F5> sidebar-prev-new
+
+# Move the highlight to the next mailbox containing new, or flagged, mail.
+bind index,pager <F6> sidebar-next-new
+
+# Toggle the visibility of the Sidebar.
+bind index,pager B sidebar-toggle-visible
+
+# --------------------------------------------------------------------------
+# COLORS - some unpleasant examples are given
+# --------------------------------------------------------------------------
+# Note: All color operations are of the form:
+#       color OBJECT FOREGROUND BACKGROUND
+
+# Color of the current, open, mailbox
+# Note: This is a general Mutt option which colors all selected items.
+color indicator cyan black
+
+# Color of the highlighted, but not open, mailbox.
+color sidebar_highlight black color8
+
+# Color of the divider separating the Sidebar from Mutt panels
+color sidebar_divider color8 black
+
+# Color to give mailboxes containing flagged mail
+color sidebar_flagged red black
+
+# Color to give mailboxes containing new mail
+color sidebar_new green black
+
+# Color to give mailboxes containing no new/flagged mail, etc</emphasis>
+color sidebar_ordinary color245 default
+
+# --------------------------------------------------------------------------
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.skip-quoted w/doc/muttrc.skip-quoted
new file mode 100644
index 0000000..ab8e978
--- /dev/null
+++ w/doc/muttrc.skip-quoted
@@ -0,0 +1,10 @@
+# Example NeoMutt config file for the skip-quoted feature.
+
+# The 'S' (skip-quoted) command scrolls the pager past the quoted text (usually
+# indented with '> '.  Setting 'skip_quoted_offset' leaves some lines of quoted
+# text on screen for context.
+
+# Show three quoted lines before the reply
+set skip_quoted_offset = 3
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.status-color w/doc/muttrc.status-color
new file mode 100644
index 0000000..d10b7f1
--- /dev/null
+++ w/doc/muttrc.status-color
@@ -0,0 +1,49 @@
+# Example NeoMutt config file for the status-color feature.
+
+# The 'status-color' feature allows you to theme different parts of
+# the status bar (also when it's used by the index).
+
+# For the examples below, set some defaults
+set status_format='-%r-Mutt: %f [Msgs:%?M?%M/?%m%?n? New:%n?%?o? Old:%o?%?d? Del:%d?%?F? Flag:%F?%?t? Tag:%t?%?p? Post:%p?%?b? Inc:%b?%?l? %l?]---(%s/%S)-%>-(%P)---'
+set index_format='%4C %Z %{%b %d} %-15.15L (%?l?%4l&%4c?) %s'
+set sort=threads
+set sort_aux=last-date-received
+
+# 'status color' can take up to 2 extra parameters
+
+# color status foreground background [ regex [ num ]]
+
+# 0 extra parameters
+# Set the default color for the entire status line
+color status blue white
+
+# 1 extra parameter
+# Set the color for a matching pattern
+# color status foreground background regexp
+
+# Highlight New, Deleted, or Flagged emails
+color status brightred white '(New|Del|Flag):[0-9]+'
+
+# Highlight mailbox ordering if it's different from the default
+# First, highlight anything (*/*)
+color status brightred default '\([^)]+/[^)]+\)'
+
+# Then override the color for one specific case
+color status default   default '\(threads/last-date-received\)'
+
+# 2 extra parameters
+# Set the color for the nth submatch of a pattern
+# color status foreground background regexp num
+
+# Highlight the contents of the []s but not the [] themselves
+color status red default '\[([^]]+)\]' 1
+
+# The '1' refers to the first regex submatch, which is the inner
+# part in ()s
+
+# Highlight the mailbox
+color status brightwhite default 'Mutt: ([^ ]+)' 1
+
+# Search for 'Mutt: ' but only highlight what comes after it
+
+# vim: syntax=muttrc
diff --git c/doc/muttrc.timeout w/doc/muttrc.timeout
new file mode 100644
index 0000000..5fea2ff
--- /dev/null
+++ w/doc/muttrc.timeout
@@ -0,0 +1,10 @@
+# Example NeoMutt config file for the timeout feature.
+
+# --------------------------------------------------------------------------
+# COMMANDS - shown with an example arguments
+# --------------------------------------------------------------------------
+
+# After $timeout seconds of inactivity, run this mutt command
+timeout-hook . 'exec sync-mailbox'
+
+# vim: syntax=muttrc
diff --git c/doc/vimrc.attach-headers-color w/doc/vimrc.attach-headers-color
new file mode 100644
index 0000000..02f7147
--- /dev/null
+++ w/doc/vimrc.attach-headers-color
@@ -0,0 +1,4 @@
+" Vim syntax file for the NeoMutt attach-headers-color feature.
+
+syntax keyword muttrcColorField contained attach_headers
+
diff --git c/doc/vimrc.compose-to-sender w/doc/vimrc.compose-to-sender
new file mode 100644
index 0000000..3d9e194
--- /dev/null
+++ w/doc/vimrc.compose-to-sender
@@ -0,0 +1,4 @@
+" Vim syntax file for the NeoMutt compose-to-sender feature.
+
+syntax match muttrcFunction     contained "\<compose-to-sender\>"
+
diff --git c/doc/vimrc.compress w/doc/vimrc.compress
new file mode 100644
index 0000000..140b1ec
--- /dev/null
+++ w/doc/vimrc.compress
@@ -0,0 +1,6 @@
+" Vim syntax file for the NeoMutt compress feature.
+
+syntax keyword muttrcCommand    append-hook
+syntax keyword muttrcCommand    close-hook
+syntax keyword muttrcCommand    open-hook
+
diff --git c/doc/vimrc.encrypt-to-self w/doc/vimrc.encrypt-to-self
new file mode 100644
index 0000000..a4948a0
--- /dev/null
+++ w/doc/vimrc.encrypt-to-self
@@ -0,0 +1,5 @@
+" Vim syntax file for the NeoMutt encrypt-to-self feature.
+
+syntax keyword muttrcVarQuad    contained skipwhite smime_encrypt_self    nextgroup=muttrcSetQuadAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarQuad    contained skipwhite pgp_encrypt_self      nextgroup=muttrcSetQuadAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
diff --git c/doc/vimrc.forgotten-attachment w/doc/vimrc.forgotten-attachment
new file mode 100644
index 0000000..5eeaa2d
--- /dev/null
+++ w/doc/vimrc.forgotten-attachment
@@ -0,0 +1,6 @@
+" Vim syntax file for the NeoMutt forgotten-attachment feature.
+
+syntax keyword muttrcVarBool    skipwhite contained abort_noattach         nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarStr     contained skipwhite attach_keyword         nextgroup=muttrcVarEqualsIdxFmt
+
diff --git c/doc/vimrc.ifdef w/doc/vimrc.ifdef
new file mode 100644
index 0000000..1c3341b
--- /dev/null
+++ w/doc/vimrc.ifdef
@@ -0,0 +1,6 @@
+" Vim syntax file for the NeoMutt ifdef feature.
+
+syntax keyword muttrcCommand    ifdef
+syntax keyword muttrcCommand    ifndef
+syntax keyword muttrcCommand    finish
+
diff --git c/doc/vimrc.index-color w/doc/vimrc.index-color
new file mode 100644
index 0000000..63178ad
--- /dev/null
+++ w/doc/vimrc.index-color
@@ -0,0 +1,12 @@
+" Vim syntax file for the NeoMutt index-color feature.
+
+syntax keyword muttrcColorField contained index
+syntax keyword muttrcColorField contained index_author
+syntax keyword muttrcColorField contained index_collapsed
+syntax keyword muttrcColorField contained index_date
+syntax keyword muttrcColorField contained index_flags
+syntax keyword muttrcColorField contained index_label
+syntax keyword muttrcColorField contained index_number
+syntax keyword muttrcColorField contained index_size
+syntax keyword muttrcColorField contained index_subject
+
diff --git c/doc/vimrc.keywords w/doc/vimrc.keywords
new file mode 100644
index 0000000..4c3eabc
--- /dev/null
+++ w/doc/vimrc.keywords
@@ -0,0 +1,9 @@
+" Vim syntax file for the NeoMutt keywords feature.
+
+syntax keyword muttrcVarBool    contained skipwhite keywords_legacy       nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite keywords_standard     nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarStr     contained skipwhite xlabel_delimiter      nextgroup=muttrcVarEqualsIdxFmt
+
+syntax match muttrcFunction     contained "\<edit-label\>"
+
diff --git c/doc/vimrc.new-mail w/doc/vimrc.new-mail
new file mode 100644
index 0000000..c1628bc
--- /dev/null
+++ w/doc/vimrc.new-mail
@@ -0,0 +1,4 @@
+" Vim syntax file for the NeoMutt new-mail feature.
+
+syntax keyword muttrcVarStr     contained skipwhite new_mail_command         nextgroup=muttrcVarEqualsIdxFmt
+
diff --git c/doc/vimrc.nntp w/doc/vimrc.nntp
new file mode 100644
index 0000000..99a6939
--- /dev/null
+++ w/doc/vimrc.nntp
@@ -0,0 +1,49 @@
+" Vim syntax file for the NeoMutt nntp feature.
+
+syntax keyword muttrcVarBool    contained skipwhite ask_follow_up         nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite ask_x_comment_to      nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite mime_subject          nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite nntp_listgroup        nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite nntp_load_description nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite save_unsubscribed     nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite show_new_news         nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite show_only_unread      nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite x_comment_to          nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarNum     contained skipwhite nntp_context          nextgroup=muttrcSetNumAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarNum     contained skipwhite nntp_poll             nextgroup=muttrcSetNumAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarQuad    contained skipwhite catchup_newsgroup     nextgroup=muttrcSetQuadAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarQuad    contained skipwhite followup_to_poster    nextgroup=muttrcSetQuadAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarQuad    contained skipwhite post_moderated        nextgroup=muttrcSetQuadAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarStr     contained skipwhite group_index_format    nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite inews                 nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite newsgroups_charset    nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite newsrc                nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite news_cache_dir        nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite news_server           nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nntp_authenticators   nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nntp_pass             nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nntp_user             nextgroup=muttrcVarEqualsIdxFmt
+
+syntax match muttrcFunction     contained "\<attach-news-message\>"
+syntax match muttrcFunction     contained "\<catchup\>"
+syntax match muttrcFunction     contained "\<change-newsgroup-readonly\>"
+syntax match muttrcFunction     contained "\<change-newsgroup\>"
+syntax match muttrcFunction     contained "\<edit-followup-to\>"
+syntax match muttrcFunction     contained "\<edit-newsgroups\>"
+syntax match muttrcFunction     contained "\<edit-x-comment-to\>"
+syntax match muttrcFunction     contained "\<followup-message\>"
+syntax match muttrcFunction     contained "\<forward-to-group\>"
+syntax match muttrcFunction     contained "\<get-children\>"
+syntax match muttrcFunction     contained "\<get-message\>"
+syntax match muttrcFunction     contained "\<get-parent\>"
+syntax match muttrcFunction     contained "\<post-message\>"
+syntax match muttrcFunction     contained "\<reconstruct-thread\>"
+syntax match muttrcFunction     contained "\<reload-active\>"
+syntax match muttrcFunction     contained "\<subscribe-pattern\>"
+syntax match muttrcFunction     contained "\<toggle-read\>"
+syntax match muttrcFunction     contained "\<uncatchup\>"
+syntax match muttrcFunction     contained "\<unsubscribe-pattern\>"
+
diff --git c/doc/vimrc.notmuch w/doc/vimrc.notmuch
new file mode 100644
index 0000000..5cbcfd3
--- /dev/null
+++ w/doc/vimrc.notmuch
@@ -0,0 +1,27 @@
+" Vim syntax file for the NeoMutt notmuch feature.
+
+syntax keyword muttrcVarBool    contained skipwhite nm_record             nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite virtual_spoolfile     nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarNum     contained skipwhite nm_db_limit           nextgroup=muttrcSetNumAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarNum     contained skipwhite nm_open_timeout       nextgroup=muttrcSetNumAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarStr     contained skipwhite nm_default_uri        nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nm_exclude_tags       nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nm_hidden_tags        nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nm_query_type         nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nm_record_tags        nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nm_unread_tag         nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite vfolder_format        nextgroup=muttrcVarEqualsIdxFmt
+
+syntax keyword muttrcCommand    virtual-mailboxes
+syntax keyword muttrcCommand    tag-transforms
+syntax keyword muttrcCommand    tag-formats
+
+syntax match muttrcFunction     contained "\<change-vfolder\>"
+syntax match muttrcFunction     contained "\<entire-thread\>"
+syntax match muttrcFunction     contained "\<modify-labels-then-hide\>"
+syntax match muttrcFunction     contained "\<modify-labels\>"
+syntax match muttrcFunction     contained "\<sidebar-toggle-virtual\>"
+syntax match muttrcFunction     contained "\<vfolder-from-query\>"
+
diff --git c/doc/vimrc.progress w/doc/vimrc.progress
new file mode 100644
index 0000000..09c78cb
--- /dev/null
+++ w/doc/vimrc.progress
@@ -0,0 +1,4 @@
+" Vim syntax file for the NeoMutt progress feature.
+
+syntax keyword muttrcColorField contained progress
+
diff --git c/doc/vimrc.quasi-delete w/doc/vimrc.quasi-delete
new file mode 100644
index 0000000..4145c17
--- /dev/null
+++ w/doc/vimrc.quasi-delete
@@ -0,0 +1,4 @@
+" Vim syntax file for the NeoMutt quasi-delete feature.
+
+syntax match muttrcFunction     contained "\<quasi-delete\>"
+
diff --git c/doc/vimrc.reply-with-xorig w/doc/vimrc.reply-with-xorig
new file mode 100644
index 0000000..d5c78ea
--- /dev/null
+++ w/doc/vimrc.reply-with-xorig
@@ -0,0 +1,4 @@
+" Vim syntax file for the NeoMutt reply-with-xorig feature.
+
+syntax keyword muttrcVarBool    skipwhite contained reply_with_xorig         nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
diff --git c/doc/vimrc.sidebar w/doc/vimrc.sidebar
new file mode 100644
index 0000000..bb2a152
--- /dev/null
+++ w/doc/vimrc.sidebar
@@ -0,0 +1,33 @@
+" Vim syntax file for the NeoMutt sidebar feature.
+
+syntax keyword muttrcVarBool    contained skipwhite sidebar_folder_indent nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite sidebar_new_mail_only nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite sidebar_next_new_wrap nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite sidebar_short_path    nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite sidebar_visible       nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarNum     contained skipwhite sidebar_width         nextgroup=muttrcSetNumAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarStr     contained skipwhite sidebar_divider_char  nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite sidebar_delim_chars   nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite sidebar_format        nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite sidebar_indent_string nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite sidebar_sort_method   nextgroup=muttrcVarEqualsIdxFmt
+
+syntax keyword muttrcCommand    sidebar_whitelist
+
+syntax match muttrcFunction     contained "\<sidebar-next\>"
+syntax match muttrcFunction     contained "\<sidebar-next-new\>"
+syntax match muttrcFunction     contained "\<sidebar-open\>"
+syntax match muttrcFunction     contained "\<sidebar-page-down\>"
+syntax match muttrcFunction     contained "\<sidebar-page-up\>"
+syntax match muttrcFunction     contained "\<sidebar-prev\>"
+syntax match muttrcFunction     contained "\<sidebar-prev-new\>"
+syntax match muttrcFunction     contained "\<sidebar-toggle-visible\>"
+
+syntax keyword muttrcColorField contained sidebar_divider
+syntax keyword muttrcColorField contained sidebar_flagged
+syntax keyword muttrcColorField contained sidebar_highlight
+syntax keyword muttrcColorField contained sidebar_indicator
+syntax keyword muttrcColorField contained sidebar_new
+
diff --git c/doc/vimrc.timeout w/doc/vimrc.timeout
new file mode 100644
index 0000000..fe32359
--- /dev/null
+++ w/doc/vimrc.timeout
@@ -0,0 +1,4 @@
+" Vim syntax file for the NeoMutt timeout feature.
+
+syntax keyword muttrcCommand    timeout-hook
+
diff --git c/dotlock.c w/dotlock.c
index 5bf0348..dc14396 100644
--- c/dotlock.c
+++ w/dotlock.c
@@ -53,7 +53,7 @@
 #endif
 
 #ifdef DL_STANDALONE
-# include "reldate.h"
+# include "oldmutt_ver.h"
 #endif
 
 #define MAXLINKS 1024 /* maximum link depth */
@@ -339,7 +339,7 @@ END_PRIVILEGED (void)
 static void 
 usage (const char *av0)
 {
-  fprintf (stderr, "dotlock [Mutt %s (%s)]\n", MUTT_VERSION, ReleaseDate);
+  fprintf (stderr, "dotlock [NeoMutt %s (%s)]\n", PACKAGE_VERSION, OldMuttVer);
   fprintf (stderr, "usage: %s [-t|-f|-u|-d] [-p] [-r <retries>] file\n",
 	  av0);
 
diff --git c/edit.c w/edit.c
index 00d8afb..b0e7cc7 100644
--- c/edit.c
+++ w/edit.c
@@ -29,6 +29,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
+#include <locale.h>
 #include <ctype.h>
 #include <sys/stat.h>
 #include <fcntl.h>
@@ -160,7 +161,9 @@ be_include_messages (char *msg, char **buf, int *bufmax, int *buflen,
       /* add the attribution */
       if (Attribution)
       {
+        setlocale (LC_TIME, NONULL (AttributionLocale));
 	mutt_make_string (tmp, sizeof (tmp) - 1, Attribution, Context, Context->hdrs[n]);
+        setlocale (LC_TIME, "");
 	strcat (tmp, "\n");	/* __STRCAT_CHECKED__ */
       }
 
diff --git c/enter.c w/enter.c
index 2f3ebdd..7a806dd 100644
--- c/enter.c
+++ w/enter.c
@@ -566,6 +566,49 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 	    }
 	    break;
 	  }
+	  else if (flags & MUTT_LABEL && ch == OP_EDITOR_COMPLETE)
+	  {
+	    for (i = state->curpos; i && state->wbuf[i-1] != ',' && 
+		 state->wbuf[i-1] != ':'; i--)
+	      ;
+	    for (; i < state->lastchar && state->wbuf[i] == ' '; i++)
+	      ;
+	    my_wcstombs (buf, buflen, state->wbuf + i, state->curpos - i);
+	    r = mutt_label_complete (buf, buflen, i, state->tabs);
+	    replace_part (state, i, buf);
+	    if (!r)
+	    {
+	      rv = 1;
+	      goto bye;
+	    }
+	    break;
+	  }
+	  else if (flags & MUTT_PATTERN && ch == OP_EDITOR_COMPLETE)
+	  {
+        char *p;
+	    for (i = state->curpos; i && state->wbuf[i-1] != ',' && 
+		 state->wbuf[i-1] != ':'; i--)
+	      ;
+	    for (; i < state->lastchar && state->wbuf[i] == ' '; i++)
+	      ;
+	    my_wcstombs (buf, buflen, state->wbuf + i, state->curpos - i);
+        p = &buf[i];
+        while (p > buf && *(p-1) != '~')
+          p--;
+        if (*p == '~' && *(p+1) == 'y')
+        {
+	      r = mutt_label_complete (buf, buflen, i, state->tabs);
+	      replace_part (state, i, buf);
+	      if (!r)
+	      {
+	        rv = 1;
+	        goto bye;
+	      }
+        }
+        else
+          goto self_insert;
+	    break;
+	  }
 	  else if (flags & MUTT_ALIAS && ch == OP_EDITOR_COMPLETE_QUERY)
 	  {
 	    /* invoke the query-menu to get more addresses */
@@ -631,6 +674,27 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 	      BEEP (); /* let the user know that nothing matched */
 	    replace_part (state, 0, buf);
 	  }
+#if USE_NOTMUCH
+	  else if (flags & MUTT_NM_QUERY)
+	  {
+	    my_wcstombs (buf, buflen, state->wbuf, state->curpos);
+	    i = strlen (buf);
+	    if (!mutt_nm_query_complete(buf, buflen, i, state->tabs))
+	      BEEP ();
+
+	    replace_part (state, 0, buf);
+	  }
+	  else if (flags & MUTT_NM_TAG)
+	  {
+	    my_wcstombs (buf, buflen, state->wbuf, state->curpos);
+	    i = strlen (buf);
+	    if (!mutt_nm_tag_complete(buf, buflen, i, state->tabs))
+	      BEEP ();
+
+	    replace_part (state, 0, buf);
+	  }
+
+#endif
 	  else
 	    goto self_insert;
 	  break;
@@ -678,12 +742,6 @@ self_insert:
       /* use the raw keypress */
       ch = LastKey;
 
-#ifdef KEY_ENTER
-      /* treat ENTER the same as RETURN */
-      if (ch == KEY_ENTER)
-	ch = '\r';
-#endif
-
       /* quietly ignore all other function keys */
       if (ch & ~0xff)
 	continue;
diff --git c/flags.c w/flags.c
index 3e80251..a7a9ec9 100644
--- c/flags.c
+++ w/flags.c
@@ -27,6 +27,9 @@
 
 void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
 {
+  if (!ctx || !h)
+    return;
+
   int changed = h->changed;
   int deleted = ctx->deleted;
   int tagged = ctx->tagged;
diff --git c/functions.h w/functions.h
index abc06ca..835a191 100644
--- c/functions.h
+++ w/functions.h
@@ -22,9 +22,6 @@
  *
  * Notes:
  *
- * - If you want to bind \n or \r, use MUTT_ENTER_S so that it will work
- * correctly under both ncurses and S-Lang
- *
  * - If you need to bind a control char, use the octal value because the \cX
  * construct does not work at this level.
  *
@@ -70,7 +67,8 @@ const struct binding_t OpGeneric[] = { /* map: generic */
   { "tag-prefix-cond",	OP_TAG_PREFIX_COND,	NULL },
   { "end-cond",		OP_END_COND,		NULL },
   { "shell-escape",	OP_SHELL_ESCAPE,	"!" },
-  { "select-entry",	OP_GENERIC_SELECT_ENTRY,MUTT_ENTER_S },
+  { "select-entry",	OP_GENERIC_SELECT_ENTRY,"\n" },
+  { "select-entry",	OP_GENERIC_SELECT_ENTRY,"\r" },
   { "search",		OP_SEARCH,		"/" },
   { "search-reverse",	OP_SEARCH_REVERSE,	"\033/" },
   { "search-opposite",	OP_SEARCH_OPPOSITE,	NULL },
@@ -88,6 +86,10 @@ const struct binding_t OpMain[] = { /* map: index */
   { "break-thread",		OP_MAIN_BREAK_THREAD,		"#" },
   { "change-folder",		OP_MAIN_CHANGE_FOLDER,		"c" },
   { "change-folder-readonly",	OP_MAIN_CHANGE_FOLDER_READONLY,	"\033c" },
+#ifdef USE_NNTP
+  { "change-newsgroup",		OP_MAIN_CHANGE_GROUP,		NULL },
+  { "change-newsgroup-readonly",OP_MAIN_CHANGE_GROUP_READONLY,	NULL },
+#endif
   { "next-unread-mailbox",	OP_MAIN_NEXT_UNREAD_MAILBOX,    NULL },
   { "collapse-thread",		OP_MAIN_COLLAPSE_THREAD,	"\033v" },
   { "collapse-all",		OP_MAIN_COLLAPSE_ALL,		"\033V" },
@@ -99,8 +101,17 @@ const struct binding_t OpMain[] = { /* map: index */
   { "delete-thread",		OP_DELETE_THREAD,		"\004" },
   { "delete-subthread",		OP_DELETE_SUBTHREAD,		"\033d" },
   { "edit",			OP_EDIT_MESSAGE,		"e" },
+  { "edit-label",		OP_EDIT_LABEL,			NULL },
   { "edit-type",		OP_EDIT_TYPE,			"\005" },
   { "forward-message",		OP_FORWARD_MESSAGE,		"f" },
+#ifdef USE_NNTP
+  { "forward-to-group",		OP_FORWARD_TO_GROUP,		NULL },
+  { "followup-message",		OP_FOLLOWUP,			NULL },
+  { "get-children",		OP_GET_CHILDREN,		NULL },
+  { "get-message",		OP_GET_MESSAGE,			NULL },
+  { "get-parent",		OP_GET_PARENT,			NULL },
+  { "reconstruct-thread",	OP_RECONSTRUCT_THREAD,		NULL },
+#endif
   { "flag-message",		OP_FLAG_MESSAGE,		"F" },
   { "group-reply",		OP_GROUP_REPLY,			"g" },
 #ifdef USE_POP
@@ -114,6 +125,7 @@ const struct binding_t OpMain[] = { /* map: index */
   { "next-undeleted",		OP_MAIN_NEXT_UNDELETED,		"j" },
   { "previous-undeleted",	OP_MAIN_PREV_UNDELETED,		"k" },
   { "limit",			OP_MAIN_LIMIT,			"l" },
+  { "limit-current-thread",	OP_LIMIT_CURRENT_THREAD,	NULL },
   { "link-threads",		OP_MAIN_LINK_THREADS,		"&" },
   { "list-reply",		OP_LIST_REPLY,			"L" },
   { "mail",			OP_MAIL,			"m" },
@@ -122,6 +134,7 @@ const struct binding_t OpMain[] = { /* map: index */
   { "next-thread",		OP_MAIN_NEXT_THREAD,		"\016" },
   { "next-subthread",		OP_MAIN_NEXT_SUBTHREAD,		"\033n" },
   { "purge-message",		OP_PURGE_MESSAGE,		NULL },
+  { "purge-thread",		OP_PURGE_THREAD,		NULL },
   { "query",			OP_QUERY,			"Q" },
   { "quit",			OP_QUIT,			"q" },
   { "reply",			OP_REPLY,			"r" },
@@ -129,12 +142,16 @@ const struct binding_t OpMain[] = { /* map: index */
   { "sort-mailbox",		OP_SORT,			"o" },
   { "sort-reverse",		OP_SORT_REVERSE,		"O" },
   { "print-message",		OP_PRINT,			"p" },
+#ifdef USE_NNTP
+  { "post-message",		OP_POST,			NULL },
+#endif
   { "previous-thread",		OP_MAIN_PREV_THREAD,		"\020" },
   { "previous-subthread",	OP_MAIN_PREV_SUBTHREAD,		"\033p" },
   { "recall-message",		OP_RECALL_MESSAGE,		"R" },
   { "read-thread",		OP_MAIN_READ_THREAD,		"\022" },
   { "read-subthread",		OP_MAIN_READ_SUBTHREAD,		"\033r" },
   { "resend-message",		OP_RESEND,			"\033e" },
+  { "compose-to-sender",	OP_COMPOSE_TO_SENDER,		NULL },
   { "save-message",		OP_SAVE,			"s" },
   { "tag-pattern",		OP_MAIN_TAG_PATTERN,		"T" },
   { "tag-subthread",		OP_TAG_SUBTHREAD,		NULL },
@@ -148,7 +165,12 @@ const struct binding_t OpMain[] = { /* map: index */
   { "show-version",		OP_VERSION,			"V" },
   { "set-flag",			OP_MAIN_SET_FLAG,		"w" },
   { "clear-flag",		OP_MAIN_CLEAR_FLAG,		"W" },
-  { "display-message",		OP_DISPLAY_MESSAGE,		MUTT_ENTER_S },
+  { "toggle-read",		OP_TOGGLE_READ,			NULL },
+#ifdef USE_NNTP
+  { "catchup",			OP_CATCHUP,			NULL },
+#endif
+  { "display-message",		OP_DISPLAY_MESSAGE,		"\n" },
+  { "display-message",		OP_DISPLAY_MESSAGE,		"\r" },
   { "buffy-list",		OP_BUFFY_LIST,			"." },
   { "sync-mailbox",		OP_MAIN_SYNC_FOLDER,		"$" },
   { "display-address",		OP_DISPLAY_ADDRESS,		"@" },
@@ -168,6 +190,7 @@ const struct binding_t OpMain[] = { /* map: index */
   { "mail-key",			OP_MAIL_KEY,			"\033k" },
   { "decrypt-copy",		OP_DECRYPT_COPY,		NULL },
   { "decrypt-save",		OP_DECRYPT_SAVE,		NULL },
+  { "quasi-delete",		OP_MAIN_QUASI_DELETE,		NULL },
 
 #ifdef USE_SIDEBAR
   { "sidebar-next",		OP_SIDEBAR_NEXT,		NULL },
@@ -177,9 +200,17 @@ const struct binding_t OpMain[] = { /* map: index */
   { "sidebar-page-up",		OP_SIDEBAR_PAGE_UP,		NULL },
   { "sidebar-prev",		OP_SIDEBAR_PREV,		NULL },
   { "sidebar-prev-new",		OP_SIDEBAR_PREV_NEW,		NULL },
+  { "sidebar-toggle-virtual",	OP_SIDEBAR_TOGGLE_VIRTUAL,	NULL },
   { "sidebar-toggle-visible",	OP_SIDEBAR_TOGGLE_VISIBLE,	NULL },
 #endif
 
+#ifdef USE_NOTMUCH
+  { "change-vfolder",		OP_MAIN_CHANGE_VFOLDER,         NULL },
+  { "vfolder-from-query",	OP_MAIN_VFOLDER_FROM_QUERY,     NULL },
+  { "modify-labels",		OP_MAIN_MODIFY_LABELS,		NULL },
+  { "modify-labels-then-hide",	OP_MAIN_MODIFY_LABELS_THEN_HIDE, NULL },
+  { "entire-thread",		OP_MAIN_ENTIRE_THREAD,          NULL },
+#endif
   { NULL,			0,				NULL }
 };
 
@@ -189,6 +220,10 @@ const struct binding_t OpPager[] = { /* map: pager */
   { "bounce-message",	OP_BOUNCE_MESSAGE,		"b" },
   { "change-folder",	OP_MAIN_CHANGE_FOLDER,		"c" },
   { "change-folder-readonly",	OP_MAIN_CHANGE_FOLDER_READONLY,	"\033c" },
+#ifdef USE_NNTP
+  { "change-newsgroup",		OP_MAIN_CHANGE_GROUP,		NULL },
+  { "change-newsgroup-readonly",OP_MAIN_CHANGE_GROUP_READONLY,	NULL },
+#endif
   { "next-unread-mailbox",	OP_MAIN_NEXT_UNREAD_MAILBOX, NULL },
   { "copy-message",	OP_COPY_MESSAGE,		"C" },
   { "decode-copy",	OP_DECODE_COPY,			"\033C" },
@@ -198,7 +233,12 @@ const struct binding_t OpPager[] = { /* map: pager */
   { "set-flag",  	OP_MAIN_SET_FLAG,		"w" },
   { "clear-flag",       OP_MAIN_CLEAR_FLAG,		"W" },
   { "edit",		OP_EDIT_MESSAGE,		"e" },
+  { "edit-label",	OP_EDIT_LABEL,			NULL },
   { "edit-type",	OP_EDIT_TYPE,			"\005" },
+#ifdef USE_NNTP
+  { "followup-message",	OP_FOLLOWUP,			NULL },
+  { "forward-to-group",	OP_FORWARD_TO_GROUP,		NULL },
+#endif
   { "forward-message",	OP_FORWARD_MESSAGE,		"f" },
   { "flag-message",	OP_FLAG_MESSAGE,		"F" },
   { "group-reply",	OP_GROUP_REPLY,			"g" },
@@ -222,9 +262,13 @@ const struct binding_t OpPager[] = { /* map: pager */
   { "sort-mailbox",	OP_SORT,			"o" },
   { "sort-reverse",	OP_SORT_REVERSE,		"O" },
   { "print-message",	OP_PRINT,			"p" },
+#ifdef USE_NNTP
+  { "post-message",	OP_POST,			NULL },
+#endif
   { "previous-thread",	OP_MAIN_PREV_THREAD,		"\020" },
   { "previous-subthread",OP_MAIN_PREV_SUBTHREAD,	"\033p" },
   { "purge-message",	OP_PURGE_MESSAGE,		NULL },
+  { "purge-thread",	OP_PURGE_THREAD,		NULL },
   { "quit",		OP_QUIT,			"Q" },
   { "exit",		OP_EXIT,			"q" },
   { "reply",		OP_REPLY,			"r" },
@@ -232,6 +276,7 @@ const struct binding_t OpPager[] = { /* map: pager */
   { "read-thread",	OP_MAIN_READ_THREAD,		"\022" },
   { "read-subthread",	OP_MAIN_READ_SUBTHREAD,		"\033r" },
   { "resend-message",	OP_RESEND,			"\033e" },
+  { "compose-to-sender",OP_COMPOSE_TO_SENDER,		NULL },
   { "save-message",	OP_SAVE,			"s" },
   { "skip-quoted",	OP_PAGER_SKIP_QUOTED,		"S" },
   { "decode-save",	OP_DECODE_SAVE,			"\033s" },
@@ -259,7 +304,8 @@ const struct binding_t OpPager[] = { /* map: pager */
   { "search",		OP_SEARCH,			"/" },
   { "search-reverse",	OP_SEARCH_REVERSE,		"\033/" },
   { "search-opposite",	OP_SEARCH_OPPOSITE,		NULL },
-  { "next-line",	OP_NEXT_LINE,			MUTT_ENTER_S },
+  { "next-line",	OP_NEXT_LINE,			"\n" },
+  { "next-line",	OP_NEXT_LINE,			"\r" },
   { "jump",		OP_JUMP,			NULL },
   { "next-unread",	OP_MAIN_NEXT_UNREAD,		NULL },
   { "previous-new",	OP_MAIN_PREV_NEW,		NULL },
@@ -283,6 +329,7 @@ const struct binding_t OpPager[] = { /* map: pager */
   { "decrypt-save",    	OP_DECRYPT_SAVE,		NULL },
 
   { "what-key",		OP_WHAT_KEY,		NULL },
+  { "quasi-delete",	OP_MAIN_QUASI_DELETE,		NULL },
 
 #ifdef USE_SIDEBAR
   { "sidebar-next",		OP_SIDEBAR_NEXT,		NULL },
@@ -292,9 +339,18 @@ const struct binding_t OpPager[] = { /* map: pager */
   { "sidebar-page-up",		OP_SIDEBAR_PAGE_UP,		NULL },
   { "sidebar-prev",		OP_SIDEBAR_PREV,		NULL },
   { "sidebar-prev-new",		OP_SIDEBAR_PREV_NEW,		NULL },
+  { "sidebar-toggle-virtual",	OP_SIDEBAR_TOGGLE_VIRTUAL,	NULL },
   { "sidebar-toggle-visible",	OP_SIDEBAR_TOGGLE_VISIBLE,	NULL },
 #endif
 
+#ifdef USE_NOTMUCH
+  { "change-vfolder",		OP_MAIN_CHANGE_VFOLDER,		NULL },
+  { "vfolder-from-query",	OP_MAIN_VFOLDER_FROM_QUERY,	NULL },
+  { "modify-labels",		OP_MAIN_MODIFY_LABELS,		NULL },
+  { "modify-labels-then-hide",	OP_MAIN_MODIFY_LABELS_THEN_HIDE, NULL },
+  { "entire-thread",		OP_MAIN_ENTIRE_THREAD,          NULL },
+#endif
+
   { NULL,		0,				NULL }
 };
 
@@ -302,6 +358,10 @@ const struct binding_t OpAttach[] = { /* map: attachment */
   { "bounce-message",	OP_BOUNCE_MESSAGE,		"b" },
   { "display-toggle-weed",	OP_DISPLAY_HEADERS,	"h" },
   { "edit-type",	OP_EDIT_TYPE,			"\005" },
+#ifdef USE_NNTP
+  { "followup-message",	OP_FOLLOWUP,			NULL },
+  { "forward-to-group",	OP_FORWARD_TO_GROUP,		NULL },
+#endif
   { "print-entry",	OP_PRINT,			"p" },
   { "save-entry",	OP_SAVE,			"s" },
   { "pipe-entry",	OP_PIPE,			"|" },
@@ -312,7 +372,8 @@ const struct binding_t OpAttach[] = { /* map: attachment */
   { "list-reply",	OP_LIST_REPLY,			"L" },
   { "forward-message",	OP_FORWARD_MESSAGE,		"f" },
   { "view-text",	OP_ATTACH_VIEW_TEXT,		"T" },
-  { "view-attach",	OP_VIEW_ATTACH,			MUTT_ENTER_S },
+  { "view-attach",	OP_VIEW_ATTACH,			"\n" },
+  { "view-attach",	OP_VIEW_ATTACH,			"\r" },
   { "delete-entry",	OP_DELETE,			"d" },
   { "undelete-entry",	OP_UNDELETE,			"u" },
   { "collapse-parts",	OP_ATTACH_COLLAPSE,		"v" },
@@ -327,6 +388,7 @@ const struct binding_t OpAttach[] = { /* map: attachment */
 const struct binding_t OpCompose[] = { /* map: compose */
   { "attach-file",	OP_COMPOSE_ATTACH_FILE,		"a" },
   { "attach-message",	OP_COMPOSE_ATTACH_MESSAGE,	"A" },
+  { "attach-news-message",OP_COMPOSE_ATTACH_NEWS_MESSAGE,NULL },
   { "edit-bcc",		OP_COMPOSE_EDIT_BCC,		"b" },
   { "edit-cc",		OP_COMPOSE_EDIT_CC,		"c" },
   { "copy-file",	OP_SAVE,			"C" },
@@ -346,6 +408,11 @@ const struct binding_t OpCompose[] = { /* map: compose */
   { "print-entry",	OP_PRINT,			"l" },
   { "edit-mime",	OP_COMPOSE_EDIT_MIME,		"m" },
   { "new-mime",		OP_COMPOSE_NEW_MIME,		"n" },
+#ifdef USE_NNTP
+  { "edit-newsgroups",	OP_COMPOSE_EDIT_NEWSGROUPS,	NULL },
+  { "edit-followup-to",	OP_COMPOSE_EDIT_FOLLOWUP_TO,	NULL },
+  { "edit-x-comment-to",OP_COMPOSE_EDIT_X_COMMENT_TO,	NULL },
+#endif
   { "postpone-message",	OP_COMPOSE_POSTPONE_MESSAGE,	"P" },
   { "edit-reply-to",	OP_COMPOSE_EDIT_REPLY_TO,	"r" },
   { "rename-file",	OP_COMPOSE_RENAME_FILE,		"R" },
@@ -356,7 +423,8 @@ const struct binding_t OpCompose[] = { /* map: compose */
   { "toggle-unlink",	OP_COMPOSE_TOGGLE_UNLINK,	"u" },
   { "toggle-recode",    OP_COMPOSE_TOGGLE_RECODE,	NULL },
   { "update-encoding",	OP_COMPOSE_UPDATE_ENCODING,	"U" },
-  { "view-attach",	OP_VIEW_ATTACH,			MUTT_ENTER_S },
+  { "view-attach",	OP_VIEW_ATTACH,			"\n" },
+  { "view-attach",	OP_VIEW_ATTACH,			"\r" },
   { "send-message",	OP_COMPOSE_SEND_MESSAGE,	"y" },
   { "pipe-entry",	OP_PIPE,			"|" },
 
@@ -397,16 +465,28 @@ const struct binding_t OpBrowser[] = { /* map: browser */
   { "select-new",	OP_BROWSER_NEW_FILE,	"N" },
   { "check-new",	OP_CHECK_NEW,		NULL },
   { "toggle-mailboxes", OP_TOGGLE_MAILBOXES, 	"\t" },
+#ifdef USE_NNTP
+  { "reload-active",	OP_LOAD_ACTIVE,		NULL },
+  { "subscribe-pattern", OP_SUBSCRIBE_PATTERN,	NULL },
+  { "unsubscribe-pattern", OP_UNSUBSCRIBE_PATTERN, NULL },
+  { "catchup",		OP_CATCHUP,		NULL },
+  { "uncatchup",	OP_UNCATCHUP,		NULL },
+#endif
   { "view-file",	OP_BROWSER_VIEW_FILE,	" " },
   { "buffy-list",	OP_BUFFY_LIST,		"." },
 #ifdef USE_IMAP
   { "create-mailbox",   OP_CREATE_MAILBOX,      "C" },
   { "delete-mailbox",   OP_DELETE_MAILBOX,      "d" },
   { "rename-mailbox",   OP_RENAME_MAILBOX,      "r" },
+#endif
+#if defined USE_IMAP || defined USE_NNTP
   { "subscribe",	OP_BROWSER_SUBSCRIBE,	"s" },
   { "unsubscribe",	OP_BROWSER_UNSUBSCRIBE,	"u" },
+#endif
+#ifdef USE_IMAP
   { "toggle-subscribed", OP_BROWSER_TOGGLE_LSUB, "T" },
 #endif
+  { "goto-folder",	OP_BROWSER_GOTO_FOLDER,	"=" },
   { NULL,		0,			NULL }
 };
 
@@ -469,7 +549,8 @@ const struct binding_t OpSmime[] = { /* map: smime */
 
 #ifdef MIXMASTER
 const struct binding_t OpMix[] = { /* map: mixmaster */
-  { "accept",		OP_MIX_USE,	MUTT_ENTER_S },
+  { "accept",		OP_MIX_USE,	"\n" },
+  { "accept",		OP_MIX_USE,	"\r" },
   { "append",		OP_MIX_APPEND,	"a"       },
   { "insert",		OP_MIX_INSERT,	"i"       },
   { "delete",		OP_MIX_DELETE,  "d"	  },
diff --git c/getdomain.c w/getdomain.c
index 9dfda2b..15803af 100644
--- c/getdomain.c
+++ w/getdomain.c
@@ -31,19 +31,21 @@
 
 int getdnsdomainname (char *d, size_t len)
 {
-  /* A DNS name can actually be only 253 octets, string is 256 */
+  int ret = -1;
+
+#ifdef HAVE_GETADDRINFO
   char *node;
   long node_len;
   struct addrinfo hints;
   struct addrinfo *h;
   char *p;
-  int ret;
 
   *d = '\0';
   memset(&hints, 0, sizeof (struct addrinfo));
   hints.ai_flags = AI_CANONNAME;
   hints.ai_family = AF_UNSPEC;
 
+  /* A DNS name can actually be only 253 octets, string is 256 */
   if ((node_len = sysconf(_SC_HOST_NAME_MAX)) == -1)
     node_len = STRING;
   node = safe_malloc(node_len + 1);
@@ -64,6 +66,8 @@ int getdnsdomainname (char *d, size_t len)
     freeaddrinfo(h);
   }
   FREE (&node);
+#endif
+
   return ret;
 }
 
diff --git c/git-version-gen w/git-version-gen
new file mode 100755
index 0000000..bd2c4b6
--- /dev/null
+++ w/git-version-gen
@@ -0,0 +1,226 @@
+#!/bin/sh
+# Print a version string.
+scriptversion=2016-05-08.18; # UTC
+
+# Copyright (C) 2007-2016 Free Software Foundation, Inc.
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# This script is derived from GIT-VERSION-GEN from GIT: http://git.or.cz/.
+# It may be run two ways:
+# - from a git repository in which the "git describe" command below
+#   produces useful output (thus requiring at least one signed tag)
+# - from a non-git-repo directory containing a .tarball-version file, which
+#   presumes this script is invoked like "./git-version-gen .tarball-version".
+
+# In order to use intra-version strings in your project, you will need two
+# separate generated version string files:
+#
+# .tarball-version - present only in a distribution tarball, and not in
+#   a checked-out repository.  Created with contents that were learned at
+#   the last time autoconf was run, and used by git-version-gen.  Must not
+#   be present in either $(srcdir) or $(builddir) for git-version-gen to
+#   give accurate answers during normal development with a checked out tree,
+#   but must be present in a tarball when there is no version control system.
+#   Therefore, it cannot be used in any dependencies.  GNUmakefile has
+#   hooks to force a reconfigure at distribution time to get the value
+#   correct, without penalizing normal development with extra reconfigures.
+#
+# .version - present in a checked-out repository and in a distribution
+#   tarball.  Usable in dependencies, particularly for files that don't
+#   want to depend on config.h but do want to track version changes.
+#   Delete this file prior to any autoconf run where you want to rebuild
+#   files to pick up a version string change; and leave it stale to
+#   minimize rebuild time after unrelated changes to configure sources.
+#
+# As with any generated file in a VC'd directory, you should add
+# /.version to .gitignore, so that you don't accidentally commit it.
+# .tarball-version is never generated in a VC'd directory, so needn't
+# be listed there.
+#
+# Use the following line in your configure.ac, so that $(VERSION) will
+# automatically be up-to-date each time configure is run (and note that
+# since configure.ac no longer includes a version string, Makefile rules
+# should not depend on configure.ac for version updates).
+#
+# AC_INIT([GNU project],
+#         m4_esyscmd([build-aux/git-version-gen .tarball-version]),
+#         [bug-project@example])
+#
+# Then use the following lines in your Makefile.am, so that .version
+# will be present for dependencies, and so that .version and
+# .tarball-version will exist in distribution tarballs.
+#
+# EXTRA_DIST = $(top_srcdir)/.version
+# BUILT_SOURCES = $(top_srcdir)/.version
+# $(top_srcdir)/.version:
+#	echo $(VERSION) > $@-t && mv $@-t $@
+# dist-hook:
+#	echo $(VERSION) > $(distdir)/.tarball-version
+
+
+me=$0
+
+version="git-version-gen $scriptversion
+
+Copyright 2011 Free Software Foundation, Inc.
+There is NO warranty.  You may redistribute this software
+under the terms of the GNU General Public License.
+For more information about these matters, see the files named COPYING."
+
+usage="\
+Usage: $me [OPTION]... \$srcdir/.tarball-version [TAG-NORMALIZATION-SED-SCRIPT]
+Print a version string.
+
+Options:
+
+   --prefix PREFIX    prefix of git tags (default 'v')
+   --fallback VERSION
+                      fallback version to use if \"git --version\" fails
+
+   --help             display this help and exit
+   --version          output version information and exit
+
+Running without arguments will suffice in most cases."
+
+prefix=v
+fallback=
+
+while test $# -gt 0; do
+  case $1 in
+    --help) echo "$usage"; exit 0;;
+    --version) echo "$version"; exit 0;;
+    --prefix) shift; prefix=${1?};;
+    --fallback) shift; fallback=${1?};;
+    -*)
+      echo "$0: Unknown option '$1'." >&2
+      echo "$0: Try '--help' for more information." >&2
+      exit 1;;
+    *)
+      if test "x$tarball_version_file" = x; then
+        tarball_version_file="$1"
+      elif test "x$tag_sed_script" = x; then
+        tag_sed_script="$1"
+      else
+        echo "$0: extra non-option argument '$1'." >&2
+        exit 1
+      fi;;
+  esac
+  shift
+done
+
+if test "x$tarball_version_file" = x; then
+    echo "$usage"
+    exit 1
+fi
+
+tag_sed_script="${tag_sed_script:-s/x/x/}"
+
+nl='
+'
+
+# Avoid meddling by environment variable of the same name.
+v=
+v_from_git=
+
+# First see if there is a tarball-only version file.
+# then try "git describe", then default.
+if test -f $tarball_version_file
+then
+    v=`cat $tarball_version_file` || v=
+    case $v in
+        *$nl*) v= ;; # reject multi-line output
+        [0-9]*) ;;
+        *) v= ;;
+    esac
+    test "x$v" = x \
+        && echo "$0: WARNING: $tarball_version_file is missing or damaged" 1>&2
+fi
+
+if test "x$v" != x
+then
+    : # use $v
+# Otherwise, if there is at least one git commit involving the working
+# directory, and "git describe" output looks sensible, use that to
+# derive a version string.
+elif test "`git log -1 --pretty=format:x . 2>&1`" = x \
+    && v=`git describe --abbrev=4 --match="$prefix*" HEAD 2>/dev/null \
+          || git describe --abbrev=4 HEAD 2>/dev/null` \
+    && v=`printf '%s\n' "$v" | sed "$tag_sed_script"` \
+    && case $v in
+         $prefix[0-9]*) ;;
+         *) (exit 1) ;;
+       esac
+then
+    # Is this a new git that lists number of commits since the last
+    # tag or the previous older version that did not?
+    #   Newer: v6.10-77-g0f8faeb
+    #   Older: v6.10-g0f8faeb
+    case $v in
+        *-*-*) : git describe is okay three part flavor ;;
+        *-*)
+            : git describe is older two part flavor
+            # Recreate the number of commits and rewrite such that the
+            # result is the same as if we were using the newer version
+            # of git describe.
+            vtag=`echo "$v" | sed 's/-.*//'`
+            commit_list=`git rev-list "$vtag"..HEAD 2>/dev/null` \
+                || { commit_list=failed;
+                     echo "$0: WARNING: git rev-list failed" 1>&2; }
+            numcommits=`echo "$commit_list" | wc -l`
+            v=`echo "$v" | sed "s/\(.*\)-\(.*\)/\1-$numcommits-\2/"`;
+            test "$commit_list" = failed && v=UNKNOWN
+            ;;
+    esac
+
+    # Change the first '-' to a '.', so version-comparing tools work properly.
+    # Remove the "g" in git describe's output string, to save a byte.
+    v=`echo "$v" | sed 's/-/./;s/\(.*\)-g/\1-/'`;
+    v_from_git=1
+elif test "x$fallback" = x || git --version >/dev/null 2>&1; then
+    v=UNKNOWN
+else
+    v=$fallback
+fi
+
+v=`echo "$v" |sed "s/^$prefix//"`
+
+# Test whether to append the "-dirty" suffix only if the version
+# string we're using came from git.  I.e., skip the test if it's "UNKNOWN"
+# or if it came from .tarball-version.
+if test "x$v_from_git" != x; then
+  # Don't declare a version "dirty" merely because a time stamp has changed.
+  git update-index --refresh > /dev/null 2>&1
+
+  dirty=`exec 2>/dev/null;git diff-index --name-only HEAD` || dirty=
+  case "$dirty" in
+      '') ;;
+      *) # Append the suffix only if there isn't one already.
+          case $v in
+            *-dirty) ;;
+            *) v="$v-dirty" ;;
+          esac ;;
+  esac
+fi
+
+# Omit the trailing newline, so that m4_esyscmd can use the result directly.
+printf %s "$v"
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-time-zone: "UTC0"
+# time-stamp-end: "; # UTC"
+# End:
diff --git c/globals.h w/globals.h
index 95a6869..d49337d 100644
--- c/globals.h
+++ w/globals.h
@@ -36,8 +36,10 @@ WHERE char *AliasFmt;
 WHERE char *AssumedCharset;
 WHERE char *AttachSep;
 WHERE char *Attribution;
+WHERE char *AttributionLocale;
 WHERE char *AttachCharset;
 WHERE char *AttachFormat;
+WHERE REGEXP AttachKeyword;
 WHERE char *Charset;
 WHERE char *ComposeFormat;
 WHERE char *ConfigCharset;
@@ -66,10 +68,9 @@ WHERE char *ImapUser INITVAL (NULL);
 #endif
 WHERE char *Inbox;
 WHERE char *Ispell;
-WHERE char *Locale;
 WHERE char *MailcapPath;
 WHERE char *Maildir;
-#if defined(USE_IMAP) || defined(USE_POP)
+#if defined(USE_IMAP) || defined(USE_POP) || defined(USE_NNTP)
 WHERE char *MessageCachedir;
 #endif
 #if USE_HCACHE
@@ -95,6 +96,17 @@ WHERE char *MixEntryFormat;
 #endif
 
 WHERE char *Muttrc INITVAL (NULL);
+#ifdef USE_NNTP
+WHERE char *GroupFormat;
+WHERE char *Inews;
+WHERE char *NewsCacheDir;
+WHERE char *NewsServer;
+WHERE char *NewsgroupsCharset;
+WHERE char *NewsRc;
+WHERE char *NntpAuthenticators;
+WHERE char *NntpUser;
+WHERE char *NntpPass;
+#endif
 WHERE char *Outbox;
 WHERE char *Pager;
 WHERE char *PagerFmt;
@@ -111,6 +123,7 @@ WHERE char *Postponed;
 WHERE char *PostponeEncryptAs;
 WHERE char *Prefix;
 WHERE char *PrintCmd;
+WHERE char *NewMailCmd;
 WHERE char *QueryCmd;
 WHERE char *QueryFormat;
 WHERE char *Realname;
@@ -153,15 +166,21 @@ WHERE char *TSIconFormat;
 WHERE short TSSupported;
 WHERE char *Username;
 WHERE char *Visual;
+WHERE char *XlabelDelim;
 
 WHERE char *CurrentFolder;
 WHERE char *LastFolder;
 
 
-WHERE const char *ReleaseDate;
+WHERE const char *OldMuttVer;
 
 WHERE HASH *Groups;
+WHERE HASH *Labels;
 WHERE HASH *ReverseAlias;
+#ifdef USE_NOTMUCH
+WHERE HASH *TagTransforms;
+WHERE HASH *TagFormats;
+#endif
 
 WHERE LIST *AutoViewList INITVAL(0);
 WHERE LIST *AlternativeOrderList INITVAL(0);
@@ -201,6 +220,11 @@ extern unsigned char QuadOptions[];
 
 WHERE unsigned short Counter INITVAL (0);
 
+#ifdef USE_NNTP
+WHERE short NewsPollTimeout;
+WHERE short NntpContext;
+#endif
+
 WHERE short ConnectTimeout;
 WHERE short HistSize;
 WHERE short MenuContext;
@@ -211,6 +235,7 @@ WHERE short ReflowWrap;
 WHERE short SaveHist;
 WHERE short SendmailWait;
 WHERE short SleepTime INITVAL (1);
+WHERE short SkipQuotedOffset;
 WHERE short TimeInc;
 WHERE short Timeout;
 WHERE short Wrap;
@@ -222,7 +247,7 @@ WHERE short ScoreThresholdRead;
 WHERE short ScoreThresholdFlag;
 
 #ifdef USE_SIDEBAR
-WHERE short SidebarWidth;
+WHERE short SidebarWidth INITVAL(0);
 WHERE LIST *SidebarWhitelist INITVAL(0);
 WHERE int SidebarNeedsRedraw INITVAL (0);
 #endif
@@ -282,6 +307,17 @@ WHERE char *SmimeGetCertCommand;
 WHERE char *SmimeImportCertCommand;
 WHERE char *SmimeGetCertEmailCommand;
 
+#ifdef USE_NOTMUCH
+WHERE int NotmuchOpenTimeout;
+WHERE char *NotmuchDefaultUri;
+WHERE char *NotmuchExcludeTags;
+WHERE char *NotmuchUnreadTag;
+WHERE char *NotmuchHiddenTags;
+WHERE char *VirtFolderFormat;
+WHERE int NotmuchDBLimit;
+WHERE char *NotmuchQueryType;
+WHERE char *NotmuchRecordTags;
+#endif
 
 
 
@@ -303,5 +339,5 @@ extern const char * const Months[];
 #include "buffy.h"
 #include "sort.h"
 #include "mutt_crypt.h"
-#include "reldate.h"
+#include "oldmutt_ver.h"
 #endif /* MAIN_C */
diff --git c/handler.c w/handler.c
index 7ce53f9..014268f 100644
--- c/handler.c
+++ w/handler.c
@@ -1596,7 +1596,9 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
   int origType;
   char *savePrefix = NULL;
   FILE *fp = NULL;
+#ifndef USE_FMEMOPEN
   char tempfile[_POSIX_PATH_MAX];
+#endif
   size_t tmplength = 0;
   LOFF_T tmpoffset = 0;
   int decode = 0;
@@ -1604,6 +1606,11 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
 
   fseeko (s->fpin, b->offset, 0);
 
+#ifdef USE_FMEMOPEN
+  char *temp;
+  size_t tempsize;
+#endif
+
   /* see if we need to decode this part before processing it */
   if (b->encoding == ENCBASE64 || b->encoding == ENCQUOTEDPRINTABLE ||
       b->encoding == ENCUUENCODED || plaintext ||
@@ -1619,6 +1626,14 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
     {
       /* decode to a tempfile, saving the original destination */
       fp = s->fpout;
+#ifdef USE_FMEMOPEN
+     s->fpout = open_memstream (&temp, &tempsize);
+     if (!s->fpout) {
+       mutt_error _("Unable to open memory stream!");
+       dprint (1, (debugfile, "Can't open memory stream.\n"));
+       return -1;
+     }
+#else
       mutt_mktemp (tempfile, sizeof (tempfile));
       if ((s->fpout = safe_fopen (tempfile, "w")) == NULL)
       {
@@ -1626,6 +1641,7 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
         dprint (1, (debugfile, "Can't open %s.\n", tempfile));
         return -1;
       }
+#endif
       /* decoding the attachment changes the size and offset, so save a copy
         * of the "real" values now, and restore them after processing
         */
@@ -1654,9 +1670,20 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
       /* restore final destination and substitute the tempfile for input */
       s->fpout = fp;
       fp = s->fpin;
+#ifdef USE_FMEMOPEN
+      if (tempsize) {
+        s->fpin = fmemopen (temp, tempsize, "r");
+      } else { /* fmemopen cannot handle zero-length buffers */
+        s->fpin = safe_fopen ("/dev/null", "r");
+      }
+      if (!s->fpin) {
+        mutt_perror ("failed to re-open memstream!");
+        return -1;
+      }
+#else
       s->fpin = fopen (tempfile, "r");
       unlink (tempfile);
-
+#endif
       /* restore the prefix */
       s->prefix = savePrefix;
     }
@@ -1681,6 +1708,10 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
 
       /* restore the original source stream */
       safe_fclose (&s->fpin);
+#ifdef USE_FMEMOPEN
+      if (tempsize)
+        FREE(&temp);
+#endif
       s->fpin = fp;
     }
   }
diff --git c/hash.c w/hash.c
index 08f7171..34b96ef 100644
--- c/hash.c
+++ w/hash.c
@@ -57,6 +57,7 @@ HASH *hash_create (int nelem, int lower)
   if (nelem == 0)
     nelem = 2;
   table->nelem = nelem;
+  table->curnelem = 0;
   table->table = safe_calloc (nelem, sizeof (struct hash_elem *));
   if (lower)
   {
@@ -71,6 +72,29 @@ HASH *hash_create (int nelem, int lower)
   return table;
 }
 
+HASH *hash_resize (HASH *ptr, int nelem, int lower)
+{
+  HASH *table;
+  struct hash_elem *elem, *tmp;
+  int i;
+
+  table = hash_create (nelem, lower);
+
+  for (i = 0; i < ptr->nelem; i++)
+  {
+    for (elem = ptr->table[i]; elem; )
+    {
+      tmp = elem;
+      elem = elem->next;
+      hash_insert (table, tmp->key, tmp->data, 1);
+      FREE (&tmp);
+    }
+  }
+  FREE (&ptr->table);
+  FREE (&ptr);
+  return table;
+}
+
 /* table        hash table to update
  * key          key to hash on
  * data         data to associate with `key'
@@ -90,6 +114,7 @@ int hash_insert (HASH * table, const char *key, void *data, int allow_dup)
   {
     ptr->next = table->table[h];
     table->table[h] = ptr;
+    table->curnelem++;
   }
   else
   {
@@ -112,6 +137,7 @@ int hash_insert (HASH * table, const char *key, void *data, int allow_dup)
     else
       table->table[h] = ptr;
     ptr->next = tmp;
+    table->curnelem++;
   }
   return h;
 }
@@ -142,6 +168,7 @@ void hash_delete_hash (HASH * table, int hash, const char *key, const void *data
       if (destroy)
 	destroy (ptr->data);
       FREE (&ptr);
+      table->curnelem--;
       
       ptr = *last;
     }
@@ -176,3 +203,30 @@ void hash_destroy (HASH **ptr, void (*destroy) (void *))
   FREE (&pptr->table);
   FREE (ptr);		/* __FREE_CHECKED__ */
 }
+
+struct hash_elem *hash_walk(const HASH *table, struct hash_walk_state *state)
+{
+  if (state->last && state->last->next)
+  {
+    state->last = state->last->next;
+    return state->last;
+  }
+
+  if (state->last)
+    state->index++;
+
+  while (state->index < table->nelem)
+  {
+    if (table->table[state->index])
+    {
+      state->last = table->table[state->index];
+      return state->last;
+    }
+    state->index++;
+  } 
+
+  state->index = 0;
+  state->last = NULL;
+  return NULL;
+}
+
diff --git c/hash.h w/hash.h
index fb77d0c..c944660 100644
--- c/hash.h
+++ w/hash.h
@@ -28,7 +28,7 @@ struct hash_elem
 
 typedef struct
 {
-  int nelem;
+  int nelem, curnelem;
   struct hash_elem **table;
   unsigned int (*hash_string)(const unsigned char *, unsigned int);
   int (*cmp_string)(const char *, const char *);
@@ -41,9 +41,17 @@ HASH;
 
 HASH *hash_create (int nelem, int lower);
 int hash_insert (HASH * table, const char *key, void *data, int allow_dup);
+HASH *hash_resize (HASH * table, int nelem, int lower);
 void *hash_find_hash (const HASH * table, int hash, const char *key);
 void hash_delete_hash (HASH * table, int hash, const char *key, const void *data,
 		       void (*destroy) (void *));
 void hash_destroy (HASH ** hash, void (*destroy) (void *));
 
+struct hash_walk_state {
+  int index;
+  struct hash_elem *last;
+};
+
+struct hash_elem *hash_walk(const HASH *table, struct hash_walk_state *state);
+
 #endif
diff --git c/hcache.c w/hcache.c
index fb6a561..870e054 100644
--- c/hcache.c
+++ w/hcache.c
@@ -28,10 +28,15 @@
 #include <villa.h>
 #elif HAVE_TC
 #include <tcbdb.h>
+#elif HAVE_KC
+#include <kclangc.h>
 #elif HAVE_GDBM
 #include <gdbm.h>
 #elif HAVE_DB4
 #include <db.h>
+#elif HAVE_LMDB
+#define LMDB_DB_SIZE    (1024 * 1024 * 1024)
+#include <lmdb.h>
 #endif
 
 #include <errno.h>
@@ -63,6 +68,13 @@ struct header_cache
   char *folder;
   unsigned int crc;
 };
+#elif HAVE_KC
+struct header_cache
+{
+  KCDB *db;
+  char *folder;
+  unsigned int crc;
+};
 #elif HAVE_GDBM
 struct header_cache
 {
@@ -83,6 +95,61 @@ struct header_cache
 
 static void mutt_hcache_dbt_init(DBT * dbt, void *data, size_t len);
 static void mutt_hcache_dbt_empty_init(DBT * dbt);
+#elif HAVE_LMDB
+enum mdb_txn_mode
+{
+  txn_uninitialized = 0,
+  txn_read = 1 << 0,
+  txn_write = 1 << 1
+};
+struct header_cache
+{
+  MDB_env *env;
+  MDB_txn *txn;
+  MDB_dbi db;
+  char *folder;
+  unsigned int crc;
+  enum mdb_txn_mode txn_mode;
+};
+
+static int mdb_get_r_txn(header_cache_t *h)
+{
+  int rc;
+
+  if (h->txn && (h->txn_mode & (txn_read | txn_write)) > 0)
+    return MDB_SUCCESS;
+
+  if (h->txn)
+    rc = mdb_txn_renew(h->txn);
+  else
+    rc = mdb_txn_begin(h->env, NULL, MDB_RDONLY, &h->txn);
+
+  if (rc == MDB_SUCCESS)
+    h->txn_mode = txn_read;
+
+  return rc;
+}
+
+static int mdb_get_w_txn(header_cache_t *h)
+{
+  int rc;
+
+  if (h->txn && (h->txn_mode == txn_write))
+    return MDB_SUCCESS;
+
+  if (h->txn)
+  {
+    if (h->txn_mode == txn_read)
+      mdb_txn_reset(h->txn);
+    h->txn = NULL;
+  }
+
+  rc = mdb_txn_begin(h->env, NULL, 0, &h->txn);
+  if (rc == MDB_SUCCESS)
+    h->txn_mode = txn_write;
+
+  return rc;
+}
 #endif
 
 typedef union
@@ -439,13 +506,19 @@ dump_envelope(ENVELOPE * e, unsigned char *d, int *off, int convert)
   d = dump_char(e->message_id, d, off, 0);
   d = dump_char(e->supersedes, d, off, 0);
   d = dump_char(e->date, d, off, 0);
-  d = dump_char(e->x_label, d, off, convert);
 
   d = dump_buffer(e->spam, d, off, convert);
 
   d = dump_list(e->references, d, off, 0);
   d = dump_list(e->in_reply_to, d, off, 0);
   d = dump_list(e->userhdrs, d, off, convert);
+  d = dump_list(e->labels, d, off, convert);
+
+#ifdef USE_NNTP
+  d = dump_char(e->xref, d, off, 0);
+  d = dump_char(e->followup_to, d, off, 0);
+  d = dump_char(e->x_comment_to, d, off, convert);
+#endif
 
   return d;
 }
@@ -476,13 +549,19 @@ restore_envelope(ENVELOPE * e, const unsigned char *d, int *off, int convert)
   restore_char(&e->message_id, d, off, 0);
   restore_char(&e->supersedes, d, off, 0);
   restore_char(&e->date, d, off, 0);
-  restore_char(&e->x_label, d, off, convert);
 
   restore_buffer(&e->spam, d, off, convert);
 
   restore_list(&e->references, d, off, 0);
   restore_list(&e->in_reply_to, d, off, 0);
   restore_list(&e->userhdrs, d, off, convert);
+  restore_list(&e->labels, d, off, convert);
+
+#ifdef USE_NNTP
+  restore_char(&e->xref, d, off, 0);
+  restore_char(&e->followup_to, d, off, 0);
+  restore_char(&e->x_comment_to, d, off, convert);
+#endif
 }
 
 static int
@@ -726,12 +805,20 @@ mutt_hcache_fetch_raw (header_cache_t *h, const char *filename,
 #elif HAVE_TC
   void *data;
   int sp;
+#elif HAVE_KC
+  void *data;
+  size_t sp;
 #elif HAVE_GDBM
   datum key;
   datum data;
 #elif HAVE_DB4
   DBT key;
   DBT data;
+#elif HAVE_LMDB
+  MDB_val key;
+  MDB_val data;
+  size_t folderlen;
+  int rc;
 #endif
   
   if (!h)
@@ -748,6 +835,40 @@ mutt_hcache_fetch_raw (header_cache_t *h, const char *filename,
   h->db->get(h->db, NULL, &key, &data, 0);
   
   return data.data;
+#elif HAVE_LMDB
+  strncpy(path, h->folder, sizeof (path));
+  safe_strcat(path, sizeof (path), filename);
+
+  folderlen = strlen(h->folder);
+  ksize = folderlen + keylen(path + folderlen);  
+  key.mv_data = (char *)path;
+  key.mv_size = ksize;
+  data.mv_data = NULL;
+  data.mv_size = 0;
+  rc = mdb_get_r_txn(h);
+  if (rc != MDB_SUCCESS)
+  {
+    h->txn = NULL;
+    fprintf(stderr, "txn_renew: %s\n", mdb_strerror(rc));
+    return NULL;
+  }
+  rc = mdb_get(h->txn, h->db, &key, &data);
+  if (rc == MDB_NOTFOUND)
+  {
+    return NULL;
+  }
+  if (rc != MDB_SUCCESS)
+  {
+    fprintf(stderr, "mdb_get: %s\n", mdb_strerror(rc));
+    return NULL;
+  }
+  /* Caller frees the data we return, so I MUST make a copy of it */
+
+  char *d = safe_malloc(data.mv_size);
+  memcpy(d, data.mv_data, data.mv_size);
+
+  return d;
+
 #else
   strncpy(path, h->folder, sizeof (path));
   safe_strcat(path, sizeof (path), filename);
@@ -762,6 +883,10 @@ mutt_hcache_fetch_raw (header_cache_t *h, const char *filename,
   data = tcbdbget(h->db, path, ksize, &sp);
 
   return data;
+#elif HAVE_KC
+  data = kcdbget(h->db, path, ksize, &sp);
+
+  return data;
 #elif HAVE_GDBM
   key.dptr = path;
   key.dsize = ksize;
@@ -813,6 +938,11 @@ mutt_hcache_store_raw (header_cache_t* h, const char* filename, void* data,
 #elif HAVE_DB4
   DBT key;
   DBT databuf;
+#elif HAVE_LMDB
+  MDB_val key;
+  MDB_val databuf;
+  size_t folderlen;
+  int rc;
 #endif
   
   if (!h)
@@ -831,6 +961,32 @@ mutt_hcache_store_raw (header_cache_t* h, const char* filename, void* data,
   databuf.ulen = dlen;
   
   return h->db->put(h->db, NULL, &key, &databuf, 0);
+#elif HAVE_LMDB
+  folderlen = strlen(h->folder);
+  strncpy(path, h->folder, sizeof (path));
+  safe_strcat(path, sizeof (path), filename);
+  ksize = folderlen + keylen(path + folderlen);
+
+  key.mv_data = (char *)path;
+  key.mv_size = ksize;
+  databuf.mv_data = data;
+  databuf.mv_size = dlen;
+  rc = mdb_get_w_txn(h);
+  if (rc != MDB_SUCCESS)
+  {
+    fprintf(stderr, "txn_begin: %s\n", mdb_strerror(rc));
+    return rc;
+  }
+  rc = mdb_put(h->txn, h->db, &key, &databuf, 0);
+  if (rc != MDB_SUCCESS)
+  {
+    fprintf(stderr, "mdb_put: %s\n", mdb_strerror(rc));
+    mdb_txn_abort(h->txn);
+    h->txn_mode = txn_uninitialized;
+    h->txn = NULL;
+    return rc;
+  }
+  return rc;
 #else
   strncpy(path, h->folder, sizeof (path));
   safe_strcat(path, sizeof (path), filename);
@@ -841,6 +997,8 @@ mutt_hcache_store_raw (header_cache_t* h, const char* filename, void* data,
   return vlput(h->db, path, ksize, data, dlen, VL_DOVER);
 #elif HAVE_TC
   return tcbdbput(h->db, path, ksize, data, dlen);
+#elif HAVE_KC
+  return kcdbset(h->db, path, ksize, data, dlen);
 #elif HAVE_GDBM
   key.dptr = path;
   key.dsize = ksize;
@@ -976,6 +1134,74 @@ mutt_hcache_delete(header_cache_t *h, const char *filename,
   return tcbdbout(h->db, path, ksize);
 }
 
+#elif HAVE_KC
+static int
+hcache_open_kc (struct header_cache *h, const char *path)
+{
+  char kcdbpath[_POSIX_PATH_MAX];
+  int printfresult;
+
+  printfresult = snprintf(kcdbpath, sizeof(kcdbpath),
+                          "%s#type=kct#opts=%s#rcomp=lex",
+                          path, option(OPTHCACHECOMPRESS) ? "lc" : "l");
+  if ((printfresult < 0) || (printfresult >= sizeof(kcdbpath)))
+  {
+    return -1;
+  }
+
+  h->db = kcdbnew();
+  if (!h->db)
+      return -1;
+
+  if (kcdbopen(h->db, kcdbpath, KCOWRITER | KCOCREATE))
+    return 0;
+  else
+  {
+#ifdef DEBUG
+    int ecode = kcdbecode (h->db);
+    dprint (2, (debugfile, "kcdbopen failed for %s: %s (ecode %d)\n", kcdbpath, kcdbemsg (h->db), ecode));
+#endif
+    kcdbdel(h->db);
+    return -1;
+  }
+}
+
+void
+mutt_hcache_close(header_cache_t *h)
+{
+  if (!h)
+    return;
+
+  if (!kcdbclose(h->db))
+  {
+#ifdef DEBUG
+    int ecode = kcdbecode (h->db);
+    dprint (2, (debugfile, "kcdbclose failed for %s: %s (ecode %d)\n", h->folder, kcdbemsg (h->db), ecode));
+#endif
+  }
+  kcdbdel(h->db);
+  FREE(&h->folder);
+  FREE(&h);
+}
+
+int
+mutt_hcache_delete(header_cache_t *h, const char *filename,
+		   size_t(*keylen) (const char *fn))
+{
+  char path[_POSIX_PATH_MAX];
+  int ksize;
+
+  if (!h)
+    return -1;
+
+  strncpy(path, h->folder, sizeof (path));
+  safe_strcat(path, sizeof (path), filename);
+
+  ksize = strlen(h->folder) + keylen(path + strlen(h->folder));
+
+  return kcdbremove(h->db, path, ksize);
+}
+
 #elif HAVE_GDBM
 static int
 hcache_open_gdbm (struct header_cache* h, const char* path)
@@ -1134,6 +1360,113 @@ mutt_hcache_delete(header_cache_t *h, const char *filename,
   mutt_hcache_dbt_init(&key, (void *) filename, keylen(filename));
   return h->db->del(h->db, NULL, &key, 0);
 }
+#elif HAVE_LMDB
+
+static int
+hcache_open_lmdb (struct header_cache* h, const char* path)
+{
+  int rc;
+
+  h->txn = NULL;
+
+  rc = mdb_env_create(&h->env);
+  if (rc != MDB_SUCCESS)
+  {
+    fprintf(stderr, "hcache_open_lmdb: mdb_env_create: %s", mdb_strerror(rc));
+    return -1;
+  }
+
+  mdb_env_set_mapsize(h->env, LMDB_DB_SIZE);
+
+  rc = mdb_env_open(h->env, path, MDB_NOSUBDIR, 0644);
+  if (rc != MDB_SUCCESS)
+  {
+    fprintf(stderr, "hcache_open_lmdb: mdb_env_open: %s", mdb_strerror(rc));
+    goto fail_env;
+  }
+
+  rc = mdb_get_r_txn(h);
+  if (rc != MDB_SUCCESS)
+  {
+      fprintf(stderr, "hcache_open_lmdb: mdb_txn_begin: %s", mdb_strerror(rc));
+      goto fail_env;
+  }
+
+  rc = mdb_dbi_open(h->txn, NULL, MDB_CREATE, &h->db);
+  if (rc != MDB_SUCCESS)
+  {
+    fprintf(stderr, "hcache_open_lmdb: mdb_dbi_open: %s", mdb_strerror(rc));
+    goto fail_dbi;
+  }
+
+  mdb_txn_reset(h->txn);
+  h->txn_mode = txn_uninitialized;
+  return 0;
+
+fail_dbi:
+  mdb_txn_abort(h->txn);
+  h->txn_mode = txn_uninitialized;
+  h->txn = NULL;
+
+fail_env:
+  mdb_env_close(h->env);
+  return -1;
+}
+
+void
+mutt_hcache_close(header_cache_t *h)
+{
+  if (!h)
+    return;
+
+  if (h->txn && h->txn_mode == txn_write)
+  {
+    mdb_txn_commit(h->txn);
+    h->txn_mode = txn_uninitialized;
+    h->txn = NULL;
+  }
+
+  mdb_env_close(h->env);
+  FREE (&h->folder);
+  FREE (&h);
+}
+
+int
+mutt_hcache_delete(header_cache_t *h, const char *filename,
+                   size_t(*keylen) (const char *fn))
+{
+  MDB_val key;
+  int rc;
+
+  if (!h)
+    return -1;
+
+  if (filename[0] == '/')
+    filename++;
+
+  key.mv_data = (char *)filename;
+  key.mv_size = strlen(filename);
+  rc = mdb_get_w_txn(h);
+  if (rc != MDB_SUCCESS)
+  {
+    fprintf(stderr, "txn_begin: %s\n", mdb_strerror(rc));
+    return rc;
+  }
+  rc = mdb_del(h->txn, h->db, &key, NULL);
+  if (rc != MDB_SUCCESS)
+  {
+    if (rc != MDB_NOTFOUND)
+    {
+      fprintf(stderr, "mdb_del: %s\n", mdb_strerror(rc));
+      mdb_txn_abort(h->txn);
+      h->txn_mode = txn_uninitialized;
+      h->txn = NULL;
+    }
+    return rc;
+  }
+
+  return rc;
+}
 #endif
 
 header_cache_t *
@@ -1146,11 +1479,15 @@ mutt_hcache_open(const char *path, const char *folder, hcache_namer_t namer)
 #if HAVE_QDBM
   hcache_open = hcache_open_qdbm;
 #elif HAVE_TC
-  hcache_open= hcache_open_tc;
+  hcache_open = hcache_open_tc;
+#elif HAVE_KC
+  hcache_open = hcache_open_kc;
 #elif HAVE_GDBM
   hcache_open = hcache_open_gdbm;
 #elif HAVE_DB4
   hcache_open = hcache_open_db4;
+#elif HAVE_LMDB
+  hcache_open = hcache_open_lmdb;
 #endif
 
   /* Calculate the current hcache version from dynamic configuration */
@@ -1188,7 +1525,11 @@ mutt_hcache_open(const char *path, const char *folder, hcache_namer_t namer)
     hcachever = digest.intval;
   }
 
+#if HAVE_LMDB
+  h->db = 0;
+#else
   h->db = NULL;
+#endif
   h->folder = get_foldername(folder);
   h->crc = hcachever;
 
@@ -1223,6 +1564,11 @@ const char *mutt_hcache_backend (void)
 {
   return DB_VERSION_STRING;
 }
+#elif HAVE_LMDB
+const char *mutt_hcache_backend (void)
+{
+  return "lmdb " MDB_VERSION_STRING;
+}
 #elif HAVE_GDBM
 const char *mutt_hcache_backend (void)
 {
@@ -1238,4 +1584,14 @@ const char *mutt_hcache_backend (void)
 {
   return "tokyocabinet " _TC_VERSION;
 }
+#elif HAVE_KC
+const char *mutt_hcache_backend (void)
+{
+  /* SHORT_STRING(128) should be more than enough for KCVERSION */
+  static char version_cache[SHORT_STRING] = "";
+  if (!version_cache[0])
+    snprintf(version_cache, sizeof(version_cache), "kyotocabinet %s", KCVERSION);
+
+  return version_cache;
+}
 #endif
diff --git c/hdrline.c w/hdrline.c
index eef19e6..5a7695f 100644
--- c/hdrline.c
+++ w/hdrline.c
@@ -36,6 +36,10 @@
 #include <alloca.h>
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 int mutt_is_mail_list (ADDRESS *addr)
 {
   if (!mutt_match_rx_list (addr->mailbox, UnMailLists))
@@ -103,6 +107,38 @@ static int first_mailing_list (char *buf, size_t buflen, ADDRESS *a)
   return 0;
 }
 
+/**
+ * add_index_color - XXX
+ *
+ * Takes the color to embed, the buffer to manipulate and the buffer length as
+ * arguments.
+ * Returns the number of chars written.
+ */
+static size_t
+add_index_color (char *buf, size_t buflen, format_flag flags, char color)
+{
+  int len;
+
+  /* only add color markers if we are operating on main index entries. */
+  if (!(flags & MUTT_FORMAT_INDEX))
+    return 0;
+
+  if (color == MT_COLOR_INDEX) { /* buf might be uninitialized other cases */
+    len = mutt_strlen (buf);
+    buf += len;
+    buflen -= len;
+  }
+
+  if (buflen < 2)
+    return 0;
+
+  buf[0] = MUTT_SPECIAL_INDEX;
+  buf[1] = color;
+  buf[2] = '\0';
+
+  return 2;
+}
+
 static void make_from (ENVELOPE *hdr, char *buf, size_t len, int do_lists)
 {
   int me;
@@ -211,7 +247,10 @@ int mutt_user_is_recipient (HEADER *h)
  * %E = number of messages in current thread
  * %f = entire from line
  * %F = like %n, unless from self
+ * %g = newsgroup name (if compiled with NNTP support)
+ * %g = message labels (e.g. notmuch tags)
  * %i = message-id
+ * %I = initials of author
  * %l = number of lines in the message
  * %L = like %F, except `lists' are displayed first
  * %m = number of messages in the mailbox
@@ -227,6 +266,8 @@ int mutt_user_is_recipient (HEADER *h)
  * %T = $to_chars
  * %u = user (login) name of author
  * %v = first name of author, unless from self
+ * %W = where user is (organization)
+ * %x = `x-comment-to:' field (if present and compiled with NNTP support)
  * %X = number of MIME attachments
  * %y = `x-label:' field (if present)
  * %Y = `x-label:' field (if present, tree unfolded, and != parent's x-label)
@@ -256,6 +297,7 @@ hdr_format_str (char *dest,
 #define THREAD_NEW (threads && hdr->collapsed && hdr->num_hidden > 1 && mutt_thread_contains_unread (ctx, hdr) == 1)
 #define THREAD_OLD (threads && hdr->collapsed && hdr->num_hidden > 1 && mutt_thread_contains_unread (ctx, hdr) == 2)
   size_t len;
+  size_t colorlen;
 
   hdr = hfi->hdr;
   ctx = hfi->ctx;
@@ -266,18 +308,20 @@ hdr_format_str (char *dest,
     case 'A':
       if(hdr->env->reply_to && hdr->env->reply_to->mailbox)
       {
-	mutt_format_s (dest, destlen, prefix, mutt_addr_for_display (hdr->env->reply_to));
+        colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_AUTHOR);
+        mutt_format_s (dest + colorlen, destlen - colorlen, prefix, mutt_addr_for_display (hdr->env->reply_to));
+        add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
 	break;
       }
       /* fall through if 'A' returns nothing */
 
     case 'a':
+      colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_AUTHOR);
       if(hdr->env->from && hdr->env->from->mailbox)
-      {
-	mutt_format_s (dest, destlen, prefix, mutt_addr_for_display (hdr->env->from));
-      }
+        mutt_format_s (dest + colorlen, destlen - colorlen, prefix, mutt_addr_for_display (hdr->env->from));
       else
-        dest[0] = '\0';
+        mutt_format_s (dest + colorlen, destlen - colorlen, prefix, "");
+      add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
       break;
 
     case 'B':
@@ -307,12 +351,16 @@ hdr_format_str (char *dest,
       break;
     
     case 'c':
+      colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_SIZE);
       mutt_pretty_size (buf2, sizeof (buf2), (long) hdr->content->length);
-      mutt_format_s (dest, destlen, prefix, buf2);
+      mutt_format_s (dest + colorlen, destlen - colorlen, prefix, buf2);
+      add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
       break;
 
     case 'C':
-      snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
+      colorlen = add_index_color (fmt, sizeof (fmt), flags, MT_COLOR_INDEX_NUMBER);
+      snprintf (fmt + colorlen, sizeof (fmt) - colorlen, "%%%sd", prefix);
+      add_index_color (fmt + colorlen, sizeof (fmt) - colorlen, flags, MT_COLOR_INDEX);
       snprintf (dest, destlen, fmt, hdr->msgno + 1);
       break;
 
@@ -328,6 +376,98 @@ hdr_format_str (char *dest,
 	const char *cp;
 	struct tm *tm; 
 	time_t T;
+	int i = 0, invert = 0;
+
+	if (optional && ((op == '[') || (op == '('))) {
+	  char *is;
+	  T = time (NULL);
+	  tm = localtime (&T);
+	  T -= (op == '(') ? hdr->received : hdr->date_sent;
+
+	  is = (char *) prefix;
+	  if (*is == '>') {
+	    invert = 1;
+	    is++;
+	  }
+
+	  while (*is && (*is != '?')) {
+	    int t = strtol (is, &is, 10);
+	    /* semi-broken (assuming 30 days in all months) */
+	    switch (*(is++)) {
+	      case 'y':
+		if (t > 1) {
+		  t--;
+		  t *= (60 * 60 * 24 * 365);
+		}
+		t += ((tm->tm_mon  * 60 * 60 * 24 * 30) +
+		      (tm->tm_mday * 60 * 60 * 24) +
+		      (tm->tm_hour * 60 * 60) +
+		      (tm->tm_min  * 60) +
+		       tm->tm_sec);
+		break;
+
+	      case 'm':
+		if (t > 1) {
+		  t--;
+		  t *= (60 * 60 * 24 * 30);
+		}
+		t += ((tm->tm_mday * 60 * 60 * 24) +
+		      (tm->tm_hour * 60 * 60) +
+		      (tm->tm_min  * 60) +
+		      tm->tm_sec);
+		break;
+
+	      case 'w':
+		if (t > 1) {
+		  t--;
+		  t *= (60 * 60 * 24 * 7);
+		}
+		t += ((tm->tm_wday * 60 * 60 * 24) +
+		      (tm->tm_hour * 60 * 60) +
+		      (tm->tm_min  * 60) +
+		       tm->tm_sec);
+		break;
+
+	      case 'd':
+		if (t > 1) {
+		  t--;
+		  t *= (60 * 60 * 24);
+		}
+		t += ((tm->tm_hour * 60 * 60) +
+		      (tm->tm_min  * 60) +
+		       tm->tm_sec);
+		break;
+
+	      case 'H':
+		if (t > 1) {
+		  t--;
+		  t *= (60 * 60);
+		}
+		t += ((tm->tm_min * 60) +
+		       tm->tm_sec);
+		break;
+
+	      case 'M':
+		if (t > 1) {
+		  t--;
+		  t *= (60);
+		}
+		t += (tm->tm_sec);
+		break;
+
+	      default:
+		break;
+	    }
+	    i += t;
+	  }
+
+	  if (i < 0)
+	    i *= -1;
+
+	  if (((T > i) || (T < (-1*i))) ^ invert)
+	    optional = 0;
+	  break;
+	}
 
 	p = dest;
 
@@ -383,9 +523,6 @@ hdr_format_str (char *dest,
 	}
 	*p = 0;
 
-	if (do_locales && Locale)
-	  setlocale (LC_TIME, Locale);
-
 	if (op == '[' || op == 'D')
 	  tm = localtime (&hdr->date_sent);
 	else if (op == '(')
@@ -406,12 +543,16 @@ hdr_format_str (char *dest,
 	  tm = gmtime (&T);
 	}
 
-	strftime (buf2, sizeof (buf2), dest, tm);
+        if (!do_locales)
+          setlocale (LC_TIME, "C");
+        strftime (buf2, sizeof (buf2), dest, tm);
+        if (!do_locales)
+          setlocale (LC_TIME, "");
 
-	if (do_locales)
-	  setlocale (LC_TIME, "C");
+	colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_DATE);
+	mutt_format_s (dest + colorlen, destlen - colorlen, prefix, buf2);
+	add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
 
-	mutt_format_s (dest, destlen, prefix, buf2);
 	if (len > 0 && op != 'd' && op != 'D') /* Skip ending op */
 	  src = cp + 1;
       }
@@ -441,13 +582,28 @@ hdr_format_str (char *dest,
     case 'F':
       if (!optional)
       {
+        colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_AUTHOR);
         make_from (hdr->env, buf2, sizeof (buf2), 0);
-	mutt_format_s (dest, destlen, prefix, buf2);
+        mutt_format_s (dest + colorlen, destlen - colorlen, prefix, buf2);
+        add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
       }
       else if (mutt_addr_is_user (hdr->env->from))
         optional = 0;
       break;
 
+#ifdef USE_NOTMUCH
+    case 'g':
+      if (!optional)
+      {
+        colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_TAGS);
+        mutt_format_s (dest+colorlen, destlen-colorlen, prefix, nm_header_get_tags_transformed(hdr));
+        add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
+      }
+      else if (!nm_header_get_tags_transformed(hdr))
+        optional = 0;
+      break;
+#endif
+
     case 'H':
       /* (Hormel) spam score */
       if (optional)
@@ -460,15 +616,45 @@ hdr_format_str (char *dest,
 
       break;
 
+#ifdef USE_NNTP
+    case 'q':
+      mutt_format_s (dest, destlen, prefix, hdr->env->newsgroups ? hdr->env->newsgroups : "");
+      break;
+#endif
+
     case 'i':
       mutt_format_s (dest, destlen, prefix, hdr->env->message_id ? hdr->env->message_id : "<no.id>");
       break;
 
+    case 'I':
+      {
+	int iflag = FALSE;
+	int j = 0;
+
+	for (i = 0; hdr->env->from && hdr->env->from->personal &&
+		    hdr->env->from->personal[i] && (j < (SHORT_STRING - 1)); i++) {
+	  if (isalpha ((int) hdr->env->from->personal[i])) {
+	    if (!iflag) {
+	      buf2[j++] = hdr->env->from->personal[i];
+	      iflag = TRUE;
+	    }
+	  } else {
+	    iflag = FALSE;
+	  }
+	}
+
+	buf2[j] = '\0';
+      }
+      mutt_format_s (dest, destlen, prefix, buf2);
+      break;
+
     case 'l':
       if (!optional)
       {
 	snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
-	snprintf (dest, destlen, fmt, (int) hdr->lines);
+	colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_SIZE);
+	snprintf (dest + colorlen, destlen - colorlen, fmt, (int) hdr->lines);
+	add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
       }
       else if (hdr->lines <= 0)
         optional = 0;
@@ -477,8 +663,10 @@ hdr_format_str (char *dest,
     case 'L':
       if (!optional)
       {
+	colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_AUTHOR);
 	make_from (hdr->env, buf2, sizeof (buf2), 1);
-	mutt_format_s (dest, destlen, prefix, buf2);
+	mutt_format_s (dest + colorlen, destlen - colorlen, prefix, buf2);
+	add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
       }
       else if (!check_for_mailing_list (hdr->env->to, NULL, NULL, 0) &&
 	       !check_for_mailing_list (hdr->env->cc, NULL, NULL, 0))
@@ -498,7 +686,9 @@ hdr_format_str (char *dest,
       break;
 
     case 'n':
-      mutt_format_s (dest, destlen, prefix, mutt_get_name (hdr->env->from));
+      colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_AUTHOR);
+      mutt_format_s (dest + colorlen, destlen - colorlen, prefix, mutt_get_name (hdr->env->from));
+      add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
       break;
 
     case 'N':
@@ -533,10 +723,18 @@ hdr_format_str (char *dest,
       snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
       if (!optional)
       {
+	colorlen = add_index_color (dest, destlen, flags,
+				   MT_COLOR_INDEX_COLLAPSED);
 	if (threads && is_index && hdr->collapsed && hdr->num_hidden > 1)
-	  snprintf (dest, destlen, fmt, hdr->num_hidden);
+	{
+	  snprintf (dest + colorlen, destlen - colorlen, fmt, hdr->num_hidden);
+	  add_index_color (dest, destlen - colorlen, flags, MT_COLOR_INDEX);
+	}
 	else if (is_index && threads)
-	  mutt_format_s (dest, destlen, prefix, " ");
+	{
+	  mutt_format_s (dest + colorlen, destlen - colorlen, prefix, " ");
+	  add_index_color (dest, destlen - colorlen, flags, MT_COLOR_INDEX);
+	}
 	else
 	  *dest = '\0';
       }
@@ -573,7 +771,9 @@ hdr_format_str (char *dest,
       {
 	if (flags & MUTT_FORMAT_FORCESUBJ)
 	{
-	  mutt_format_s (dest, destlen, "", NONULL (hdr->env->subject));
+	  colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_SUBJECT);
+	  mutt_format_s (dest + colorlen, destlen - colorlen, "", NONULL (hdr->env->subject));
+	  add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
 	  snprintf (buf2, sizeof (buf2), "%s%s", hdr->tree, dest);
 	  mutt_format_s_tree (dest, destlen, prefix, buf2);
 	}
@@ -581,7 +781,11 @@ hdr_format_str (char *dest,
 	  mutt_format_s_tree (dest, destlen, prefix, hdr->tree);
       }
       else
-	mutt_format_s (dest, destlen, prefix, NONULL (hdr->env->subject));
+      {
+	colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_SUBJECT);
+	mutt_format_s (dest + colorlen, destlen - colorlen, prefix, NONULL (hdr->env->subject));
+	add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
+      }
       break;
 
     case 'S':
@@ -604,8 +808,11 @@ hdr_format_str (char *dest,
 
       /* FOO - this is probably unsafe, but we are not likely to have such
 	 a short string passed into this routine */
-      *dest = ch;
-      *(dest + 1) = 0;
+      buf2[0] = ch;
+      buf2[1] = 0;
+      colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_FLAGS);
+      mutt_format_s (dest + colorlen, destlen - colorlen, prefix, buf2);
+      add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
       break;
 
     case 't':
@@ -656,6 +863,22 @@ hdr_format_str (char *dest,
       mutt_format_s (dest, destlen, prefix, buf2);
       break;
 
+    case 'W':
+      if (!optional)
+	mutt_format_s (dest, destlen, prefix, hdr->env->organization ? hdr->env->organization : "");
+      else if (!hdr->env->organization)
+	optional = 0;
+      break;
+
+#ifdef USE_NNTP
+    case 'x':
+      if (!optional)
+	mutt_format_s (dest, destlen, prefix, hdr->env->x_comment_to ? hdr->env->x_comment_to : "");
+      else if (!hdr->env->x_comment_to)
+	optional = 0;
+      break;
+#endif
+
     case 'Z':
     
       ch = ' ';
@@ -677,7 +900,9 @@ hdr_format_str (char *dest,
 		hdr->tagged ? '*' :
 		(hdr->flagged ? '!' :
 		 (Tochars && ((i = mutt_user_is_recipient (hdr)) < mutt_strlen (Tochars)) ? Tochars[i] : ' ')));
-      mutt_format_s (dest, destlen, prefix, buf2);
+      colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_FLAGS);
+      mutt_format_s (dest + colorlen, destlen - colorlen, prefix, buf2);
+      add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
       break;
 
     case 'X':
@@ -695,40 +920,101 @@ hdr_format_str (char *dest,
 
      case 'y':
        if (optional)
-	 optional = hdr->env->x_label ? 1 : 0;
+	 optional = hdr->env->labels ? 1 : 0;
 
-       mutt_format_s (dest, destlen, prefix, NONULL (hdr->env->x_label));
+       colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_LABEL);
+       mutt_format_s (dest + colorlen, destlen - colorlen, prefix, mutt_labels(NULL, 0, hdr->env, NULL));
+       add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
        break;
  
     case 'Y':
-      if (hdr->env->x_label)
+      if (hdr->env->labels == NULL)
       {
-	i = 1;	/* reduce reuse recycle */
-	htmp = NULL;
-	if (flags & MUTT_FORMAT_TREE
-	    && (hdr->thread->prev && hdr->thread->prev->message
-		&& hdr->thread->prev->message->env->x_label))
-	  htmp = hdr->thread->prev->message;
-	else if (flags & MUTT_FORMAT_TREE
-		 && (hdr->thread->parent && hdr->thread->parent->message
-		     && hdr->thread->parent->message->env->x_label))
-	  htmp = hdr->thread->parent->message;
-	if (htmp && mutt_strcasecmp (hdr->env->x_label,
-				     htmp->env->x_label) == 0)
-	  i = 0;
+        if (optional)
+          optional = 0;
+        mutt_format_s(dest, destlen, prefix, "");
+        break;
       }
       else
-	i = 0;
+      {
+        char labels[HUGE_STRING];
+        char labelstmp[HUGE_STRING];
+
+        i = 1;  /* reduce reuse recycle */
+        htmp = NULL;
+        if ((flags & MUTT_FORMAT_TREE) &&
+            hdr->thread->prev &&
+            hdr->thread->prev->message &&
+            hdr->thread->prev->message->env->labels)
+          htmp = hdr->thread->prev->message;
+        else if ((flags & MUTT_FORMAT_TREE) &&
+                 hdr->thread->parent &&
+                 hdr->thread->parent->message &&
+                 hdr->thread->parent->message->env->labels)
+          htmp = hdr->thread->parent->message;
+
+        mutt_labels(labels, sizeof(labels), hdr->env, NULL);
+        if (htmp)
+        {
+          mutt_labels(labelstmp, sizeof(labelstmp), htmp->env, NULL);
+          if (htmp && mutt_strcasecmp (labels, labelstmp) == 0)
+            i = 0;
+        }
+
+        if (optional)
+	  optional = i;
+
+        colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_LABEL);
+        if (i)
+	  mutt_format_s (dest + colorlen, destlen - colorlen, prefix, labels);
+        else
+          mutt_format_s (dest + colorlen, destlen - colorlen, prefix, "");
+        add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
+      }
 
-      if (optional)
-	optional = i;
+      break;
 
-      if (i)
-        mutt_format_s (dest, destlen, prefix, NONULL (hdr->env->x_label));
+#ifdef USE_NOTMUCH
+    case 'G':
+    {
+      char *tag_transformed;
+      char format[3];
+      char *tag;
+
+      if (!optional)
+      {
+        format[0] = op;
+        format[1] = *src;
+        format[2] = 0;
+
+        tag = hash_find(TagFormats, format);
+        if (tag != NULL)
+        {
+            tag_transformed = nm_header_get_tag_transformed(tag, hdr);
+
+            colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_TAG);
+            mutt_format_s (dest+colorlen, destlen-colorlen, prefix,
+                           (tag_transformed) ? tag_transformed : "");
+            add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
+        }
+
+        src++;
+      }
       else
-        mutt_format_s (dest, destlen, prefix, "");
+      {
+        format[0] = op;
+        format[1] = *prefix;
+        format[2] = 0;
+
+        tag = hash_find(TagFormats, format);
+        if (tag != NULL)
+          if (nm_header_get_tag_transformed(tag, hdr) == NULL)
+            optional = 0;
+      }
 
       break;
+    }
+#endif
 
     default:
       snprintf (dest, destlen, "%%%s%c", prefix, op);
diff --git c/headers.c w/headers.c
index 0a75998..130b9b2 100644
--- c/headers.c
+++ w/headers.c
@@ -114,6 +114,9 @@ void mutt_edit_headers (const char *editor,
      $edit_headers set, we remove References: as they're likely invalid;
      we can simply compare strings as we don't generate References for
      multiple Message-Ids in IRT anyways */
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
   if (msg->env->in_reply_to &&
       (!n->in_reply_to || mutt_strcmp (n->in_reply_to->data,
 				       msg->env->in_reply_to->data) != 0))
@@ -211,3 +214,195 @@ void mutt_edit_headers (const char *editor,
     }
   }
 }
+
+void mutt_label_ref_dec(ENVELOPE *env)
+{
+  uintptr_t count;
+  LIST *label;
+
+  if (!env || !env->labels || !Labels)
+    return;
+
+  for (label = env->labels; label; label = label->next)
+  {
+    if (label->data == NULL)
+      continue;
+    count = (uintptr_t)hash_find(Labels, label->data);
+    if (count)
+    {
+      hash_delete(Labels, label->data, NULL, NULL);
+      count--;
+      if (count > 0)
+        hash_insert(Labels, label->data, (void *)count, 0);
+    }
+    dprint(1, (debugfile, "--label %s: %d\n", label->data, count));
+  }
+}
+
+void mutt_label_ref_inc(ENVELOPE *env)
+{
+  uintptr_t count;
+  LIST *label;
+
+  if (!env || !env->labels || !Labels)
+    return;
+
+  for (label = env->labels; label; label = label->next)
+  {
+    if (label->data == NULL)
+      continue;
+    count = (uintptr_t)hash_find(Labels, label->data);
+    if (count)
+      hash_delete(Labels, label->data, NULL, NULL);
+    count++;  /* was zero if not found */
+    hash_insert(Labels, label->data, (void *)count, 0);
+    dprint(1, (debugfile, "++label %s: %d\n", label->data, count));
+  }
+}
+
+/*
+ * set labels on a message
+ */
+static int label_message(HEADER *hdr, char *new)
+{
+  if (hdr == NULL)
+    return 0;
+  if (hdr->env->labels == NULL && new == NULL)
+    return 0;
+  if (hdr->env->labels != NULL && new != NULL)
+  {
+    char old[HUGE_STRING];
+    mutt_labels(old, sizeof(old), hdr->env, NULL);
+    if (!strcmp(old, new))
+      return 0;
+  }
+
+  if (hdr->env->labels != NULL)
+  {
+    mutt_label_ref_dec(hdr->env);
+    mutt_free_list(&hdr->env->labels);
+  }
+
+  if ((new != NULL) && (*new != '\0'))
+  {
+    char *last, *label;
+
+    for (label = strtok_r(new, ",", &last); label;
+         label = strtok_r(NULL, ",", &last)) 
+    {
+      SKIPWS(label);
+      if (mutt_find_list(hdr->env->labels, label))
+        continue;
+      if (hdr->env->labels == NULL)
+      {
+        hdr->env->labels = mutt_new_list();
+        hdr->env->labels->data = safe_strdup(label);
+      }
+      else
+        mutt_add_list(hdr->env->labels, label);
+    }
+    mutt_label_ref_inc(hdr->env);
+  }
+  return hdr->changed = hdr->label_changed = 1;
+}
+
+int mutt_label_message(HEADER *hdr)
+{
+  char buf[LONG_STRING], *new;
+  int i;
+  int changed;
+
+  *buf = '\0';
+  if (hdr != NULL && hdr->env->labels != NULL)
+    mutt_labels(buf, sizeof(buf)-2, hdr->env, NULL);
+
+  /* add a comma-space so that new typing is a new keyword */
+  if (buf[0])
+    strcat(buf, ", ");    /* __STRCAT_CHECKED__ */
+
+  if (mutt_get_field("Label: ", buf, sizeof(buf), MUTT_LABEL /* | MUTT_CLEAR */) != 0)
+    return 0;
+
+  new = buf;
+  SKIPWS(new);
+  if (new && *new)
+  {
+    char *p;
+    int len = strlen(new);
+    p = &new[len]; /* '\0' */
+    while (p > new)
+    {
+      if (!isspace((unsigned char)*(p-1)) && *(p-1) != ',')
+        break;
+      p--;
+    }
+    *p = '\0';
+  }
+  if (*new == '\0')
+    new = NULL;
+
+  changed = 0;
+  if (hdr != NULL) {
+    changed += label_message(hdr, new);
+  } else {
+#define HDR_OF(index) Context->hdrs[Context->v2r[(index)]]
+    for (i = 0; i < Context->vcount; ++i) {
+      if (HDR_OF(i)->tagged)
+        if (label_message(HDR_OF(i), new)) {
+          ++changed;
+        }
+    }
+  }
+
+  return changed;
+}
+
+/* scan a context (mailbox) and hash all labels we find */
+void mutt_scan_labels(CONTEXT *ctx)
+{
+  int i;
+
+  if (!ctx)
+    return;
+
+  for (i = 0; i < ctx->msgcount; i++)
+    if (ctx->hdrs[i]->env->labels)
+      mutt_label_ref_inc(ctx->hdrs[i]->env);
+}
+
+
+char *mutt_labels(char *dst, int sz, ENVELOPE *env, char *sep)
+{
+  static char sbuf[HUGE_STRING];
+  int off = 0;
+  int len;
+  LIST *label;
+
+  if (sep == NULL)
+    sep = ", ";
+
+  if (dst == NULL)
+  {
+    dst = sbuf;
+    sz = sizeof(sbuf);
+  }
+
+  *dst = '\0';
+
+  for (label = env->labels; label; label = label->next)
+  {
+    if (label->data == NULL)
+      continue;
+    len = MIN(mutt_strlen(label->data), sz-off);
+    strfcpy(&dst[off], label->data, len+1);
+    off += len;
+    if (label->next)
+    {
+      len = MIN(mutt_strlen(sep), sz-off);
+      strfcpy(&dst[off], sep, len+1);
+      off += len;
+    }
+  }
+
+  return dst;
+}
diff --git c/hook.c w/hook.c
index 1b906c3..dbf78d5 100644
--- c/hook.c
+++ w/hook.c
@@ -24,6 +24,10 @@
 #include "mailbox.h"
 #include "mutt_crypt.h"
 
+#ifdef USE_COMPRESSED
+#include "compress.h"
+#endif
+
 #include <limits.h>
 #include <string.h>
 #include <stdlib.h>
@@ -109,6 +113,14 @@ int mutt_parse_hook (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
     memset (&pattern, 0, sizeof (pattern));
     pattern.data = safe_strdup (path);
   }
+#ifdef USE_COMPRESSED
+  else if (data & (MUTT_APPENDHOOK | MUTT_OPENHOOK | MUTT_CLOSEHOOK)) {
+    if (comp_valid_command (command.data) == 0) {
+      strfcpy (err->data, _("badly formatted command string"), err->dsize);
+      return -1;
+    }
+  }
+#endif
   else if (DefaultHook && !(data & (MUTT_CHARSETHOOK | MUTT_ICONVHOOK | MUTT_ACCOUNTHOOK))
            && (!WithCrypto || !(data & MUTT_CRYPTHOOK))
       )
@@ -142,7 +154,7 @@ int mutt_parse_hook (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
 	ptr->rx.not == not &&
 	!mutt_strcmp (pattern.data, ptr->rx.pattern))
     {
-      if (data & (MUTT_FOLDERHOOK | MUTT_SENDHOOK | MUTT_SEND2HOOK | MUTT_MESSAGEHOOK | MUTT_ACCOUNTHOOK | MUTT_REPLYHOOK | MUTT_CRYPTHOOK))
+      if (data & (MUTT_FOLDERHOOK | MUTT_SENDHOOK | MUTT_SEND2HOOK | MUTT_MESSAGEHOOK | MUTT_ACCOUNTHOOK | MUTT_REPLYHOOK | MUTT_CRYPTHOOK | MUTT_TIMEOUTHOOK))
       {
 	/* these hooks allow multiple commands with the same
 	 * pattern, so if we've already seen this pattern/command pair, just
@@ -362,7 +374,7 @@ void mutt_message_hook (CONTEXT *ctx, HEADER *hdr, int type)
 
     if (hook->type & type)
       if ((mutt_pattern_exec (hook->pattern, 0, ctx, hdr) > 0) ^ hook->rx.not)
-	if (mutt_parse_rc_line (hook->command, &token, &err) != 0)
+	if (mutt_parse_rc_line (hook->command, &token, &err) == -1)
 	{
 	  FREE (&token.data);
 	  mutt_error ("%s", err.data);
@@ -542,3 +554,32 @@ void mutt_account_hook (const char* url)
   FREE (&err.data);
 }
 #endif
+
+void mutt_timeout_hook (void)
+{
+  HOOK *hook;
+  BUFFER token;
+  BUFFER err;
+  char buf[STRING];
+
+  err.data = buf;
+  err.dsize = sizeof (buf);
+  memset (&token, 0, sizeof (token));
+
+  for (hook = Hooks; hook; hook = hook->next)
+  {
+    if (!(hook->command && (hook->type & MUTT_TIMEOUTHOOK)))
+      continue;
+
+    if (mutt_parse_rc_line (hook->command, &token, &err) == -1)
+    {
+      FREE (&token.data);
+      mutt_error ("%s", err.data);
+      mutt_sleep (1);
+
+      /* The hooks should be independent of each other, so even though this on
+       * failed, we'll carry on with the others. */
+    }
+  }
+}
+
diff --git c/imap/command.c w/imap/command.c
index 4d34d24..5177475 100644
--- c/imap/command.c
+++ w/imap/command.c
@@ -242,9 +242,12 @@ int imap_exec (IMAP_DATA* idata, const char* cmdstr, int flags)
   if (flags & IMAP_CMD_QUEUE)
     return 0;
 
+  // Allow interruptions, particularly useful if there are network problems.
+  mutt_allow_interrupt (1);
   do
     rc = imap_cmd_step (idata);
   while (rc == IMAP_CMD_CONTINUE);
+  mutt_allow_interrupt (0);
 
   if (rc == IMAP_CMD_NO && (flags & IMAP_CMD_FAIL_OK))
     return -2;
diff --git c/imap/imap.c w/imap/imap.c
index 2e3d27d..f560161 100644
--- c/imap/imap.c
+++ w/imap/imap.c
@@ -306,7 +306,7 @@ static int imap_check_capabilities (IMAP_DATA* idata)
   if (!(mutt_bit_isset(idata->capabilities,IMAP4)
       ||mutt_bit_isset(idata->capabilities,IMAP4REV1)))
   {
-    mutt_error _("This IMAP server is ancient. Mutt does not work with it.");
+    mutt_error _("This IMAP server is ancient. NeoMutt does not work with it.");
     mutt_sleep (2);	/* pause a moment to let the user see the error */
 
     return -1;
@@ -1240,7 +1240,7 @@ int imap_sync_mailbox (CONTEXT* ctx, int expunge, int* index_hint)
        * we delete the message and reupload it.
        * This works better if we're expunging, of course. */
       if ((h->env && (h->env->refs_changed || h->env->irt_changed)) ||
-	  h->attach_del)
+	  h->attach_del || h->label_changed)
       {
         mutt_message (_("Saving changed messages... [%d/%d]"), n+1,
                       ctx->msgcount);
@@ -1250,6 +1250,7 @@ int imap_sync_mailbox (CONTEXT* ctx, int expunge, int* index_hint)
 	  dprint (1, (debugfile, "imap_sync_mailbox: Error opening mailbox in append mode\n"));
 	else
 	  _mutt_save_message (h, appendctx, 1, 0, 0);
+	h->label_changed = 0;
       }
     }
   }
diff --git c/imap/imap.h w/imap/imap.h
index 94506ea..584982d 100644
--- c/imap/imap.h
+++ w/imap/imap.h
@@ -70,5 +70,8 @@ int imap_wait_keepalive (pid_t pid);
 void imap_keepalive (void);
 
 int imap_account_match (const ACCOUNT* a1, const ACCOUNT* a2);
+void imap_get_parent (char *output, const char *mbox, size_t olen, char delim);
+void imap_get_parent_path (char *output, const char *path, size_t olen);
+void imap_clean_path (char *path, size_t plen);
 
 #endif
diff --git c/imap/message.c w/imap/message.c
index 5ce5858..3e8b555 100644
--- c/imap/message.c
+++ w/imap/message.c
@@ -69,7 +69,7 @@ int imap_read_headers (IMAP_DATA* idata, int msgbegin, int msgend)
   int rc, mfhrc, oldmsgcount;
   int fetchlast = 0;
   int maxuid = 0;
-  static const char * const want_headers = "DATE FROM SUBJECT TO CC MESSAGE-ID REFERENCES CONTENT-TYPE CONTENT-DESCRIPTION IN-REPLY-TO REPLY-TO LINES LIST-POST X-LABEL";
+  static const char * const want_headers = "DATE FROM SUBJECT TO CC MESSAGE-ID REFERENCES CONTENT-TYPE CONTENT-DESCRIPTION IN-REPLY-TO REPLY-TO LINES LIST-POST X-LABEL X-KEYWORDS X-MOZILLA-KEYS KEYWORDS X-ORIGINAL-TO";
   progress_t progress;
   int retval = -1;
 
@@ -407,6 +407,7 @@ int imap_fetch_message (CONTEXT *ctx, MESSAGE *msg, int msgno)
   IMAP_CACHE *cache;
   int read;
   int rc;
+
   /* Sam's weird courier server returns an OK response even when FETCH
    * fails. Thanks Sam. */
   short fetched = 0;
diff --git c/imap/util.c w/imap/util.c
index 924d573..cb911a1 100644
--- c/imap/util.c
+++ w/imap/util.c
@@ -72,6 +72,107 @@ int imap_expand_path (char* path, size_t len)
   return rc;
 }
 
+/* Public function
+ *
+ * Provided an imap mbox name and a delimiter, returns the mbox parent
+ * name.
+ *
+ * Could be static with a prototype in imap_private.h, but could be useful
+ * as a public function.
+ */
+void imap_get_parent (char *output, const char *mbox, size_t olen, char delim)
+{
+  int n;
+
+  /* Make a copy of the mailbox name, but only if the pointers are different */
+  if (mbox != output)
+    strfcpy (output, mbox, olen);
+
+  n = mutt_strlen (output);
+
+  /* Let's go backwards until the next delimiter
+   *
+   * If output[n] is a '/', the first n-- will allow us
+   * to ignore it. If it isn't, then output looks like
+   * "/aaaaa/bbbb". There is at least one "b", so we can't skip
+   * the "/" after the 'a's.
+   *
+   * If output == '/', then n-- => n == 0, so the loop ends
+   * immediately
+   */
+  for (n--; n >= 0 && output[n] != delim ; n--);
+
+  /* We stopped before the beginning. There is a trailing
+   * slash.
+   */
+  if (n > 0)
+  {
+    /* Strip the trailing delimiter.  */
+    output[n] = '\0';
+  }
+  else
+  {
+    output[0] = (n == 0) ? delim : '\0';
+  }
+}
+
+/* Public function
+ * Provided an imap path, returns in output the parent directory if
+ * existent. Else returns the same path.
+ */
+void imap_get_parent_path (char *output, const char *path, size_t olen)
+{
+  IMAP_MBOX mx;
+  IMAP_DATA *idata;
+  char mbox[LONG_STRING] = "";
+
+  if (imap_parse_path (path, &mx) < 0)
+  {
+    strfcpy (output, path, olen);
+    return;
+  }
+
+  idata = imap_conn_find (&mx.account, MUTT_IMAP_CONN_NONEW);
+  if (!idata)
+  {
+    strfcpy (output, path, olen);
+    return;
+  }
+
+  /* Stores a fixed path in mbox */
+  imap_fix_path (idata, mx.mbox, mbox, sizeof (mbox));
+
+  /* Gets the parent mbox in mbox */
+  imap_get_parent (mbox, mbox, sizeof (mbox), idata->delim);
+
+  /* Returns a fully qualified IMAP url */
+  imap_qualify_path (output, olen, &mx, mbox);
+}
+
+/* Public function
+ *
+ * Cleans an IMAP path using imap_fix_path. Does it in place.
+ */
+void imap_clean_path (char *path, size_t plen)
+{
+  IMAP_MBOX mx;
+  IMAP_DATA *idata;
+  char mbox[LONG_STRING] = "";
+
+  if (imap_parse_path (path, &mx) < 0)
+    return;
+
+  idata = imap_conn_find (&mx.account, MUTT_IMAP_CONN_NONEW);
+  if (!idata)
+    return;
+
+  /* Stores a fixed path in mbox */
+  imap_fix_path (idata, mx.mbox, mbox, sizeof (mbox));
+
+  /* Returns a fully qualified IMAP url */
+  imap_qualify_path (path, plen, &mx, mbox);
+}
+
 #ifdef USE_HCACHE
 static int imap_hcache_namer (const char* path, char* dest, size_t dlen)
 {
diff --git c/init.c w/init.c
index 0586638..95e2a7d 100644
--- c/init.c
+++ w/init.c
@@ -32,12 +32,15 @@
 #include "mutt_crypt.h"
 #include "mutt_idna.h"
 #include "group.h"
+#include "version.h"
 
 #if defined(USE_SSL)
 #include "mutt_ssl.h"
 #endif
 
-
+#if USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
 
 #include "mx.h"
 #include "init.h"
@@ -76,6 +79,12 @@ static void myvar_set (const char* var, const char* val);
 static const char* myvar_get (const char* var);
 static void myvar_del (const char* var);
 
+#if USE_NOTMUCH
+/* List of tags found in last call to mutt_nm_query_complete(). */
+static char **nm_tags;
+#endif
+
+
 static void toggle_quadoption (int opt)
 {
   int n = opt/4;
@@ -601,6 +610,125 @@ static void remove_from_list (LIST **l, const char *str)
   }
 }
 
+/**
+ * finish_source - 'finish' command: stop processing current config file
+ * @tmp:  Temporary space shared by all command handlers
+ * @s:    Current line of the config file
+ * @data: data field from init.h:struct command_t
+ * @err:  Buffer for any error message
+ *
+ * If the 'finish' command is found, we should stop reading the current file.
+ *
+ * Returns:
+ *       1 Stop processing the current file
+ *      -1 Failed
+ */
+static int finish_source (BUFFER *tmp, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  if (MoreArgs (s))
+  {
+    snprintf (err->data, err->dsize, _("finish: too many arguments"));
+    return -1;
+  }
+
+  return 1;
+}
+
+/**
+ * parse_ifdef - 'ifdef' command: conditional config
+ * @tmp:  Temporary space shared by all command handlers
+ * @s:    Current line of the config file
+ * @data: data field from init.h:struct command_t
+ * @err:  Buffer for any error message
+ *
+ * The 'ifdef' command allows conditional elements in the config file.
+ * If a given variable, function, command or compile-time symbol exists, then
+ * read the rest of the line of config commands.
+ * e.g.
+ *      ifdef USE_SIDEBAR source ~/.mutt/sidebar.rc
+ *
+ * If (data == 1) then it means use the 'ifndef' (if-not-defined) command.
+ * e.g.
+ *      ifndef USE_IMAP finish
+ *
+ * Returns:
+ *       0 Success
+ *      -1 Failed
+ */
+static int parse_ifdef (BUFFER *tmp, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  int i, j, res = 0;
+  BUFFER token;
+
+  memset (&token, 0, sizeof (token));
+  mutt_extract_token (tmp, s, 0);
+
+  /* is the item defined as a variable? */
+  res = (mutt_option_index (tmp->data) != -1);
+
+  /* is the item a compiled-in feature? */
+  if (!res)
+  {
+    res = feature_enabled (tmp->data);
+  }
+
+  /* or a function? */
+  if (!res)
+  {
+    for (i = 0; !res && (i < MENU_MAX); i++)
+    {
+      const struct binding_t *b = km_get_table (Menus[i].value);
+      if (!b)
+        continue;
+
+      for (j = 0; b[j].name; j++)
+      {
+        if (mutt_strcmp (tmp->data, b[j].name) == 0)
+        {
+          res = 1;
+          break;
+        }
+      }
+    }
+  }
+
+  /* or a command? */
+  if (!res)
+  {
+    for (i = 0; Commands[i].name; i++)
+    {
+      if (mutt_strcmp (tmp->data, Commands[i].name) == 0)
+      {
+        res = 1;
+        break;
+      }
+    }
+  }
+
+  if (!MoreArgs (s))
+  {
+    snprintf (err->data, err->dsize, _("%s: too few arguments"),
+      (data ? "ifndef" : "ifdef"));
+    return -1;
+  }
+  mutt_extract_token (tmp, s, MUTT_TOKEN_SPACE);
+
+  /* ifdef KNOWN_SYMBOL or ifndef UNKNOWN_SYMBOL */
+  if ((res && (data == 0)) || (!res && (data == 1)))
+  {
+                int rc = mutt_parse_rc_line (tmp->data, &token, err);
+    if (rc == -1)
+    {
+      mutt_error ("Error: %s", err->data);
+      FREE(&token.data);
+      return -1;
+    }
+    FREE(&token.data);
+                return rc;
+  }
+  return 0;
+}
+
 static int parse_unignore (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
 {
   do
@@ -2253,7 +2381,7 @@ static int parse_set (BUFFER *tmp, BUFFER *s, unsigned long data, BUFFER *err)
 static int source_rc (const char *rcfile, BUFFER *err)
 {
   FILE *f;
-  int line = 0, rc = 0, conv = 0;
+  int line = 0, rc = 0, conv = 0, line_rc;
   BUFFER token;
   char *linebuf = NULL;
   char *currentline = NULL;
@@ -2282,17 +2410,17 @@ static int source_rc (const char *rcfile, BUFFER *err)
     else 
       currentline=linebuf;
 
-    if (mutt_parse_rc_line (currentline, &token, err) == -1)
-    {
+    line_rc = mutt_parse_rc_line (currentline, &token, err);
+    if (line_rc == -1) {
       mutt_error (_("Error in %s, line %d: %s"), rcfile, line, err->data);
       if (--rc < -MAXERRS) 
       {
         if (conv) FREE(&currentline);
         break;
       }
-    }
-    else
-    {
+    } else if (line_rc == 1) {
+      break;	/* Found "finish" command */
+    } else {
       if (rc < 0)
         rc = -1;
     }
@@ -2347,7 +2475,7 @@ static int parse_source (BUFFER *tmp, BUFFER *s, unsigned long data, BUFFER *err
    err		where to write error messages */
 int mutt_parse_rc_line (/* const */ char *line, BUFFER *token, BUFFER *err)
 {
-  int i, r = -1;
+  int i, r = 0;
   BUFFER expn;
 
   if (!line || !*line)
@@ -2374,22 +2502,24 @@ int mutt_parse_rc_line (/* const */ char *line, BUFFER *token, BUFFER *err)
     {
       if (!mutt_strcmp (token->data, Commands[i].name))
       {
-	if (Commands[i].func (token, &expn, Commands[i].data, err) != 0)
-	  goto finish;
-        break;
+        r = Commands[i].func (token, &expn, Commands[i].data, err);
+        if (r != 0) {   /* -1 Error, +1 Finish */
+          goto finish;  /* Propagate return code */
+        }
+        break;          /* Continue with next command */
       }
     }
     if (!Commands[i].name)
     {
       snprintf (err->data, err->dsize, _("%s: unknown command"), NONULL (token->data));
-      goto finish;
+      r = -1;
+      break;            /* Ignore the rest of the line */
     }
   }
-  r = 0;
 finish:
   if (expn.destroy)
     FREE (&expn.data);
-  return (r);
+  return r;
 }
 
 
@@ -2648,6 +2778,178 @@ int mutt_var_value_complete (char *buffer, size_t len, int pos)
   return 0;
 }
 
+#if USE_NOTMUCH
+
+/* Fetch a list of all notmuch tags and insert them into the completion
+ * machinery.
+ */
+static int complete_all_nm_tags (const char *pt)
+{
+  int num;
+  int tag_count_1 = 0;
+  int tag_count_2 = 0;
+
+  Num_matched = 0;
+  strfcpy (User_typed, pt, sizeof (User_typed));
+  memset (Matches, 0, Matches_listsize);
+  memset (Completed, 0, sizeof (Completed));
+
+  nm_longrun_init(Context, FALSE);
+
+  /* Work out how many tags there are. */
+  if (nm_get_all_tags(Context, NULL, &tag_count_1) || tag_count_1 == 0)
+    goto done;
+
+  /* Free the old list, if any. */
+  if (nm_tags != NULL) {
+    int i;
+    for (i = 0; nm_tags[i] != NULL; i++)
+      FREE (&nm_tags[i]);
+    FREE (&nm_tags);
+  }
+  /* Allocate a new list, with sentinel. */
+  nm_tags = safe_malloc((tag_count_1 + 1) * sizeof (char *));
+  nm_tags[tag_count_1] = NULL;
+
+  /* Get all the tags. */
+  if (nm_get_all_tags(Context, nm_tags, &tag_count_2) ||
+      tag_count_1 != tag_count_2) {
+    FREE (&nm_tags);
+    nm_tags = NULL;
+    nm_longrun_done(Context);
+    return -1;
+  }
+
+  /* Put them into the completion machinery. */
+  for (num = 0; num < tag_count_1; num++) {
+    candidate (Completed, User_typed, nm_tags[num], sizeof (Completed));
+  }
+
+  matches_ensure_morespace (Num_matched);
+  Matches[Num_matched++] = User_typed;
+
+done:
+  nm_longrun_done(Context);
+  return 0;
+}
+
+/* Return the last instance of needle in the haystack, or NULL.
+ * Like strstr(), only backwards, and for a limited haystack length.
+ */
+static const char* rstrnstr(const char* haystack,
+                            size_t haystack_length,
+                            const char* needle)
+{
+  int needle_length = strlen(needle);
+  const char* haystack_end = haystack + haystack_length - needle_length;
+  const char* p;
+
+  for (p = haystack_end; p >= haystack; --p)
+  {
+    size_t i;
+    for (i = 0; i < needle_length; ++i) {
+      if (p[i] != needle[i])
+        goto next;
+    }
+    return p;
+
+    next:;
+  }
+  return NULL;
+}
+
+/* Complete the nearest "tag:"-prefixed string previous to pos. */
+int mutt_nm_query_complete (char *buffer, size_t len, int pos, int numtabs)
+{
+  char *pt = buffer;
+  int spaces;
+
+  SKIPWS (buffer);
+  spaces = buffer - pt;
+
+  pt = (char *)rstrnstr((char *)buffer, pos, "tag:");
+  if (pt != NULL) {
+    pt += 4;
+    if (numtabs == 1) {
+      /* First TAB. Collect all the matches */
+      complete_all_nm_tags(pt);
+
+      /* All matches are stored. Longest non-ambiguous string is ""
+       * i.e. don't change 'buffer'. Fake successful return this time.
+       */
+      if (User_typed[0] == 0)
+	return 1;
+    }
+
+    if (Completed[0] == 0 && User_typed[0])
+      return 0;
+
+    /* Num_matched will _always_ be atleast 1 since the initial
+     * user-typed string is always stored */
+    if (numtabs == 1 && Num_matched == 2)
+      snprintf(Completed, sizeof(Completed),"%s", Matches[0]);
+    else if (numtabs > 1 && Num_matched > 2)
+      /* cycle thru all the matches */
+      snprintf(Completed, sizeof(Completed), "%s",
+	       Matches[(numtabs - 2) % Num_matched]);
+
+    /* return the completed query */
+    strncpy (pt, Completed, buffer + len - pt - spaces);
+  }
+  else
+    return 0;
+
+  return 1;
+}
+
+/* Complete the nearest "+" or "-" -prefixed string previous to pos. */
+int mutt_nm_tag_complete (char *buffer, size_t len, int pos, int numtabs)
+{
+  if (!buffer)
+    return 0;
+
+  char *pt = buffer;
+
+  /* Only examine the last token */
+  char *last_space = strrchr (buffer, ' ');
+  if (last_space)
+    pt = (last_space + 1);
+
+  /* Skip the +/- */
+  if ((pt[0] == '+') || (pt[0] == '-'))
+    pt++;
+
+  if (numtabs == 1)
+  {
+    /* First TAB. Collect all the matches */
+    complete_all_nm_tags(pt);
+
+    /* All matches are stored. Longest non-ambiguous string is ""
+      * i.e. don't change 'buffer'. Fake successful return this time.
+      */
+    if (User_typed[0] == 0)
+      return 1;
+  }
+
+  if (Completed[0] == 0 && User_typed[0])
+    return 0;
+
+  /* Num_matched will _always_ be atleast 1 since the initial
+    * user-typed string is always stored */
+  if (numtabs == 1 && Num_matched == 2)
+    snprintf(Completed, sizeof(Completed),"%s", Matches[0]);
+  else if (numtabs > 1 && Num_matched > 2)
+    /* cycle thru all the matches */
+    snprintf(Completed, sizeof(Completed), "%s",
+	      Matches[(numtabs - 2) % Num_matched]);
+
+  /* return the completed query */
+  strncpy (pt, Completed, buffer + len - pt);
+
+  return 1;
+}
+#endif
+
 static int var_to_string (int idx, char* val, size_t len)
 {
   char tmp[LONG_STRING];
@@ -2851,8 +3153,8 @@ static void start_debug (void)
   if ((debugfile = safe_fopen(buf, "w")) != NULL)
   {
     setbuf (debugfile, NULL); /* don't buffer the debugging output! */
-    dprint(1,(debugfile,"Mutt/%s (%s) debugging at level %d\n",
-	      MUTT_VERSION, ReleaseDate, debuglevel));
+    dprint(1,(debugfile,"NeoMutt/%s (%s) debugging at level %d\n",
+				PACKAGE_VERSION, OldMuttVer, debuglevel));
   }
 }
 #endif
@@ -2867,7 +3169,7 @@ static int mutt_execute_commands (LIST *p)
   mutt_buffer_init (&token);
   for (; p; p = p->next)
   {
-    if (mutt_parse_rc_line (p->data, &token, &err) != 0)
+    if (mutt_parse_rc_line (p->data, &token, &err) == -1)
     {
       fprintf (stderr, _("Error in command line: %s\n"), err.data);
       FREE (&token.data);
@@ -2882,23 +3184,6 @@ static int mutt_execute_commands (LIST *p)
   return 0;
 }
 
-static void mutt_srandom (void)
-{
-  struct timeval tv;
-  unsigned seed;
-
-  gettimeofday(&tv, NULL);
-  /* POSIX.1-2008 states that seed is 'unsigned' without specifying its width.
-   * Use as many of the lower order bits from the current time of day as the seed.
-   * If the upper bound is truncated, that is fine.
-   *
-   * tv_sec is integral of type integer or float.  Cast to 'long long' before
-   * bitshift in case it is a float.
-   */
-  seed = ((LONGLONG) tv.tv_sec << 20) | tv.tv_usec;
-  srandom(seed);
-}
-
 void mutt_init (int skip_sys_rc, LIST *commands)
 {
   struct passwd *pw;
@@ -2915,15 +3200,15 @@ void mutt_init (int skip_sys_rc, LIST *commands)
 
   Groups = hash_create (1031, 0);
   ReverseAlias = hash_create (1031, 1);
-  
+#ifdef USE_NOTMUCH
+  TagTransforms = hash_create (64, 1);
+  TagFormats = hash_create (64, 0);
+#endif
+
   mutt_menu_init ();
-  mutt_srandom ();
 
-  /* 
-   * XXX - use something even more difficult to predict?
-   */
   snprintf (AttachmentMarker, sizeof (AttachmentMarker),
-	    "\033]9;%ld\a", (long) time (NULL));
+	    "\033]9;%" PRIu64 "\a", mutt_rand64());
   
   /* on one of the systems I use, getcwd() does not return the same prefix
      as is listed in the passwd file */
@@ -3017,6 +3302,28 @@ void mutt_init (int skip_sys_rc, LIST *commands)
     Fqdn = safe_strdup(utsname.nodename);
 
 
+#ifdef USE_NNTP
+  {
+    FILE *f;
+    char *i;
+
+    if ((f = safe_fopen (SYSCONFDIR "/nntpserver", "r")))
+    {
+      buffer[0] = '\0';
+      fgets (buffer, sizeof (buffer), f);
+      p = buffer;
+      SKIPWS (p);
+      i = p;
+      while (*i && (*i != ' ') && (*i != '\t') && (*i != '\r') && (*i != '\n')) i++;
+      *i = '\0';
+      NewsServer = safe_strdup (p);
+      fclose (f);
+    }
+  }
+  if ((p = getenv ("NNTPSERVER")))
+    NewsServer = safe_strdup (p);
+#endif
+
   if ((p = getenv ("MAIL")))
     Spoolfile = safe_strdup (p);
   else if ((p = getenv ("MAILDIR")))
@@ -3109,33 +3416,42 @@ void mutt_init (int skip_sys_rc, LIST *commands)
    */
   add_to_list(&MailtoAllow, "body");
   add_to_list(&MailtoAllow, "subject");
-  
-  
-  
-  /*
-   * 
-   *			   BIG FAT WARNING
-   * 
-   * When changing the code which looks for a configuration file,
-   * please also change the corresponding code in muttbug.sh.in.
-   * 
-   * 
-   */
-  
-  
-  
-  
+
   if (!Muttrc)
   {
-    snprintf (buffer, sizeof(buffer), "%s/.muttrc-%s", NONULL(Homedir), MUTT_VERSION);
-    if (access(buffer, F_OK) == -1)
-      snprintf (buffer, sizeof(buffer), "%s/.muttrc", NONULL(Homedir));
-    if (access(buffer, F_OK) == -1)
-      snprintf (buffer, sizeof (buffer), "%s/.mutt/muttrc-%s", NONULL(Homedir), MUTT_VERSION);
-    if (access(buffer, F_OK) == -1)
-      snprintf (buffer, sizeof (buffer), "%s/.mutt/muttrc", NONULL(Homedir));
-    if (access(buffer, F_OK) == -1) /* default to .muttrc for alias_file */
-      snprintf (buffer, sizeof(buffer), "%s/.muttrc", NONULL(Homedir));
+    do
+    {
+      if (mutt_set_xdg_path (kXDGConfigHome, buffer, sizeof buffer))
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/.neomuttrc", NONULL(Homedir));
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/.mutt/neomuttrc", NONULL(Homedir));
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/.muttrc-%s", NONULL(Homedir), PACKAGE_VERSION);
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/.muttrc", NONULL(Homedir));
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/.mutt/muttrc-%s", NONULL(Homedir), PACKAGE_VERSION);
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/.mutt/muttrc", NONULL(Homedir));
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      /* default to .muttrc for alias_file */
+      snprintf (buffer, sizeof buffer, "%s/.muttrc", NONULL(Homedir));
+    }
+    while (0);
 
     default_rc = 1;
     Muttrc = safe_strdup (buffer);
@@ -3154,14 +3470,30 @@ void mutt_init (int skip_sys_rc, LIST *commands)
      requested not to via "-n".  */
   if (!skip_sys_rc)
   {
-    snprintf (buffer, sizeof(buffer), "%s/Muttrc-%s", SYSCONFDIR, MUTT_VERSION);
-    if (access (buffer, F_OK) == -1)
-      snprintf (buffer, sizeof(buffer), "%s/Muttrc", SYSCONFDIR);
-    if (access (buffer, F_OK) == -1)
-      snprintf (buffer, sizeof (buffer), "%s/Muttrc-%s", PKGDATADIR, MUTT_VERSION);
-    if (access (buffer, F_OK) == -1)
-      snprintf (buffer, sizeof (buffer), "%s/Muttrc", PKGDATADIR);
-    if (access (buffer, F_OK) != -1)
+    do
+    {
+      if (mutt_set_xdg_path (kXDGConfigDirs, buffer, sizeof buffer))
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/NeoMuttrc", SYSCONFDIR);
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/Muttrc-%s", SYSCONFDIR, PACKAGE_VERSION);
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/Muttrc", SYSCONFDIR);
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/Muttrc-%s", PKGDATADIR, PACKAGE_VERSION);
+      if (access (buffer, F_OK) == 0)
+        break;
+
+      snprintf (buffer, sizeof buffer, "%s/Muttrc", PKGDATADIR);
+    } while (0);
+    if (access (buffer, F_OK) == 0)
     {
       if (source_rc (buffer, &err) != 0)
       {
@@ -3203,6 +3535,11 @@ void mutt_init (int skip_sys_rc, LIST *commands)
 
   mutt_read_histfile ();
 
+#ifdef USE_NOTMUCH
+  if (option (OPTVIRTSPOOLFILE) && VirtIncoming)
+    mutt_str_replace(&Spoolfile, VirtIncoming->path);
+#endif
+
 #if 0
   set_option (OPTWEED); /* turn weeding on by default */
 #endif
@@ -3250,6 +3587,70 @@ static int parse_group_context (group_context_t **ctx, BUFFER *buf, BUFFER *s, u
   return -1;
 }
 
+#ifdef USE_NOTMUCH
+int parse_tag_transforms (BUFFER *b, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  char *tmp;
+
+  while (MoreArgs (s))
+  {
+    char *tag, *transform;
+
+    mutt_extract_token (b, s, 0);
+    if (b->data && *b->data)
+      tag = safe_strdup (b->data);
+    else
+      continue;
+
+    mutt_extract_token (b, s, 0);
+    transform = safe_strdup (b->data);
+
+    /* avoid duplicates */
+    tmp = hash_find(TagTransforms, tag);
+    if (tmp) {
+      dprint(3,(debugfile,"tag transform '%s' already registered as '%s'\n", tag, tmp));
+      FREE(&tag);
+      FREE(&transform);
+      continue;
+    }
+
+    hash_insert(TagTransforms, tag, transform, 0);
+  }
+  return 0;
+}
+
+int parse_tag_formats (BUFFER *b, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  char *tmp;
+
+  while (MoreArgs (s))
+  {
+    char *tag, *format;
+
+    mutt_extract_token (b, s, 0);
+    if (b->data && *b->data)
+      tag = safe_strdup (b->data);
+    else
+      continue;
+
+    mutt_extract_token (b, s, 0);
+    format = safe_strdup (b->data);
+
+    /* avoid duplicates */
+    tmp = hash_find(TagFormats, format);
+    if (tmp) {
+      dprint(3,(debugfile,"tag format '%s' already registered as '%s'\n", format, tmp));
+      FREE(&tag);
+      FREE(&format);
+      continue;
+    }
+
+    hash_insert(TagFormats, format, tag, 0);
+  }
+  return 0;
+}
+#endif
+
 static void myvar_set (const char* var, const char* val)
 {
   myvar_t** cur;
@@ -3297,3 +3698,58 @@ static const char* myvar_get (const char* var)
 
   return NULL;
 }
+
+int mutt_label_complete (char *buffer, size_t len, int pos, int numtabs)
+{
+  char *pt = buffer;
+  int spaces; /* keep track of the number of leading spaces on the line */
+  int prefix;
+
+  SKIPWS (buffer);
+  spaces = buffer - pt;
+
+  for (pt = buffer; pt && *pt && *(pt+1); pt++);
+  for (; pt > buffer && !isspace(*(pt-1)); pt--);
+  prefix = pt - buffer;
+
+  /* first TAB. Collect all the matches */
+  if (numtabs == 1)
+  {
+    struct hash_elem *entry;
+    struct hash_walk_state state;
+
+    Num_matched = 0;
+    strfcpy (User_typed, pt, sizeof (User_typed));
+    memset (Matches, 0, Matches_listsize);
+    memset (Completed, 0, sizeof (Completed));
+    memset (&state, 0, sizeof(state));
+    while ((entry = hash_walk(Labels, &state)))
+      candidate (Completed, User_typed, entry->key, sizeof (Completed));
+    matches_ensure_morespace (Num_matched);
+    qsort(Matches, Num_matched, sizeof(char *), (sort_t *) mutt_strcasecmp);
+    Matches[Num_matched++] = User_typed;
+
+    /* All matches are stored. Longest non-ambiguous string is ""
+     * i.e. dont change 'buffer'. Fake successful return this time */
+    if (User_typed[0] == 0)
+      return 1;
+  }
+
+  if (Completed[0] == 0 && User_typed[0])
+    return 0;
+
+   /* Num_matched will _always_ be atleast 1 since the initial
+    * user-typed string is always stored */
+  if (numtabs == 1 && Num_matched == 2)
+    snprintf(Completed, sizeof(Completed), "%s", Matches[0]);
+  else if (numtabs > 1 && Num_matched > 2)
+    /* cycle thru all the matches */
+    snprintf(Completed, sizeof(Completed), "%s", 
+             Matches[(numtabs - 2) % Num_matched]);
+
+  /* return the completed label */
+  strncpy (&buffer[prefix], Completed, len - spaces);
+
+  return 1;
+}
+
diff --git c/init.h w/init.h
index 3f3f96d..0c76cd0 100644
--- c/init.h
+++ w/init.h
@@ -86,6 +86,15 @@ struct option_t
 
 struct option_t MuttVars[] = {
   /*++*/
+
+  { "abort_noattach", DT_QUAD, R_NONE, OPT_ATTACH, MUTT_NO },
+  /*
+  ** .pp
+  ** If set to \fIyes\fP, when composing messages containing the regular expression
+  ** specified by $attach_keyword (default is "\\<attach(|ed|ments?)\\>") and no attachments
+  ** are given, composition will be aborted. If set to \fIno\fP, composing
+  ** messages as such will never be aborted.
+  */
   { "abort_nosubject",	DT_QUAD, R_NONE, OPT_SUBJECT, MUTT_ASKYES },
   /*
   ** .pp
@@ -179,6 +188,20 @@ struct option_t MuttVars[] = {
   ** If \fIset\fP, Mutt will prompt you for carbon-copy (Cc) recipients before
   ** editing the body of an outgoing message.
   */
+#ifdef USE_NNTP
+  { "ask_follow_up",	DT_BOOL, R_NONE, OPTASKFOLLOWUP, 0 },
+  /*
+  ** .pp
+  ** If set, Mutt will prompt you for follow-up groups before editing
+  ** the body of an outgoing message.
+  */
+  { "ask_x_comment_to",	DT_BOOL, R_NONE, OPTASKXCOMMENTTO, 0 },
+  /*
+  ** .pp
+  ** If set, Mutt will prompt you for x-comment-to field before editing
+  ** the body of an outgoing message.
+  */
+#endif
   { "assumed_charset", DT_STR, R_NONE, UL &AssumedCharset, UL 0},
   /*
   ** .pp
@@ -244,6 +267,13 @@ struct option_t MuttVars[] = {
   ** .pp
   ** For an explanation of ``soft-fill'', see the $$index_format documentation.
   */
+  { "attach_keyword",  DT_RX,  R_NONE, UL &AttachKeyword, UL "\\<attach(|ed|ments?)\\>" },
+  /*
+  ** .pp
+  ** If $abort_noattach is not set to no, then the body of the message
+  ** will be scanned for this regular expression, and if found, you will
+  ** be prompted if there are no attachments.
+  */
   { "attach_sep",	DT_STR,	 R_NONE, UL &AttachSep, UL "\n" },
   /*
   ** .pp
@@ -266,6 +296,18 @@ struct option_t MuttVars[] = {
   ** in a reply.  For a full listing of defined \fCprintf(3)\fP-like sequences see
   ** the section on $$index_format.
   */
+  { "attribution_locale", DT_STR, R_NONE, UL &AttributionLocale, UL "" },
+  /*
+  ** .pp
+  ** The locale used by \fCstrftime(3)\fP to format dates in the
+  ** $attribution string.  Legal values are the strings your system
+  ** accepts for the locale environment variable \fC$$$LC_TIME\fP.
+  ** .pp
+  ** This variable is to allow the attribution date format to be
+  ** customized by recipient or folder using hooks.  By default, Mutt
+  ** will use your locale environment, so there is no need to set
+  ** this except to override that default.
+  */
   { "auto_tag",		DT_BOOL, R_NONE, OPTAUTOTAG, 0 },
   /*
   ** .pp
@@ -293,6 +335,13 @@ struct option_t MuttVars[] = {
   { "beep",		DT_BOOL, R_NONE, OPTBEEP, 1 },
   /*
   ** .pp
+  ** If \fIset\fP, Mutt will call this command after a new message is received.
+  ** See the $$status_format documentation for the values that can be formatted
+  ** into this command.
+  */
+  { "new_mail_command",	DT_PATH, R_NONE, UL &NewMailCmd, UL NULL },
+  /*
+  ** .pp
   ** When this variable is \fIset\fP, mutt will beep when an error occurs.
   */
   { "beep_new",		DT_BOOL, R_NONE, OPTBEEPNEW, 0 },
@@ -325,6 +374,14 @@ struct option_t MuttVars[] = {
   ** follow these menus.  The option is \fIunset\fP by default because many
   ** visual terminals don't permit making the cursor invisible.
   */
+#ifdef USE_NNTP
+  { "catchup_newsgroup", DT_QUAD, R_NONE, OPT_CATCHUP, MUTT_ASKYES },
+  /*
+  ** .pp
+  ** If this variable is \fIset\fP, Mutt will mark all articles in newsgroup
+  ** as read when you quit the newsgroup (catchup newsgroup).
+  */
+#endif
 #if defined(USE_SSL)
   { "certificate_file",	DT_PATH, R_NONE, UL &SslCertFile, UL "~/.mutt_certificates" },
   /*
@@ -392,7 +449,7 @@ struct option_t MuttVars[] = {
   ** When \fIunset\fP, Mutt will not collapse a thread if it contains any
   ** unread messages.
   */
-  { "compose_format",	DT_STR,	 R_BOTH, UL &ComposeFormat, UL "-- Mutt: Compose  [Approx. msg size: %l   Atts: %a]%>-" },
+  { "compose_format",	DT_STR,	 R_BOTH, UL &ComposeFormat, UL "-- NeoMutt: Compose  [Approx. msg size: %l   Atts: %a]%>-" },
   /*
   ** .pp
   ** Controls the format of the status line displayed in the ``compose''
@@ -554,6 +611,12 @@ struct option_t MuttVars[] = {
   ** to find out whether an encrypted message is also signed.
   ** (Crypto only)
   */
+  { "pgp_encrypt_self",		DT_QUAD,	 R_NONE, OPT_PGPENCRYPTSELF, MUTT_NO },
+  /*
+  ** .pp
+  ** Encrypt the message to $$pgp_sign_as too.
+  ** (PGP only)
+  */
   { "crypt_timestamp", DT_BOOL, R_NONE, OPTCRYPTTIMESTAMP, 1 },
   /*
   ** .pp
@@ -599,8 +662,8 @@ struct option_t MuttVars[] = {
   ** function to process the date, see the man page for the proper syntax.
   ** .pp
   ** Unless the first character in the string is a bang (``!''), the month
-  ** and week day names are expanded according to the locale specified in
-  ** the variable $$locale. If the first character in the string is a
+  ** and week day names are expanded according to the locale.
+  ** If the first character in the string is a
   ** bang, the bang is discarded, and the month and week day names in the
   ** rest of the string are expanded in the \fIC\fP locale (that is in US
   ** English).
@@ -852,6 +915,16 @@ struct option_t MuttVars[] = {
   ** sent to both the list and your address, resulting in two copies
   ** of the same email for you.
   */
+#ifdef USE_NNTP
+  { "followup_to_poster", DT_QUAD, R_NONE, OPT_FOLLOWUPTOPOSTER, MUTT_ASKYES },
+  /*
+  ** .pp
+  ** If this variable is \fIset\fP and the keyword "poster" is present in
+  ** \fIFollowup-To\fP header, follow-up to newsgroup function is not
+  ** permitted.  The message will be mailed to the submitter of the
+  ** message via mail.
+  */
+#endif
   { "force_name",	DT_BOOL, R_NONE, OPTFORCENAME, 0 },
   /*
   ** .pp
@@ -934,6 +1007,26 @@ struct option_t MuttVars[] = {
   ** a regular expression that will match the whole name so mutt will expand
   ** ``Franklin'' to ``Franklin, Steve''.
   */
+#ifdef USE_NNTP
+  { "group_index_format", DT_STR, R_BOTH, UL &GroupFormat, UL "%4C %M%N %5s  %-45.45f %d" },
+  /*
+  ** .pp
+  ** This variable allows you to customize the newsgroup browser display to
+  ** your personal taste.  This string is similar to ``$index_format'', but
+  ** has its own set of printf()-like sequences:
+  ** .dl
+  ** .dt %C  .dd current newsgroup number
+  ** .dt %d  .dd description of newsgroup (becomes from server)
+  ** .dt %f  .dd newsgroup name
+  ** .dt %M  .dd - if newsgroup not allowed for direct post (moderated for example)
+  ** .dt %N  .dd N if newsgroup is new, u if unsubscribed, blank otherwise
+  ** .dt %n  .dd number of new articles in newsgroup
+  ** .dt %s  .dd number of unread articles in newsgroup
+  ** .dt %>X .dd right justify the rest of the string and pad with character "X"
+  ** .dt %|X .dd pad to the end of the line with character "X"
+  ** .de
+  */
+#endif
   { "hdr_format",	DT_SYN,  R_NONE, UL "index_format", 0 },
   /*
   */
@@ -965,16 +1058,17 @@ struct option_t MuttVars[] = {
   ** Header caching can greatly improve speed when opening POP, IMAP
   ** MH or Maildir folders, see ``$caching'' for details.
   */
-#if defined(HAVE_QDBM) || defined(HAVE_TC)
+#if defined(HAVE_QDBM) || defined(HAVE_TC) || defined(HAVE_KC)
   { "header_cache_compress", DT_BOOL, R_NONE, OPTHCACHECOMPRESS, 1 },
   /*
   ** .pp
-  ** When mutt is compiled with qdbm or tokyocabinet as header cache backend,
-  ** this option determines whether the database will be compressed.
-  ** Compression results in database files roughly being one fifth
-  ** of the usual diskspace, but the decompression can result in a
-  ** slower opening of cached folder(s) which in general is still
-  ** much faster than opening non header cached folders.
+  ** When mutt is compiled with qdbm, tokyocabinet or kyotocabinet
+  ** as header cache backend, this option determines whether the
+  ** database will be compressed. Compression results in database
+  ** files roughly being one fifth of the usual diskspace, but the
+  ** decompression can result in a slower opening of cached folder(s)
+  ** which in general is still much faster than opening non header
+  ** cached folders.
   */
 #endif /* HAVE_QDBM */
 #if defined(HAVE_GDBM) || defined(HAVE_DB4)
@@ -1326,6 +1420,8 @@ struct option_t MuttVars[] = {
   ** .dt %E .dd number of messages in current thread
   ** .dt %f .dd sender (address + real name), either From: or Return-Path:
   ** .dt %F .dd author name, or recipient name if the message is from you
+  ** .dt %g .dd newsgroup name (if compiled with NNTP support)
+  ** .dt %g .dd message labels (e.g. notmuch tags)
   ** .dt %H .dd spam attribute(s) of this message
   ** .dt %i .dd message-id of the current message
   ** .dt %l .dd number of lines in the message (does not work with maildir,
@@ -1349,6 +1445,8 @@ struct option_t MuttVars[] = {
   ** .dt %T .dd the appropriate character from the $$to_chars string
   ** .dt %u .dd user (login) name of the author
   ** .dt %v .dd first name of the author, or the recipient if the message is from you
+  ** .dt %W .dd name of organization of author (``Organization:'' field)
+  ** .dt %x .dd ``X-Comment-To:'' field (if present and compiled with NNTP support)
   ** .dt %X .dd number of attachments
   **            (please see the ``$attachments'' section for possible speed effects)
   ** .dt %y .dd ``X-Label:'' field, if present
@@ -1372,6 +1470,10 @@ struct option_t MuttVars[] = {
   ** .dt %*X    .dd soft-fill with character ``X'' as pad
   ** .de
   ** .pp
+  ** Date format expressions can be constructed based on relative dates. Using
+  ** the date formatting operators along with nested conditionals, the date
+  ** format can be modified based on how old a message is.  See the section on
+  ** ``Conditional Dates'' for an explanation and examples
   ** ``Soft-fill'' deserves some explanation: Normal right-justification
   ** will print everything to the left of the ``%>'', displaying padding and
   ** whatever lies to the right only if there's room. By contrast,
@@ -1383,6 +1485,25 @@ struct option_t MuttVars[] = {
   ** Note that these expandos are supported in
   ** ``$save-hook'', ``$fcc-hook'' and ``$fcc-save-hook'', too.
   */
+#ifdef USE_NNTP
+  { "inews",		DT_PATH, R_NONE, UL &Inews, UL "" },
+  /*
+  ** .pp
+  ** If set, specifies the program and arguments used to deliver news posted
+  ** by Mutt.  Otherwise, mutt posts article using current connection to
+  ** news server.  The following printf-style sequence is understood:
+  ** .dl
+  ** .dt %a .dd account url
+  ** .dt %p .dd port
+  ** .dt %P .dd port if specified
+  ** .dt %s .dd news server name
+  ** .dt %S .dd url schema
+  ** .dt %u .dd username
+  ** .de
+  ** .pp
+  ** Example: set inews="/usr/local/bin/inews -hS"
+  */
+#endif
   { "ispell",		DT_PATH, R_NONE, UL &Ispell, UL ISPELL },
   /*
   ** .pp
@@ -1395,11 +1516,27 @@ struct option_t MuttVars[] = {
   ** from your spool mailbox to your $$mbox mailbox, or as a result of
   ** a ``$mbox-hook'' command.
   */
-  { "locale",		DT_STR,  R_BOTH, UL &Locale, UL "C" },
+  { "keywords_legacy", DT_BOOL, R_NONE, OPTKEYWORDSLEGACY, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP, keywords/labels/tags will be written to whatever
+  ** legacy, nonstandard headers (X-Label, X-Keywords, X-Mozilla-Keys)
+  ** they were sourced from.
+  ** .pp
+  ** If both ``$$keywords_legacy'' and
+  ** ``$$keywords_standard'' are \fCfalse\fP, mutt will save keywords
+  ** to legacy headers to ensure that it does not lose your labels.
+  */
+  { "keywords_standard", DT_BOOL, R_NONE, OPTKEYWORDSSTANDARD, 0 },
   /*
   ** .pp
-  ** The locale used by \fCstrftime(3)\fP to format dates. Legal values are
-  ** the strings your system accepts for the locale environment variable \fC$$$LC_TIME\fP.
+  ** If \fIset\fP, keywords/labels/tags will be written to the
+  ** RFC2822-standard Keywords: header; this may imply a conversion from
+  ** legacy headers.
+  ** .pp
+  ** If both ``$$keywords_legacy'' and
+  ** ``$$keywords_standard'' are \fCfalse\fP, mutt will save keywords
+  ** to legacy headers to ensure that it does not lose your labels.
   */
   { "mail_check",	DT_NUM,  R_NONE, UL &BuffyTimeout, 5 },
   /*
@@ -1643,6 +1780,15 @@ struct option_t MuttVars[] = {
   ** menu, attachments which cannot be decoded in a reasonable manner will
   ** be attached to the newly composed message if this option is \fIset\fP.
   */
+#ifdef USE_NNTP
+  { "mime_subject",	DT_BOOL, R_NONE, OPTMIMESUBJECT, 1 },
+  /*
+  ** .pp
+  ** If \fIunset\fP, 8-bit ``subject:'' line in article header will not be
+  ** encoded according to RFC2047 to base64.  This is useful when message
+  ** is Usenet article, because MIME for news is nonstandard feature.
+  */
+#endif
 #ifdef MIXMASTER
   { "mix_entry_format", DT_STR,  R_NONE, UL &MixEntryFormat, UL "%4n %c %-16s %a" },
   /*
@@ -1690,6 +1836,160 @@ struct option_t MuttVars[] = {
    ** See also $$read_inc, $$write_inc and $$net_inc.
    */
 #endif
+#ifdef USE_NNTP
+  { "news_cache_dir",	DT_PATH, R_NONE, UL &NewsCacheDir, UL "~/.mutt" },
+  /*
+  ** .pp
+  ** This variable pointing to directory where Mutt will save cached news
+  ** articles and headers in. If \fIunset\fP, articles and headers will not be
+  ** saved at all and will be reloaded from the server each time.
+  */
+  { "news_server",	DT_STR, R_NONE, UL &NewsServer, 0 },
+  /*
+  ** .pp
+  ** This variable specifies domain name or address of NNTP server. It
+  ** defaults to the news server specified in the environment variable
+  ** $$$NNTPSERVER or contained in the file /etc/nntpserver.  You can also
+  ** specify username and an alternative port for each news server, ie:
+  ** .pp
+  ** [[s]news://][username[:password]@]server[:port]
+  */
+  { "newsgroups_charset", DT_STR, R_NONE, UL &NewsgroupsCharset, UL "utf-8" },
+  /*
+  ** .pp
+  ** Character set of newsgroups descriptions.
+  */
+  { "newsrc",		DT_PATH, R_NONE, UL &NewsRc, UL "~/.newsrc" },
+  /*
+  ** .pp
+  ** The file, containing info about subscribed newsgroups - names and
+  ** indexes of read articles.  The following printf-style sequence
+  ** is understood:
+  ** .dl
+  ** .dt %a .dd account url
+  ** .dt %p .dd port
+  ** .dt %P .dd port if specified
+  ** .dt %s .dd news server name
+  ** .dt %S .dd url schema
+  ** .dt %u .dd username
+  ** .de
+  */
+  { "nntp_authenticators", DT_STR, R_NONE, UL &NntpAuthenticators, UL 0 },
+  /*
+  ** .pp
+  ** This is a colon-delimited list of authentication methods mutt may
+  ** attempt to use to log in to a news server, in the order mutt should
+  ** try them.  Authentication methods are either ``user'' or any
+  ** SASL mechanism, e.g. ``digest-md5'', ``gssapi'' or ``cram-md5''.
+  ** This option is case-insensitive.  If it's \fIunset\fP (the default)
+  ** mutt will try all available methods, in order from most-secure to
+  ** least-secure.
+  ** .pp
+  ** Example:
+  ** .ts
+  ** set nntp_authenticators="digest-md5:user"
+  ** .te
+  ** .pp
+  ** \fBNote:\fP Mutt will only fall back to other authentication methods if
+  ** the previous methods are unavailable. If a method is available but
+  ** authentication fails, mutt will not connect to the IMAP server.
+  */
+  { "nntp_context",	DT_NUM, R_NONE, UL &NntpContext, 1000 },
+  /*
+  ** .pp
+  ** This variable defines number of articles which will be in index when
+  ** newsgroup entered.  If active newsgroup have more articles than this
+  ** number, oldest articles will be ignored.  Also controls how many
+  ** articles headers will be saved in cache when you quit newsgroup.
+  */
+  { "nntp_listgroup",	DT_BOOL, R_NONE, OPTLISTGROUP, 1 },
+  /*
+  ** .pp
+  ** This variable controls whether or not existence of each article is
+  ** checked when newsgroup is entered.
+  */
+  { "nntp_load_description", DT_BOOL, R_NONE, OPTLOADDESC, 1 },
+  /*
+  ** .pp
+  ** This variable controls whether or not descriptions for each newsgroup
+  ** must be loaded when newsgroup is added to list (first time list
+  ** loading or new newsgroup adding).
+  */
+  { "nntp_user",	DT_STR, R_NONE, UL &NntpUser, UL "" },
+  /*
+  ** .pp
+  ** Your login name on the NNTP server.  If \fIunset\fP and NNTP server requires
+  ** authentication, Mutt will prompt you for your account name when you
+  ** connect to news server.
+  */
+  { "nntp_pass",	DT_STR, R_NONE, UL &NntpPass, UL "" },
+  /*
+  ** .pp
+  ** Your password for NNTP account.
+  */
+  { "nntp_poll",	DT_NUM, R_NONE, UL &NewsPollTimeout, 60 },
+  /*
+  ** .pp
+  ** The time in seconds until any operations on newsgroup except post new
+  ** article will cause recheck for new news.  If set to 0, Mutt will
+  ** recheck newsgroup on each operation in index (stepping, read article,
+  ** etc.).
+  */
+#endif
+#ifdef USE_NOTMUCH
+  { "nm_open_timeout", DT_NUM, R_NONE, UL &NotmuchOpenTimeout, 5 },
+  /*
+   ** .pp
+   ** This variable specifies the timeout for database open in seconds.
+   */
+
+  { "nm_default_uri", DT_STR, R_NONE, UL &NotmuchDefaultUri, 0 },
+  /*
+   ** .pp
+   ** This variable specifies the default Notmuch database in format
+   ** notmuch://<absolute path>.
+   */
+
+  { "nm_hidden_tags", DT_STR, R_NONE, UL &NotmuchHiddenTags, UL "unread,draft,flagged,passed,replied,attachment,signed,encrypted" },
+  /*
+   ** .pp
+   ** This variable specifies private notmuch tags which should not be printed
+   ** on screen.
+   */
+  { "nm_exclude_tags", DT_STR,  R_NONE, UL &NotmuchExcludeTags, 0 },
+  /*
+   ** .pp
+   ** The messages tagged with these tags are excluded and not loaded
+   ** from notmuch DB to mutt unless specified explicitly.
+   */
+  { "nm_unread_tag", DT_STR, R_NONE, UL &NotmuchUnreadTag, UL "unread" },
+  /*
+   ** .pp
+   ** This variable specifies notmuch tag which is used for unread messages. The
+   ** variable is used to count unread messages in DB only. All other mutt commands
+   ** use standard (e.g. maildir) flags.
+   */
+  { "nm_db_limit", DT_NUM, R_NONE, UL &NotmuchDBLimit, 0 },
+  /*
+   ** .pp
+   ** This variable specifies the default limit used in notmuch queries.
+   */
+  { "nm_query_type", DT_STR, R_NONE, UL &NotmuchQueryType, UL "messages" },
+  /*
+   ** .pp
+   ** This variable specifies the default query type (threads or messages) used in notmuch queries.
+   */
+  { "nm_record", DT_BOOL, R_NONE, OPTNOTMUCHRECORD, 0 },
+  /*
+   ** .pp
+   ** This variable specifies if the mutt record should indexed by notmuch.
+   */
+  { "nm_record_tags", DT_STR, R_NONE, UL &NotmuchRecordTags, 0 },
+  /*
+   ** .pp
+   ** This variable specifies the default tags applied to messages stored to the mutt record.
+   */
+#endif
   { "pager",		DT_PATH, R_NONE, UL &Pager, UL "builtin" },
   /*
   ** .pp
@@ -2216,6 +2516,16 @@ struct option_t MuttVars[] = {
   { "post_indent_str",  DT_SYN,  R_NONE, UL "post_indent_string", 0 },
   /*
   */
+#ifdef USE_NNTP
+  { "post_moderated",	DT_QUAD, R_NONE, OPT_TOMODERATED, MUTT_ASKYES },
+  /*
+  ** .pp
+  ** If set to \fIyes\fP, Mutt will post article to newsgroup that have
+  ** not permissions to posting (e.g. moderated).  \fBNote:\fP if news server
+  ** does not support posting to that newsgroup or totally read-only, that
+  ** posting will not have an effect.
+  */
+#endif
   { "postpone",		DT_QUAD, R_NONE, OPT_POSTPONE, MUTT_ASKYES },
   /*
   ** .pp
@@ -2481,6 +2791,16 @@ struct option_t MuttVars[] = {
   ** header field to the list address and you want to send a private
   ** message to the author of a message.
   */
+  { "reply_with_xorig", DT_BOOL, R_NONE, OPTREPLYWITHXORIG, 0 },
+  /*
+  ** .pp
+  ** This variable provides a toggle. When active, the From: header will be
+  ** extracted from the current mail's `X-Original-To:' header. This setting
+  ** does not have precedence over ``$reverse_realname''.
+  ** .pp
+  ** Assuming `fast_reply' is disabled, this option will prompt the user with a
+  ** prefilled From: header.
+  */
   { "resolve",		DT_BOOL, R_NONE, OPTRESOLVE, 1 },
   /*
   ** .pp
@@ -2692,14 +3012,29 @@ struct option_t MuttVars[] = {
   ** Command to use when spawning a subshell.  By default, the user's login
   ** shell from \fC/etc/passwd\fP is used.
   */
-#ifdef USE_SIDEBAR
-  { "sidebar_divider_char", DT_STR, R_SIDEBAR, UL &SidebarDividerChar, UL "|" },
+#ifdef USE_NNTP
+  { "save_unsubscribed", DT_BOOL, R_NONE, OPTSAVEUNSUB, 0 },
   /*
   ** .pp
-  ** This specifies the characters to be drawn between the sidebar (when
-  ** visible) and the other Mutt panels. ASCII and Unicode line-drawing
-  ** characters are supported.
+  ** When \fIset\fP, info about unsubscribed newsgroups will be saved into
+  ** ``newsrc'' file and into cache.
+  */
+  { "show_new_news",	DT_BOOL, R_NONE, OPTSHOWNEWNEWS, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP, news server will be asked for new newsgroups on entering
+  ** the browser.  Otherwise, it will be done only once for a news server.
+  ** Also controls whether or not number of new articles of subscribed
+  ** newsgroups will be then checked.
+  */
+  { "show_only_unread",	DT_BOOL, R_NONE, OPTSHOWONLYUNREAD, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, only subscribed newsgroups that contain unread articles
+  ** will be displayed in browser.
   */
+#endif
+#ifdef USE_SIDEBAR
   { "sidebar_delim_chars", DT_STR, R_SIDEBAR, UL &SidebarDelimChars, UL "/." },
   /*
   ** .pp
@@ -2718,6 +3053,13 @@ struct option_t MuttVars[] = {
   ** .pp
   ** \fBSee also:\fP $$sidebar_short_path, $$sidebar_folder_indent, $$sidebar_indent_string.
   */
+  { "sidebar_divider_char", DT_STR, R_SIDEBAR, UL &SidebarDividerChar, UL "|" },
+  /*
+  ** .pp
+  ** This specifies the characters to be drawn between the sidebar (when
+  ** visible) and the other Mutt panels. ASCII and Unicode line-drawing
+  ** characters are supported.
+  */
   { "sidebar_folder_indent", DT_BOOL, R_SIDEBAR, OPTSIDEBARFOLDERINDENT, 0 },
   /*
   ** .pp
@@ -2780,6 +3122,11 @@ struct option_t MuttVars[] = {
   ** \fC<sidebar-prev-new>\fP command is similarly affected, wrapping around to
   ** the end of the list.
   */
+  { "sidebar_on_right", DT_BOOL, R_BOTH|R_REFLOW, UL OPTSIDEBARONRIGHT, 0 },
+  /*
+  ** .pp
+  ** When set, the sidebar will appear on the right-hand side of the screen.
+  */
   { "sidebar_short_path", DT_BOOL, R_SIDEBAR, OPTSIDEBARSHORTPATH, 0 },
   /*
   ** .pp
@@ -2866,6 +3213,12 @@ struct option_t MuttVars[] = {
   ** replacing ``%s'' with the supplied string.
   ** For the default value, ``joe'' would be expanded to: ``~f joe | ~s joe''.
   */
+  { "skip_quoted_offset", DT_NUM, R_NONE, UL &SkipQuotedOffset, 0 },
+  /*
+  ** .pp
+  ** Lines of quoted text that are displayed before the unquoted text after
+  ** "skip to quoted" command (S)
+  */
   { "sleep_time",	DT_NUM, R_NONE, UL &SleepTime, 1 },
   /*
   ** .pp
@@ -2971,6 +3324,12 @@ struct option_t MuttVars[] = {
   ** possible \fCprintf(3)\fP-like sequences.
   ** (S/MIME only)
   */
+  { "smime_encrypt_self",		DT_QUAD,	 R_NONE, OPT_SMIMEENCRYPTSELF, MUTT_NO },
+  /*
+  ** .pp
+  ** Encrypt the message to $$smime_default_key too.
+  ** (S/MIME only)
+  */
   { "smime_encrypt_with",	DT_STR,	 R_NONE, UL &SmimeCryptAlg, UL "aes256" },
   /*
   ** .pp
@@ -3209,7 +3568,10 @@ struct option_t MuttVars[] = {
   ** entries are sorted alphabetically.  Valid values:
   ** .il
   ** .dd alpha (alphabetically)
+  ** .dd count (all message count)
   ** .dd date
+  ** .dd desc (description)
+  ** .dd new (new message count)
   ** .dd size
   ** .dd unsorted
   ** .ie
@@ -3220,14 +3582,15 @@ struct option_t MuttVars[] = {
   { "sort_re",		DT_BOOL, R_INDEX|R_RESORT|R_RESORT_INIT, OPTSORTRE, 1 },
   /*
   ** .pp
-  ** This variable is only useful when sorting by threads with
-  ** $$strict_threads \fIunset\fP.  In that case, it changes the heuristic
-  ** mutt uses to thread messages by subject.  With $$sort_re \fIset\fP, mutt will
-  ** only attach a message as the child of another message by subject if
-  ** the subject of the child message starts with a substring matching the
-  ** setting of $$reply_regexp.  With $$sort_re \fIunset\fP, mutt will attach
-  ** the message whether or not this is the case, as long as the
-  ** non-$$reply_regexp parts of both messages are identical.
+  ** This variable is only useful when sorting by mailboxes in sidebar. By default,
+  ** entries are unsorted.  Valid values:
+  ** .il
+  ** .dd count (all message count)
+  ** .dd desc  (virtual mailbox description)
+  ** .dd new (new message count)
+  ** .dd path
+  ** .dd unsorted
+  ** .ie
   */
   { "spam_separator",   DT_STR, R_NONE, UL &SpamSep, UL "," },
   /*
@@ -3377,7 +3740,7 @@ struct option_t MuttVars[] = {
   ** message mode (Certain operations like composing a new mail, replying,
   ** forwarding, etc. are not permitted in this mode).
   */
-  { "status_format",	DT_STR,	 R_BOTH, UL &Status, UL "-%r-Mutt: %f [Msgs:%?M?%M/?%m%?n? New:%n?%?o? Old:%o?%?d? Del:%d?%?F? Flag:%F?%?t? Tag:%t?%?p? Post:%p?%?b? Inc:%b?%?l? %l?]---(%s/%S)-%>-(%P)---" },
+  { "status_format",	DT_STR,	 R_BOTH, UL &Status, UL "-%r-NeoMutt: %f [Msgs:%?M?%M/?%m%?n? New:%n?%?o? Old:%o?%?d? Del:%d?%?F? Flag:%F?%?t? Tag:%t?%?p? Post:%p?%?b? Inc:%b?%?l? %l?]---(%s/%S)-%>-(%P)---" },
   /*
   ** .pp
   ** Controls the format of the status line displayed in the ``index''
@@ -3585,7 +3948,7 @@ struct option_t MuttVars[] = {
   ** Controls whether mutt tries to set the terminal status line and icon name.
   ** Most terminal emulators emulate the status line in the window title.
   */
-  {"ts_status_format",	DT_STR,   R_BOTH, UL &TSStatusFormat, UL "Mutt with %?m?%m messages&no messages?%?n? [%n NEW]?"},
+  {"ts_status_format",	DT_STR,   R_BOTH, UL &TSStatusFormat, UL "NeoMutt with %?m?%m messages&no messages?%?n? [%n NEW]?"},
   /*
   ** .pp
   ** Controls the format of the terminal status line (or window title),
@@ -3680,6 +4043,21 @@ struct option_t MuttVars[] = {
   ** Specifies the visual editor to invoke when the ``\fC~v\fP'' command is
   ** given in the built-in editor.
   */
+#ifdef USE_NOTMUCH
+  { "vfolder_format",	DT_STR,	 R_INDEX, UL &VirtFolderFormat, UL "%2C %?n?%4n/&     ?%4m %f" },
+  /*
+  ** .pp
+  ** This variable allows you to customize the file browser display for virtual
+  ** folders to your personal taste.  This string uses many of the same
+  ** expandos as $$folder_format.
+  */
+  { "virtual_spoolfile", DT_BOOL, R_NONE, OPTVIRTSPOOLFILE, 0 },
+  /*
+  ** .pp
+  ** When \fset\fP, mutt will use the first defined virtual mailbox (see
+  ** virtual-mailboxes) as a spool file.
+  */
+#endif
   { "wait_key",		DT_BOOL, R_NONE, OPTWAITKEY, 1 },
   /*
   ** .pp
@@ -3763,6 +4141,28 @@ struct option_t MuttVars[] = {
   {"xterm_set_titles",	DT_SYN,  R_NONE, UL "ts_enabled", 0 },
   /*
   */
+  { "xlabel_delimiter", DT_STR, R_NONE, UL &XlabelDelim, UL "" },
+  /*
+  ** .pp
+  ** The character used to delimit distinct keywords in X-Label headers.
+  ** X-Label is primarily a Mutt artifact, and the semantics of the field
+  ** were never defined: it is free-form text.  However interaction with
+  ** X-Keywords:, X-Mozilla-Keys:, and Keywords: requires that we adopt
+  ** some means of identifying separate keywords within the field.  Set
+  ** this to your personal convention.
+  ** .pp
+  ** This affect both parsing existing X-Label headers and writing new
+  ** X-Label headers.  You can modify this variable in runtime to accomplish
+  ** various kinds of conversion.
+  */
+#ifdef USE_NNTP
+  { "x_comment_to",	DT_BOOL, R_NONE, OPTXCOMMENTTO, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, Mutt will add ``X-Comment-To:'' field (that contains full
+  ** name of original article author) to article that followuped to newsgroup.
+  */
+#endif
   /*--*/
   { NULL, 0, 0, 0, 0 }
 };
@@ -3779,6 +4179,7 @@ const struct mapping_t SortMethods[] = {
   { "to",		SORT_TO },
   { "score",		SORT_SCORE },
   { "spam",		SORT_SPAM },
+  { "label",		SORT_LABEL },
   { NULL,               0 }
 };
 
@@ -3798,13 +4199,17 @@ const struct mapping_t SortAuxMethods[] = {
   { "to",		SORT_TO },
   { "score",		SORT_SCORE },
   { "spam",		SORT_SPAM },
+  { "label",		SORT_LABEL },
   { NULL,               0 }
 };
 
 
 const struct mapping_t SortBrowserMethods[] = {
   { "alpha",	SORT_SUBJECT },
+  { "count",	SORT_COUNT },
   { "date",	SORT_DATE },
+  { "desc",	SORT_DESC },
+  { "new",	SORT_COUNT_NEW },
   { "size",	SORT_SIZE },
   { "unsorted",	SORT_ORDER },
   { NULL,       0 }
@@ -3828,6 +4233,7 @@ const struct mapping_t SortKeyMethods[] = {
 const struct mapping_t SortSidebarMethods[] = {
   { "alpha",		SORT_PATH },
   { "count",		SORT_COUNT },
+  { "desc",		SORT_DESC },
   { "flagged",		SORT_FLAGGED },
   { "mailbox-order",	SORT_ORDER },
   { "name",		SORT_PATH },
@@ -3850,6 +4256,8 @@ static int parse_lists (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_unlists (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_alias (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_unalias (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int finish_source (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_ifdef (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_ignore (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_unignore (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_source (BUFFER *, BUFFER *, unsigned long, BUFFER *);
@@ -3861,13 +4269,16 @@ static int parse_unsubscribe (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_attachments (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_unattachments (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 
-
 static int parse_alternates (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_unalternates (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 
 /* Parse -group arguments */
 static int parse_group_context (group_context_t **ctx, BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err);
 
+#ifdef USE_NOTMUCH
+static int parse_tag_transforms (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_tag_formats (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+#endif
 
 struct command_t
 {
@@ -3897,9 +4308,17 @@ const struct command_t Commands[] = {
   { "fcc-hook",		mutt_parse_hook,	MUTT_FCCHOOK },
   { "fcc-save-hook",	mutt_parse_hook,	MUTT_FCCHOOK | MUTT_SAVEHOOK },
   { "folder-hook",	mutt_parse_hook,	MUTT_FOLDERHOOK },
+#ifdef USE_COMPRESSED
+  { "open-hook",	mutt_parse_hook,	MUTT_OPENHOOK },
+  { "close-hook",	mutt_parse_hook,	MUTT_CLOSEHOOK },
+  { "append-hook",	mutt_parse_hook,	MUTT_APPENDHOOK },
+#endif
   { "group",		parse_group,		MUTT_GROUP },
   { "ungroup",		parse_group,		MUTT_UNGROUP },
   { "hdr_order",	parse_list,		UL &HeaderOrderList },
+  { "ifdef",		parse_ifdef,		0 },
+  { "ifndef",		parse_ifdef,		1 },
+  { "finish",		finish_source,		0 },
 #ifdef HAVE_ICONV
   { "iconv-hook",	mutt_parse_hook,	MUTT_ICONVHOOK },
 #endif
@@ -3908,6 +4327,11 @@ const struct command_t Commands[] = {
   { "macro",		mutt_parse_macro,	0 },
   { "mailboxes",	mutt_parse_mailboxes,	MUTT_MAILBOXES },
   { "unmailboxes",	mutt_parse_mailboxes,	MUTT_UNMAILBOXES },
+#ifdef USE_NOTMUCH
+  { "virtual-mailboxes",mutt_parse_virtual_mailboxes, 0 },
+  { "tag-transforms",	parse_tag_transforms,	0 },
+  { "tag-formats",	parse_tag_formats,	0 },
+#endif
   { "mailto_allow",	parse_list,		UL &MailtoAllow },
   { "unmailto_allow",	parse_unlist,		UL &MailtoAllow },
   { "message-hook",	mutt_parse_hook,	MUTT_MESSAGEHOOK },
@@ -3928,11 +4352,13 @@ const struct command_t Commands[] = {
   { "set",		parse_set,		0 },
 #ifdef USE_SIDEBAR
   { "sidebar_whitelist",parse_list,		UL &SidebarWhitelist },
+  { "unsidebar_whitelist",parse_unlist,		UL &SidebarWhitelist },
 #endif
   { "source",		parse_source,		0 },
   { "spam",		parse_spam_list,	MUTT_SPAM },
   { "nospam",		parse_spam_list,	MUTT_NOSPAM },
   { "subscribe",	parse_subscribe,	0 },
+  { "timeout-hook",	mutt_parse_hook,	MUTT_TIMEOUTHOOK },
   { "toggle",		parse_set,		MUTT_SET_INV },
   { "unalias",		parse_unalias,		0 },
   { "unalternative_order",parse_unlist,		UL &AlternativeOrderList },
diff --git c/keymap.c w/keymap.c
index 8b8b972..cd8c9a0 100644
--- c/keymap.c
+++ w/keymap.c
@@ -76,10 +76,8 @@ static struct mapping_t KeyNames[] = {
   { "<Insert>",	KEY_IC },
   { "<Home>",	KEY_HOME },
   { "<End>",	KEY_END },
-#ifdef KEY_ENTER
-  { "<Enter>",	KEY_ENTER },
-#endif
-  { "<Return>",	MUTT_ENTER_C },
+  { "<Enter>",	'\n' },
+  { "<Return>",	'\r' },
   { "<Esc>",	'\033' },
   { "<Tab>",	'\t' },
   { "<Space>",	' ' },
@@ -461,13 +459,13 @@ int km_dokey (int menu)
     tmp = mutt_getch();
     timeout (-1);
 
-    /* hide timeouts from line editor */
-    if (menu == MENU_EDITOR && tmp.ch == -2)
-      continue;
-
 #ifdef USE_IMAP
   gotkey:
 #endif
+    /* hide timeouts and window resizes from line editor. */
+    if (menu == MENU_EDITOR && tmp.ch == -2)
+      continue;
+
     LastKey = tmp.ch;
     if (LastKey < 0)
       return -1;
@@ -785,6 +783,7 @@ void km_init (void)
   km_bindkey ("8", MENU_GENERIC, OP_JUMP);
   km_bindkey ("9", MENU_GENERIC, OP_JUMP);
 
+  km_bindkey ("<return>", MENU_GENERIC, OP_GENERIC_SELECT_ENTRY);
   km_bindkey ("<enter>", MENU_GENERIC, OP_GENERIC_SELECT_ENTRY);
 
   /* Miscellaneous extra bindings */
@@ -796,6 +795,7 @@ void km_init (void)
   km_bindkey ("K", MENU_MAIN, OP_PREV_ENTRY);
   km_bindkey ("x", MENU_MAIN, OP_EXIT);
 
+  km_bindkey ("<return>", MENU_MAIN, OP_DISPLAY_MESSAGE);
   km_bindkey ("<enter>", MENU_MAIN, OP_DISPLAY_MESSAGE);
 
   km_bindkey ("x", MENU_PAGER, OP_EXIT);
@@ -819,13 +819,16 @@ void km_init (void)
   km_bindkey ("8", MENU_PAGER, OP_JUMP);
   km_bindkey ("9", MENU_PAGER, OP_JUMP);
 
+  km_bindkey ("<return>", MENU_PAGER, OP_NEXT_LINE);
   km_bindkey ("<enter>", MENU_PAGER, OP_NEXT_LINE);
   
   km_bindkey ("<return>", MENU_ALIAS, OP_GENERIC_SELECT_ENTRY);
   km_bindkey ("<enter>",  MENU_ALIAS, OP_GENERIC_SELECT_ENTRY);
   km_bindkey ("<space>", MENU_ALIAS, OP_TAG);
 
+  km_bindkey ("<return>", MENU_ATTACH, OP_VIEW_ATTACH);
   km_bindkey ("<enter>", MENU_ATTACH, OP_VIEW_ATTACH);
+  km_bindkey ("<return>", MENU_COMPOSE, OP_VIEW_ATTACH);
   km_bindkey ("<enter>", MENU_COMPOSE, OP_VIEW_ATTACH);
 
   /* edit-to (default "t") hides generic tag-entry in Compose menu
diff --git c/lib.c w/lib.c
index 224232b..5f7c38f 100644
--- c/lib.c
+++ w/lib.c
@@ -219,8 +219,10 @@ int safe_fsync_close (FILE **f)
   {
     if (fflush (*f) || fsync (fileno (*f)))
     {
+      int save_errno = errno;
       r = -1;
       safe_fclose (f);
+      errno = save_errno;
     }
     else
       r = safe_fclose (f);
@@ -367,6 +369,7 @@ int mutt_copy_bytes (FILE *in, FILE *out, size_t size)
     size -= chunk;
   }
 
+  if (fflush(out) != 0) return -1;
   return 0;
 }
 
@@ -381,6 +384,7 @@ int mutt_copy_stream (FILE *fin, FILE *fout)
       return (-1);
   }
 
+  if (fflush(fout) != 0) return -1;
   return 0;
 }
 
diff --git c/mailbox.h w/mailbox.h
index 35fb601..9b2443c 100644
--- c/mailbox.h
+++ w/mailbox.h
@@ -48,6 +48,7 @@ typedef struct _message
 {
   FILE *fp;	/* pointer to the message data */
   char *path;	/* path to temp file */
+  char *commited_path; /* the final path generated by mx_commit_message() */
   short write;	/* nonzero if message is open for writing */
   struct {
     unsigned read : 1;
@@ -78,6 +79,9 @@ int mx_is_imap (const char *);
 #ifdef USE_POP
 int mx_is_pop (const char *);
 #endif
+#ifdef USE_NNTP
+int mx_is_nntp (const char *);
+#endif
 
 int mx_access (const char*, int);
 int mx_check_empty (const char *);
diff --git c/main.c w/main.c
index b654169..ed2cc4e 100644
--- c/main.c
+++ w/main.c
@@ -31,6 +31,7 @@
 #include "url.h"
 #include "mutt_crypt.h"
 #include "mutt_idna.h"
+#include "version.h"
 #ifdef USE_SIDEBAR
 #include "sidebar.h"
 #endif
@@ -65,45 +66,9 @@
 #include <idn/stringprep.h>
 #endif
 
-static const char *ReachingUs = N_("\
-To contact the developers, please mail to <mutt-dev@mutt.org>.\n\
-To report a bug, please visit http://bugs.mutt.org/.\n");
-
-static const char *Notice = N_("\
-Copyright (C) 1996-2016 Michael R. Elkins and others.\n\
-Mutt comes with ABSOLUTELY NO WARRANTY; for details type `mutt -vv'.\n\
-Mutt is free software, and you are welcome to redistribute it\n\
-under certain conditions; type `mutt -vv' for details.\n");
-
-static const char *Copyright = N_("\
-Copyright (C) 1996-2016 Michael R. Elkins <me@mutt.org>\n\
-Copyright (C) 1996-2002 Brandon Long <blong@fiction.net>\n\
-Copyright (C) 1997-2009 Thomas Roessler <roessler@does-not-exist.org>\n\
-Copyright (C) 1998-2005 Werner Koch <wk@isil.d.shuttle.de>\n\
-Copyright (C) 1999-2014 Brendan Cully <brendan@kublai.com>\n\
-Copyright (C) 1999-2002 Tommi Komulainen <Tommi.Komulainen@iki.fi>\n\
-Copyright (C) 2000-2004 Edmund Grimley Evans <edmundo@rano.org>\n\
-Copyright (C) 2006-2009 Rocco Rutte <pdmef@gmx.net>\n\
-Copyright (C) 2014-2016 Kevin J. McCarthy <kevin@8t8.us>\n\
-\n\
-Many others not mentioned here contributed code, fixes,\n\
-and suggestions.\n");
-
-static const char *Licence = N_("\
-    This program is free software; you can redistribute it and/or modify\n\
-    it under the terms of the GNU General Public License as published by\n\
-    the Free Software Foundation; either version 2 of the License, or\n\
-    (at your option) any later version.\n\
-\n\
-    This program is distributed in the hope that it will be useful,\n\
-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
-    GNU General Public License for more details.\n");
-static const char *Obtaining = N_("\
-    You should have received a copy of the GNU General Public License\n\
-    along with this program; if not, write to the Free Software\n\
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\
-");
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
 
 void mutt_exit (int code)
 {
@@ -141,6 +106,8 @@ options:\n\
   -e <command>\tspecify a command to be executed after initialization\n\
   -f <file>\tspecify which mailbox to read\n\
   -F <file>\tspecify an alternate muttrc file\n\
+  -g <server>\tspecify a news server (if compiled with NNTP)\n\
+  -G\t\tselect a newsgroup (if compiled with NNTP)\n\
   -H <file>\tspecify a draft file to read header and body from\n\
   -i <file>\tspecify a file which Mutt should include in the body\n\
   -m <type>\tspecify a default mailbox type\n\
@@ -161,365 +128,6 @@ options:\n\
   exit (0);
 }
 
-extern const char cc_version[];
-extern const char cc_cflags[];
-extern const char configure_options[];
-
-static char *
-rstrip_in_place(char *s)
-{
-  char *p;
-
-  p = &s[strlen(s)];
-  if (p == s)
-    return s;
-  p--;
-  while (p >= s && (*p == '\n' || *p == '\r'))
-    *p-- = '\0';
-  return s;
-}
-
-static void show_version (void)
-{
-  struct utsname uts;
-
-  puts (mutt_make_version());
-  puts (_(Notice));
-
-  uname (&uts);
-
-#ifdef _AIX
-  printf ("System: %s %s.%s", uts.sysname, uts.version, uts.release);
-#elif defined (SCO)
-  printf ("System: SCO %s", uts.release);
-#else
-  printf ("System: %s %s", uts.sysname, uts.release);
-#endif
-
-  printf (" (%s)", uts.machine);
-
-#ifdef NCURSES_VERSION
-  printf ("\nncurses: %s (compiled with %s)", curses_version(), NCURSES_VERSION);
-#elif defined(USE_SLANG_CURSES)
-  printf ("\nslang: %d", SLANG_VERSION);
-#endif
-
-#ifdef _LIBICONV_VERSION
-  printf ("\nlibiconv: %d.%d", _LIBICONV_VERSION >> 8,
-	  _LIBICONV_VERSION & 0xff);
-#endif
-
-#ifdef HAVE_LIBIDN
-  printf ("\nlibidn: %s (compiled with %s)", stringprep_check_version (NULL), 
-	  STRINGPREP_VERSION);
-#endif
-
-#ifdef USE_HCACHE
-  printf ("\nhcache backend: %s", mutt_hcache_backend ());
-#endif
-
-  puts ("\n\nCompiler:");
-  rstrip_in_place((char *)cc_version);
-  puts (cc_version);
-
-  rstrip_in_place((char *)configure_options);
-  printf ("\nConfigure options: %s\n", configure_options);
-
-  rstrip_in_place((char *)cc_cflags);
-  printf ("\nCompilation CFLAGS: %s\n", cc_cflags);
-
-  puts (_("\nCompile options:"));
-
-#ifdef DOMAIN
-  printf ("DOMAIN=\"%s\"\n", DOMAIN);
-#else
-  puts ("-DOMAIN");
-#endif
-
-#ifdef DEBUG
-  puts ("+DEBUG");
-#else
-  puts ("-DEBUG");
-#endif
-  
-
-  
-  puts (
-
-#ifdef HOMESPOOL
-	"+HOMESPOOL  "
-#else
-	"-HOMESPOOL  "
-#endif
-
-#ifdef USE_SETGID
-	"+USE_SETGID  "
-#else
-	"-USE_SETGID  "
-#endif
-
-#ifdef USE_DOTLOCK
-	"+USE_DOTLOCK  "
-#else
-	"-USE_DOTLOCK  "
-#endif
-
-#ifdef DL_STANDALONE
-	"+DL_STANDALONE  "
-#else
-	"-DL_STANDALONE  "
-#endif
-
-#ifdef USE_FCNTL
-	"+USE_FCNTL  "
-#else
-	"-USE_FCNTL  "
-#endif
-
-#ifdef USE_FLOCK
-	"+USE_FLOCK   "
-#else
-	"-USE_FLOCK   "
-#endif
-    );
-  puts (
-#ifdef USE_POP
-	"+USE_POP  "
-#else
-	"-USE_POP  "
-#endif
-
-#ifdef USE_IMAP
-        "+USE_IMAP  "
-#else
-        "-USE_IMAP  "
-#endif
-
-#ifdef USE_SMTP
-	"+USE_SMTP  "
-#else
-	"-USE_SMTP  "
-#endif
-	"\n"
-	
-#ifdef USE_SSL_OPENSSL
-	"+USE_SSL_OPENSSL  "
-#else
-	"-USE_SSL_OPENSSL  "
-#endif
-
-#ifdef USE_SSL_GNUTLS
-	"+USE_SSL_GNUTLS  "
-#else
-	"-USE_SSL_GNUTLS  "
-#endif
-
-#ifdef USE_SASL
-	"+USE_SASL  "
-#else
-	"-USE_SASL  "
-#endif
-#ifdef USE_GSS
-	"+USE_GSS  "
-#else
-	"-USE_GSS  "
-#endif
-
-#if HAVE_GETADDRINFO
-	"+HAVE_GETADDRINFO  "
-#else
-	"-HAVE_GETADDRINFO  "
-#endif
-        );
-  	
-  puts (
-#ifdef HAVE_REGCOMP
-	"+HAVE_REGCOMP  "
-#else
-	"-HAVE_REGCOMP  "
-#endif
-
-#ifdef USE_GNU_REGEX
-	"+USE_GNU_REGEX  "
-#else
-	"-USE_GNU_REGEX  "
-#endif
-
-	"\n"
-	
-#ifdef HAVE_COLOR
-	"+HAVE_COLOR  "
-#else
-	"-HAVE_COLOR  "
-#endif
-	
-#ifdef HAVE_START_COLOR
-	"+HAVE_START_COLOR  "
-#else
-	"-HAVE_START_COLOR  "
-#endif
-	
-#ifdef HAVE_TYPEAHEAD
-	"+HAVE_TYPEAHEAD  "
-#else
-	"-HAVE_TYPEAHEAD  "
-#endif
-	
-#ifdef HAVE_BKGDSET
-	"+HAVE_BKGDSET  "
-#else
-	"-HAVE_BKGDSET  "
-#endif
-
-	"\n"
-	
-#ifdef HAVE_CURS_SET
-	"+HAVE_CURS_SET  "
-#else
-	"-HAVE_CURS_SET  "
-#endif
-	
-#ifdef HAVE_META
-	"+HAVE_META  "
-#else
-	"-HAVE_META  "
-#endif
-	
-#ifdef HAVE_RESIZETERM
-	"+HAVE_RESIZETERM  "
-#else
-	"-HAVE_RESIZETERM  "
-#endif
-        );	
-  
-  puts (
-#ifdef CRYPT_BACKEND_CLASSIC_PGP
-        "+CRYPT_BACKEND_CLASSIC_PGP  "
-#else
-        "-CRYPT_BACKEND_CLASSIC_PGP  "
-#endif
-#ifdef CRYPT_BACKEND_CLASSIC_SMIME
-        "+CRYPT_BACKEND_CLASSIC_SMIME  "
-#else
-        "-CRYPT_BACKEND_CLASSIC_SMIME  "
-#endif
-#ifdef CRYPT_BACKEND_GPGME
-        "+CRYPT_BACKEND_GPGME  "
-#else
-        "-CRYPT_BACKEND_GPGME  "
-#endif
-        );
-  
-  puts (
-#ifdef EXACT_ADDRESS
-	"+EXACT_ADDRESS  "
-#else
-	"-EXACT_ADDRESS  "
-#endif
-
-#ifdef SUN_ATTACHMENT
-	"+SUN_ATTACHMENT  "
-#else
-	"-SUN_ATTACHMENT  "
-#endif
-
-	"\n"
-	
-#ifdef ENABLE_NLS
-	"+ENABLE_NLS  "
-#else
-	"-ENABLE_NLS  "
-#endif
-
-#ifdef LOCALES_HACK
-	"+LOCALES_HACK  "
-#else
-	"-LOCALES_HACK  "
-#endif
-	      
-#ifdef HAVE_WC_FUNCS
-	"+HAVE_WC_FUNCS  "
-#else
-	"-HAVE_WC_FUNCS  "
-#endif
-	
-#ifdef HAVE_LANGINFO_CODESET
-	"+HAVE_LANGINFO_CODESET  "
-#else
-	"-HAVE_LANGINFO_CODESET  "
-#endif
-
-	
-#ifdef HAVE_LANGINFO_YESEXPR
- 	"+HAVE_LANGINFO_YESEXPR  "
-#else
- 	"-HAVE_LANGINFO_YESEXPR  "
-#endif
-	
-	"\n"
-
-#if HAVE_ICONV
-	"+HAVE_ICONV  "
-#else
-	"-HAVE_ICONV  "
-#endif
-
-#if ICONV_NONTRANS
-	"+ICONV_NONTRANS  "
-#else
-	"-ICONV_NONTRANS  "
-#endif
-
-#if HAVE_LIBIDN
-	"+HAVE_LIBIDN  "
-#else
-	"-HAVE_LIBIDN  "
-#endif
-	
-#if HAVE_GETSID
-	"+HAVE_GETSID  "
-#else
-	"-HAVE_GETSID  "
-#endif
-
-#if USE_HCACHE
-	"+USE_HCACHE  "
-#else
-	"-USE_HCACHE  "
-#endif
-
-#ifdef USE_SIDEBAR
-	"+USE_SIDEBAR  "
-#else
-	"-USE_SIDEBAR  "
-#endif
-
-	);
-
-#ifdef ISPELL
-  printf ("ISPELL=\"%s\"\n", ISPELL);
-#else
-  puts ("-ISPELL");
-#endif
-
-  printf ("SENDMAIL=\"%s\"\n", SENDMAIL);
-  printf ("MAILPATH=\"%s\"\n", MAILPATH);
-  printf ("PKGDATADIR=\"%s\"\n", PKGDATADIR);
-  printf ("SYSCONFDIR=\"%s\"\n", SYSCONFDIR);
-  printf ("EXECSHELL=\"%s\"\n", EXECSHELL);
-#ifdef MIXMASTER
-  printf ("MIXMASTER=\"%s\"\n", MIXMASTER);
-#else
-  puts ("-MIXMASTER");
-#endif
-
-  puts(_(ReachingUs));
-
-  mutt_print_patchlist();
-  
-  exit (0);
-}
-
 static void start_curses (void)
 {
   km_init (); /* must come before mutt_init */
@@ -549,6 +157,7 @@ static void start_curses (void)
   keypad (stdscr, TRUE);
   cbreak ();
   noecho ();
+  nonl ();
 #if HAVE_TYPEAHEAD
   typeahead (-1);       /* simulate smooth scrolling */
 #endif
@@ -564,6 +173,9 @@ init_extended_keys();
 #define MUTT_NOSYSRC (1<<2)	/* -n */
 #define MUTT_RO      (1<<3)	/* -R */
 #define MUTT_SELECT  (1<<4)	/* -y */
+#ifdef USE_NNTP
+#define MUTT_NEWS    (1<<5)	/* -g and -G */
+#endif
 
 int main (int argc, char **argv)
 {
@@ -597,18 +209,17 @@ int main (int argc, char **argv)
     exit(1);
   }
 
+  setlocale (LC_ALL, "");
+
 #ifdef ENABLE_NLS
   /* FIXME what about init.c:1439 ? */
-  setlocale (LC_ALL, "");
   bindtextdomain (PACKAGE, MUTTLOCALEDIR);
   textdomain (PACKAGE);
 #endif
 
-  setlocale (LC_CTYPE, "");
-
   mutt_error = mutt_nocurses_error;
   mutt_message = mutt_nocurses_error;
-  SRAND (time (NULL));
+  (void)mutt_rand32();
   umask (077);
 
   memset (Options, 0, sizeof (Options));
@@ -637,7 +248,11 @@ int main (int argc, char **argv)
         argv[nargc++] = argv[optind];
     }
 
+#ifdef USE_NNTP
+    if ((i = getopt (argc, argv, "+A:a:b:F:f:c:Dd:Ee:g:GH:s:i:hm:npQ:RvxyzZ")) != EOF)
+#else
     if ((i = getopt (argc, argv, "+A:a:b:F:f:c:Dd:Ee:H:s:i:hm:npQ:RvxyzZ")) != EOF)
+#endif
       switch (i)
       {
       case 'A':
@@ -738,6 +353,20 @@ int main (int argc, char **argv)
 	flags |= MUTT_SELECT;
 	break;
 
+#ifdef USE_NNTP
+      case 'g': /* Specify a news server */
+	{
+	  char buf[LONG_STRING];
+
+	  snprintf (buf, sizeof (buf), "set news_server=%s", optarg);
+	  commands = mutt_add_list (commands, buf);
+	}
+
+      case 'G': /* List of newsgroups */
+	flags |= MUTT_SELECT | MUTT_NEWS;
+	break;
+#endif
+
       case 'z':
 	flags |= MUTT_IGNORE;
 	break;
@@ -762,14 +391,10 @@ int main (int argc, char **argv)
     case 0:
       break;
     case 1:
-      show_version ();
-      break;
+      print_version();
+      exit (0);
     default:
-      puts (mutt_make_version ());
-      puts (_(Copyright));
-      puts (_(Licence));
-      puts (_(Obtaining));
-      puts (_(ReachingUs));
+      print_copyright();
       exit (0);
   }
 
@@ -1183,6 +808,18 @@ int main (int argc, char **argv)
     }
     else if (flags & MUTT_SELECT)
     {
+#ifdef USE_NNTP
+      if (flags & MUTT_NEWS)
+      {
+	set_option (OPTNEWS);
+	if(!(CurrentNewsSrv = nntp_select_server (NewsServer, 0)))
+	{
+	  mutt_endwin (Errorbuf);
+	  exit (1);
+	}
+      }
+      else
+#endif
       if (!Incoming) {
 	mutt_endwin _("No incoming mailboxes defined.");
 	exit (1);
@@ -1197,7 +834,22 @@ int main (int argc, char **argv)
     }
 
     if (!folder[0])
-      strfcpy (folder, NONULL(Spoolfile), sizeof (folder));
+    {
+      if (Spoolfile)
+        strfcpy (folder, NONULL(Spoolfile), sizeof (folder));
+      else if (Maildir)
+        strfcpy (folder, NONULL(Maildir), sizeof (folder));
+      /* else no folder */
+    }
+
+#ifdef USE_NNTP
+    if (option (OPTNEWS))
+    {
+      unset_option (OPTNEWS);
+      nntp_expand_path (folder, sizeof (folder), &CurrentNewsSrv->conn->account);
+    }
+    else
+#endif
     mutt_expand_path (folder, sizeof (folder));
 
     mutt_str_replace (&CurrentFolder, folder);
@@ -1225,9 +877,13 @@ int main (int argc, char **argv)
 #ifdef USE_SIDEBAR
       mutt_sb_set_open_buffy ();
 #endif
+      Labels = hash_create (131, 0);
+      mutt_scan_labels(Context);
       mutt_index_menu ();
       if (Context)
 	FREE (&Context);
+      if (Labels)
+        hash_destroy(&Labels, NULL);
     }
 #ifdef USE_IMAP
     imap_logout_all ();
diff --git c/mbyte.c w/mbyte.c
index 3df143f..faa3b60 100644
--- c/mbyte.c
+++ w/mbyte.c
@@ -107,7 +107,7 @@ static size_t wcrtomb_iconv (char *s, wchar_t wc, iconv_t cd)
   char buf[MB_LEN_MAX+1];
   ICONV_CONST char *ib;
   char *ob;
-  size_t ibl, obl, r;
+  size_t ibl, obl;
 
   if (s)
   {
@@ -117,7 +117,7 @@ static size_t wcrtomb_iconv (char *s, wchar_t wc, iconv_t cd)
     ib = buf;
     ob = s;
     obl = MB_LEN_MAX;
-    r = iconv (cd, &ib, &ibl, &ob, &obl);
+    iconv (cd, &ib, &ibl, &ob, &obl);
   }
   else
   {
@@ -125,7 +125,7 @@ static size_t wcrtomb_iconv (char *s, wchar_t wc, iconv_t cd)
     ibl = 1;
     ob = buf;
     obl = sizeof (buf);
-    r = iconv (cd, &ib, &ibl, &ob, &obl);
+    iconv (cd, &ib, &ibl, &ob, &obl);
   }
   return ob - s;
 }
@@ -530,6 +530,7 @@ int is_display_corrupting_utf8 (wchar_t wc)
   if (wc == (wchar_t)0x200f ||   /* bidi markers: #3827 */
       wc == (wchar_t)0x200e ||
       wc == (wchar_t)0x00ad ||   /* soft hyphen: #3848 */
+      wc == (wchar_t)0xfeff ||   /* zero width no-break space */
       (wc >= (wchar_t)0x202a &&  /* misc directional markers: #3854 */
        wc <= (wchar_t)0x202e))
     return 1;
diff --git c/menu.c w/menu.c
index 3c45656..7e3293c 100644
--- c/menu.c
+++ w/menu.c
@@ -30,7 +30,51 @@
 
 char* SearchBuffers[MENU_MAX];
 
-static void print_enriched_string (int attr, unsigned char *s, int do_color)
+/**
+ * get_color - XXX
+ */
+static int
+get_color (int index, unsigned char *s)
+{
+  COLOR_LINE *color;
+  HEADER *hdr = Context->hdrs[Context->v2r[index]];
+  int type = *s;
+
+  switch (type)
+  {
+    case MT_COLOR_INDEX_AUTHOR:
+      color = ColorIndexAuthorList;
+      break;
+    case MT_COLOR_INDEX_FLAGS:
+      color = ColorIndexFlagsList;
+      break;
+    case MT_COLOR_INDEX_SUBJECT:
+      color = ColorIndexSubjectList;
+      break;
+#ifdef USE_NOTMUCH
+    case MT_COLOR_INDEX_TAG:
+      for (color = ColorIndexTagList; color; color = color->next)
+      {
+        const char * transform = hash_find(TagTransforms, color->pattern);
+        if (transform && (strncmp((const char *)(s+1),
+            transform, strlen(transform)) == 0))
+          return color->pair;
+      }
+      return 0;
+#endif
+    default:
+      return ColorDefs[type];
+  }
+
+  for (; color; color = color->next)
+    if (mutt_pattern_exec (color->color_pattern, MUTT_MATCH_FULL_ADDRESS,
+        Context, hdr))
+      return color->pair;
+
+  return 0;
+}
+
+static void print_enriched_string (int index, int attr, unsigned char *s, int do_color)
 {
   wchar_t wc;
   size_t k;
@@ -162,6 +206,30 @@ static void print_enriched_string (int attr, unsigned char *s, int do_color)
       }
       if (do_color) ATTRSET(attr);
     }
+    else if (*s == MUTT_SPECIAL_INDEX)
+    {
+      s++;
+      if (do_color)
+      {
+        if (*s == MT_COLOR_INDEX)
+	{
+          attrset (attr);
+	}
+	else
+	{
+          if (get_color (index, s) == 0)
+	  {
+            attron (attr);
+	  }
+	  else
+	  {
+            attron (get_color (index, s));
+	  }
+        }
+      }
+      s++;
+      n -= 2;
+    }
     else if ((k = mbrtowc (&wc, (char *)s, n, &mbstate)) > 0)
     {
       addnstr ((char *)s, k);
@@ -277,7 +345,7 @@ void menu_redraw_index (MUTTMENU *menu)
       else if (option(OPTARROWCURSOR))
 	addstr("   ");
 
-      print_enriched_string (attr, (unsigned char *) buf, do_color);
+      print_enriched_string (i, attr, (unsigned char *) buf, do_color);
     }
     else
     {
@@ -312,7 +380,7 @@ void menu_redraw_motion (MUTTMENU *menu)
       menu_make_entry (buf, sizeof (buf), menu, menu->oldcurrent);
       menu_pad_string (menu, buf, sizeof (buf));
       mutt_window_move (menu->indexwin, menu->oldcurrent + menu->offset - menu->top, 3);
-      print_enriched_string (menu->color(menu->oldcurrent), (unsigned char *) buf, 1);
+      print_enriched_string (menu->oldcurrent, menu->color (menu->oldcurrent), (unsigned char *) buf, 1);
     }
 
     /* now draw it in the new location */
@@ -324,14 +392,14 @@ void menu_redraw_motion (MUTTMENU *menu)
     /* erase the current indicator */
     menu_make_entry (buf, sizeof (buf), menu, menu->oldcurrent);
     menu_pad_string (menu, buf, sizeof (buf));
-    print_enriched_string (menu->color(menu->oldcurrent), (unsigned char *) buf, 1);
+    print_enriched_string (menu->oldcurrent, menu->color (menu->oldcurrent), (unsigned char *) buf, 1);
 
     /* now draw the new one to reflect the change */
     menu_make_entry (buf, sizeof (buf), menu, menu->current);
     menu_pad_string (menu, buf, sizeof (buf));
     SETCOLOR(MT_COLOR_INDICATOR);
     mutt_window_move (menu->indexwin, menu->current + menu->offset - menu->top, 0);
-    print_enriched_string (menu->color(menu->current), (unsigned char *) buf, 0);
+    print_enriched_string (menu->current, menu->color (menu->current), (unsigned char *) buf, 0);
   }
   menu->redraw &= REDRAW_STATUS;
   NORMAL_COLOR;
@@ -353,10 +421,10 @@ void menu_redraw_current (MUTTMENU *menu)
     ATTRSET(attr);
     addch (' ');
     menu_pad_string (menu, buf, sizeof (buf));
-    print_enriched_string (attr, (unsigned char *) buf, 1);
+    print_enriched_string (menu->current, attr, (unsigned char *) buf, 1);
   }
   else
-    print_enriched_string (attr, (unsigned char *) buf, 0);
+    print_enriched_string (menu->current, attr, (unsigned char *) buf, 0);
   menu->redraw &= REDRAW_STATUS;
   NORMAL_COLOR;
 }
@@ -870,8 +938,17 @@ int menu_redraw (MUTTMENU *menu)
 
 int mutt_menuLoop (MUTTMENU *menu)
 {
+  static int last_position = -1;
   int i = OP_NULL;
 
+  if (menu->max && menu->is_mailbox_list)
+  {
+    if (last_position > (menu->max - 1))
+      last_position = -1;
+    else if (last_position >= 0)
+      menu->current = last_position;
+  }
+
   FOREVER
   {
     if (option (OPTMENUCALLER))
@@ -1095,6 +1172,8 @@ int mutt_menuLoop (MUTTMENU *menu)
 	break;
 
       default:
+        if (menu->is_mailbox_list)
+          last_position = menu->current;
 	return (i);
     }
   }
diff --git c/mh.c w/mh.c
index 371656a..c90679e 100644
--- c/mh.c
+++ w/mh.c
@@ -56,6 +56,14 @@
 #include <sys/time.h>
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #define		INS_SORT_THRESHOLD		6
 
 static int maildir_check_mailbox (CONTEXT * ctx, int *index_hint);
@@ -355,8 +363,8 @@ static int mh_mkstemp (CONTEXT * dest, FILE ** fp, char **tgt)
   omask = umask (mh_umask (dest));
   FOREVER
   {
-    snprintf (path, _POSIX_PATH_MAX, "%s/.mutt-%s-%d-%d",
-	      dest->path, NONULL (Hostname), (int) getpid (), Counter++);
+    snprintf (path, _POSIX_PATH_MAX, "%s/.mutt-%s-%d-%" PRIu64,
+	      dest->path, NONULL (Hostname), (int) getpid (), mutt_rand64());
     if ((fd = open (path, O_WRONLY | O_EXCL | O_CREAT, 0666)) == -1)
     {
       if (errno != EEXIST)
@@ -661,7 +669,7 @@ static void maildir_free_maildir (struct maildir **md)
   }
 }
 
-static void maildir_parse_flags (HEADER * h, const char *path)
+void maildir_parse_flags (HEADER * h, const char *path)
 {
   char *p, *q = NULL;
 
@@ -744,40 +752,51 @@ static void maildir_update_mtime (CONTEXT * ctx)
  * Actually parse a maildir message.  This may also be used to fill
  * out a fake header structure generated by lazy maildir parsing.
  */
-static HEADER *maildir_parse_message (int magic, const char *fname,
+HEADER *maildir_parse_stream (int magic, FILE *f, const char *fname,
 				      int is_old, HEADER * _h)
 {
-  FILE *f;
   HEADER *h = _h;
   struct stat st;
 
-  if ((f = fopen (fname, "r")) != NULL)
-  {
-    if (!h)
-      h = mutt_new_header ();
-    h->env = mutt_read_rfc822_header (f, h, 0, 0);
+  if (!h)
+    h = mutt_new_header ();
+  h->env = mutt_read_rfc822_header (f, h, 0, 0);
 
-    fstat (fileno (f), &st);
-    safe_fclose (&f);
+  fstat (fileno (f), &st);
 
-    if (!h->received)
-      h->received = h->date_sent;
+  if (!h->received)
+    h->received = h->date_sent;
 
-    /* always update the length since we have fresh information available. */
-    h->content->length = st.st_size - h->content->offset;
+  /* always update the length since we have fresh information available. */
+  h->content->length = st.st_size - h->content->offset;
 
-    h->index = -1;
+  h->index = -1;
 
-    if (magic == MUTT_MAILDIR)
-    {
-      /* 
-       * maildir stores its flags in the filename, so ignore the
-       * flags in the header of the message 
-       */
+  if (magic == MUTT_MAILDIR)
+  {
+    /*
+     * maildir stores its flags in the filename, so ignore the
+     * flags in the header of the message
+     */
 
-      h->old = is_old;
-      maildir_parse_flags (h, fname);
-    }
+    h->old = is_old;
+    maildir_parse_flags (h, fname);
+  }
+  return h;
+}
+
+/*
+ * Actually parse a maildir message.  This may also be used to fill
+ * out a fake header structure generated by lazy maildir parsing.
+ */
+HEADER *maildir_parse_message (int magic, const char *fname,
+				      int is_old, HEADER * h)
+{
+  FILE *f;
+
+  if ((f = fopen (fname, "r")) != NULL) {
+    h = maildir_parse_stream (magic, f, fname, is_old, h);
+    safe_fclose (&f);
     return h;
   }
   return NULL;
@@ -1385,7 +1404,7 @@ static int ch_compar (const void *a, const void *b)
   return (int)( *((const char *) a) - *((const char *) b));
 }
 
-static void maildir_flags (char *dest, size_t destlen, HEADER * hdr)
+void maildir_flags (char *dest, size_t destlen, HEADER * hdr)
 {
   *dest = '\0';
 
@@ -1422,7 +1441,7 @@ static int maildir_mh_open_message (CONTEXT *ctx, MESSAGE *msg, int msgno,
 
   msg->fp = fopen (path, "r");
   if (msg->fp == NULL && errno == ENOENT && is_maildir)
-    msg->fp = maildir_open_find_message (ctx->path, cur->path);
+    msg->fp = maildir_open_find_message (ctx->path, cur->path, NULL);
 
   if (!msg->fp)
   {
@@ -1486,9 +1505,9 @@ static int maildir_open_new_message (MESSAGE * msg, CONTEXT * dest, HEADER * hdr
   omask = umask (mh_umask (dest));
   FOREVER
   {
-    snprintf (path, _POSIX_PATH_MAX, "%s/tmp/%s.%lld.%u_%d.%s%s",
-	      dest->path, subdir, (long long)time (NULL), (unsigned int)getpid (),
-	      Counter++, NONULL (Hostname), suffix);
+    snprintf (path, _POSIX_PATH_MAX, "%s/tmp/%s.%lld.R%" PRIu64 ".%s%s",
+	      dest->path, subdir, (long long)time (NULL), mutt_rand64(),
+              NONULL (Hostname), suffix);
 
     dprint (2, (debugfile, "maildir_open_new_message (): Trying %s.\n",
 		path));
@@ -1572,8 +1591,8 @@ static int _maildir_commit_message (CONTEXT * ctx, MESSAGE * msg, HEADER * hdr)
   /* construct a new file name. */
   FOREVER
   {
-    snprintf (path, _POSIX_PATH_MAX, "%s/%lld.%u_%d.%s%s", subdir,
-	      (long long)time (NULL), (unsigned int)getpid (), Counter++,
+    snprintf (path, _POSIX_PATH_MAX, "%s/%lld.R%" PRIu64 ".%s%s", subdir,
+	      (long long)time (NULL), mutt_rand64(),
 	      NONULL (Hostname), suffix);
     snprintf (full, _POSIX_PATH_MAX, "%s/%s", ctx->path, path);
 
@@ -1582,10 +1601,6 @@ static int _maildir_commit_message (CONTEXT * ctx, MESSAGE * msg, HEADER * hdr)
 
     if (safe_rename (msg->path, full) == 0)
     {
-      if (hdr)
-	mutt_str_replace (&hdr->path, path);
-      FREE (&msg->path);
-
       /*
        * Adjust the mtime on the file to match the time at which this
        * message was received.  Currently this is only set when copying
@@ -1601,11 +1616,23 @@ static int _maildir_commit_message (CONTEXT * ctx, MESSAGE * msg, HEADER * hdr)
 	if (utime (full, &ut))
 	{
 	  mutt_perror (_("_maildir_commit_message(): unable to set time on file"));
-	  return -1;
+	  goto post_rename_err;
 	}
       }
 
+#ifdef USE_NOTMUCH
+      if (ctx->magic == MUTT_NOTMUCH)
+	nm_update_filename(ctx, hdr->path, full, hdr);
+#endif
+      if (hdr)
+	mutt_str_replace (&hdr->path, path);
+      mutt_str_replace (&msg->commited_path, full);
+      FREE (&msg->path);
+
       return 0;
+
+post_rename_err:
+      return -1;
     }
     else if (errno != EEXIST)
     {
@@ -1686,6 +1713,7 @@ static int _mh_commit_message (CONTEXT * ctx, MESSAGE * msg, HEADER * hdr,
     {
       if (hdr)
 	mutt_str_replace (&hdr->path, tmp);
+      mutt_str_replace (&msg->commited_path, path);
       FREE (&msg->path);
       break;
     }
@@ -1790,7 +1818,7 @@ static int mh_sync_message (CONTEXT * ctx, int msgno)
 {
   HEADER *h = ctx->hdrs[msgno];
 
-  if (h->attach_del || 
+  if (h->attach_del || h->label_changed ||
       (h->env && (h->env->refs_changed || h->env->irt_changed)))
     if (mh_rewrite_message (ctx, msgno) != 0)
       return -1;
@@ -1802,7 +1830,7 @@ static int maildir_sync_message (CONTEXT * ctx, int msgno)
 {
   HEADER *h = ctx->hdrs[msgno];
 
-  if (h->attach_del || 
+  if (h->attach_del || h->label_changed ||
       (h->env && (h->env->refs_changed || h->env->irt_changed)))
   {
     /* when doing attachment deletion/rethreading, fall back to the MH case. */
@@ -1861,96 +1889,114 @@ static int maildir_sync_message (CONTEXT * ctx, int msgno)
   return (0);
 }
 
-int mh_sync_mailbox (CONTEXT * ctx, int *index_hint)
-{
-  char path[_POSIX_PATH_MAX], tmp[_POSIX_PATH_MAX];
-  int i, j;
-#if USE_HCACHE
-  header_cache_t *hc = NULL;
-#endif /* USE_HCACHE */
-  char msgbuf[STRING];
-  progress_t progress;
-
-  if (ctx->magic == MUTT_MH)
-    i = mh_check_mailbox (ctx, index_hint);
-  else 
-    i = maildir_check_mailbox (ctx, index_hint);
-      
-  if (i != 0)
-    return i;
-
 #if USE_HCACHE
-  if (ctx->magic == MUTT_MAILDIR || ctx->magic == MUTT_MH)
-    hc = mutt_hcache_open(HeaderCache, ctx->path, NULL);
-#endif /* USE_HCACHE */
-
-  if (!ctx->quiet)
-  {
-    snprintf (msgbuf, sizeof (msgbuf), _("Writing %s..."), ctx->path);
-    mutt_progress_init (&progress, msgbuf, MUTT_PROGRESS_MSG, WriteInc, ctx->msgcount);
-  }
-
-  for (i = 0; i < ctx->msgcount; i++)
-  {
-    if (!ctx->quiet)
-      mutt_progress_update (&progress, i, -1);
+int mh_sync_mailbox_message (CONTEXT * ctx, int msgno, header_cache_t *hc)
+#else
+int mh_sync_mailbox_message (CONTEXT * ctx, int msgno)
+#endif
+{
+    char path[_POSIX_PATH_MAX], tmp[_POSIX_PATH_MAX];
+    HEADER *h = ctx->hdrs[msgno];
 
-    if (ctx->hdrs[i]->deleted
-	&& (ctx->magic != MUTT_MAILDIR || !option (OPTMAILDIRTRASH)))
+    if (h->deleted && (ctx->magic != MUTT_MAILDIR || !option (OPTMAILDIRTRASH)))
     {
-      snprintf (path, sizeof (path), "%s/%s", ctx->path, ctx->hdrs[i]->path);
+      snprintf (path, sizeof (path), "%s/%s", ctx->path, h->path);
       if (ctx->magic == MUTT_MAILDIR
 	  || (option (OPTMHPURGE) && ctx->magic == MUTT_MH))
       {
 #if USE_HCACHE
-        if (ctx->magic == MUTT_MAILDIR)
-          mutt_hcache_delete (hc, ctx->hdrs[i]->path + 3, &maildir_hcache_keylen);
-	else if (ctx->magic == MUTT_MH)
-	  mutt_hcache_delete (hc, ctx->hdrs[i]->path, strlen);
+	if (hc) {
+           if (ctx->magic == MUTT_MAILDIR)
+              mutt_hcache_delete (hc, h->path + 3, &maildir_hcache_keylen);
+	   else if (ctx->magic == MUTT_MH)
+	      mutt_hcache_delete (hc, h->path, strlen);
+	}
 #endif /* USE_HCACHE */
 	unlink (path);
       }
       else if (ctx->magic == MUTT_MH)
       {
 	/* MH just moves files out of the way when you delete them */
-	if (*ctx->hdrs[i]->path != ',')
+	if (*h->path != ',')
 	{
-	  snprintf (tmp, sizeof (tmp), "%s/,%s", ctx->path,
-		    ctx->hdrs[i]->path);
+	  snprintf (tmp, sizeof (tmp), "%s/,%s", ctx->path, h->path);
 	  unlink (tmp);
 	  rename (path, tmp);
 	}
 
       }
     }
-    else if (ctx->hdrs[i]->changed || ctx->hdrs[i]->attach_del ||
+    else if (h->changed || h->attach_del ||
+	     h->label_changed ||
 	     (ctx->magic == MUTT_MAILDIR
-	      && (option (OPTMAILDIRTRASH) || ctx->hdrs[i]->trash)
-	      && (ctx->hdrs[i]->deleted != ctx->hdrs[i]->trash)))
+	      && (option (OPTMAILDIRTRASH) || h->trash)
+	      && (h->deleted != h->trash)))
     {
       if (ctx->magic == MUTT_MAILDIR)
       {
-	if (maildir_sync_message (ctx, i) == -1)
-	  goto err;
+	if (maildir_sync_message (ctx, msgno) == -1)
+	  return -1;
       }
       else
       {
-	if (mh_sync_message (ctx, i) == -1)
-	  goto err;
+	if (mh_sync_message (ctx, msgno) == -1)
+	  return -1;
       }
     }
 
 #if USE_HCACHE
-    if (ctx->hdrs[i]->changed)
+    if (hc && h->changed)
     {
       if (ctx->magic == MUTT_MAILDIR)
-	mutt_hcache_store (hc, ctx->hdrs[i]->path + 3, ctx->hdrs[i],
-			   0, &maildir_hcache_keylen, MUTT_GENERATE_UIDVALIDITY);
+	mutt_hcache_store (hc, h->path + 3, h, 0, &maildir_hcache_keylen, MUTT_GENERATE_UIDVALIDITY);
       else if (ctx->magic == MUTT_MH)
-	mutt_hcache_store (hc, ctx->hdrs[i]->path, ctx->hdrs[i], 0, strlen, MUTT_GENERATE_UIDVALIDITY);
+	mutt_hcache_store (hc, h->path, h, 0, strlen, MUTT_GENERATE_UIDVALIDITY);
     }
 #endif
 
+    return 0;
+}
+
+int mh_sync_mailbox (CONTEXT * ctx, int *index_hint)
+{
+  int i, j;
+#if USE_HCACHE
+  header_cache_t *hc = NULL;
+#endif /* USE_HCACHE */
+  char msgbuf[STRING];
+  progress_t progress;
+
+  if (ctx->magic == MUTT_MH)
+    i = mh_check_mailbox (ctx, index_hint);
+  else
+    i = maildir_check_mailbox (ctx, index_hint);
+
+  if (i != 0)
+    return i;
+
+#if USE_HCACHE
+  if (ctx->magic == MUTT_MAILDIR || ctx->magic == MUTT_MH)
+    hc = mutt_hcache_open(HeaderCache, ctx->path, NULL);
+#endif /* USE_HCACHE */
+
+  if (!ctx->quiet)
+  {
+    snprintf (msgbuf, sizeof (msgbuf), _("Writing %s..."), ctx->path);
+    mutt_progress_init (&progress, msgbuf, MUTT_PROGRESS_MSG, WriteInc, ctx->msgcount);
+  }
+
+  for (i = 0; i < ctx->msgcount; i++)
+  {
+    if (!ctx->quiet)
+      mutt_progress_update (&progress, i, -1);
+
+#if USE_HCACHE
+    if (mh_sync_mailbox_message (ctx, i, hc) == -1)
+      goto err;
+#else
+    if (mh_sync_mailbox_message (ctx, i) == -1)
+      goto err;
+#endif
   }
 
 #if USE_HCACHE
@@ -2029,7 +2075,7 @@ static void maildir_update_tables (CONTEXT *ctx, int *index_hint)
   mutt_clear_threads (ctx);
 }
 
-static void maildir_update_flags (CONTEXT *ctx, HEADER *o, HEADER *n)
+void maildir_update_flags (CONTEXT *ctx, HEADER *o, HEADER *n)
 {
   /* save the global state here so we can reset it at the
    * end of list block if required.
@@ -2332,7 +2378,7 @@ static int mh_check_mailbox (CONTEXT * ctx, int *index_hint)
  */
 
 static FILE *_maildir_open_find_message (const char *folder, const char *unique,
-				  const char *subfolder)
+				  const char *subfolder, char **newname)
 {
   char dir[_POSIX_PATH_MAX];
   char tunique[_POSIX_PATH_MAX];
@@ -2368,11 +2414,15 @@ static FILE *_maildir_open_find_message (const char *folder, const char *unique,
 
   closedir (dp);
 
+  if (newname && fp)
+    *newname = safe_strdup(fname);
+
   errno = oe;
   return fp;
 }
 
-FILE *maildir_open_find_message (const char *folder, const char *msg)
+FILE *maildir_open_find_message (const char *folder, const char *msg,
+                                  char **newname)
 {
   char unique[_POSIX_PATH_MAX];
   FILE *fp;
@@ -2384,7 +2434,8 @@ FILE *maildir_open_find_message (const char *folder, const char *msg)
   if (
       (fp =
        _maildir_open_find_message (folder, unique,
-				   new_hits > cur_hits ? "new" : "cur"))
+				   new_hits > cur_hits ? "new" : "cur",
+				   newname))
       || errno != ENOENT)
   {
     if (new_hits < UINT_MAX && cur_hits < UINT_MAX)
@@ -2398,7 +2449,8 @@ FILE *maildir_open_find_message (const char *folder, const char *msg)
   if (
       (fp =
        _maildir_open_find_message (folder, unique,
-				   new_hits > cur_hits ? "cur" : "new"))
+				   new_hits > cur_hits ? "cur" : "new",
+				   newname))
       || errno != ENOENT)
   {
     if (new_hits < UINT_MAX && cur_hits < UINT_MAX)
diff --git c/mutt.h w/mutt.h
index 2cf55b1..63f8c4c 100644
--- c/mutt.h
+++ w/mutt.h
@@ -52,6 +52,11 @@
 #include <limits.h>
 #endif
 
+/* PATH_MAX is undefined on the hurd */
+#ifndef PATH_MAX
+#define PATH_MAX _POSIX_PATH_MAX
+#endif
+
 #include <pwd.h>
 #include <grp.h>
 
@@ -66,6 +71,14 @@
 # define MB_LEN_MAX 16
 #endif
 
+#ifdef HAVE_FGETS_UNLOCKED
+# define fgets fgets_unlocked
+#endif
+
+#ifdef HAVE_FGETC_UNLOCKED
+# define fgetc fgetc_unlocked
+#endif
+
 /* nifty trick I stole from ELM 2.5alpha. */
 #ifdef MAIN_C
 #define WHERE 
@@ -88,6 +101,11 @@
 #define  MUTT_CLEAR   (1<<5) /* clear input if printable character is pressed */
 #define  MUTT_COMMAND (1<<6) /* do command completion */
 #define  MUTT_PATTERN (1<<7) /* pattern mode - only used for history classes */
+#define  MUTT_LABEL   (1<<8) /* do label completion */
+#if USE_NOTMUCH
+#define  MUTT_NM_QUERY (1<<9) /* Notmuch query mode. */
+#define  MUTT_NM_TAG   (1<<10) /* Notmuch tag +/- mode. */
+#endif
 
 /* flags for mutt_get_token() */
 #define MUTT_TOKEN_EQUAL      1       /* treat '=' as a special */
@@ -141,6 +159,12 @@ typedef enum
 #define MUTT_ACCOUNTHOOK (1<<9)
 #define MUTT_REPLYHOOK   (1<<10)
 #define MUTT_SEND2HOOK   (1<<11)
+#ifdef USE_COMPRESSED
+#define MUTT_OPENHOOK    (1<<12)
+#define MUTT_APPENDHOOK  (1<<13)
+#define MUTT_CLOSEHOOK   (1<<14)
+#endif
+#define MUTT_TIMEOUTHOOK (1<<15)
 
 /* tree characters for linearize_tree and print_enriched_string */
 #define MUTT_TREE_LLCORNER      1
@@ -158,6 +182,8 @@ typedef enum
 #define MUTT_TREE_MISSING       13
 #define MUTT_TREE_MAX           14
 
+#define MUTT_SPECIAL_INDEX		MUTT_TREE_MAX
+
 #define MUTT_THREAD_COLLAPSE    (1<<0)
 #define MUTT_THREAD_UNCOLLAPSE  (1<<1)
 #define MUTT_THREAD_GET_HIDDEN  (1<<2)
@@ -225,7 +251,13 @@ enum
   MUTT_CRYPT_ENCRYPT,
   MUTT_PGP_KEY,
   MUTT_XLABEL,
+#ifdef USE_NOTMUCH
+  MUTT_NOTMUCH_LABEL,
+#endif
   MUTT_MIMEATTACH,
+#ifdef USE_NNTP
+  MUTT_NEWSGROUPS,
+#endif
   
   /* Options for Mailcap lookup */
   MUTT_EDIT,
@@ -268,6 +300,8 @@ enum
   OPT_MIMEFWDREST,
   OPT_MOVE,
   OPT_PGPMIMEAUTO,     /* ask to revert to PGP/MIME when inline fails */
+  OPT_SMIMEENCRYPTSELF,
+  OPT_PGPENCRYPTSELF,
 #ifdef USE_POP
   OPT_POPDELETE,
   OPT_POPRECONNECT,
@@ -282,7 +316,12 @@ enum
 #endif
   OPT_SUBJECT,
   OPT_VERIFYSIG,      /* verify PGP signatures */
-    
+#ifdef USE_NNTP
+  OPT_TOMODERATED,
+  OPT_CATCHUP,
+  OPT_FOLLOWUPTOPOSTER,
+#endif
+  OPT_ATTACH, /* forgotten attachment detector */
   /* THIS MUST BE THE LAST VALUE. */
   OPT_MAX
 };
@@ -300,6 +339,7 @@ enum
 #define SENDPOSTPONEDFCC	(1<<9) /* used by mutt_get_postponed() to signal that the x-mutt-fcc header field was present */
 #define SENDNOFREEHEADER	(1<<10)   /* Used by the -E flag */
 #define SENDDRAFTFILE		(1<<11)   /* Used by the -H flag */
+#define SENDNEWS	(1<<12)
 
 /* flags for mutt_compose_menu() */
 #define MUTT_COMPOSE_NOFREEHEADER (1<<0)
@@ -308,11 +348,18 @@ enum
 #define MUTT_SEL_BUFFY  (1<<0)
 #define MUTT_SEL_MULTI  (1<<1)
 #define MUTT_SEL_FOLDER (1<<2)
+#define MUTT_SEL_VFOLDER	(1<<3)
 
 /* flags for parse_spam_list */
 #define MUTT_SPAM          1
 #define MUTT_NOSPAM        2
 
+/* flags for keywords headers */
+#define MUTT_X_LABEL         (1<<0)  /* introduced to mutt in 2000 */
+#define MUTT_X_KEYWORDS      (1<<1)  /* used in c-client, dovecot */
+#define MUTT_X_MOZILLA_KEYS  (1<<2)  /* tbird */
+#define MUTT_KEYWORDS        (1<<3)  /* rfc2822 */
+
 /* boolean vars */
 enum
 {
@@ -322,6 +369,8 @@ enum
   OPTASCIICHARS,
   OPTASKBCC,
   OPTASKCC,
+  OPTASKFOLLOWUP,
+  OPTASKXCOMMENTTO,
   OPTATTACHSPLIT,
   OPTAUTOEDIT,
   OPTAUTOTAG,
@@ -348,7 +397,7 @@ enum
   OPTFORWQUOTE,
 #ifdef USE_HCACHE
   OPTHCACHEVERIFY,
-#if defined(HAVE_QDBM) || defined(HAVE_TC)
+#if defined(HAVE_QDBM) || defined(HAVE_TC) || defined(HAVE_KC)
   OPTHCACHECOMPRESS,
 #endif /* HAVE_QDBM */
 #endif
@@ -388,6 +437,8 @@ enum
   OPTIMPLICITAUTOVIEW,
   OPTINCLUDEONLYFIRST,
   OPTKEEPFLAGGED,
+  OPTKEYWORDSLEGACY,
+  OPTKEYWORDSSTANDARD,
   OPTMAILCAPSANITIZE,
   OPTMAILCHECKRECENT,
   OPTMAILCHECKSTATS,
@@ -404,6 +455,9 @@ enum
   OPTMETOO,
   OPTMHPURGE,
   OPTMIMEFORWDECODE,
+#ifdef USE_NNTP
+  OPTMIMESUBJECT,	/* encode subject line with RFC2047 */
+#endif
   OPTNARROWTREE,
   OPTPAGERSTOP,
   OPTPIPEDECODE,
@@ -420,6 +474,7 @@ enum
   OPTREFLOWSPACEQUOTES,
   OPTREFLOWTEXT,
   OPTREPLYSELF,
+  OPTREPLYWITHXORIG,
   OPTRESOLVE,
   OPTRESUMEDRAFTFILES,
   OPTRESUMEEDITEDDRAFTFILES,
@@ -437,6 +492,7 @@ enum
   OPTSIDEBARNEWMAILONLY,
   OPTSIDEBARNEXTNEWWRAP,
   OPTSIDEBARSHORTPATH,
+  OPTSIDEBARONRIGHT,
 #endif
   OPTSIGDASHES,
   OPTSIGONTOP,
@@ -501,6 +557,17 @@ enum
   OPTPGPAUTOINLINE,
   OPTPGPREPLYINLINE,
 
+  /* news options */
+
+#ifdef USE_NNTP
+  OPTSHOWNEWNEWS,
+  OPTSHOWONLYUNREAD,
+  OPTSAVEUNSUB,
+  OPTLISTGROUP,
+  OPTLOADDESC,
+  OPTXCOMMENTTO,
+#endif
+
   /* pseudo options */
 
   OPTAUXSORT,		/* (pseudo) using auxiliary sort function */
@@ -521,6 +588,7 @@ enum
   OPTSORTSUBTHREADS,	/* (pseudo) used when $sort_aux changes */
   OPTNEEDRESCORE,	/* (pseudo) set when the `score' command is used */
   OPTATTACHMSG,		/* (pseudo) used by attach-message */
+  OPTHIDEREAD,		/* (pseudo) whether or not hide read messages */
   OPTKEEPQUIET,		/* (pseudo) shut up the message and refresh
 			 * 	    functions while we are executing an
 			 * 	    external program.
@@ -531,6 +599,15 @@ enum
   OPTDONTHANDLEPGPKEYS,	/* (pseudo) used to extract PGP keys */
   OPTIGNOREMACROEVENTS, /* (pseudo) don't process macro/push/exec events while set */
 
+#ifdef USE_NNTP
+  OPTNEWS,		/* (pseudo) used to change reader mode */
+  OPTNEWSSEND,		/* (pseudo) used to change behavior when posting */
+#endif
+#ifdef USE_NOTMUCH
+  OPTVIRTSPOOLFILE,
+  OPTNOTMUCHRECORD,
+#endif
+
   OPTMAX
 };
 
@@ -603,6 +680,7 @@ typedef struct envelope
   ADDRESS *sender;
   ADDRESS *reply_to;
   ADDRESS *mail_followup_to;
+  ADDRESS *x_original_to;
   char *list_post;		/* this stores a mailto URL, or nothing */
   char *subject;
   char *real_subj;		/* offset of the real subject */
@@ -610,10 +688,19 @@ typedef struct envelope
   char *supersedes;
   char *date;
   char *x_label;
+  char *organization;
+#ifdef USE_NNTP
+  char *newsgroups;
+  char *xref;
+  char *followup_to;
+  char *x_comment_to;
+#endif
   BUFFER *spam;
   LIST *references;		/* message references (in reverse order) */
   LIST *in_reply_to;		/* in-reply-to header content */
   LIST *userhdrs;		/* user defined headers */
+  LIST *labels;
+  int kwtypes;
 
   unsigned int irt_changed : 1; /* In-Reply-To changed to link/break threads */
   unsigned int refs_changed : 1; /* References changed to break thread */
@@ -731,6 +818,7 @@ typedef struct header
   unsigned int tagged : 1;
   unsigned int deleted : 1;
   unsigned int purge : 1;               /* skip trash folder when deleting */
+  unsigned int quasi_deleted : 1;	/* deleted from mutt, but not modified on disk */
   unsigned int changed : 1;
   unsigned int attach_del : 1; 		/* has an attachment marked for deletion */
   unsigned int old : 1;
@@ -747,6 +835,7 @@ typedef struct header
 					 * This flag is used by the maildir_trash
 					 * option.
 					 */
+  unsigned int label_changed : 1;	/* editable - used for syncing */
   
   /* timezone of the sender of this message */
   unsigned int zhours : 5;
@@ -795,8 +884,9 @@ typedef struct header
   int refno;			/* message number on server */
 #endif
 
-#if defined USE_POP || defined USE_IMAP
+#if defined USE_POP || defined USE_IMAP || defined USE_NNTP || defined USE_NOTMUCH
   void *data;            	/* driver-specific data */
+  void (*free_cb)(struct header *); /* driver-specific data free function */
 #endif
   
   char *maildir_flags;		/* unknown maildir flags */
@@ -946,6 +1036,10 @@ typedef struct _context
   unsigned int closing : 1;	/* mailbox is being closed */
   unsigned int peekonly : 1;	/* just taking a glance, revert atime */
 
+#ifdef USE_COMPRESSED
+  void *compress_info;		/* compressed mbox module private data */
+#endif /* USE_COMPRESSED */
+
   /* driver hooks */
   void *data;			/* driver specific data */
   struct mx_ops *mx_ops;
diff --git c/mutt_curses.h w/mutt_curses.h
index 6200449..bb6aa00 100644
--- c/mutt_curses.h
+++ w/mutt_curses.h
@@ -33,13 +33,6 @@
 #define KEY_DC SL_KEY_DELETE
 #define KEY_IC SL_KEY_IC
 
-/*
- * ncurses and SLang seem to send different characters when the Enter key is
- * pressed, so define some macros to properly detect the Enter key.
- */
-#define MUTT_ENTER_C '\r'
-#define MUTT_ENTER_S "\r"
-
 #else /* USE_SLANG_CURSES */
 
 #if HAVE_NCURSESW_NCURSES_H
@@ -52,9 +45,6 @@
 # include <curses.h>
 #endif
 
-#define MUTT_ENTER_C '\n'
-#define MUTT_ENTER_S "\n"
-
 #endif /* USE_SLANG_CURSES */
 
 /* AIX defines ``lines'' in <term.h>, but it's used as a var name in
@@ -118,25 +108,43 @@ enum
   MT_COLOR_HEADER,
   MT_COLOR_MESSAGE,
   MT_COLOR_ATTACHMENT,
+  MT_COLOR_ATTACH_HEADERS,
   MT_COLOR_SEARCH,
   MT_COLOR_BOLD,
   MT_COLOR_UNDERLINE,
-  MT_COLOR_INDEX,
   MT_COLOR_PROMPT,
+  MT_COLOR_PROGRESS,
 #ifdef USE_SIDEBAR
   MT_COLOR_DIVIDER,
   MT_COLOR_FLAGGED,
   MT_COLOR_HIGHLIGHT,
   MT_COLOR_NEW,
+  MT_COLOR_ORDINARY,
   MT_COLOR_SB_INDICATOR,
   MT_COLOR_SB_SPOOLFILE,
 #endif
+  /* please no non-MT_COLOR_INDEX objects after this point */
+  MT_COLOR_INDEX,
+  MT_COLOR_INDEX_AUTHOR,
+  MT_COLOR_INDEX_FLAGS,
+  MT_COLOR_INDEX_SUBJECT,
+  /* below here - only index coloring stuff that doesn't have a pattern */
+  MT_COLOR_INDEX_COLLAPSED,
+  MT_COLOR_INDEX_DATE,
+  MT_COLOR_INDEX_LABEL,
+  MT_COLOR_INDEX_NUMBER,
+  MT_COLOR_INDEX_SIZE,
+#ifdef USE_NOTMUCH
+  MT_COLOR_INDEX_TAG,
+  MT_COLOR_INDEX_TAGS,
+#endif
   MT_COLOR_MAX
 };
 
 typedef struct color_line
 {
   regex_t rx;
+  int match; /* which substringmap 0 for old behaviour */
   char *pattern;
   pattern_t *color_pattern; /* compiled pattern to speed up index color
                                calculation */
@@ -212,7 +220,16 @@ extern int ColorQuoteUsed;
 extern int ColorDefs[];
 extern COLOR_LINE *ColorHdrList;
 extern COLOR_LINE *ColorBodyList;
+extern COLOR_LINE *ColorAttachList;
+extern COLOR_LINE *ColorStatusList;
 extern COLOR_LINE *ColorIndexList;
+extern COLOR_LINE *ColorIndexAuthorList;
+extern COLOR_LINE *ColorIndexFlagsList;
+extern COLOR_LINE *ColorIndexSubjectList;
+
+#ifdef USE_NOTMUCH
+extern COLOR_LINE *ColorIndexTagList;
+#endif
 
 void ci_init_color (void);
 void ci_start_color (void);
diff --git c/mutt_menu.h w/mutt_menu.h
index b229fd4..be4165d 100644
--- c/mutt_menu.h
+++ w/mutt_menu.h
@@ -53,6 +53,7 @@ typedef struct menu_t
   int offset;  /* row offset within the window to start the index */
   int pagelen;	/* number of entries per screen */
   int tagprefix;
+  int is_mailbox_list;
   mutt_window_t *indexwin;
   mutt_window_t *statuswin;
   mutt_window_t *helpwin;
@@ -126,4 +127,6 @@ int mutt_menuLoop (MUTTMENU *);
 void index_make_entry (char *, size_t, struct menu_t *, int);
 int index_color (int);
 
+int mutt_limit_current_thread (HEADER *h);
+
 #endif /* _MUTT_MENU_H_ */
diff --git c/mutt_notmuch.c w/mutt_notmuch.c
new file mode 100644
index 0000000..e592dbd
--- /dev/null
+++ w/mutt_notmuch.c
@@ -0,0 +1,2028 @@
+/*
+ * Notmuch support for mutt
+ *
+ * Copyright (C) 2011, 2012 Karel Zak <kzak@redhat.com>
+ *
+ * Notes:
+ *
+ * - notmuch uses private CONTEXT->data and private HEADER->data
+ *
+ * - all exported functions are usable within notmuch context only
+ *
+ * - all functions have to be covered by "ctx->magic == MUTT_NOTMUCH" check
+ *   (it's implemented in get_ctxdata() and init_context() functions).
+ *
+ * - exception are nm_nonctx_* functions -- these functions use nm_default_uri
+ *   (or parse URI from another resource)
+ */
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mx.h"
+#include "rfc2047.h"
+#include "sort.h"
+#include "mailbox.h"
+#include "copy.h"
+#include "keymap.h"
+#include "url.h"
+#include "buffy.h"
+
+#include <dirent.h>
+#include <fcntl.h>
+#include <sys/file.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <utime.h>
+
+#include <notmuch.h>
+
+#include "mutt_notmuch.h"
+#include "mutt_curses.h"
+
+#ifdef LIBNOTMUCH_CHECK_VERSION
+#undef LIBNOTMUCH_CHECK_VERSION
+#endif
+
+/* The definition in <notmuch.h> is broken */
+#define LIBNOTMUCH_CHECK_VERSION(major, minor, micro)                               \
+    (LIBNOTMUCH_MAJOR_VERSION > (major) ||                                          \
+     (LIBNOTMUCH_MAJOR_VERSION == (major) && LIBNOTMUCH_MINOR_VERSION > (minor)) || \
+     (LIBNOTMUCH_MAJOR_VERSION == (major) && LIBNOTMUCH_MINOR_VERSION == (minor) && \
+      LIBNOTMUCH_MICRO_VERSION >= (micro)))
+
+
+/* read whole-thread or matching messages only? */
+enum {
+	NM_QUERY_TYPE_MESGS = 1,	/* default */
+	NM_QUERY_TYPE_THREADS
+};
+
+/*
+ * Parsed URI arguments
+ */
+struct uri_tag {
+	char *name;
+	char *value;
+	struct uri_tag *next;
+};
+
+/*
+ * HEADER->(nm_hdrdata *)data->tag_list node
+ */
+struct nm_hdrtag
+{
+  char *tag;
+  char *transformed;
+  struct nm_hdrtag *next;
+};
+
+/*
+ * HEADER->data
+ */
+struct nm_hdrdata {
+	char *folder;
+	char *tags;
+	char *tags_transformed;
+	struct nm_hdrtag *tag_list;
+	char *oldpath;
+	char *virtual_id;
+	int magic;
+};
+
+/*
+ * CONTEXT->data
+ */
+struct nm_ctxdata {
+	notmuch_database_t *db;
+
+	char *db_filename;
+	char *db_query;
+	int db_limit;
+	int query_type;
+
+	struct uri_tag *query_items;
+
+	progress_t progress;
+	int oldmsgcount;
+	int ignmsgcount;	/* ingored messages */
+
+	unsigned int noprogress : 1,
+		     longrun : 1,
+		     trans : 1,
+		     progress_ready : 1;
+
+};
+
+static HEADER *get_mutt_header(CONTEXT *ctx, notmuch_message_t *msg);
+static notmuch_message_t *get_nm_message(notmuch_database_t *db, HEADER *hdr);
+
+static void url_free_tags(struct uri_tag *tags)
+{
+	while (tags) {
+		struct uri_tag *next = tags->next;
+		FREE(&tags->name);
+		FREE(&tags->value);
+		FREE(&tags);
+		tags = next;
+	}
+}
+
+static int url_parse_query(char *url, char **filename, struct uri_tag **tags)
+{
+	char *p = strstr(url, "://");	/* remote unsupported */
+	char *e;
+	struct uri_tag *tag, *last = NULL;
+
+	*filename = NULL;
+	*tags = NULL;
+
+	if (!p || !*(p + 3))
+		return -1;
+
+	p += 3;
+	*filename = p;
+
+	e = strchr(p, '?');
+
+	*filename = e ? e == p ? NULL : strndup(p, e - p) : safe_strdup(p);
+	if (!e)
+		return 0;
+
+	if (*filename && url_pct_decode(*filename) < 0)
+		goto err;
+	if (!e)
+		return 0;	/* only filename */
+
+	++e;	/* skip '?' */
+	p = e;
+
+	while (p && *p) {
+		tag = safe_calloc(1, sizeof(struct uri_tag));
+		if (!tag)
+			goto err;
+
+		if (!*tags)
+			last = *tags = tag;
+		else {
+			last->next = tag;
+			last = tag;
+		}
+
+		e = strchr(p, '=');
+		if (!e)
+			e = strchr(p, '&');
+		tag->name = e ? strndup(p, e - p) : safe_strdup(p);
+		if (!tag->name || url_pct_decode(tag->name) < 0)
+			goto err;
+		if (!e)
+			break;
+
+		p = e + 1;
+
+		if (*e == '&')
+			continue;
+
+		e = strchr(p, '&');
+		tag->value = e ? strndup(p, e - p) : safe_strdup(p);
+		if (!tag->value || url_pct_decode(tag->value) < 0)
+			goto err;
+		if (!e)
+			break;
+		p = e + 1;
+	}
+
+	return 0;
+err:
+	FREE(&(*filename));
+	url_free_tags(*tags);
+	return -1;
+}
+
+static void free_tag_list(struct nm_hdrtag **tag_list)
+{
+	struct nm_hdrtag *tmp;
+
+	while ((tmp = *tag_list) != NULL)
+	{
+		*tag_list = tmp->next;
+		FREE(&tmp->tag);
+		FREE(&tmp->transformed);
+		FREE(&tmp);
+	}
+
+	*tag_list = 0;
+}
+
+static void free_hdrdata(struct nm_hdrdata *data)
+{
+	if (!data)
+		return;
+
+	dprint(2, (debugfile, "nm: freeing header %p\n", data));
+	FREE(&data->folder);
+	FREE(&data->tags);
+	FREE(&data->tags_transformed);
+	free_tag_list(&data->tag_list);
+	FREE(&data->oldpath);
+	FREE(&data->virtual_id);
+	FREE(&data);
+}
+
+static void free_ctxdata(struct nm_ctxdata *data)
+{
+	if (!data)
+		return;
+
+	dprint(1, (debugfile, "nm: freeing context data %p\n", data));
+
+	if (data->db)
+#ifdef NOTMUCH_API_3
+	        notmuch_database_destroy(data->db);
+#else
+		notmuch_database_close(data->db);
+#endif
+	data->db = NULL;
+
+	FREE(&data->db_filename);
+	FREE(&data->db_query);
+	url_free_tags(data->query_items);
+	FREE(&data);
+}
+
+static struct nm_ctxdata *new_ctxdata(char *uri)
+{
+	struct nm_ctxdata *data;
+
+	if (!uri)
+		return NULL;
+
+	data = safe_calloc(1, sizeof(struct nm_ctxdata));
+	dprint(1, (debugfile, "nm: initialize context data %p\n", data));
+
+	data->db_limit = NotmuchDBLimit;
+
+	if (url_parse_query(uri, &data->db_filename, &data->query_items)) {
+		mutt_error(_("failed to parse notmuch uri: %s"), uri);
+		data->db_filename = NULL;
+		data->query_items = NULL;
+		data->query_type = 0;
+		return NULL;
+	}
+
+	return data;
+}
+
+static int deinit_context(CONTEXT *ctx)
+{
+	int i;
+
+	if (!ctx || ctx->magic != MUTT_NOTMUCH)
+		return -1;
+
+	for (i = 0; i < ctx->msgcount; i++) {
+		HEADER *h = ctx->hdrs[i];
+
+		if (h) {
+			free_hdrdata(h->data);
+			h->data = NULL;
+		}
+	}
+
+	free_ctxdata(ctx->data);
+	ctx->data = NULL;
+	return 0;
+}
+
+static int init_context(CONTEXT *ctx)
+{
+	if (!ctx || ctx->magic != MUTT_NOTMUCH)
+		return -1;
+
+	if (ctx->data)
+		return 0;
+
+	ctx->data = new_ctxdata(ctx->path);
+	if (!ctx->data)
+		return -1;
+
+	return 0;
+}
+
+char *nm_header_get_folder(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->folder : NULL;
+}
+
+/* returns all unhidden tags */
+char *nm_header_get_tags(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->tags : NULL;
+}
+
+char *nm_header_get_tags_transformed(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->tags_transformed : NULL;
+}
+
+char *nm_header_get_tag_transformed(char *tag, HEADER *h)
+{
+	struct nm_hdrtag *tmp;
+
+	if (!h || !h->data)
+		return NULL;
+
+	for (tmp = ((struct nm_hdrdata *) h->data)->tag_list;
+	     tmp != NULL;
+	     tmp = tmp->next)
+	{
+		if (strcmp(tag, tmp->tag) == 0)
+			return tmp->transformed;
+	}
+
+	return NULL;
+}
+
+int nm_header_get_magic(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->magic : 0;
+}
+
+/*
+ * Returns notmuch message Id.
+ */
+static char *nm_header_get_id(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->virtual_id : NULL;
+}
+
+
+char *nm_header_get_fullpath(HEADER *h, char *buf, size_t bufsz)
+{
+	snprintf(buf, bufsz, "%s/%s", nm_header_get_folder(h), h->path);
+	/*dprint(2, (debugfile, "nm: returns fullpath '%s'\n", buf));*/
+	return buf;
+}
+
+
+static struct nm_ctxdata *get_ctxdata(CONTEXT *ctx)
+{
+	if (ctx && ctx->magic == MUTT_NOTMUCH)
+		return ctx->data;
+
+	return NULL;
+}
+
+static int string_to_guery_type(const char *str)
+{
+	if (!str)
+		str = NotmuchQueryType;		/* user's default */
+	if (!str)
+		return NM_QUERY_TYPE_MESGS;	/* hardcoded default */
+
+	if (strcmp(str, "threads") == 0)
+		return NM_QUERY_TYPE_THREADS;
+	else if (strcmp(str, "messages") == 0)
+		return NM_QUERY_TYPE_MESGS;
+
+	mutt_error (_("failed to parse notmuch query type: %s"), str);
+	return NM_QUERY_TYPE_MESGS;
+}
+
+static char *get_query_string(struct nm_ctxdata *data)
+{
+	struct uri_tag *item;
+
+	if (!data)
+		return NULL;
+	if (data->db_query)
+		return data->db_query;
+
+	for (item = data->query_items; item; item = item->next) {
+		if (!item->value || !item->name)
+			continue;
+
+		if (strcmp(item->name, "limit") == 0) {
+			if (mutt_atoi(item->value, &data->db_limit))
+				mutt_error (_("failed to parse notmuch limit: %s"), item->value);
+
+		} else if (strcmp(item->name, "type") == 0)
+			data->query_type = string_to_guery_type(item->value);
+
+		else if (strcmp(item->name, "query") == 0)
+			data->db_query = safe_strdup(item->value);
+	}
+
+	if (!data->query_type)
+		data->query_type = string_to_guery_type(NULL);
+
+	dprint(2, (debugfile, "nm: query '%s'\n", data->db_query));
+
+	return data->db_query;
+}
+
+static int get_limit(struct nm_ctxdata *data)
+{
+	return data ? data->db_limit : 0;
+}
+
+static int get_query_type(struct nm_ctxdata *data)
+{
+	return (data && data->query_type) ? data->query_type : string_to_guery_type(NULL);
+}
+
+static const char *get_db_filename(struct nm_ctxdata *data)
+{
+	char *db_filename;
+
+	if (!data)
+		return NULL;
+
+	db_filename = data->db_filename ? data->db_filename : NotmuchDefaultUri;
+	if (!db_filename)
+		db_filename = Maildir;
+	if (!db_filename)
+		return NULL;
+	if (strncmp(db_filename, "notmuch://", 10) == 0)
+		db_filename += 10;
+
+	dprint(2, (debugfile, "nm: db filename '%s'\n", db_filename));
+	return db_filename;
+}
+
+static notmuch_database_t *do_database_open(const char *filename,
+					    int writable, int verbose)
+{
+	notmuch_database_t *db = NULL;
+	unsigned int ct = 0;
+	notmuch_status_t st = NOTMUCH_STATUS_SUCCESS;
+
+	dprint(1, (debugfile, "nm: db open '%s' %s (timeout %d)\n", filename,
+			writable ? "[WRITE]" : "[READ]", NotmuchOpenTimeout));
+	do {
+#ifdef NOTMUCH_API_3
+		st = notmuch_database_open(filename,
+					writable ? NOTMUCH_DATABASE_MODE_READ_WRITE :
+					NOTMUCH_DATABASE_MODE_READ_ONLY, &db);
+#else
+		db = notmuch_database_open(filename,
+					writable ? NOTMUCH_DATABASE_MODE_READ_WRITE :
+					NOTMUCH_DATABASE_MODE_READ_ONLY);
+#endif
+		if (db || !NotmuchOpenTimeout || ct / 2 > NotmuchOpenTimeout)
+			break;
+
+		if (verbose && ct && ct % 2 == 0)
+			mutt_error(_("Waiting for notmuch DB... (%d sec)"), ct / 2);
+		usleep(500000);
+		ct++;
+	} while (1);
+
+	if (verbose) {
+		if (!db)
+			mutt_error (_("Cannot open notmuch database: %s: %s"),
+				    filename,
+				    st ? notmuch_status_to_string(st) :
+					 _("unknown reason"));
+		else if (ct > 1)
+			mutt_clear_error();
+	}
+	return db;
+}
+
+static notmuch_database_t *get_db(struct nm_ctxdata *data, int writable)
+{
+	if (!data)
+	       return NULL;
+	if (!data->db) {
+		const char *db_filename = get_db_filename(data);
+
+		if (db_filename)
+			data->db = do_database_open(db_filename, writable, TRUE);
+	}
+	return data->db;
+}
+
+static int release_db(struct nm_ctxdata *data)
+{
+	if (data && data->db) {
+		dprint(1, (debugfile, "nm: db close\n"));
+#ifdef NOTMUCH_API_3
+		notmuch_database_destroy(data->db);
+#else
+		notmuch_database_close(data->db);
+#endif
+		data->db = NULL;
+		data->longrun = 0;
+		return 0;
+	}
+
+	return -1;
+}
+
+/* returns:	< 0 = error
+ *		  1 = new transaction started
+ *		  0 = already within transaction
+ */
+static int db_trans_begin(struct nm_ctxdata *data)
+{
+	if (!data || !data->db)
+		return -1;
+
+	if (!data->trans) {
+		dprint(2, (debugfile, "nm: db trans start\n"));
+		if (notmuch_database_begin_atomic(data->db))
+			return -1;
+		data->trans = 1;
+		return 1;
+	}
+
+	return 0;
+}
+
+static int db_trans_end(struct nm_ctxdata *data)
+{
+	if (!data || !data->db)
+		return -1;
+
+	if (data->trans) {
+		dprint(2, (debugfile, "nm: db trans end\n"));
+		data->trans = 0;
+		if (notmuch_database_end_atomic(data->db))
+			return -1;
+	}
+
+	return 0;
+}
+
+void nm_longrun_init(CONTEXT *ctx, int writable)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (data && get_db(data, writable)) {
+		data->longrun = 1;
+		dprint(2, (debugfile, "nm: long run initialized\n"));
+	}
+}
+
+void nm_longrun_done(CONTEXT *ctx)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (data && release_db(data) == 0)
+		dprint(2, (debugfile, "nm: long run deinitialized\n"));
+}
+
+static int is_longrun(struct nm_ctxdata *data)
+{
+	return data && data->longrun;
+}
+
+void nm_debug_check(CONTEXT *ctx)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (!data)
+		return;
+
+	if (data->db) {
+		dprint(1, (debugfile, "nm: ERROR: db is open, closing\n"));
+		release_db(data);
+	}
+}
+
+static int get_database_mtime(struct nm_ctxdata *data, time_t *mtime)
+{
+	char path[_POSIX_PATH_MAX];
+	struct stat st;
+
+	if (!data)
+	       return -1;
+
+	snprintf(path, sizeof(path), "%s/.notmuch/xapian", get_db_filename(data));
+	dprint(2, (debugfile, "nm: checking '%s' mtime\n", path));
+
+	if (stat(path, &st))
+		return -1;
+
+	if (mtime)
+		*mtime = st.st_mtime;
+
+	return 0;
+}
+
+static void apply_exclude_tags(notmuch_query_t *query)
+{
+	char *buf, *p, *end = NULL, *tag = NULL;
+
+	if (!NotmuchExcludeTags || !*NotmuchExcludeTags)
+		return;
+	buf = safe_strdup(NotmuchExcludeTags);
+
+	for (p = buf; p && *p; p++) {
+		if (!tag && isspace(*p))
+			continue;
+		if (!tag)
+			tag = p;		/* begin of the tag */
+		if (*p == ',' || *p == ' ')
+			end = p;		/* terminate the tag */
+		else if (*(p + 1) == '\0')
+			end = p + 1;		/* end of optstr */
+		if (!tag || !end)
+			continue;
+		if (tag >= end)
+			break;
+		*end = '\0';
+
+		dprint(2, (debugfile, "nm: query exclude tag '%s'\n", tag));
+		notmuch_query_add_tag_exclude(query, tag);
+		end = tag = NULL;
+	}
+	notmuch_query_set_omit_excluded(query, 1);
+	FREE(&buf);
+}
+
+static notmuch_query_t *get_query(struct nm_ctxdata *data, int writable)
+{
+	notmuch_database_t *db = NULL;
+	notmuch_query_t *q = NULL;
+	const char *str;
+
+	if (!data)
+		return NULL;
+
+	db = get_db(data, writable);
+	str = get_query_string(data);
+
+	if (!db || !str)
+		goto err;
+
+	q = notmuch_query_create(db, str);
+	if (!q)
+		goto err;
+
+	apply_exclude_tags(q);
+	notmuch_query_set_sort(q, NOTMUCH_SORT_NEWEST_FIRST);
+	dprint(2, (debugfile, "nm: query successfully initialized\n"));
+	return q;
+err:
+	if (!is_longrun(data))
+		release_db(data);
+	return NULL;
+}
+
+static void append_str_item(char **str, const char *item, int sep)
+{
+	char *p;
+	size_t sz = strlen(item);
+	size_t ssz = *str ? strlen(*str) : 0;
+
+	safe_realloc(str, ssz + (ssz && sep ? 1 : 0) + sz + 1);
+	p = *str + ssz;
+	if (sep && ssz)
+	    *p++ = sep;
+	memcpy(p, item, sz + 1);
+}
+
+static int update_header_tags(HEADER *h, notmuch_message_t *msg)
+{
+	struct nm_hdrdata *data = h->data;
+	notmuch_tags_t *tags;
+	char *tstr = NULL, *ttstr = NULL;
+	struct nm_hdrtag *tag_list = NULL, *tmp;
+
+	dprint(2, (debugfile, "nm: tags update requested (%s)\n", data->virtual_id));
+
+	for (tags = notmuch_message_get_tags(msg);
+	     tags && notmuch_tags_valid(tags);
+	     notmuch_tags_move_to_next(tags)) {
+
+		const char *t = notmuch_tags_get(tags);
+		const char *tt = NULL;
+
+		if (!t || !*t)
+			continue;
+
+		tt = hash_find(TagTransforms, t);
+		if (!tt)
+			tt = t;
+
+		/* tags list contains all tags */
+		tmp = safe_calloc(1, sizeof(*tmp));
+		tmp->tag = safe_strdup(t);
+		tmp->transformed = safe_strdup(tt);
+		tmp->next = tag_list;
+		tag_list = tmp;
+
+		/* filter out hidden tags */
+		if (NotmuchHiddenTags) {
+			char *p = strstr(NotmuchHiddenTags, t);
+			size_t xsz = p ? strlen(t) : 0;
+
+			if (p && (p == NotmuchHiddenTags
+				  || *(p - 1) == ','
+				  || *(p - 1) == ' ')
+			    && (*(p + xsz) == '\0'
+				  || *(p + xsz) == ','
+				  || *(p + xsz) == ' '))
+				continue;
+		}
+
+		/* expand the transformed tag string */
+		append_str_item(&ttstr, tt, ' ');
+
+		/* expand the un-transformed tag string */
+		append_str_item(&tstr, t, ' ');
+	}
+
+	free_tag_list(&data->tag_list);
+	data->tag_list = tag_list;
+
+	if (data->tags && tstr && strcmp(data->tags, tstr) == 0) {
+		FREE(&tstr);
+		FREE(&ttstr);
+		dprint(2, (debugfile, "nm: tags unchanged\n"));
+		return 1;
+	}
+
+	/* free old version */
+	FREE(&data->tags);
+	FREE(&data->tags_transformed);
+
+	/* new version */
+	data->tags = tstr;
+	dprint(2, (debugfile, "nm: new tags: '%s'\n", tstr));
+
+	data->tags_transformed = ttstr;
+	dprint(2, (debugfile, "nm: new tag transforms: '%s'\n", ttstr));
+
+	return 0;
+}
+
+/*
+ * set/update HEADER->path and HEADER->data->path
+ */
+static int update_message_path(HEADER *h, const char *path)
+{
+	struct nm_hdrdata *data = h->data;
+	char *p;
+
+	dprint(2, (debugfile, "nm: path update requested path=%s, (%s)\n",
+				path, data->virtual_id));
+
+	p = strrchr(path, '/');
+	if (p && p - path > 3 &&
+	    (strncmp(p - 3, "cur", 3) == 0 ||
+	     strncmp(p - 3, "new", 3) == 0 ||
+	     strncmp(p - 3, "tmp", 3) == 0)) {
+
+		data->magic = MUTT_MAILDIR;
+
+		FREE(&h->path);
+		FREE(&data->folder);
+
+		p -= 3;				/* skip subfolder (e.g. "new") */
+		h->path = safe_strdup(p);
+
+		for (; p > path && *(p - 1) == '/'; p--);
+
+		data->folder = strndup(path, p - path);
+
+		dprint(2, (debugfile, "nm: folder='%s', file='%s'\n", data->folder, h->path));
+		return 0;
+	}
+
+	return 1;
+}
+
+static char *get_folder_from_path(const char *path)
+{
+	char *p = strrchr(path, '/');
+
+	if (p && p - path > 3 &&
+	    (strncmp(p - 3, "cur", 3) == 0 ||
+	     strncmp(p - 3, "new", 3) == 0 ||
+	     strncmp(p - 3, "tmp", 3) == 0)) {
+
+		p -= 3;
+		for (; p > path && *(p - 1) == '/'; p--);
+
+		return strndup(path, p - path);
+	}
+
+	return NULL;
+}
+
+static void deinit_header(HEADER *h)
+{
+	if (h) {
+		free_hdrdata(h->data);
+		h->data = NULL;
+	}
+}
+
+/* converts notmuch message Id to mutt message <Id> */
+static char *nm2mutt_message_id(const char *id)
+{
+	size_t sz;
+	char *mid;
+
+	if (!id)
+		return NULL;
+	sz = strlen(id) + 3;
+	mid = safe_malloc(sz);
+
+	snprintf(mid, sz, "<%s>", id);
+	return mid;
+}
+
+static int init_header(HEADER *h, const char *path, notmuch_message_t *msg)
+{
+	const char *id;
+
+	if (h->data)
+		return 0;
+
+	id = notmuch_message_get_message_id(msg);
+
+	h->data = safe_calloc(1, sizeof(struct nm_hdrdata));
+	h->free_cb = deinit_header;
+
+	/*
+	 * Notmuch ensures that message Id exists (if not notmuch Notmuch will
+	 * generate an ID), so it's more safe than use mutt HEADER->env->id
+	 */
+	((struct nm_hdrdata *) h->data)->virtual_id = safe_strdup( id );
+
+	dprint(2, (debugfile, "nm: initialize header data: [hdr=%p, data=%p] (%s)\n",
+				h, h->data, id));
+
+	if (!h->env->message_id)
+		h->env->message_id = nm2mutt_message_id( id );
+
+	if (update_message_path(h, path))
+		return -1;
+
+	update_header_tags(h, msg);
+
+	return 0;
+}
+
+/**
+static void debug_print_filenames(notmuch_message_t *msg)
+{
+	notmuch_filenames_t *ls;
+	const char *id = notmuch_message_get_message_id(msg);
+
+	for (ls = notmuch_message_get_filenames(msg);
+	     ls && notmuch_filenames_valid(ls);
+	     notmuch_filenames_move_to_next(ls)) {
+
+		dprint(2, (debugfile, "nm: %s: %s\n", id, notmuch_filenames_get(ls)));
+	}
+}
+
+static void debug_print_tags(notmuch_message_t *msg)
+{
+	notmuch_tags_t *tags;
+	const char *id = notmuch_message_get_message_id(msg);
+
+	for (tags = notmuch_message_get_tags(msg);
+	     tags && notmuch_tags_valid(tags);
+	     notmuch_tags_move_to_next(tags)) {
+
+		dprint(2, (debugfile, "nm: %s: %s\n", id, notmuch_tags_get(tags)));
+	}
+}
+***/
+
+static const char *get_message_last_filename(notmuch_message_t *msg)
+{
+	notmuch_filenames_t *ls;
+	const char *name = NULL;
+
+	for (ls = notmuch_message_get_filenames(msg);
+	     ls && notmuch_filenames_valid(ls);
+	     notmuch_filenames_move_to_next(ls)) {
+
+		name = notmuch_filenames_get(ls);
+	}
+
+	return name;
+}
+
+static void nm_progress_reset(CONTEXT *ctx)
+{
+	struct nm_ctxdata *data;
+
+	if (ctx->quiet)
+		return;
+
+	data = get_ctxdata(ctx);
+
+	memset(&data->progress, 0, sizeof(data->progress));
+	data->oldmsgcount = ctx->msgcount;
+	data->ignmsgcount = 0;
+	data->noprogress = 0;
+	data->progress_ready = 0;
+}
+
+static void nm_progress_update(CONTEXT *ctx, notmuch_query_t *q)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (ctx->quiet || data->noprogress)
+		return;
+
+	if (!data->progress_ready && q) {
+		unsigned count;
+		static char msg[STRING];
+		snprintf(msg, sizeof(msg), _("Reading messages..."));
+
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+		if (notmuch_query_count_messages_st (q, &count) != NOTMUCH_STATUS_SUCCESS)
+			count = 0;	/* may not be defined on error */
+#else
+		count = notmuch_query_count_messages(q);
+#endif
+		mutt_progress_init(&data->progress, msg, MUTT_PROGRESS_MSG,
+			ReadInc, count);
+		data->progress_ready = 1;
+	}
+
+	if (data->progress_ready)
+		mutt_progress_update(&data->progress,
+				ctx->msgcount + data->ignmsgcount
+					      - data->oldmsgcount, -1);
+}
+
+static void append_message(CONTEXT *ctx,
+			   notmuch_query_t *q,
+			   notmuch_message_t *msg,
+			   int dedup)
+{
+	char *newpath = NULL;
+	const char *path;
+	HEADER *h = NULL;
+
+	/* deduplicate */
+	if (dedup && get_mutt_header(ctx, msg)) {
+		get_ctxdata(ctx)->ignmsgcount++;
+		nm_progress_update(ctx, q);
+	        dprint(2, (debugfile, "nm: ignore id=%s, already in the context\n",
+					notmuch_message_get_message_id(msg)));
+		return;
+	}
+
+	path = get_message_last_filename(msg);
+	if (!path)
+		return;
+
+	dprint(2, (debugfile, "nm: appending message, i=%d, id=%s, path=%s\n",
+				ctx->msgcount,
+				notmuch_message_get_message_id(msg),
+				path));
+
+	if (ctx->msgcount >= ctx->hdrmax) {
+		dprint(2, (debugfile, "nm: allocate mx memory\n"));
+		mx_alloc_memory(ctx);
+	}
+	if (access(path, F_OK) == 0)
+		h = maildir_parse_message(MUTT_MAILDIR, path, 0, NULL);
+	else {
+		/* maybe moved try find it... */
+		char *folder = get_folder_from_path(path);
+
+		if (folder) {
+			FILE *f = maildir_open_find_message(folder, path, &newpath);
+			if (f) {
+				h = maildir_parse_stream(MUTT_MAILDIR, f, newpath, 0, NULL);
+				fclose(f);
+
+				dprint(1, (debugfile, "nm: not up-to-date: %s -> %s\n",
+							path, newpath));
+			}
+		}
+		FREE(&folder);
+	}
+
+	if (!h) {
+		dprint(1, (debugfile, "nm: failed to parse message: %s\n", path));
+		goto done;
+	}
+	if (init_header(h, newpath ? newpath : path, msg) != 0) {
+		mutt_free_header(&h);
+		dprint(1, (debugfile, "nm: failed to append header!\n"));
+		goto done;
+	}
+
+	h->active = 1;
+	h->index = ctx->msgcount;
+	ctx->size += h->content->length
+		   + h->content->offset
+		   - h->content->hdr_offset;
+	ctx->hdrs[ctx->msgcount] = h;
+	ctx->msgcount++;
+
+	if (newpath) {
+		/* remember that file has been moved -- nm_sync() will update the DB */
+		struct nm_hdrdata *hd = (struct nm_hdrdata *) h->data;
+
+		if (hd) {
+			dprint(1, (debugfile, "nm: remember obsolete path: %s\n", path));
+			hd->oldpath = safe_strdup(path);
+		}
+	}
+	nm_progress_update(ctx, q);
+done:
+	FREE(&newpath);
+}
+
+/*
+ * add all the replies to a given messages into the display.
+ * Careful, this calls itself recursively to make sure we get
+ * everything.
+ */
+static void append_replies(CONTEXT *ctx,
+			   notmuch_query_t *q,
+			   notmuch_message_t *top,
+			   int dedup)
+{
+	notmuch_messages_t *msgs;
+
+	for (msgs = notmuch_message_get_replies(top);
+	     notmuch_messages_valid(msgs);
+	     notmuch_messages_move_to_next(msgs)) {
+
+		notmuch_message_t *m = notmuch_messages_get(msgs);
+		append_message(ctx, q, m, dedup);
+		/* recurse through all the replies to this message too */
+		append_replies(ctx, q, m, dedup);
+		notmuch_message_destroy(m);
+	}
+}
+
+/*
+ * add each top level reply in the thread, and then add each
+ * reply to the top level replies
+ */
+static void append_thread(CONTEXT *ctx,
+			  notmuch_query_t *q,
+			  notmuch_thread_t *thread,
+			  int dedup)
+{
+	notmuch_messages_t *msgs;
+
+	for (msgs = notmuch_thread_get_toplevel_messages(thread);
+	     notmuch_messages_valid(msgs);
+	     notmuch_messages_move_to_next(msgs)) {
+
+		notmuch_message_t *m = notmuch_messages_get(msgs);
+		append_message(ctx, q, m, dedup);
+		append_replies(ctx, q, m, dedup);
+		notmuch_message_destroy(m);
+	}
+}
+
+static void read_mesgs_query(CONTEXT *ctx, notmuch_query_t *q, int dedup)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	int limit;
+	notmuch_messages_t *msgs;
+
+	if (!data)
+		return;
+
+	limit = get_limit(data);
+
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+	if (notmuch_query_search_messages_st (q, &msgs) != NOTMUCH_STATUS_SUCCESS)
+		return;
+#else
+	msgs = notmuch_query_search_messages(q);
+#endif
+
+	for (; notmuch_messages_valid(msgs) &&
+		(limit == 0 || ctx->msgcount < limit);
+	     notmuch_messages_move_to_next(msgs)) {
+
+		notmuch_message_t *m = notmuch_messages_get(msgs);
+		append_message(ctx, q, m, dedup);
+		notmuch_message_destroy(m);
+	}
+}
+
+static void read_threads_query(CONTEXT *ctx, notmuch_query_t *q, int dedup, int limit)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	notmuch_threads_t *threads;
+
+	if (!data)
+		return;
+
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+	if (notmuch_query_search_threads_st (q, &threads) != NOTMUCH_STATUS_SUCCESS)
+		return;
+#else
+	threads = notmuch_query_search_threads(q);
+#endif
+
+	for (; notmuch_threads_valid(threads) &&
+		(limit == 0 || ctx->msgcount < limit);
+	     notmuch_threads_move_to_next(threads)) {
+
+		notmuch_thread_t *thread = notmuch_threads_get(threads);
+		append_thread(ctx, q, thread, dedup);
+		notmuch_thread_destroy(thread);
+	}
+}
+
+int nm_read_query(CONTEXT *ctx)
+{
+	notmuch_query_t *q;
+	struct nm_ctxdata *data;
+	int rc = -1;
+
+	if (init_context(ctx) != 0)
+		return -1;
+
+	data = get_ctxdata(ctx);
+	if (!data)
+		return -1;
+
+	dprint(1, (debugfile, "nm: reading messages...[current count=%d]\n",
+				ctx->msgcount));
+
+	nm_progress_reset(ctx);
+
+	q = get_query(data, FALSE);
+	if (q) {
+		switch(get_query_type(data)) {
+		case NM_QUERY_TYPE_MESGS:
+			read_mesgs_query(ctx, q, 0);
+			break;
+		case NM_QUERY_TYPE_THREADS:
+			read_threads_query(ctx, q, 0, get_limit(data));
+			break;
+		}
+		notmuch_query_destroy(q);
+		rc = 0;
+
+	}
+
+	if (!is_longrun(data))
+		release_db(data);
+
+	ctx->mtime = time(NULL);
+
+	mx_update_context(ctx, ctx->msgcount);
+	data->oldmsgcount = 0;
+
+	dprint(1, (debugfile, "nm: reading messages... done [rc=%d, count=%d]\n",
+				rc, ctx->msgcount));
+	return rc;
+}
+
+int nm_read_entire_thread(CONTEXT *ctx, HEADER *h)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	const char *id;
+	char *qstr = NULL;
+	notmuch_query_t *q = NULL;
+	notmuch_database_t *db = NULL;
+	notmuch_message_t *msg = NULL;
+	int rc = -1;
+
+	if (!data)
+		return -1;
+	if (!(db = get_db(data, FALSE)) || !(msg = get_nm_message(db, h)))
+		goto done;
+
+	dprint(1, (debugfile, "nm: reading entire-thread messages...[current count=%d]\n",
+				ctx->msgcount));
+
+	nm_progress_reset(ctx);
+	id = notmuch_message_get_thread_id(msg);
+	if (!id)
+		goto done;
+	append_str_item(&qstr, "thread:", 0);
+	append_str_item(&qstr, id, 0);
+
+	q = notmuch_query_create(db, qstr);
+	FREE(&qstr);
+	if (!q)
+		goto done;
+	apply_exclude_tags(q);
+	notmuch_query_set_sort(q, NOTMUCH_SORT_NEWEST_FIRST);
+
+	read_threads_query(ctx, q, 1, 0);
+	ctx->mtime = time(NULL);
+	rc = 0;
+
+	if (ctx->msgcount > data->oldmsgcount)
+		mx_update_context(ctx, ctx->msgcount - data->oldmsgcount);
+done:
+	if (q)
+		notmuch_query_destroy(q);
+	if (!is_longrun(data))
+		release_db(data);
+
+	if (ctx->msgcount == data->oldmsgcount)
+		mutt_message _("No more messages in the thread.");
+
+	data->oldmsgcount = 0;
+	dprint(1, (debugfile, "nm: reading entire-thread messages... done [rc=%d, count=%d]\n",
+				rc, ctx->msgcount));
+	return rc;
+}
+
+char *nm_uri_from_query(CONTEXT *ctx, char *buf, size_t bufsz)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	char uri[_POSIX_PATH_MAX + LONG_STRING + 32];	/* path to DB + query + URI "decoration" */
+
+	if (data)
+		snprintf(uri, sizeof(uri), "notmuch://%s?query=%s",
+			 get_db_filename(data), buf);
+	else if (NotmuchDefaultUri)
+		snprintf(uri, sizeof(uri), "%s?query=%s", NotmuchDefaultUri, buf);
+	else if (Maildir)
+		snprintf(uri, sizeof(uri), "notmuch://%s?query=%s", Maildir, buf);
+	else
+		return NULL;
+
+	strncpy(buf, uri, bufsz);
+	buf[bufsz - 1] = '\0';
+
+	dprint(1, (debugfile, "nm: uri from query '%s'\n", buf));
+	return buf;
+}
+
+/*
+ * returns message from notmuch database
+ */
+static notmuch_message_t *get_nm_message(notmuch_database_t *db, HEADER *hdr)
+{
+	notmuch_message_t *msg = NULL;
+	char *id = nm_header_get_id(hdr);
+
+	dprint(2, (debugfile, "nm: find message (%s)\n", id));
+
+	if (id && db)
+		notmuch_database_find_message(db, id, &msg);
+
+	return msg;
+}
+
+static int update_tags(notmuch_message_t *msg, const char *tags)
+{
+	char *tag = NULL, *end = NULL, *p;
+	char *buf = safe_strdup(tags);
+
+	if (!buf)
+		return -1;
+
+	notmuch_message_freeze(msg);
+
+	for (p = buf; p && *p; p++) {
+		if (!tag && isspace(*p))
+			continue;
+		if (!tag)
+			tag = p;		/* begin of the tag */
+		if (*p == ',' || *p == ' ')
+			end = p;		/* terminate the tag */
+		else if (*(p + 1) == '\0')
+			end = p + 1;		/* end of optstr */
+		if (!tag || !end)
+			continue;
+		if (tag >= end)
+			break;
+
+		*end = '\0';
+
+		if (*tag == '-') {
+			dprint(1, (debugfile, "nm: remove tag: '%s'\n", tag + 1));
+			notmuch_message_remove_tag(msg, tag + 1);
+		} else {
+			dprint(1, (debugfile, "nm: add tag: '%s'\n", *tag == '+' ? tag + 1 : tag));
+			notmuch_message_add_tag(msg, *tag == '+' ? tag + 1 : tag);
+		}
+		end = tag = NULL;
+	}
+
+	notmuch_message_thaw(msg);
+	FREE(&buf);
+	return 0;
+}
+
+int nm_modify_message_tags(CONTEXT *ctx, HEADER *hdr, char *buf)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	notmuch_database_t *db = NULL;
+	notmuch_message_t *msg = NULL;
+	int rc = -1;
+
+	if (!buf || !*buf || !data)
+		return -1;
+
+	if (!(db = get_db(data, TRUE)) || !(msg = get_nm_message(db, hdr)))
+		goto done;
+
+	dprint(1, (debugfile, "nm: tags modify: '%s'\n", buf));
+
+	update_tags(msg, buf);
+	update_header_tags(hdr, msg);
+	mutt_set_header_color(ctx, hdr);
+
+	rc = 0;
+	hdr->changed = TRUE;
+done:
+	if (!is_longrun(data))
+		release_db(data);
+	if (hdr->changed)
+		ctx->mtime = time(NULL);
+	dprint(1, (debugfile, "nm: tags modify done [rc=%d]\n", rc));
+	return rc;
+}
+
+static int rename_maildir_filename(const char *old, char *newpath, size_t newsz, HEADER *h)
+{
+	char filename[_POSIX_PATH_MAX];
+	char suffix[_POSIX_PATH_MAX];
+	char folder[_POSIX_PATH_MAX];
+	char *p;
+
+	strfcpy(folder, old, sizeof(folder));
+	p = strrchr(folder, '/');
+	if (p)
+		*p = '\0';
+
+	p++;
+	strfcpy(filename, p, sizeof(filename));
+
+	/* remove (new,cur,...) from folder path */
+	p = strrchr(folder, '/');
+	if (p)
+		*p = '\0';
+
+	/* remove old flags from filename */
+	if ((p = strchr(filename, ':')))
+		*p = '\0';
+
+	/* compose new flags */
+	maildir_flags(suffix, sizeof(suffix), h);
+
+	snprintf(newpath, newsz, "%s/%s/%s%s",
+			folder,
+			(h->read || h->old) ? "cur" : "new",
+			filename,
+			suffix);
+
+	if (strcmp(old, newpath) == 0)
+		return 1;
+
+	if (rename(old, newpath) != 0) {
+		dprint(1, (debugfile, "nm: rename(2) failed %s -> %s\n", old, newpath));
+		return -1;
+	}
+
+	return 0;
+}
+
+static int remove_filename(struct nm_ctxdata *data, const char *path)
+{
+	notmuch_status_t st;
+	notmuch_filenames_t *ls;
+	notmuch_message_t *msg = NULL;
+	notmuch_database_t *db = get_db(data, TRUE);
+	int trans;
+
+	dprint(2, (debugfile, "nm: remove filename '%s'\n", path));
+
+	if (!db)
+		return -1;
+	st = notmuch_database_find_message_by_filename(db, path, &msg);
+	if (st || !msg)
+		return -1;
+	trans = db_trans_begin(data);
+	if (trans < 0)
+		return -1;
+
+	/*
+	 * note that unlink() is probably unnecessary here, it's already removed
+	 * by mh_sync_mailbox_message(), but for sure...
+	 */
+	st = notmuch_database_remove_message(db, path);
+	switch (st) {
+	case NOTMUCH_STATUS_SUCCESS:
+		dprint(2, (debugfile, "nm: remove success, call unlink\n"));
+		unlink(path);
+		break;
+	case NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID:
+		dprint(2, (debugfile, "nm: remove success (duplicate), call unlink\n"));
+		unlink(path);
+		for (ls = notmuch_message_get_filenames(msg);
+		     ls && notmuch_filenames_valid(ls);
+		     notmuch_filenames_move_to_next(ls)) {
+
+			path = notmuch_filenames_get(ls);
+
+			dprint(2, (debugfile, "nm: remove duplicate: '%s'\n", path));
+			unlink(path);
+			notmuch_database_remove_message(db, path);
+		}
+		break;
+	default:
+		dprint(1, (debugfile, "nm: failed to remove '%s' [st=%d]\n", path, (int) st));
+		break;
+	}
+
+	notmuch_message_destroy(msg);
+	if (trans)
+		db_trans_end(data);
+	return 0;
+}
+
+static int rename_filename(struct nm_ctxdata *data,
+			const char *old, const char *new, HEADER *h)
+{
+	int rc = -1;
+	notmuch_status_t st;
+	notmuch_filenames_t *ls;
+	notmuch_message_t *msg;
+	notmuch_database_t *db = get_db(data, TRUE);
+	int trans;
+
+	if (!db || !new || !old || access(new, F_OK) != 0)
+		return -1;
+
+	dprint(1, (debugfile, "nm: rename filename, %s -> %s\n", old, new));
+	trans = db_trans_begin(data);
+	if (trans < 0)
+		return -1;
+
+	dprint(2, (debugfile, "nm: rename: add '%s'\n", new));
+	st = notmuch_database_add_message(db, new, &msg);
+
+	if (st != NOTMUCH_STATUS_SUCCESS &&
+	    st != NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID) {
+		dprint(1, (debugfile, "nm: failed to add '%s' [st=%d]\n", new, (int) st));
+		goto done;
+	}
+
+	dprint(2, (debugfile, "nm: rename: rem '%s'\n", old));
+	st = notmuch_database_remove_message(db, old);
+	switch (st) {
+	case NOTMUCH_STATUS_SUCCESS:
+		break;
+	case NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID:
+		dprint(2, (debugfile, "nm: rename: syncing duplicate filename\n"));
+		notmuch_message_destroy(msg);
+		msg = NULL;
+		notmuch_database_find_message_by_filename(db, new, &msg);
+
+		for (ls = notmuch_message_get_filenames(msg);
+		     msg && ls && notmuch_filenames_valid(ls);
+		     notmuch_filenames_move_to_next(ls)) {
+
+			const char *path = notmuch_filenames_get(ls);
+			char newpath[_POSIX_PATH_MAX];
+
+			if (strcmp(new, path) == 0)
+				continue;
+
+			dprint(2, (debugfile, "nm: rename: syncing duplicate: %s\n", path));
+
+			if (rename_maildir_filename(path, newpath, sizeof(newpath), h) == 0) {
+				dprint(2, (debugfile, "nm: rename dup %s -> %s\n", path, newpath));
+				notmuch_database_remove_message(db, path);
+				notmuch_database_add_message(db, newpath, NULL);
+			}
+		}
+		notmuch_message_destroy(msg);
+		msg = NULL;
+		notmuch_database_find_message_by_filename(db, new, &msg);
+		st = NOTMUCH_STATUS_SUCCESS;
+		break;
+	default:
+		dprint(1, (debugfile, "nm: failed to remove '%s' [st=%d]\n",
+					old, (int) st));
+		break;
+	}
+
+	if (st == NOTMUCH_STATUS_SUCCESS && h && msg) {
+		notmuch_message_maildir_flags_to_tags(msg);
+		update_header_tags(h, msg);
+		update_tags(msg, nm_header_get_tags(h));
+	}
+
+	rc = 0;
+done:
+	if (msg)
+		notmuch_message_destroy(msg);
+	if (trans)
+		db_trans_end(data);
+	return rc;
+}
+
+int nm_update_filename(CONTEXT *ctx, const char *old, const char *new, HEADER *h)
+{
+	char buf[PATH_MAX];
+	int rc;
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (!data || !new)
+		return -1;
+
+	if (!old && h && h->data) {
+		nm_header_get_fullpath(h, buf, sizeof(buf));
+		old = buf;
+	}
+
+	rc = rename_filename(data, old, new, h);
+
+	if (!is_longrun(data))
+		release_db(data);
+	ctx->mtime = time(NULL);
+	return rc;
+}
+
+int nm_sync(CONTEXT *ctx, int *index_hint)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	int i, rc = 0;
+	char msgbuf[STRING];
+	progress_t progress;
+	char *uri = ctx->path;
+	int changed = 0;
+
+	if (!data)
+		return -1;
+
+	dprint(1, (debugfile, "nm: sync start ...\n"));
+
+	if (!ctx->quiet) {
+		/* all is in this function so we don't use data->progress here */
+		snprintf(msgbuf, sizeof (msgbuf), _("Writing %s..."), ctx->path);
+		mutt_progress_init(&progress, msgbuf, MUTT_PROGRESS_MSG,
+				   WriteInc, ctx->msgcount);
+	}
+
+	for (i = 0; i < ctx->msgcount; i++) {
+		char old[_POSIX_PATH_MAX], new[_POSIX_PATH_MAX];
+		HEADER *h = ctx->hdrs[i];
+		struct nm_hdrdata *hd = h->data;
+
+		if (!ctx->quiet)
+			mutt_progress_update(&progress, i, -1);
+
+		*old = *new = '\0';
+
+		if (hd->oldpath) {
+			strncpy(old, hd->oldpath, sizeof(old));
+			old[sizeof(old) - 1] = '\0';
+			dprint(2, (debugfile, "nm: fixing obsolete path '%s'\n", old));
+		} else
+			nm_header_get_fullpath(h, old, sizeof(old));
+
+		ctx->path = hd->folder;
+		ctx->magic = hd->magic;
+#if USE_HCACHE
+		rc = mh_sync_mailbox_message(ctx, i, NULL);
+#else
+		rc = mh_sync_mailbox_message(ctx, i);
+#endif
+		ctx->path = uri;
+		ctx->magic = MUTT_NOTMUCH;
+
+		if (rc)
+			break;
+
+		if (!h->deleted)
+			nm_header_get_fullpath(h, new, sizeof(new));
+
+		if (h->deleted || strcmp(old, new) != 0) {
+			if (h->deleted && remove_filename(data, old) == 0)
+				changed = 1;
+			else if (*new && *old && rename_filename(data, old, new, h) == 0)
+				changed = 1;
+		}
+
+		FREE(&hd->oldpath);
+	}
+
+	ctx->path = uri;
+	ctx->magic = MUTT_NOTMUCH;
+
+	if (!is_longrun(data))
+		release_db(data);
+	if (changed)
+		ctx->mtime = time(NULL);
+
+	dprint(1, (debugfile, "nm: .... sync done [rc=%d]\n", rc));
+	return rc;
+}
+
+static unsigned count_query(notmuch_database_t *db, const char *qstr)
+{
+	unsigned res = 0;
+	notmuch_query_t *q = notmuch_query_create(db, qstr);
+
+	if (q) {
+		apply_exclude_tags(q);
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+		if (notmuch_query_count_messages_st (q, &res) != NOTMUCH_STATUS_SUCCESS)
+			res = 0;	/* may not be defined on error */
+#else
+		res = notmuch_query_count_messages(q);
+#endif
+		notmuch_query_destroy(q);
+		dprint(1, (debugfile, "nm: count '%s', result=%d\n", qstr, res));
+	}
+	return res;
+}
+
+int nm_nonctx_get_count(char *path, int *all, int *new)
+{
+	struct uri_tag *query_items = NULL, *item;
+	char *db_filename = NULL, *db_query = NULL;
+	notmuch_database_t *db = NULL;
+	int rc = -1, dflt = 0;
+
+	dprint(1, (debugfile, "nm: count\n"));
+
+	if (url_parse_query(path, &db_filename, &query_items)) {
+		mutt_error(_("failed to parse notmuch uri: %s"), path);
+		goto done;
+	}
+	if (!query_items)
+		goto done;
+
+	for (item = query_items; item; item = item->next) {
+		if (item->value && strcmp(item->name, "query") == 0) {
+			db_query = item->value;
+			break;
+		}
+	}
+
+	if (!db_query)
+		goto done;
+
+	if (!db_filename) {
+		if (NotmuchDefaultUri) {
+			if (strncmp(NotmuchDefaultUri, "notmuch://", 10) == 0)
+				db_filename = NotmuchDefaultUri + 10;
+			else
+				db_filename = NotmuchDefaultUri;
+		} else if (Maildir)
+			db_filename = Maildir;
+		dflt = 1;
+	}
+
+	/* don't be verbose about connection, as we're called from
+	 * sidebar/buffy very often */
+	db = do_database_open(db_filename, FALSE, FALSE);
+	if (!db)
+		goto done;
+
+	/* all emails */
+	if (all)
+		*all = count_query(db, db_query);
+
+	/* new messages */
+	if (new) {
+		char *qstr;
+
+		safe_asprintf(&qstr, "( %s ) tag:%s",
+				db_query, NotmuchUnreadTag);
+		*new = count_query(db, qstr);
+		FREE(&qstr);
+	}
+
+	rc = 0;
+done:
+	if (db) {
+#ifdef NOTMUCH_API_3
+		notmuch_database_destroy(db);
+#else
+		notmuch_database_close(db);
+#endif
+		dprint(1, (debugfile, "nm: count close DB\n"));
+	}
+	if (!dflt)
+		FREE(&db_filename);
+	url_free_tags(query_items);
+
+	dprint(1, (debugfile, "nm: count done [rc=%d]\n", rc));
+	return rc;
+}
+
+char *nm_get_description(CONTEXT *ctx)
+{
+	BUFFY *p;
+
+	for (p = VirtIncoming; p; p = p->next)
+		if (p->desc && strcmp(p->path, ctx->path) == 0)
+			return p->desc;
+
+	return NULL;
+}
+
+int nm_description_to_path(const char *desc, char *buf, size_t bufsz)
+{
+	BUFFY *p;
+
+	if (!desc || !buf || !bufsz)
+		return -EINVAL;
+
+	for (p = VirtIncoming; p; p = p->next)
+		if (p->desc && strcmp(desc, p->desc) == 0) {
+			strncpy(buf, p->path, bufsz);
+			buf[bufsz - 1] = '\0';
+			return 0;
+		}
+
+	return -1;
+}
+
+/*
+ * returns header from mutt context
+ */
+static HEADER *get_mutt_header(CONTEXT *ctx, notmuch_message_t *msg)
+{
+	char *mid;
+	const char *id;
+	HEADER *h;
+
+	if (!ctx || !msg)
+		return NULL;
+
+	id = notmuch_message_get_message_id(msg);
+	if (!id)
+		return NULL;
+
+	dprint(2, (debugfile, "nm: mutt header, id='%s'\n", id));
+
+	if (!ctx->id_hash) {
+		dprint(2, (debugfile, "nm: init hash\n"));
+		ctx->id_hash = mutt_make_id_hash(ctx);
+		if (!ctx->id_hash)
+			return NULL;
+	}
+
+	mid = nm2mutt_message_id( id );
+	dprint(2, (debugfile, "nm: mutt id='%s'\n", mid));
+
+	h = hash_find(ctx->id_hash, mid);
+	FREE(&mid);
+	return h;
+}
+
+static int nm_check_database(CONTEXT *ctx, int *index_hint)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	time_t mtime = 0;
+	notmuch_query_t *q;
+	notmuch_messages_t *msgs;
+	int i, limit, occult = 0, new_flags = 0;
+
+	if (!data || get_database_mtime(data, &mtime) != 0)
+		return -1;
+
+	if (ctx->mtime >= mtime) {
+		dprint(2, (debugfile, "nm: check unnecessary (db=%d ctx=%d)\n", mtime, ctx->mtime));
+		return 0;
+	}
+
+	dprint(1, (debugfile, "nm: checking (db=%d ctx=%d)\n", mtime, ctx->mtime));
+
+	q = get_query(data, FALSE);
+	if (!q)
+		goto done;
+
+	dprint(1, (debugfile, "nm: start checking (count=%d)\n", ctx->msgcount));
+	data->oldmsgcount = ctx->msgcount;
+	data->noprogress = 1;
+
+	for (i = 0; i < ctx->msgcount; i++)
+		ctx->hdrs[i]->active = 0;
+
+	limit = get_limit(data);
+
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+	if (notmuch_query_search_messages_st (q, &msgs) != NOTMUCH_STATUS_SUCCESS)
+		goto done;
+#else
+	msgs = notmuch_query_search_messages(q);
+#endif
+
+	for (i = 0;
+	     notmuch_messages_valid(msgs) && (limit == 0 || i < limit);
+	     notmuch_messages_move_to_next(msgs), i++) {
+
+		char old[_POSIX_PATH_MAX];
+		const char *new;
+
+		notmuch_message_t *m = notmuch_messages_get(msgs);
+		HEADER *h = get_mutt_header(ctx, m);
+
+		if (!h) {
+			/* new email */
+			append_message(ctx, NULL, m, 0);
+			notmuch_message_destroy(m);
+			continue;
+		}
+
+		/* message already exists, merge flags */
+		h->active = 1;
+
+		/* check to see if the message has moved to a different
+		 * subdirectory.  If so, update the associated filename.
+		 */
+		new = get_message_last_filename(m);
+		nm_header_get_fullpath(h, old, sizeof(old));
+
+		if (mutt_strcmp(old, new) != 0)
+			update_message_path(h, new);
+
+		if (!h->changed) {
+			/* if the user hasn't modified the flags on
+			 * this message, update the flags we just
+			 * detected.
+			 */
+			HEADER tmp;
+			memset(&tmp, 0, sizeof(tmp));
+			maildir_parse_flags(&tmp, new);
+			maildir_update_flags(ctx, h, &tmp);
+		}
+
+		if (update_header_tags(h, m) == 0)
+			new_flags++;
+
+		notmuch_message_destroy(m);
+	}
+
+	for (i = 0; i < ctx->msgcount; i++) {
+		if (ctx->hdrs[i]->active == 0) {
+			occult = 1;
+			break;
+		}
+	}
+
+	if (ctx->msgcount > data->oldmsgcount)
+		mx_update_context(ctx, ctx->msgcount - data->oldmsgcount);
+done:
+	if (q)
+		notmuch_query_destroy(q);
+
+	if (!is_longrun(data))
+		release_db(data);
+
+	ctx->mtime = time(NULL);
+
+	dprint(1, (debugfile, "nm: ... check done [count=%d, new_flags=%d, occult=%d]\n",
+				ctx->msgcount, new_flags, occult));
+
+	return occult ? MUTT_REOPENED :
+	       ctx->msgcount > data->oldmsgcount ? MUTT_NEW_MAIL :
+	       new_flags ? MUTT_FLAGS : 0;
+}
+
+int nm_record_message(CONTEXT *ctx, char *path, HEADER *h)
+{
+	notmuch_database_t *db;
+	notmuch_status_t st;
+	notmuch_message_t *msg = NULL;
+	int rc = -1, trans;
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (!path || !data || access(path, F_OK) != 0)
+		return 0;
+	db = get_db(data, TRUE);
+	if (!db)
+		return -1;
+
+	dprint(1, (debugfile, "nm: record message: %s\n", path));
+	trans = db_trans_begin(data);
+	if (trans < 0)
+		goto done;
+
+	st = notmuch_database_add_message(db, path, &msg);
+
+	if (st != NOTMUCH_STATUS_SUCCESS &&
+	    st != NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID) {
+		dprint(1, (debugfile, "nm: failed to add '%s' [st=%d]\n", path, (int) st));
+		goto done;
+	}
+
+	if (st == NOTMUCH_STATUS_SUCCESS && msg) {
+		notmuch_message_maildir_flags_to_tags(msg);
+		if (h)
+			update_tags(msg, nm_header_get_tags(h));
+		if (NotmuchRecordTags)
+			update_tags(msg, NotmuchRecordTags);
+	}
+
+	rc = 0;
+done:
+	if (msg)
+		notmuch_message_destroy(msg);
+	if (trans == 1)
+		db_trans_end(data);
+	if (!is_longrun(data))
+		release_db(data);
+	return rc;
+}
+
+/*
+ * Fill a list with all notmuch tags.
+ *
+ * If tag_list is NULL, just count the tags.
+ */
+int nm_get_all_tags(CONTEXT *ctx, char **tag_list, int *tag_count)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	notmuch_database_t *db = NULL;
+	notmuch_tags_t *tags = NULL;
+	int rc = -1;
+
+	if (!data)
+		return -1;
+
+	if (!(db = get_db(data, FALSE)) ||
+			!(tags = notmuch_database_get_all_tags(db)))
+		goto done;
+
+	*tag_count = 0;
+	dprint(1, (debugfile, "nm: get all tags\n"));
+
+	while (notmuch_tags_valid(tags)) {
+		if (tag_list != NULL) {
+			tag_list[*tag_count] = safe_strdup(notmuch_tags_get(tags));
+		}
+		(*tag_count)++;
+		notmuch_tags_move_to_next(tags);
+	}
+
+	rc = 0;
+done:
+	if (tags)
+		notmuch_tags_destroy(tags);
+
+	if (!is_longrun(data))
+		release_db(data);
+
+	dprint(1, (debugfile, "nm: get all tags done [rc=%d tag_count=%u]\n", rc,
+						 *tag_count));
+	return rc;
+}
+
+static int nm_open_message (CONTEXT *ctx, MESSAGE *msg, int msgno)
+{
+	if (!ctx || !msg)
+		return 1;
+	HEADER *cur = ctx->hdrs[msgno];
+	char *folder = ctx->path;
+	char path[_POSIX_PATH_MAX];
+	folder = nm_header_get_folder(cur);
+
+	snprintf (path, sizeof (path), "%s/%s", folder, cur->path);
+
+	msg->fp = fopen (path, "r");
+	if ((msg->fp == NULL) && (errno == ENOENT) && ((ctx->magic == MUTT_MAILDIR) || (ctx->magic == MUTT_NOTMUCH)))
+		msg->fp = maildir_open_find_message (folder, cur->path, NULL);
+
+	dprint(1, (debugfile, "%s\n", __func__));
+	return 0;
+}
+
+static int nm_close_message (CONTEXT *ctx, MESSAGE *msg)
+{
+	if (!msg)
+		return 1;
+	safe_fclose (&(msg->fp));
+	return 0;
+}
+
+static int nm_commit_message (CONTEXT *ctx, MESSAGE *msg)
+{
+	mutt_perror _("Can't write to virtual folder.");
+	return 1;
+}
+
+struct mx_ops mx_notmuch_ops = {
+	.open         = nm_read_query,	/* calls init_context() */
+        .open_append  = NULL,
+	.close        = deinit_context,
+	.check        = nm_check_database,
+	.open_msg     = nm_open_message,
+	.close_msg    = nm_close_message,
+	.commit_msg   = nm_commit_message,
+        .open_new_msg = NULL
+};
+
diff --git c/mutt_notmuch.h w/mutt_notmuch.h
new file mode 100644
index 0000000..8267b1f
--- /dev/null
+++ w/mutt_notmuch.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2011 Karel Zak <kzak@redhat.com>
+ */
+#ifndef _MUTT_NOTMUCH_H_
+#define _MUTT_NOTMUCH_H_ 1
+
+int nm_read_query(CONTEXT *ctx);
+int nm_read_entire_thread(CONTEXT *ctx, HEADER *h);
+
+int nm_sync(CONTEXT * ctx, int *index_hint);
+char *nm_header_get_folder(HEADER *h);
+int nm_header_get_magic(HEADER *h);
+char *nm_header_get_fullpath(HEADER *h, char *buf, size_t bufsz);
+int nm_update_filename(CONTEXT *ctx, const char *o, const char *n, HEADER *h);
+char *nm_uri_from_query(CONTEXT *ctx, char *buf, size_t bufsz);
+int nm_modify_message_tags(CONTEXT *ctx, HEADER *hdr, char *tags);
+
+void nm_longrun_init(CONTEXT *cxt, int writable);
+void nm_longrun_done(CONTEXT *cxt);
+
+char *nm_get_description(CONTEXT *ctx);
+int nm_description_to_path(const char *desc, char *buf, size_t bufsz);
+
+int nm_record_message(CONTEXT *ctx, char *path, HEADER *h);
+
+void nm_debug_check(CONTEXT *ctx);
+int nm_get_all_tags(CONTEXT *ctx, char **tag_list, int *tag_count);
+
+/*
+ * functions usable outside notmuch CONTEXT
+ */
+int nm_nonctx_get_count(char *path, int *all, int *new);
+
+char *nm_header_get_tag_transformed(char *tag, HEADER *h);
+char *nm_header_get_tags_transformed(HEADER *h);
+char *nm_header_get_tags(HEADER *h);
+
+extern struct mx_ops mx_notmuch_ops;
+
+#endif /* _MUTT_NOTMUCH_H_ */
diff --git c/mutt_sasl.c w/mutt_sasl.c
index d99ba72..39aa8bd 100644
--- c/mutt_sasl.c
+++ w/mutt_sasl.c
@@ -192,6 +192,11 @@ int mutt_sasl_client_new (CONNECTION* conn, sasl_conn_t** saslconn)
     case MUTT_ACCT_TYPE_SMTP:
       service = "smtp";
       break;
+#ifdef USE_NNTP
+    case MUTT_ACCT_TYPE_NNTP:
+      service = "nntp";
+      break;
+#endif
     default:
       mutt_error (_("Unknown SASL profile"));
       return -1;
diff --git c/mutt_socket.c w/mutt_socket.c
index a2c489f..79aa81e 100644
--- c/mutt_socket.c
+++ w/mutt_socket.c
@@ -398,12 +398,19 @@ int raw_socket_read (CONNECTION* conn, char* buf, size_t len)
 {
   int rc;
 
+  mutt_allow_interrupt (1);
   if ((rc = read (conn->fd, buf, len)) == -1)
   {
     mutt_error (_("Error talking to %s (%s)"), conn->account.host,
 		strerror (errno));
     mutt_sleep (2);
-  }
+  } else if (errno == EINTR) {
+    rc = -1;
+    mutt_error (_("Error talking to %s (%s)"), conn->account.host,
+               strerror (errno));
+    mutt_sleep (2);
+   }
+  mutt_allow_interrupt (0);
 
   return rc;
 }
@@ -412,12 +419,19 @@ int raw_socket_write (CONNECTION* conn, const char* buf, size_t count)
 {
   int rc;
 
+  mutt_allow_interrupt (1);
   if ((rc = write (conn->fd, buf, count)) == -1)
   {
     mutt_error (_("Error talking to %s (%s)"), conn->account.host,
 		strerror (errno));
     mutt_sleep (2);
+  } else if (errno == EINTR) {
+    rc = -1;
+    mutt_error (_("Error talking to %s (%s)"), conn->account.host,
+               strerror (errno));
+    mutt_sleep (2);
   }
+  mutt_allow_interrupt (0);
 
   return rc;
 }
diff --git c/mutt_ssl.c w/mutt_ssl.c
index bf67972..3a78b95 100644
--- c/mutt_ssl.c
+++ w/mutt_ssl.c
@@ -37,12 +37,6 @@
 #include "mutt_ssl.h"
 #include "mutt_idna.h"
 
-#if OPENSSL_VERSION_NUMBER >= 0x00904000L
-#define READ_X509_KEY(fp, key)	PEM_read_X509(fp, key, NULL, NULL)
-#else
-#define READ_X509_KEY(fp, key)	PEM_read_X509(fp, key, NULL)
-#endif
-
 /* Just in case OpenSSL doesn't define DEVRANDOM */
 #ifndef DEVRANDOM
 #define DEVRANDOM "/dev/urandom"
@@ -303,8 +297,12 @@ static int ssl_socket_read (CONNECTION* conn, char* buf, size_t len)
   int rc;
 
   rc = SSL_read (data->ssl, buf, len);
-  if (rc <= 0)
+  if (rc <= 0 || errno == EINTR)
   {
+    if (errno == EINTR)
+    {
+      rc = -1;
+    }
     data->isopen = 0;
     ssl_err (data, rc);
   }
@@ -318,8 +316,13 @@ static int ssl_socket_write (CONNECTION* conn, const char* buf, size_t len)
   int rc;
 
   rc = SSL_write (data->ssl, buf, len);
-  if (rc <= 0)
+  if (rc <= 0 || errno == EINTR) {
+    if (errno == EINTR)
+    {
+      rc = -1;
+    }
     ssl_err (data, rc);
+  }
 
   return rc;
 }
@@ -406,10 +409,18 @@ static int ssl_negotiate (CONNECTION *conn, sslsockdata* ssldata)
   int err;
   const char* errmsg;
 
-#if OPENSSL_VERSION_NUMBER >= 0x00906000L
-  /* This only exists in 0.9.6 and above. Without it we may get interrupted
-   *   reads or writes. Bummer. */
   SSL_set_mode (ssldata->ssl, SSL_MODE_AUTO_RETRY);
+
+#if (OPENSSL_VERSION_NUMBER >= 0x0090806fL) && !defined(OPENSSL_NO_TLSEXT)
+  /* TLS Virtual-hosting requires that the server present the correct
+   * certificate; to do this, the ServerNameIndication TLS extension is used.
+   * If TLS is negotiated, and OpenSSL is recent enough that it might have
+   * support, and support was enabled when OpenSSL was built, mutt supports
+   * sending the hostname we think we're connecting to, so a server can send
+   * back the correct certificate.
+   * This has been tested over SMTP against Exim 4.80.
+   * Not yet found an IMAP server which supports this. */
+  SSL_set_tlsext_host_name (ssldata->ssl, conn->account.host);
 #endif
 
   if ((err = SSL_connect (ssldata->ssl)) != 1)
@@ -443,14 +454,6 @@ static int ssl_negotiate (CONNECTION *conn, sslsockdata* ssldata)
   if (!ssl_check_certificate (conn, ssldata))
     return -1;
 
-  /* L10N:
-     %1$s is version (e.g. "TLSv1.2")
-     %2$s is cipher_version (e.g. "TLSv1/SSLv3")
-     %3$s is cipher_name (e.g. "ECDHE-RSA-AES128-GCM-SHA256") */
-  mutt_message (_("%s connection using %s (%s)"),
-    SSL_get_version(ssldata->ssl), SSL_get_cipher_version (ssldata->ssl), SSL_get_cipher_name (ssldata->ssl));
-  mutt_sleep (0);
-
   return 0;
 }
 
@@ -631,7 +634,7 @@ static char *asn1time_to_string (ASN1_UTCTIME *tm)
 
 static int check_certificate_by_signer (X509 *peercert)
 {
-  X509_STORE_CTX xsc;
+  X509_STORE_CTX *xsc;
   X509_STORE *ctx;
   int pass = 0, i;
 
@@ -661,23 +664,25 @@ static int check_certificate_by_signer (X509 *peercert)
     return 0;
   }
 
-  X509_STORE_CTX_init (&xsc, ctx, peercert, SslSessionCerts);
+  xsc = X509_STORE_CTX_new();
+  if (xsc == NULL) return 0;
+  X509_STORE_CTX_init (xsc, ctx, peercert, SslSessionCerts);
 
-  pass = (X509_verify_cert (&xsc) > 0);
+  pass = (X509_verify_cert (xsc) > 0);
 #ifdef DEBUG
   if (! pass)
   {
     char buf[SHORT_STRING];
     int err;
 
-    err = X509_STORE_CTX_get_error (&xsc);
+    err = X509_STORE_CTX_get_error (xsc);
     snprintf (buf, sizeof (buf), "%s (%d)",
 	X509_verify_cert_error_string(err), err);
     dprint (2, (debugfile, "X509_verify_cert: %s\n", buf));
     dprint (2, (debugfile, " [%s]\n", peercert->name));
   }
 #endif
-  X509_STORE_CTX_cleanup (&xsc);
+  X509_STORE_CTX_free (xsc);
   X509_STORE_free (ctx);
 
   return pass;
@@ -766,7 +771,7 @@ static int check_certificate_by_digest (X509 *peercert)
     return 0;
   }
 
-  while ((cert = READ_X509_KEY (fp, &cert)) != NULL)
+  while ((cert = PEM_read_X509 (fp, &cert, NULL, NULL)) != NULL)
   {
     pass = compare_certificates (cert, peercert, peermd, peermdlen) ? 0 : 1;
 
@@ -1123,6 +1128,7 @@ static int interactive_check_cert (X509 *cert, int idx, int len)
   }
   unset_option(OPTIGNOREMACROEVENTS);
   mutt_menuDestroy (&menu);
+  set_option (OPTNEEDREDRAW);
   dprint (2, (debugfile, "ssl interactive_check_cert: done=%d\n", done));
   return (done == 2);
 }
diff --git c/mutt_ssl_gnutls.c w/mutt_ssl_gnutls.c
index 2084ad0..4e6a4fd 100644
--- c/mutt_ssl_gnutls.c
+++ w/mutt_ssl_gnutls.c
@@ -141,14 +141,16 @@ static int tls_socket_read (CONNECTION* conn, char* buf, size_t len)
 
   do {
     ret = gnutls_record_recv (data->state, buf, len);
-    if (ret < 0 && gnutls_error_is_fatal(ret) == 1)
+    if ((ret < 0 &&
+         gnutls_error_is_fatal(ret) == 1) ||
+        ret == GNUTLS_E_INTERRUPTED
+       )
     {
       mutt_error ("tls_socket_read (%s)", gnutls_strerror (ret));
-      mutt_sleep (4);
+      mutt_sleep (2);
       return -1;
     }
-  }
-  while (ret == GNUTLS_E_AGAIN || ret == GNUTLS_E_INTERRUPTED);
+  } while (ret == GNUTLS_E_AGAIN);
 
   return ret;
 }
@@ -171,7 +173,7 @@ static int tls_socket_write (CONNECTION* conn, const char* buf, size_t len)
     ret = gnutls_record_send (data->state, buf + sent, len - sent);
     if (ret < 0)
     {
-      if (gnutls_error_is_fatal(ret) == 1)
+      if (gnutls_error_is_fatal(ret) == 1 || ret == GNUTLS_E_INTERRUPTED)
       {
 	mutt_error ("tls_socket_write (%s)", gnutls_strerror (ret));
 	mutt_sleep (4);
@@ -434,7 +436,7 @@ static int tls_negotiate (CONNECTION * conn)
 
   err = gnutls_handshake(data->state);
 
-  while (err == GNUTLS_E_AGAIN || err == GNUTLS_E_INTERRUPTED)
+  while (err == GNUTLS_E_AGAIN)
   {
     err = gnutls_handshake(data->state);
   }
diff --git c/muttbug w/muttbug
deleted file mode 100755
index e94d8cd..0000000
--- c/muttbug
+++ /dev/null
@@ -1,3 +0,0 @@
-#!/bin/sh
-
-exec flea "$@"
diff --git c/muttbug.sh.in w/muttbug.sh.in
deleted file mode 100644
index b429fae..0000000
--- c/muttbug.sh.in
+++ /dev/null
@@ -1,332 +0,0 @@
-#!/bin/sh
-
-#
-#     File a bug against the Mutt mail user agent.
-#
-
-# 
-#     $Id$
-#
-
-#
-#     Copyright (c) 2000 Thomas Roessler <roessler@does-not-exist.org>
-#
-#
-#     This program is free software; you can redistribute it and/or modify
-#     it under the terms of the GNU General Public License as published by
-#     the Free Software Foundation; either version 2 of the License, or
-#     (at your option) any later version.
-# 
-#     This program is distributed in the hope that it will be useful,
-#     but WITHOUT ANY WARRANTY; without even the implied warranty of
-#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#     GNU General Public License for more details.
-# 
-#     You should have received a copy of the GNU General Public License
-#     along with this program; if not, write to the Free Software
-#     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
-#
-
-SUBMIT="fleas@mutt.org"
-DEBIAN_SUBMIT="submit@bugs.debian.org"
-
-prefix=@prefix@
-
-DEBUGGER=@DEBUGGER@
-SENDMAIL=@SENDMAIL@
-sysconfdir=@sysconfdir@
-pkgdatadir=@pkgdatadir@
-
-include_file ()
-{
-	echo
-	echo "--- Begin $1"
-	sed -e '/^[	 ]*#/d; /^[	 ]*$/d; s/^-/- -/' $1
-	echo "--- End $1"
-	echo
-}
-
-debug_gdb ()
-{
-	cat << EOF > $SCRATCH/gdb.rc
-bt
-list
-quit
-EOF
-	$DEBUGGER -n -x $SCRATCH/gdb.rc -c $CORE mutt
-}
-
-debug_dbx ()
-{
-	cat << EOF > $SCRATCH/dbx.rc
-where
-list
-quit
-EOF
-	$DEBUGGER -s $SCRATCH/dbx.rc mutt $CORE
-}
-
-debug_sdb ()
-{
-	cat << EOF > $SCRATCH/sdb.rc
-t
-w
-q
-EOF
-	$DEBUGGER mutt $CORE < $SCRATCH/sdb.rc
-}
-
-case `echo -n` in
-"") n=-n; c=   ;;
- *) n=; c='\c' ;;
-esac
- 
-
-exec > /dev/tty
-exec < /dev/tty
-
-SCRATCH=${TMPDIR-/tmp}/`basename $0`.`hostname`.$$
-
-mkdir ${SCRATCH} || \
-{ 
-	echo "`basename $0`: Can't create temporary directory." >& 2 ; 
-	exit 1 ; 
-}
-
-trap "rm -r -f ${SCRATCH} ; trap '' 0 ; exit" 0 1 2
-
-TEMPLATE=${SCRATCH}/template.txt
-
-if test -z "$EMAIL" ; then
-	EMAIL="`mutt -Q from 2> /dev/null | sed -e 's/^from=.\(.*\).$/\1/'`"
-fi
-
-EMAILTMP=''
-while test -z "$EMAILTMP"
-do
-  echo "Please enter your e-mail address [$EMAIL]:"
-  echo $n "> $c"
-  read EMAILTMP
-
-  if test -z "$EMAILTMP"; then EMAILTMP="$EMAIL"; fi
-
-  if ! echo "$EMAILTMP" | grep -q @
-  then
-    echo "$EMAILTMP does not appear to be a valid email address"
-    EMAILTMP=''
-    continue
-  fi
-
-  EMAIL="$EMAILTMP"
-done
-
-echo "Please enter a one-line description of the problem you experience:"
-echo $n "> $c"
-read SUBJECT
-
-cat <<EOF  
-What should the severity for this bug report be?
-
-       0) Feature request, or maybe a bug which is very difficult to
-       fix due to major design considerations.
-
-       1) The package fails to perform correctly in some conditions,
-       or on some systems, or fails to comply with current policy
-       documents. Most bugs are in this category.
-
-       2) This bug makes this version of the package unsuitable for
-       a stable release.
-
-       3) Dangerous bug. Makes the package in question unusable by
-       anyone or mostly so, or causes data loss, or introduces a
-       security hole allowing access to the accounts of users who
-       use the package.
-
-       4) Critical bug. Makes unrelated software on the system (or
-       the whole system) break, or causes serious data loss, or
-       introduces a security hole on systems where you install the
-       package.
-
-EOF
-echo $n "Severity? [01234] $c"
-read severity
-case "$severity" in
-0|[Ww]) severity=wishlist  ;;
-2|[Ii]) severity=important ;;
-3|[Gg]) severity=grave     ;;
-4|[Cc]) severity=critical  ;;
-     *) severity=normal    ;;
-esac
-
-if test -x $DEBUGGER ; then
-	test -f core && CORE=core
-	echo "If mutt has crashed, it may have saved some program state in"
-	echo "a file named core.  We can include this information with the bug"
-	echo "report if you wish so."
-	echo "Do you want to include information gathered from a core file?"
-	echo "If yes, please enter the path - otherwise just say no: [$CORE]"
-	echo $n "> $c"
-	read _CORE
-	test "$_CORE" && CORE="$_CORE"
-fi
-
-echo $n "Do you want to include your personal mutt configuration files? [Y|n] $c"
-read personal
-case "$personal" in
-[nN]*)  personal=no  ;;
-    *)  personal=yes ;;
-esac
-
-echo $n "Do you want to include your system's global mutt configuration file? [Y|n] $c"
-read global
-case "$global" in
-[nN]*)  global=no  ;;
-    *)	global=yes ;;
-esac
-
-if test -f /etc/debian_version ; then
-	DEBIAN=yes
-	echo $n "Checking whether mutt has been installed as a package... $c"
-	DEBIANVERSION="`dpkg -l mutt | grep '^[ih]' | awk '{print $3}'`" 2> /dev/null
-	if test "$DEBIANVERSION" ; then
-		DPKG=yes
-	else
-		DPKG=no
-		unset DEBIANVERSION
-	fi
-	echo "$DPKG"
-	echo $n "File this bug with Debian? [Y|n] $c"
-	read DPKG
-	case "$DPKG" in
-	[nN])	DPKG=no ;;
-	*)	DPKG=yes ;;
-	esac
-else
-	DEBIAN=no
-	DPKG=no
-fi
-
-if rpm -q mutt > /dev/null 2> /dev/null ; then
-	echo "Mutt seems to come from an RPM package."
-	RPMVERSION="`rpm -q mutt`"
-	RPMPACKAGER="`rpm -q -i mutt | sed -n -e 's/^Packager *: *//p'`"
-fi
-
-MUTTVERSION="`mutt -v | awk '{print $2; exit; }'`"
-test "$DPKG" = "yes" && SUBMIT="$SUBMIT, $DEBIAN_SUBMIT"
-
-exec > ${TEMPLATE}
-
-test "$EMAIL"        && echo "From: $EMAIL"
-test "$REPLYTO"      && echo "Reply-To: $REPLYTO"
-test "$ORGANIZATION" && echo "Organization: $ORGANIZATION"
-
-echo "Subject: mutt-$MUTTVERSION: $SUBJECT"
-echo "To: $SUBMIT"
-test "$EMAIL" 	     && echo "Bcc: ${EMAIL}"
-echo
-echo "Package: mutt"
-echo "Version: ${DEBIANVERSION-${RPMVERSION-$MUTTVERSION}}"
-echo "Severity: $severity"
-echo 
-echo "-- Please type your report below this line"
-echo
-echo
-echo
-
-if test "$DEBIAN" = "yes" ; then
-	echo "Obtaining Debian-specific information..." > /dev/tty
-	bug -p -s dummy mutt < /dev/null 2> /dev/null |        \
-		sed -n -e "/^-- System Information/,/^---/p" | \
-		grep -v '^---'
-else
-	echo "-- System Information"
-	echo "System Version: `uname -a`"
-	test -z "$RPMPACKAGER" || echo "RPM Packager: $RPMPACKAGER";
-	test -f /etc/redhat-release && echo "RedHat Release: `cat /etc/redhat-release`"
-	test -f /etc/SuSE-release && echo "SuSE Release: `sed 1q /etc/SuSE-release`"
-	# Please provide more of these if you have any.
-fi
-
-echo
-echo "-- Mutt Version Information"
-echo
-LC_ALL=C mutt -v
-
-if test "$CORE" && test -f "$CORE" ; then
-	echo 
-	echo "-- Core Dump Analysis Output"
-	echo
-
-	case "$DEBUGGER" in
-		*sdb) debug_sdb $CORE ;;
-		*dbx) debug_dbx $CORE ;;
-		*gdb) debug_gdb $CORE ;;
-	esac
-	
-	echo
-fi
-
-if test "$personal" = "yes" ; then
-	CANDIDATES=".muttrc-${MUTTVERSION} .muttrc .mutt/muttrc-${MUTTVERSION} .mutt/muttrc"
-	MATCHED="none"
-	for f in $CANDIDATES; do
-		if test -f "${HOME}/$f" ; then
-			MATCHED="${HOME}/$f"
-			break
-	        fi
-	done
-	
-	if test "$MATCHED" = "none" ; then
-		echo "Warning: Can't find your personal .muttrc." >&2
-	else
-		include_file $MATCHED
-	fi
-fi
-
-
-if test "$global" = "yes" ; then
-	CANDIDATES="Muttrc-${MUTTVERSION} Muttrc"
-	DIRECTORIES="$sysconfdir $pkgdatadir"
-	MATCHED="none"
-	for d in $DIRECTORIES ; do
-		for f in $CANDIDATES; do
-			if test -f $d/$f ; then
-				MATCHED="$d/$f"
-				break
-			fi
-		done
-		test "$MATCHED" = "none" || break
-	done
-	
-	if test "$MATCHED" = "none" ; then
-		echo "Warning: Can't find global Muttrc." >&2
-	else
-		include_file $MATCHED
-	fi
-fi
-
-exec > /dev/tty
-
-cp $TEMPLATE $SCRATCH/mutt-bug.txt
-
-input="e"
-while : ; do
-	if test "$input" = "e" ; then
-		${VISUAL-${EDITOR-vi}} $SCRATCH/mutt-bug.txt
-		if cmp $SCRATCH/mutt-bug.txt ${TEMPLATE} > /dev/null ; then
-			echo "Warning: Bug report was not modified!"
-		fi
-	fi
-	
-	echo $n "Submit, Edit, View, Quit? [S|e|v|q] $c"
-	read _input
-	input="`echo $_input | tr EVSQ evsq`"
-	case $input in
-	e*)	;;
-	v*)	${PAGER-more} $SCRATCH/mutt-bug.txt ;;
-	s*|"")	$SENDMAIL -t < $SCRATCH/mutt-bug.txt ; exit ;;
-	q*)	exit
-	esac
-done
-
diff --git c/muttlib.c w/muttlib.c
index 209c7ab..b5bf1c1 100644
--- c/muttlib.c
+++ w/muttlib.c
@@ -32,11 +32,18 @@
 #include "imap.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include "mutt_crypt.h"
 
 #include <string.h>
 #include <ctype.h>
 #include <unistd.h>
+#ifdef HAVE_SYS_SYSCALL_H
+#include <sys/syscall.h>
+#endif
 #include <stdlib.h>
 #include <sys/wait.h>
 #include <errno.h>
@@ -46,6 +53,18 @@
 #include <sys/types.h>
 #include <utime.h>
 
+static const char *xdg_env_vars[] =
+{
+  [kXDGConfigHome] = "XDG_CONFIG_HOME",
+  [kXDGConfigDirs] = "XDG_CONFIG_DIRS",
+};
+
+static const char *xdg_defaults[] =
+{
+  [kXDGConfigHome] = "~/.config",
+  [kXDGConfigDirs] = "/etc/xdg",
+};
+
 BODY *mutt_new_body (void)
 {
   BODY *p = (BODY *) safe_calloc (1, sizeof (BODY));
@@ -311,6 +330,26 @@ void mutt_free_list (LIST **list)
   }
 }
 
+LIST *mutt_copy_list (LIST *p)
+{
+  LIST *t, *r=NULL, *l=NULL;
+
+  for (; p; p = p->next)
+  {
+    t = (LIST *) safe_malloc (sizeof (LIST));
+    t->data = safe_strdup (p->data);
+    t->next = NULL;
+    if (l)
+    { 
+      r->next = t;
+      r = r->next;
+    }
+    else
+      l = r = t;
+  }
+  return (l);
+}
+
 HEADER *mutt_dup_header(HEADER *h)
 {
   HEADER *hnew;
@@ -331,7 +370,9 @@ void mutt_free_header (HEADER **h)
 #ifdef MIXMASTER
   mutt_free_list (&(*h)->chain);
 #endif
-#if defined USE_POP || defined USE_IMAP
+#if defined USE_POP || defined USE_IMAP || defined USE_NNTP || defined USE_NOTMUCH
+  if ((*h)->free_cb)
+    (*h)->free_cb(*h);
   FREE (&(*h)->data);
 #endif
   FREE (h);		/* __FREE_CHECKED__ */
@@ -442,6 +483,11 @@ char *_mutt_expand_path (char *s, size_t slen, int rx)
 	  strfcpy (p, NONULL (Maildir), sizeof (p));
 	else
 #endif
+#ifdef USE_NOTMUCH
+	if (mx_is_notmuch (NONULL (Maildir)))
+	  strfcpy (p, NONULL (Maildir), sizeof (p));
+	else
+#endif
 	if (Maildir && *Maildir && Maildir[strlen (Maildir) - 1] == '/')
 	  strfcpy (p, NONULL (Maildir), sizeof (p));
 	else
@@ -716,12 +762,21 @@ void mutt_free_envelope (ENVELOPE **p)
   FREE (&(*p)->supersedes);
   FREE (&(*p)->date);
   FREE (&(*p)->x_label);
+  FREE (&(*p)->organization);
+#ifdef USE_NNTP
+  FREE (&(*p)->newsgroups);
+  FREE (&(*p)->xref);
+  FREE (&(*p)->followup_to);
+  FREE (&(*p)->x_comment_to);
+#endif
 
   mutt_buffer_free (&(*p)->spam);
 
   mutt_free_list (&(*p)->references);
   mutt_free_list (&(*p)->in_reply_to);
   mutt_free_list (&(*p)->userhdrs);
+  mutt_label_ref_dec ((*p));
+  mutt_free_list (&(*p)->labels);
   FREE (p);		/* __FREE_CHECKED__ */
 }
 
@@ -744,7 +799,8 @@ void mutt_merge_envelopes(ENVELOPE* base, ENVELOPE** extra)
   MOVE_ELEM(message_id);
   MOVE_ELEM(supersedes);
   MOVE_ELEM(date);
-  MOVE_ELEM(x_label);
+  MOVE_ELEM(labels);
+  MOVE_ELEM(x_original_to);
   if (!base->refs_changed)
   {
     MOVE_ELEM(references);
@@ -773,12 +829,73 @@ void mutt_merge_envelopes(ENVELOPE* base, ENVELOPE** extra)
   mutt_free_envelope(extra);
 }
 
+static FILE *frandom;
+
+void mutt_randbuf(void *out, size_t len)
+{
+  if (len > 1048576) {
+    mutt_error (_("mutt_randbuf len=%zu"), len);
+    exit(1);
+  }
+  /* XXX switch to HAVE_GETRANDOM and getrandom() in about 2017 */
+#if defined(SYS_getrandom) && defined(__linux__)
+  long ret;
+  do {
+    ret = syscall(SYS_getrandom, out, len, 0, 0, 0, 0);
+  } while ((ret == -1) && (errno == EINTR));
+  if (ret == len) return;
+  /* let's try urandom in case we're on an old kernel, or the user has
+   * configured selinux, seccomp or something to not allow getrandom */
+#endif
+  if (frandom == NULL) {
+    frandom = fopen("/dev/urandom", "rb");
+    if (frandom == NULL) {
+      mutt_error (_("open /dev/urandom: %s"), strerror(errno));
+      exit(1);
+    }
+    setbuf(frandom, NULL);
+  }
+  if (fread(out, 1, len, frandom) != len) {
+    mutt_error (_("read /dev/urandom: %s"), strerror(errno));
+    exit(1);
+  }
+}
+
+static const unsigned char base32[] = "abcdefghijklmnopqrstuvwxyz234567";
+
+void mutt_rand_base32(void *out, size_t len)
+{
+  size_t pos;
+  uint8_t *p = out;
+
+  mutt_randbuf(p, len);
+  for (pos = 0; pos < len; pos++)
+    p[pos] = base32[p[pos] % 32];
+}
+
+uint32_t mutt_rand32(void)
+{
+  uint32_t ret;
+
+  mutt_randbuf(&ret, sizeof(ret));
+  return ret;
+}
+
+uint64_t mutt_rand64(void)
+{
+  uint64_t ret;
+
+  mutt_randbuf(&ret, sizeof(ret));
+  return ret;
+}
+
+
 void _mutt_mktemp (char *s, size_t slen, const char *prefix, const char *suffix,
                    const char *src, int line)
 {
-  size_t n = snprintf (s, slen, "%s/%s-%s-%d-%d-%ld%ld%s%s",
+  size_t n = snprintf (s, slen, "%s/%s-%s-%d-%d-%" PRIu64 "%s%s",
       NONULL (Tempdir), NONULL (prefix), NONULL (Hostname),
-      (int) getuid (), (int) getpid (), random (), random (),
+      (int) getuid (), (int) getpid (), mutt_rand64(),
       suffix ? "." : "", NONULL (suffix));
   if (n >= slen)
     dprint (1, (debugfile, "%s:%d: ERROR: insufficient buffer space to hold temporary filename! slen=%zu but need %zu\n",
@@ -821,6 +938,11 @@ void mutt_pretty_mailbox (char *s, size_t buflen)
   }
 #endif
 
+#ifdef USE_NOTMUCH
+  if (scheme == U_NOTMUCH)
+    return;
+#endif
+
   /* if s is an url, only collapse path component */
   if (scheme != U_UNKNOWN)
   {
@@ -1216,8 +1338,34 @@ void mutt_FormatString (char *dest,		/* output buffer */
 
       if (*src == '?')
       {
+	/* change original %? to new %< notation */
+	/* %?x?y&z? to %<x?y&z> where y and z are nestable */
+	char *p = (char *) src;
+	*p = '<';
+	for ( ; *p && *p != '?'; p++);
+	  /* nothing */
+	if (*p == '?') {
+	  p++;
+	}
+	for ( ; *p && *p != '?'; p++);
+	  /* nothing */
+	if (*p == '?') {
+	  *p = '>';
+	}
+      }
+
+      if (*src == '<')
+      {
 	flags |= MUTT_FORMAT_OPTIONAL;
+	ch = *(++src); /* save the character to switch on */
 	src++;
+	cp = prefix;
+	count = 0;
+	while ((count < sizeof (prefix)) && (*src != '?')) {
+	  *cp++ = *src++;
+	  count++;
+	}
+	*cp = 0;
       }
       else
       {
@@ -1233,15 +1381,17 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	  count++;
 	}
 	*cp = 0;
-      }
 
-      if (!*src)
-	break; /* bad format */
+	if (!*src)
+	  break; /* bad format */
 
-      ch = *src++; /* save the character to switch on */
+	ch = *src++; /* save the character to switch on */
+      }
 
       if (flags & MUTT_FORMAT_OPTIONAL)
       {
+	int lrbalance;
+
         if (*src != '?')
           break; /* bad format */
         src++;
@@ -1249,8 +1399,20 @@ void mutt_FormatString (char *dest,		/* output buffer */
         /* eat the `if' part of the string */
         cp = ifstring;
 	count = 0;
-        while (count < sizeof (ifstring) && *src && *src != '?' && *src != '&')
-	{
+	lrbalance = 1;
+        while ((lrbalance > 0) && (count < sizeof (ifstring)) && *src) {
+	  if (*src == '\\') {
+	    src++;
+	    *cp++ = *src++;
+	  } else if ((src[0] == '%') && (src[1] == '<')) {
+	    lrbalance++;
+	  } else if (src[0] == '>') {
+	    lrbalance--;
+	  }
+	  if (lrbalance == 0)
+	    break;
+	  if ((lrbalance == 1) && (src[0] == '&'))
+	    break;
           *cp++ = *src++;
 	  count++;
 	}
@@ -1261,9 +1423,20 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	  src++; /* skip the & */
 	cp = elsestring;
 	count = 0;
-	while (count < sizeof (elsestring) && *src && *src != '?')
-	{
-	  *cp++ = *src++;
+	while ((lrbalance > 0) && (count < sizeof (elsestring)) && *src) {
+	  if (*src == '\\') {
+	    src++;
+	    *cp++ = *src++;
+	  } else if ((src[0] == '%') && (src[1] == '<')) {
+	    lrbalance++;
+	  } else if (src[0] == '>') {
+	    lrbalance--;
+	  }
+	  if (lrbalance == 0)
+	    break;
+	  if ((lrbalance == 1) && (src[0] == '&'))
+	    break;
+          *cp++ = *src++;
 	  count++;
 	}
 	*cp = 0;
@@ -1271,7 +1444,7 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	if (!*src)
 	  break; /* bad format */
 
-        src++; /* move past the trailing `?' */
+        src++; /* move past the trailing `>' (formerly '?') */
       }
 
       /* handle generic cases first */
@@ -1545,6 +1718,14 @@ int mutt_save_confirm (const char *s, struct stat *st)
     }
   }
 
+#ifdef USE_NNTP
+  if (magic == MUTT_NNTP)
+  {
+    mutt_error _("Can't save message to news server.");
+    return 0;
+  }
+#endif
+
   if (stat (s, st) != -1)
   {
     if (magic == -1)
@@ -1827,8 +2008,8 @@ void mutt_set_mtime (const char* from, const char* to)
 const char *mutt_make_version (void)
 {
   static char vstring[STRING];
-  snprintf (vstring, sizeof (vstring), "Mutt %s (%s)",
-	    MUTT_VERSION, ReleaseDate);
+  snprintf (vstring, sizeof (vstring), "NeoMutt %s (%s)",
+	    PACKAGE_VERSION, OldMuttVer);
   return vstring;
 }
 
@@ -1979,3 +2160,56 @@ void mutt_encode_path (char *dest, size_t dlen, const char *src)
   strfcpy (dest, (rc == 0) ? NONULL(p) : NONULL(src), dlen);
   FREE (&p);
 }
+
+/*
+ * Process an XDG environment variable or its fallback.
+ *
+ * Return 1 if an entry was found that actually exists on disk and 0 otherwise.
+ */
+int mutt_set_xdg_path(const XDGType type, char *buf, size_t bufsize)
+{
+  char *xdg_env = getenv (xdg_env_vars[type]);
+  char *xdg     = (xdg_env && *xdg_env) ? safe_strdup (xdg_env) : safe_strdup (xdg_defaults[type]);
+  char *x       = xdg;  /* strsep() changes xdg, so free x instead later */
+  char *token   = NULL;
+
+  while ((token = strsep (&xdg, ":")))
+  {
+    if (snprintf (buf, bufsize, "%s/neomutt/config", token) < 0)
+      continue;
+    mutt_expand_path (buf, bufsize);
+    if (access (buf, F_OK) == 0)
+    {
+      FREE (&x);
+      return 1;
+    }
+  }
+
+  FREE (&x);
+  return 0;
+}
+
+void mutt_get_parent_path (char *output, char *path, size_t olen)
+{
+#ifdef USE_IMAP
+  if (mx_is_imap (path))
+    imap_get_parent_path (output, path, olen);
+  else
+#endif
+  {
+    strfcpy (output, path, olen);
+    int n = mutt_strlen (output);
+
+    /* Remove everything until the next slash */
+    for (n--; ((n >= 0) && (output[n] != '/')); n--);
+
+    if (n > 0)
+      output[n] = '\0';
+    else
+    {
+      output[0] = '/';
+      output[1] = '\0';
+    }
+  }
+}
+
diff --git c/mx.c w/mx.c
index fbe82e4..78f29c6 100644
--- c/mx.c
+++ w/mx.c
@@ -33,6 +33,10 @@
 #include "sidebar.h"
 #endif
 
+#ifdef USE_COMPRESSED
+#include "compress.h"
+#endif
+
 #ifdef USE_IMAP
 #include "imap.h"
 #endif
@@ -41,6 +45,14 @@
 #include "pop.h"
 #endif
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
+
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include "buffy.h"
 
 #ifdef USE_DOTLOCK
@@ -60,7 +72,7 @@
 #include <ctype.h>
 #include <utime.h>
 
-static struct mx_ops* mx_get_ops (int magic)
+struct mx_ops* mx_get_ops (int magic)
 {
   switch (magic)
   {
@@ -80,6 +92,18 @@ static struct mx_ops* mx_get_ops (int magic)
     case MUTT_POP:
       return &mx_pop_ops;
 #endif
+#ifdef USE_COMPRESSED
+    case MUTT_COMPRESSED:
+      return &mx_comp_ops;
+#endif
+#ifdef USE_NNTP
+    case MUTT_NNTP:
+      return &mx_nntp_ops;
+#endif
+#ifdef USE_NOTMUCH
+    case MUTT_NOTMUCH:
+      return &mx_notmuch_ops;
+#endif
     default:
       return NULL;
   }
@@ -328,7 +352,7 @@ static void mx_unlink_empty (const char *path)
 /* try to figure out what type of mailbox ``path'' is
  *
  * return values:
- *	M_*	mailbox type
+ *	MUTT_*	mailbox type
  *	0	not a mailbox
  *	-1	error
  */
@@ -370,6 +394,40 @@ int mx_is_pop (const char *p)
 }
 #endif
 
+#ifdef USE_NNTP
+int mx_is_nntp (const char *p)
+{
+  url_scheme_t scheme;
+
+  if (!p)
+    return 0;
+
+  scheme = url_check_scheme (p);
+  if (scheme == U_NNTP || scheme == U_NNTPS)
+    return 1;
+
+  return 0;
+}
+#endif
+
+#ifdef USE_NOTMUCH
+
+int mx_is_notmuch(const char *p)
+{
+  url_scheme_t scheme;
+
+  if (!p)
+    return 0;
+
+  scheme = url_check_scheme (p);
+  if (scheme == U_NOTMUCH)
+    return 1;
+
+  return 0;
+}
+
+#endif
+
 int mx_get_magic (const char *path)
 {
   struct stat st;
@@ -387,6 +445,16 @@ int mx_get_magic (const char *path)
     return MUTT_POP;
 #endif /* USE_POP */
 
+#ifdef USE_NNTP
+  if (mx_is_nntp (path))
+    return MUTT_NNTP;
+#endif /* USE_NNTP */
+
+#ifdef USE_NOTMUCH
+  if (mx_is_notmuch(path))
+    return MUTT_NOTMUCH;
+#endif
+
   if (stat (path, &st) == -1)
   {
     dprint (1, (debugfile, "mx_get_magic(): unable to stat %s: %s (errno %d).\n",
@@ -441,6 +509,12 @@ int mx_get_magic (const char *path)
     return (-1);
   }
 
+#ifdef USE_COMPRESSED
+  /* If there are no other matches, see if there are any
+   * compress hooks that match */
+  if ((magic == 0) && comp_can_read (path))
+    return MUTT_COMPRESSED;
+#endif
   return (magic);
 }
 
@@ -507,6 +581,11 @@ static int mx_open_mailbox_append (CONTEXT *ctx, int flags)
       return -1;
   }
 
+#ifdef USE_COMPRESSED
+  if (comp_can_append (ctx))
+    ctx->mx_ops = &mx_comp_ops;
+  else
+#endif
   ctx->mx_ops = mx_get_ops (ctx->magic);
   if (!ctx->mx_ops || !ctx->mx_ops->open_append)
     return -1;
@@ -700,6 +779,19 @@ static int sync_mailbox (CONTEXT *ctx, int *index_hint)
       rc = pop_sync_mailbox (ctx, index_hint);
       break;
 #endif /* USE_POP */
+
+#ifdef USE_NNTP
+    case MUTT_NNTP:
+      rc = nntp_sync_mailbox (ctx);
+      break;
+#endif /* USE_NNTP */
+
+#ifdef USE_NOTMUCH
+    case MUTT_NOTMUCH:
+      rc = nm_sync (ctx, index_hint);
+      break;
+#endif /* USE_NOTMUCH */
+
   }
 
 #if 0
@@ -709,6 +801,14 @@ static int sync_mailbox (CONTEXT *ctx, int *index_hint)
   
   if (tmp && tmp->new == 0)
     mutt_update_mailbox (tmp);
+
+#ifdef USE_COMPRESSED
+  /* If everything went well, the mbox handler saved the changes to our
+   * temporary file.  Next, comp_sync() will compress the temporary file. */
+  if ((rc == 0) && ctx->compress_info)
+    return comp_sync (ctx);
+#endif
+
   return rc;
 }
 
@@ -810,6 +910,25 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
     return 0;
   }
 
+#ifdef USE_NNTP
+  if (ctx->unread && ctx->magic == MUTT_NNTP)
+  {
+    NNTP_DATA *nntp_data = ctx->data;
+
+    if (nntp_data && nntp_data->nserv && nntp_data->group)
+    {
+      int rc = query_quadoption (OPT_CATCHUP, _("Mark all articles read?"));
+      if (rc < 0)
+      {
+	ctx->closing = 0;
+	return -1;
+      }
+      else if (rc == MUTT_YES)
+	mutt_newsgroup_catchup (nntp_data->nserv, nntp_data->group);
+    }
+  }
+#endif
+
   for (i = 0; i < ctx->msgcount; i++)
   {
     if (!ctx->hdrs[i]->deleted && ctx->hdrs[i]->read 
@@ -823,6 +942,12 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
 #endif
   }
 
+#ifdef USE_NNTP
+  /* don't need to move articles from newsgroup */
+  if (ctx->magic == MUTT_NNTP)
+    read_msgs = 0;
+#endif
+
   if (read_msgs && quadoption (OPT_MOVE) != MUTT_NO)
   {
     char *p;
@@ -1014,6 +1139,10 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
   return 0;
 }
 
+#if USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 
 /* update a Context structure's internal tables. */
 
@@ -1033,9 +1162,10 @@ void mx_update_tables(CONTEXT *ctx, int committing)
 #define this_body ctx->hdrs[j]->content
   for (i = 0, j = 0; i < ctx->msgcount; i++)
   {
-    if ((committing && (!ctx->hdrs[i]->deleted || 
+    if (!ctx->hdrs[i]->quasi_deleted &&
+	((committing && (!ctx->hdrs[i]->deleted ||
 			(ctx->magic == MUTT_MAILDIR && option (OPTMAILDIRTRASH)))) ||
-	(!committing && ctx->hdrs[i]->active))
+	(!committing && ctx->hdrs[i]->active)))
     {
       if (i != j)
       {
@@ -1241,7 +1371,7 @@ MESSAGE *mx_open_new_message (CONTEXT *dest, HEADER *hdr, int flags)
   ADDRESS *p = NULL;
   MESSAGE *msg;
 
-  if (!dest->mx_ops->open_new_msg)
+  if (!dest->mx_ops || !dest->mx_ops->open_new_msg)
   {
       dprint (1, (debugfile, "mx_open_new_message(): function unimplemented for mailbox type %d.\n",
               dest->magic));
@@ -1293,7 +1423,7 @@ MESSAGE *mx_open_new_message (CONTEXT *dest, HEADER *hdr, int flags)
 /* check for new mail */
 int mx_check_mailbox (CONTEXT *ctx, int *index_hint)
 {
-  if (!ctx)
+  if (!ctx || !ctx->mx_ops)
   {
     dprint (1, (debugfile, "mx_check_mailbox: null or invalid context.\n"));
     return -1;
@@ -1307,7 +1437,7 @@ MESSAGE *mx_open_message (CONTEXT *ctx, int msgno)
 {
   MESSAGE *msg;
 
-  if (!ctx->mx_ops->open_msg)
+  if (!ctx->mx_ops || !ctx->mx_ops->open_msg)
   {
     dprint (1, (debugfile, "mx_open_message(): function not implemented for mailbox type %d.\n", ctx->magic));
     return NULL;
@@ -1324,7 +1454,7 @@ MESSAGE *mx_open_message (CONTEXT *ctx, int msgno)
 
 int mx_commit_message (MESSAGE *msg, CONTEXT *ctx)
 {
-  if (!ctx->mx_ops->commit_msg)
+  if (!ctx->mx_ops || !ctx->mx_ops->commit_msg)
     return -1;
 
   if (!(msg->write && ctx->append))
@@ -1342,7 +1472,7 @@ int mx_close_message (CONTEXT *ctx, MESSAGE **msg)
 {
   int r = 0;
 
-  if (ctx->mx_ops->close_msg)
+  if (ctx->mx_ops && ctx->mx_ops->close_msg)
     r = ctx->mx_ops->close_msg (ctx, *msg);
 
   if ((*msg)->path)
@@ -1353,6 +1483,7 @@ int mx_close_message (CONTEXT *ctx, MESSAGE **msg)
     FREE (&(*msg)->path);
   }
 
+  FREE (&(*msg)->commited_path);
   FREE (msg);		/* __FREE_CHECKED__ */
   return (r);
 }
diff --git c/mx.h w/mx.h
index ba9a78f..2f62abf 100644
--- c/mx.h
+++ w/mx.h
@@ -35,8 +35,15 @@ enum
   MUTT_MMDF,
   MUTT_MH,
   MUTT_MAILDIR,
+#ifdef USE_NNTP
+  MUTT_NNTP,
+#endif
   MUTT_IMAP,
+  MUTT_NOTMUCH,
   MUTT_POP
+#ifdef USE_COMPRESSED
+  , MUTT_COMPRESSED
+#endif
 };
 
 WHERE short DefaultMagic INITVAL (MUTT_MBOX);
@@ -57,7 +64,24 @@ int mh_check_empty (const char *);
 
 int maildir_check_empty (const char *);
 
-FILE *maildir_open_find_message (const char *, const char *);
+HEADER *maildir_parse_message (int magic, const char *fname, int is_old, HEADER * _h);
+HEADER *maildir_parse_stream (int magic, FILE *f, const char *fname, int is_old, HEADER * _h);
+void maildir_parse_flags (HEADER * h, const char *path);
+void maildir_update_flags (CONTEXT *ctx, HEADER *o, HEADER *n);
+void maildir_flags(char *dest, size_t destlen, HEADER * hdr);
+
+#if USE_HCACHE
+#include <hcache.h>
+int mh_sync_mailbox_message (CONTEXT * ctx, int msgno, header_cache_t *hc);
+#else
+int mh_sync_mailbox_message (CONTEXT * ctx, int msgno);
+#endif
+
+#ifdef USE_NOTMUCH
+int mx_is_notmuch(const char *p);
+#endif
+
+FILE *maildir_open_find_message (const char *, const char *, char **);
 
 int mbox_strict_cmp_headers (const HEADER *, const HEADER *);
 int mutt_reopen_mailbox (CONTEXT *, int *);
@@ -70,6 +94,7 @@ void mx_update_tables (CONTEXT *, int);
 int mx_lock_file (const char *, int, int, int, int);
 int mx_unlock_file (const char *path, int fd, int dot);
 
+struct mx_ops* mx_get_ops (int magic);
 extern struct mx_ops mx_maildir_ops;
 extern struct mx_ops mx_mbox_ops;
 extern struct mx_ops mx_mh_ops;
diff --git c/newsrc.c w/newsrc.c
new file mode 100644
index 0000000..6f7eff0
--- /dev/null
+++ w/newsrc.c
@@ -0,0 +1,1263 @@
+/*
+ * Copyright (C) 1998 Brandon Long <blong@fiction.net>
+ * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>
+ * Copyright (C) 2000-2012 Vsevolod Volkov <vvv@mutt.org.ua>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mutt_curses.h"
+#include "sort.h"
+#include "mx.h"
+#include "mime.h"
+#include "mailbox.h"
+#include "nntp.h"
+#include "rfc822.h"
+#include "rfc1524.h"
+#include "rfc2047.h"
+#include "bcache.h"
+
+#if USE_HCACHE
+#include "hcache.h"
+#endif
+
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <errno.h>
+
+/* Find NNTP_DATA for given newsgroup or add it */
+static NNTP_DATA *nntp_data_find (NNTP_SERVER *nserv, const char *group)
+{
+  NNTP_DATA *nntp_data = hash_find (nserv->groups_hash, group);
+
+  if (!nntp_data)
+  {
+    int len = strlen (group) + 1;
+    /* create NNTP_DATA structure and add it to hash */
+    nntp_data = safe_calloc (1, sizeof (NNTP_DATA) + len);
+    nntp_data->group = (char *)nntp_data + sizeof (NNTP_DATA);
+    strfcpy (nntp_data->group, group, len);
+    nntp_data->nserv = nserv;
+    nntp_data->deleted = 1;
+    if (nserv->groups_hash->nelem < nserv->groups_hash->curnelem * 2)
+      nserv->groups_hash = hash_resize (nserv->groups_hash,
+			   nserv->groups_hash->nelem * 2, 0);
+    hash_insert (nserv->groups_hash, nntp_data->group, nntp_data, 0);
+
+    /* add NNTP_DATA to list */
+    if (nserv->groups_num >= nserv->groups_max)
+    {
+      nserv->groups_max *= 2;
+      safe_realloc (&nserv->groups_list,
+		    nserv->groups_max * sizeof (nntp_data));
+    }
+    nserv->groups_list[nserv->groups_num++] = nntp_data;
+  }
+  return nntp_data;
+}
+
+/* Remove all temporarily cache files */
+void nntp_acache_free (NNTP_DATA *nntp_data)
+{
+  int i;
+
+  for (i = 0; i < NNTP_ACACHE_LEN; i++)
+  {
+    if (nntp_data->acache[i].path)
+    {
+      unlink (nntp_data->acache[i].path);
+      FREE (&nntp_data->acache[i].path);
+    }
+  }
+}
+
+/* Free NNTP_DATA, used to destroy hash elements */
+void nntp_data_free (void *data)
+{
+  NNTP_DATA *nntp_data = data;
+
+  if (!nntp_data)
+    return;
+  nntp_acache_free (nntp_data);
+  mutt_bcache_close (&nntp_data->bcache);
+  FREE (&nntp_data->newsrc_ent);
+  FREE (&nntp_data->desc);
+  FREE (&data);
+}
+
+/* Unlock and close .newsrc file */
+void nntp_newsrc_close (NNTP_SERVER *nserv)
+{
+  if (!nserv->newsrc_fp)
+    return;
+
+  dprint (1, (debugfile, "Unlocking %s\n", nserv->newsrc_file));
+  mx_unlock_file (nserv->newsrc_file, fileno (nserv->newsrc_fp), 0);
+  safe_fclose (&nserv->newsrc_fp);
+}
+
+/* Parse .newsrc file:
+ *  0 - not changed
+ *  1 - parsed
+ * -1 - error */
+int nntp_newsrc_parse (NNTP_SERVER *nserv)
+{
+  unsigned int i;
+  char *line;
+  struct stat sb;
+
+  /* if file doesn't exist, create it */
+  nserv->newsrc_fp = safe_fopen (nserv->newsrc_file, "a");
+  safe_fclose (&nserv->newsrc_fp);
+
+  /* open .newsrc */
+  nserv->newsrc_fp = safe_fopen (nserv->newsrc_file, "r");
+  if (!nserv->newsrc_fp)
+  {
+    mutt_perror (nserv->newsrc_file);
+    mutt_sleep (2);
+    return -1;
+  }
+
+  /* lock it */
+  dprint (1, (debugfile, "Locking %s\n", nserv->newsrc_file));
+  if (mx_lock_file (nserv->newsrc_file, fileno (nserv->newsrc_fp), 0, 0, 1))
+  {
+    safe_fclose (&nserv->newsrc_fp);
+    return -1;
+  }
+
+  if (stat (nserv->newsrc_file, &sb))
+  {
+    mutt_perror (nserv->newsrc_file);
+    nntp_newsrc_close (nserv);
+    mutt_sleep (2);
+    return -1;
+  }
+
+  if (nserv->size == sb.st_size && nserv->mtime == sb.st_mtime)
+    return 0;
+
+  nserv->size = sb.st_size;
+  nserv->mtime = sb.st_mtime;
+  nserv->newsrc_modified = 1;
+  dprint (1, (debugfile, "Parsing %s\n", nserv->newsrc_file));
+
+  /* .newsrc has been externally modified or hasn't been loaded yet */
+  for (i = 0; i < nserv->groups_num; i++)
+  {
+    NNTP_DATA *nntp_data = nserv->groups_list[i];
+
+    if (!nntp_data)
+      continue;
+
+    nntp_data->subscribed = 0;
+    nntp_data->newsrc_len = 0;
+    FREE (&nntp_data->newsrc_ent);
+  }
+
+  line = safe_malloc (sb.st_size + 1);
+  while (sb.st_size && fgets (line, sb.st_size + 1, nserv->newsrc_fp))
+  {
+    char *b, *h, *p;
+    unsigned int subs = 0, i = 1;
+    NNTP_DATA *nntp_data;
+
+    /* find end of newsgroup name */
+    p = strpbrk (line, ":!");
+    if (!p)
+      continue;
+
+    /* ":" - subscribed, "!" - unsubscribed */
+    if (*p == ':')
+      subs++;
+    *p++ = '\0';
+
+    /* get newsgroup data */
+    nntp_data = nntp_data_find (nserv, line);
+    FREE (&nntp_data->newsrc_ent);
+
+    /* count number of entries */
+    b = p;
+    while (*b)
+      if (*b++ == ',')
+	i++;
+    nntp_data->newsrc_ent = safe_calloc (i, sizeof (NEWSRC_ENTRY));
+    nntp_data->subscribed = subs;
+
+    /* parse entries */
+    i = 0;
+    while (p)
+    {
+      b = p;
+
+      /* find end of entry */
+      p = strchr (p, ',');
+      if (p)
+	*p++ = '\0';
+
+      /* first-last or single number */
+      h = strchr (b, '-');
+      if (h)
+	*h++ = '\0';
+      else
+	h = b;
+
+      if (sscanf (b, ANUM, &nntp_data->newsrc_ent[i].first) == 1 &&
+	  sscanf (h, ANUM, &nntp_data->newsrc_ent[i].last) == 1)
+	i++;
+    }
+    if (i == 0)
+    {
+	nntp_data->newsrc_ent[i].first = 1;
+	nntp_data->newsrc_ent[i].last = 0;
+	i++;
+    }
+    if (nntp_data->lastMessage == 0)
+      nntp_data->lastMessage = nntp_data->newsrc_ent[i - 1].last;
+    nntp_data->newsrc_len = i;
+    safe_realloc (&nntp_data->newsrc_ent, i * sizeof (NEWSRC_ENTRY));
+    nntp_group_unread_stat (nntp_data);
+    dprint (2, (debugfile, "nntp_newsrc_parse: %s\n", nntp_data->group));
+  }
+  FREE (&line);
+  return 1;
+}
+
+/* Generate array of .newsrc entries */
+void nntp_newsrc_gen_entries (CONTEXT *ctx)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  anum_t last = 0, first = 1;
+  int series, i;
+  int save_sort = SORT_ORDER;
+  unsigned int entries;
+
+  if (Sort != SORT_ORDER)
+  {
+    save_sort = Sort;
+    Sort = SORT_ORDER;
+    mutt_sort_headers (ctx, 0);
+  }
+
+  entries = nntp_data->newsrc_len;
+  if (!entries)
+  {
+    entries = 5;
+    nntp_data->newsrc_ent = safe_calloc (entries, sizeof (NEWSRC_ENTRY));
+  }
+
+  /* Set up to fake initial sequence from 1 to the article before the
+   * first article in our list */
+  nntp_data->newsrc_len = 0;
+  series = 1;
+  for (i = 0; i < ctx->msgcount; i++)
+  {
+    /* search for first unread */
+    if (series)
+    {
+      /* We don't actually check sequential order, since we mark
+       * "missing" entries as read/deleted */
+      last = NHDR (ctx->hdrs[i])->article_num;
+      if (last >= nntp_data->firstMessage && !ctx->hdrs[i]->deleted &&
+	  !ctx->hdrs[i]->read)
+      {
+	if (nntp_data->newsrc_len >= entries)
+	{
+	  entries *= 2;
+	  safe_realloc (&nntp_data->newsrc_ent, entries * sizeof (NEWSRC_ENTRY));
+	}
+	nntp_data->newsrc_ent[nntp_data->newsrc_len].first = first;
+	nntp_data->newsrc_ent[nntp_data->newsrc_len].last = last - 1;
+	nntp_data->newsrc_len++;
+	series = 0;
+      }
+    }
+
+    /* search for first read */
+    else
+    {
+      if (ctx->hdrs[i]->deleted || ctx->hdrs[i]->read)
+      {
+	first = last + 1;
+	series = 1;
+      }
+      last = NHDR (ctx->hdrs[i])->article_num;
+    }
+  }
+
+  if (series && first <= nntp_data->lastLoaded)
+  {
+    if (nntp_data->newsrc_len >= entries)
+    {
+      entries++;
+      safe_realloc (&nntp_data->newsrc_ent, entries * sizeof (NEWSRC_ENTRY));
+    }
+    nntp_data->newsrc_ent[nntp_data->newsrc_len].first = first;
+    nntp_data->newsrc_ent[nntp_data->newsrc_len].last = nntp_data->lastLoaded;
+    nntp_data->newsrc_len++;
+  }
+  safe_realloc (&nntp_data->newsrc_ent,
+		nntp_data->newsrc_len * sizeof (NEWSRC_ENTRY));
+
+  if (save_sort != Sort)
+  {
+    Sort = save_sort;
+    mutt_sort_headers (ctx, 0);
+  }
+}
+
+/* Update file with new contents */
+static int update_file (char *filename, char *buf)
+{
+  FILE *fp;
+  char tmpfile[_POSIX_PATH_MAX];
+  int rc = -1;
+
+  while (1)
+  {
+    snprintf (tmpfile, sizeof (tmpfile), "%s.tmp", filename);
+    fp = safe_fopen (tmpfile, "w");
+    if (!fp)
+    {
+      mutt_perror (tmpfile);
+      *tmpfile = '\0';
+      break;
+    }
+    if (fputs (buf, fp) == EOF)
+    {
+      mutt_perror (tmpfile);
+      break;
+    }
+    if (fclose (fp) == EOF)
+    {
+      mutt_perror (tmpfile);
+      fp = NULL;
+      break;
+    }
+    fp = NULL;
+    if (rename (tmpfile, filename) < 0)
+    {
+      mutt_perror (filename);
+      break;
+    }
+    *tmpfile = '\0';
+    rc = 0;
+    break;
+  }
+  if (fp)
+    fclose (fp);
+  if (*tmpfile)
+    unlink (tmpfile);
+  if (rc)
+    mutt_sleep (2);
+  return rc;
+}
+
+/* Update .newsrc file */
+int nntp_newsrc_update (NNTP_SERVER *nserv)
+{
+  char *buf;
+  size_t buflen, off;
+  unsigned int i;
+  int rc = -1;
+
+  if (!nserv)
+    return -1;
+
+  buflen = 10 * LONG_STRING;
+  buf = safe_calloc (1, buflen);
+  off = 0;
+
+  /* we will generate full newsrc here */
+  for (i = 0; i < nserv->groups_num; i++)
+  {
+    NNTP_DATA *nntp_data = nserv->groups_list[i];
+    unsigned int n;
+
+    if (!nntp_data || !nntp_data->newsrc_ent)
+      continue;
+
+    /* write newsgroup name */
+    if (off + strlen (nntp_data->group) + 3 > buflen)
+    {
+      buflen *= 2;
+      safe_realloc (&buf, buflen);
+    }
+    snprintf (buf + off, buflen - off, "%s%c ", nntp_data->group,
+	      nntp_data->subscribed ? ':' : '!');
+    off += strlen (buf + off);
+
+    /* write entries */
+    for (n = 0; n < nntp_data->newsrc_len; n++)
+    {
+      if (off + LONG_STRING > buflen)
+      {
+	buflen *= 2;
+	safe_realloc (&buf, buflen);
+      }
+      if (n)
+	buf[off++] = ',';
+      if (nntp_data->newsrc_ent[n].first == nntp_data->newsrc_ent[n].last)
+	snprintf (buf + off, buflen - off, "%d", nntp_data->newsrc_ent[n].first);
+      else if (nntp_data->newsrc_ent[n].first < nntp_data->newsrc_ent[n].last)
+	snprintf (buf + off, buflen - off, "%d-%d",
+		  nntp_data->newsrc_ent[n].first, nntp_data->newsrc_ent[n].last);
+      off += strlen (buf + off);
+    }
+    buf[off++] = '\n';
+  }
+  buf[off] = '\0';
+
+  /* newrc being fully rewritten */
+  dprint (1, (debugfile, "Updating %s\n", nserv->newsrc_file));
+  if (nserv->newsrc_file && update_file (nserv->newsrc_file, buf) == 0)
+  {
+    struct stat sb;
+
+    rc = stat (nserv->newsrc_file, &sb);
+    if (rc == 0)
+    {
+      nserv->size = sb.st_size;
+      nserv->mtime = sb.st_mtime;
+    }
+    else
+    {
+      mutt_perror (nserv->newsrc_file);
+      mutt_sleep (2);
+    }
+  }
+  FREE (&buf);
+  return rc;
+}
+
+/* Make fully qualified cache file name */
+static void cache_expand (char *dst, size_t dstlen, ACCOUNT *acct, char *src)
+{
+  char *c;
+  char file[_POSIX_PATH_MAX];
+
+  /* server subdirectory */
+  if (acct)
+  {
+    ciss_url_t url;
+
+    mutt_account_tourl (acct, &url);
+    url.path = src;
+    url_ciss_tostring (&url, file, sizeof (file), U_PATH);
+  }
+  else
+    strfcpy (file, src ? src : "", sizeof (file));
+
+  snprintf (dst, dstlen, "%s/%s", NewsCacheDir, file);
+
+  /* remove trailing slash */
+  c = dst + strlen (dst) - 1;
+  if (*c == '/')
+    *c = '\0';
+  mutt_expand_path (dst, dstlen);
+}
+
+/* Make fully qualified url from newsgroup name */
+void nntp_expand_path (char *line, size_t len, ACCOUNT *acct)
+{
+  ciss_url_t url;
+
+  url.path = safe_strdup (line);
+  mutt_account_tourl (acct, &url);
+  url_ciss_tostring (&url, line, len, 0);
+  FREE (&url.path);
+}
+
+/* Parse newsgroup */
+int nntp_add_group (char *line, void *data)
+{
+  NNTP_SERVER *nserv = data;
+  NNTP_DATA *nntp_data;
+  char group[LONG_STRING];
+  char desc[HUGE_STRING] = "";
+  char mod;
+  anum_t first, last;
+
+  if (!nserv || !line)
+    return 0;
+
+  if (sscanf (line, "%s " ANUM " " ANUM " %c %[^\n]", group,
+	      &last, &first, &mod, desc) < 4)
+    return 0;
+
+  nntp_data = nntp_data_find (nserv, group);
+  nntp_data->deleted = 0;
+  nntp_data->firstMessage = first;
+  nntp_data->lastMessage = last;
+  nntp_data->allowed = mod == 'y' || mod == 'm' ? 1 : 0;
+  mutt_str_replace (&nntp_data->desc, desc);
+  if (nntp_data->newsrc_ent || nntp_data->lastCached)
+    nntp_group_unread_stat (nntp_data);
+  else if (nntp_data->lastMessage &&
+	   nntp_data->firstMessage <= nntp_data->lastMessage)
+    nntp_data->unread = nntp_data->lastMessage - nntp_data->firstMessage + 1;
+  else
+    nntp_data->unread = 0;
+  return 0;
+}
+
+/* Load list of all newsgroups from cache */
+static int active_get_cache (NNTP_SERVER *nserv)
+{
+  char buf[HUGE_STRING];
+  char file[_POSIX_PATH_MAX];
+  time_t t;
+  FILE *fp;
+
+  cache_expand (file, sizeof (file), &nserv->conn->account, ".active");
+  dprint (1, (debugfile, "Parsing %s\n", file));
+  fp = safe_fopen (file, "r");
+  if (!fp)
+    return -1;
+
+  if (fgets (buf, sizeof (buf), fp) == NULL ||
+      sscanf (buf, "%ld%s", &t, file) != 1 || t == 0)
+  {
+    fclose (fp);
+    return -1;
+  }
+  nserv->newgroups_time = t;
+
+  mutt_message _("Loading list of groups from cache...");
+  while (fgets (buf, sizeof (buf), fp))
+    nntp_add_group (buf, nserv);
+  nntp_add_group (NULL, NULL);
+  fclose (fp);
+  mutt_clear_error ();
+  return 0;
+}
+
+/* Save list of all newsgroups to cache */
+int nntp_active_save_cache (NNTP_SERVER *nserv)
+{
+  char file[_POSIX_PATH_MAX];
+  char *buf;
+  size_t buflen, off;
+  unsigned int i;
+  int rc;
+
+  if (!nserv->cacheable)
+    return 0;
+
+  buflen = 10 * LONG_STRING;
+  buf = safe_calloc (1, buflen);
+  snprintf (buf, buflen, "%lu\n", (unsigned long)nserv->newgroups_time);
+  off = strlen (buf);
+
+  for (i = 0; i < nserv->groups_num; i++)
+  {
+    NNTP_DATA *nntp_data = nserv->groups_list[i];
+
+    if (!nntp_data || nntp_data->deleted)
+      continue;
+
+    if (off + strlen (nntp_data->group) +
+	(nntp_data->desc ? strlen (nntp_data->desc) : 0) + 50 > buflen)
+    {
+      buflen *= 2;
+      safe_realloc (&buf, buflen);
+    }
+    snprintf (buf + off, buflen - off, "%s %d %d %c%s%s\n", nntp_data->group,
+	      nntp_data->lastMessage, nntp_data->firstMessage,
+	      nntp_data->allowed ? 'y' : 'n', nntp_data->desc ? " " : "",
+	      nntp_data->desc ? nntp_data->desc : "");
+    off += strlen (buf + off);
+  }
+
+  cache_expand (file, sizeof (file), &nserv->conn->account, ".active");
+  dprint (1, (debugfile, "Updating %s\n", file));
+  rc = update_file (file, buf);
+  FREE (&buf);
+  return rc;
+}
+
+#ifdef USE_HCACHE
+/* Used by mutt_hcache_open() to compose hcache file name */
+static int nntp_hcache_namer (const char *path, char *dest, size_t destlen)
+{
+  return snprintf (dest, destlen, "%s.hcache", path);
+}
+
+/* Open newsgroup hcache */
+header_cache_t *nntp_hcache_open (NNTP_DATA *nntp_data)
+{
+  ciss_url_t url;
+  char file[_POSIX_PATH_MAX];
+
+  if (!nntp_data->nserv || !nntp_data->nserv->cacheable ||
+      !nntp_data->nserv->conn || !nntp_data->group ||
+      !(nntp_data->newsrc_ent || nntp_data->subscribed ||
+      option (OPTSAVEUNSUB)))
+    return NULL;
+
+  mutt_account_tourl (&nntp_data->nserv->conn->account, &url);
+  url.path = nntp_data->group;
+  url_ciss_tostring (&url, file, sizeof (file), U_PATH);
+  return mutt_hcache_open (NewsCacheDir, file, nntp_hcache_namer);
+}
+
+/* Remove stale cached headers */
+void nntp_hcache_update (NNTP_DATA *nntp_data, header_cache_t *hc)
+{
+  char buf[16];
+  int old = 0;
+  void *hdata;
+  anum_t first, last, current;
+
+  if (!hc)
+    return;
+
+  /* fetch previous values of first and last */
+  hdata = mutt_hcache_fetch_raw (hc, "index", strlen);
+  if (hdata)
+  {
+    dprint (2, (debugfile,
+		"nntp_hcache_update: mutt_hcache_fetch index: %s\n", hdata));
+    if (sscanf (hdata, ANUM " " ANUM, &first, &last) == 2)
+    {
+      old = 1;
+      nntp_data->lastCached = last;
+
+      /* clean removed headers from cache */
+      for (current = first; current <= last; current++)
+      {
+	if (current >= nntp_data->firstMessage &&
+	    current <= nntp_data->lastMessage)
+	  continue;
+
+	snprintf (buf, sizeof (buf), "%d", current);
+	dprint (2, (debugfile,
+		    "nntp_hcache_update: mutt_hcache_delete %s\n", buf));
+	mutt_hcache_delete (hc, buf, strlen);
+      }
+    }
+    FREE (&hdata);
+  }
+
+  /* store current values of first and last */
+  if (!old || nntp_data->firstMessage != first ||
+	      nntp_data->lastMessage != last)
+  {
+    snprintf (buf, sizeof (buf), "%u %u", nntp_data->firstMessage,
+					  nntp_data->lastMessage);
+    dprint (2, (debugfile,
+		"nntp_hcache_update: mutt_hcache_store index: %s\n", buf));
+    mutt_hcache_store_raw (hc, "index", buf, strlen (buf) + 1, strlen);
+  }
+}
+#endif
+
+/* Remove bcache file */
+static int nntp_bcache_delete (const char *id, body_cache_t *bcache, void *data)
+{
+  NNTP_DATA *nntp_data = data;
+  anum_t anum;
+  char c;
+
+  if (!nntp_data || sscanf (id, ANUM "%c", &anum, &c) != 1 ||
+      anum < nntp_data->firstMessage || anum > nntp_data->lastMessage)
+  {
+    if (nntp_data)
+      dprint (2, (debugfile, "nntp_bcache_delete: mutt_bcache_del %s\n", id));
+    mutt_bcache_del (bcache, id);
+  }
+  return 0;
+}
+
+/* Remove stale cached messages */
+void nntp_bcache_update (NNTP_DATA *nntp_data)
+{
+  mutt_bcache_list (nntp_data->bcache, nntp_bcache_delete, nntp_data);
+}
+
+/* Remove hcache and bcache of newsgroup */
+void nntp_delete_group_cache (NNTP_DATA *nntp_data)
+{
+  char file[_POSIX_PATH_MAX];
+
+  if (!nntp_data || !nntp_data->nserv || !nntp_data->nserv->cacheable)
+    return;
+
+#ifdef USE_HCACHE
+  nntp_hcache_namer (nntp_data->group, file, sizeof (file));
+  cache_expand (file, sizeof (file), &nntp_data->nserv->conn->account, file);
+  unlink (file);
+  nntp_data->lastCached = 0;
+  dprint (2, (debugfile, "nntp_delete_group_cache: %s\n", file));
+#endif
+
+  if (!nntp_data->bcache)
+    nntp_data->bcache = mutt_bcache_open (&nntp_data->nserv->conn->account,
+			nntp_data->group);
+  if (nntp_data->bcache)
+  {
+    dprint (2, (debugfile, "nntp_delete_group_cache: %s/*\n", nntp_data->group));
+    mutt_bcache_list (nntp_data->bcache, nntp_bcache_delete, NULL);
+    mutt_bcache_close (&nntp_data->bcache);
+  }
+}
+
+/* Remove hcache and bcache of all unexistent and unsubscribed newsgroups */
+void nntp_clear_cache (NNTP_SERVER *nserv)
+{
+  char file[_POSIX_PATH_MAX];
+  char *fp;
+  struct dirent *entry;
+  DIR *dp;
+
+  if (!nserv || !nserv->cacheable)
+    return;
+
+  cache_expand (file, sizeof (file), &nserv->conn->account, NULL);
+  dp = opendir (file);
+  if (dp)
+  {
+    safe_strncat (file, sizeof (file), "/", 1);
+    fp = file + strlen (file);
+    while ((entry = readdir (dp)))
+    {
+      char *group = entry->d_name;
+      struct stat sb;
+      NNTP_DATA *nntp_data;
+      NNTP_DATA nntp_tmp;
+
+      if (mutt_strcmp (group, ".") == 0 ||
+	  mutt_strcmp (group, "..") == 0)
+	continue;
+      *fp = '\0';
+      safe_strncat (file, sizeof (file), group, strlen (group));
+      if (stat (file, &sb))
+	continue;
+
+#ifdef USE_HCACHE
+      if (S_ISREG (sb.st_mode))
+      {
+	char *ext = group + strlen (group) - 7;
+	if (strlen (group) < 8 || mutt_strcmp (ext, ".hcache"))
+	  continue;
+	*ext = '\0';
+      }
+      else
+#endif
+      if (!S_ISDIR (sb.st_mode))
+	continue;
+
+      nntp_data = hash_find (nserv->groups_hash, group);
+      if (!nntp_data)
+      {
+	nntp_data = &nntp_tmp;
+	nntp_data->nserv = nserv;
+	nntp_data->group = group;
+	nntp_data->bcache = NULL;
+      }
+      else if (nntp_data->newsrc_ent || nntp_data->subscribed ||
+	       option (OPTSAVEUNSUB))
+	continue;
+
+      nntp_delete_group_cache (nntp_data);
+      if (S_ISDIR (sb.st_mode))
+      {
+	rmdir (file);
+	dprint (2, (debugfile, "nntp_clear_cache: %s\n", file));
+      }
+    }
+    closedir (dp);
+  }
+  return;
+}
+
+/* %a = account url
+ * %p = port
+ * %P = port if specified
+ * %s = news server name
+ * %S = url schema
+ * %u = username */
+const char *
+nntp_format_str (char *dest, size_t destlen, size_t col, int cols, char op, const char *src,
+		const char *fmt, const char *ifstring, const char *elsestring,
+		unsigned long data, format_flag flags)
+{
+  NNTP_SERVER *nserv = (NNTP_SERVER *)data;
+  ACCOUNT *acct = &nserv->conn->account;
+  ciss_url_t url;
+  char fn[SHORT_STRING], tmp[SHORT_STRING], *p;
+
+  switch (op)
+  {
+    case 'a':
+      mutt_account_tourl (acct, &url);
+      url_ciss_tostring (&url, fn, sizeof (fn), U_PATH);
+      p = strchr (fn, '/');
+      if (p)
+	*p = '\0';
+      snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+      snprintf (dest, destlen, tmp, fn);
+      break;
+    case 'p':
+      snprintf (tmp, sizeof (tmp), "%%%su", fmt);
+      snprintf (dest, destlen, tmp, acct->port);
+      break;
+    case 'P':
+      *dest = '\0';
+      if (acct->flags & MUTT_ACCT_PORT)
+      {
+	snprintf (tmp, sizeof (tmp), "%%%su", fmt);
+	snprintf (dest, destlen, tmp, acct->port);
+      }
+      break;
+    case 's':
+      strncpy (fn, acct->host, sizeof (fn) - 1);
+      mutt_strlower (fn);
+      snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+      snprintf (dest, destlen, tmp, fn);
+      break;
+    case 'S':
+      mutt_account_tourl (acct, &url);
+      url_ciss_tostring (&url, fn, sizeof (fn), U_PATH);
+      p = strchr (fn, ':');
+      if (p)
+	*p = '\0';
+      snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+      snprintf (dest, destlen, tmp, fn);
+      break;
+    case 'u':
+      snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+      snprintf (dest, destlen, tmp, acct->user);
+      break;
+  }
+  return (src);
+}
+
+/* Automatically loads a newsrc into memory, if necessary.
+ * Checks the size/mtime of a newsrc file, if it doesn't match, load
+ * again.  Hmm, if a system has broken mtimes, this might mean the file
+ * is reloaded every time, which we'd have to fix. */
+NNTP_SERVER *nntp_select_server (char *server, int leave_lock)
+{
+  char file[_POSIX_PATH_MAX];
+  char *p;
+  int rc;
+  struct stat sb;
+  ACCOUNT acct;
+  NNTP_SERVER *nserv;
+  NNTP_DATA *nntp_data;
+  CONNECTION *conn;
+  ciss_url_t url;
+
+  if (!server || !*server)
+  {
+    mutt_error _("No news server defined!");
+    mutt_sleep (2);
+    return NULL;
+  }
+
+  /* create account from news server url */
+  acct.flags = 0;
+  acct.port = NNTP_PORT;
+  acct.type = MUTT_ACCT_TYPE_NNTP;
+  snprintf (file, sizeof (file), "%s%s",
+	    strstr (server, "://") ? "" : "news://", server);
+  if (url_parse_ciss (&url, file) < 0 ||
+      (url.path && *url.path) ||
+      !(url.scheme == U_NNTP || url.scheme == U_NNTPS) ||
+      mutt_account_fromurl (&acct, &url) < 0)
+  {
+    mutt_error (_("%s is an invalid news server specification!"), server);
+    mutt_sleep (2);
+    return NULL;
+  }
+  if (url.scheme == U_NNTPS)
+  {
+    acct.flags |= MUTT_ACCT_SSL;
+    acct.port = NNTP_SSL_PORT;
+  }
+
+  /* find connection by account */
+  conn = mutt_conn_find (NULL, &acct);
+  if (!conn)
+    return NULL;
+  if (!(conn->account.flags & MUTT_ACCT_USER) && acct.flags & MUTT_ACCT_USER)
+  {
+    conn->account.flags |= MUTT_ACCT_USER;
+    conn->account.user[0] = '\0';
+  }
+
+  /* news server already exists */
+  nserv = conn->data;
+  if (nserv)
+  {
+    if (nserv->status == NNTP_BYE)
+      nserv->status = NNTP_NONE;
+    if (nntp_open_connection (nserv) < 0)
+      return NULL;
+
+    rc = nntp_newsrc_parse (nserv);
+    if (rc < 0)
+      return NULL;
+
+    /* check for new newsgroups */
+    if (!leave_lock && nntp_check_new_groups (nserv) < 0)
+      rc = -1;
+
+    /* .newsrc has been externally modified */
+    if (rc > 0)
+      nntp_clear_cache (nserv);
+    if (rc < 0 || !leave_lock)
+      nntp_newsrc_close (nserv);
+    return rc < 0 ? NULL : nserv;
+  }
+
+  /* new news server */
+  nserv = safe_calloc (1, sizeof (NNTP_SERVER));
+  nserv->conn = conn;
+  nserv->groups_hash = hash_create (1009, 0);
+  nserv->groups_max = 16;
+  nserv->groups_list = safe_malloc (nserv->groups_max * sizeof (nntp_data));
+
+  rc = nntp_open_connection (nserv);
+
+  /* try to create cache directory and enable caching */
+  nserv->cacheable = 0;
+  if (rc >= 0 && NewsCacheDir && *NewsCacheDir)
+  {
+    cache_expand (file, sizeof (file), &conn->account, NULL);
+    p = *file == '/' ? file + 1 : file;
+    while (1)
+    {
+      p = strchr (p, '/');
+      if (p)
+	*p = '\0';
+      if ((stat (file, &sb) || (sb.st_mode & S_IFDIR) == 0) &&
+	  mkdir (file, 0700))
+      {
+	mutt_error (_("Can't create %s: %s."), file, strerror (errno));
+	mutt_sleep (2);
+	break;
+      }
+      if (!p)
+      {
+	nserv->cacheable = 1;
+	break;
+      }
+      *p++ = '/';
+    }
+  }
+
+  /* load .newsrc */
+  if (rc >= 0)
+  {
+    mutt_FormatString (file, sizeof (file), 0, MuttIndexWindow->cols, NONULL (NewsRc),
+		       nntp_format_str, (unsigned long)nserv, 0);
+    mutt_expand_path (file, sizeof (file));
+    nserv->newsrc_file = safe_strdup (file);
+    rc = nntp_newsrc_parse (nserv);
+  }
+  if (rc >= 0)
+  {
+    /* try to load list of newsgroups from cache */
+    if (nserv->cacheable && active_get_cache (nserv) == 0)
+      rc = nntp_check_new_groups (nserv);
+
+    /* load list of newsgroups from server */
+    else
+      rc = nntp_active_fetch (nserv);
+  }
+
+  if (rc >= 0)
+    nntp_clear_cache (nserv);
+
+#ifdef USE_HCACHE
+  /* check cache files */
+  if (rc >= 0 && nserv->cacheable)
+  {
+    struct dirent *entry;
+    DIR *dp = opendir (file);
+
+    if (dp)
+    {
+      while ((entry = readdir (dp)))
+      {
+	header_cache_t *hc;
+	void *hdata;
+	char *group = entry->d_name;
+
+	p = group + strlen (group) - 7;
+	if (strlen (group) < 8 || strcmp (p, ".hcache"))
+	  continue;
+	*p = '\0';
+	nntp_data = hash_find (nserv->groups_hash, group);
+	if (!nntp_data)
+	  continue;
+
+	hc = nntp_hcache_open (nntp_data);
+	if (!hc)
+	  continue;
+
+	/* fetch previous values of first and last */
+	hdata = mutt_hcache_fetch_raw (hc, "index", strlen);
+	if (hdata)
+	{
+	  anum_t first, last;
+
+	  if (sscanf (hdata, ANUM " " ANUM, &first, &last) == 2)
+	  {
+	    if (nntp_data->deleted)
+	    {
+	      nntp_data->firstMessage = first;
+	      nntp_data->lastMessage = last;
+	    }
+	    if (last >= nntp_data->firstMessage &&
+		last <= nntp_data->lastMessage)
+	    {
+	      nntp_data->lastCached = last;
+	      dprint (2, (debugfile, "nntp_select_server: %s lastCached=%u\n",
+			  nntp_data->group, last));
+	    }
+	  }
+	  FREE (&hdata);
+	}
+	mutt_hcache_close (hc);
+      }
+      closedir (dp);
+    }
+  }
+#endif
+
+  if (rc < 0 || !leave_lock)
+    nntp_newsrc_close (nserv);
+
+  if (rc < 0)
+  {
+    hash_destroy (&nserv->groups_hash, nntp_data_free);
+    FREE (&nserv->groups_list);
+    FREE (&nserv->newsrc_file);
+    FREE (&nserv->authenticators);
+    FREE (&nserv);
+    mutt_socket_close (conn);
+    mutt_socket_free (conn);
+    return NULL;
+  }
+
+  conn->data = nserv;
+  return nserv;
+}
+
+/* Full status flags are not supported by nntp, but we can fake some of them:
+ * Read = a read message number is in the .newsrc
+ * New = not read and not cached
+ * Old = not read but cached */
+void nntp_article_status (CONTEXT *ctx, HEADER *hdr, char *group, anum_t anum)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  unsigned int i;
+
+  if (group)
+    nntp_data = hash_find (nntp_data->nserv->groups_hash, group);
+
+  if (!nntp_data)
+    return;
+
+  for (i = 0; i < nntp_data->newsrc_len; i++)
+  {
+    if ((anum >= nntp_data->newsrc_ent[i].first) &&
+	(anum <= nntp_data->newsrc_ent[i].last))
+    {
+      /* can't use mutt_set_flag() because mx_update_context()
+	 didn't called yet */
+      hdr->read = 1;
+      return;
+    }
+  }
+
+  /* article was not cached yet, it's new */
+  if (anum > nntp_data->lastCached)
+    return;
+
+  /* article isn't read but cached, it's old */
+  if (option (OPTMARKOLD))
+    hdr->old = 1;
+}
+
+/* calculate number of unread articles using .newsrc data */
+void nntp_group_unread_stat (NNTP_DATA *nntp_data)
+{
+  unsigned int i;
+  anum_t first, last;
+
+  nntp_data->unread = 0;
+  if (nntp_data->lastMessage == 0 ||
+      nntp_data->firstMessage > nntp_data->lastMessage)
+    return;
+
+  nntp_data->unread = nntp_data->lastMessage - nntp_data->firstMessage + 1;
+  for (i = 0; i < nntp_data->newsrc_len; i++)
+  {
+    first = nntp_data->newsrc_ent[i].first;
+    if (first < nntp_data->firstMessage)
+      first = nntp_data->firstMessage;
+    last = nntp_data->newsrc_ent[i].last;
+    if (last > nntp_data->lastMessage)
+      last = nntp_data->lastMessage;
+    if (first <= last)
+      nntp_data->unread -= last - first + 1;
+  }
+}
+
+/* Subscribe newsgroup */
+NNTP_DATA *mutt_newsgroup_subscribe (NNTP_SERVER *nserv, char *group)
+{
+  NNTP_DATA *nntp_data;
+
+  if (!nserv || !nserv->groups_hash || !group || !*group)
+    return NULL;
+
+  nntp_data = nntp_data_find (nserv, group);
+  nntp_data->subscribed = 1;
+  if (!nntp_data->newsrc_ent)
+  {
+    nntp_data->newsrc_ent = safe_calloc (1, sizeof (NEWSRC_ENTRY));
+    nntp_data->newsrc_len = 1;
+    nntp_data->newsrc_ent[0].first = 1;
+    nntp_data->newsrc_ent[0].last = 0;
+  }
+  return nntp_data;
+}
+
+/* Unsubscribe newsgroup */
+NNTP_DATA *mutt_newsgroup_unsubscribe (NNTP_SERVER *nserv, char *group)
+{
+  NNTP_DATA *nntp_data;
+
+  if (!nserv || !nserv->groups_hash || !group || !*group)
+    return NULL;
+
+  nntp_data = hash_find (nserv->groups_hash, group);
+  if (!nntp_data)
+    return NULL;
+
+  nntp_data->subscribed = 0;
+  if (!option (OPTSAVEUNSUB))
+  {
+    nntp_data->newsrc_len = 0;
+    FREE (&nntp_data->newsrc_ent);
+  }
+  return nntp_data;
+}
+
+/* Catchup newsgroup */
+NNTP_DATA *mutt_newsgroup_catchup (NNTP_SERVER *nserv, char *group)
+{
+  NNTP_DATA *nntp_data;
+
+  if (!nserv || !nserv->groups_hash || !group || !*group)
+    return NULL;
+
+  nntp_data = hash_find (nserv->groups_hash, group);
+  if (!nntp_data)
+    return NULL;
+
+  if (nntp_data->newsrc_ent)
+  {
+    safe_realloc (&nntp_data->newsrc_ent, sizeof (NEWSRC_ENTRY));
+    nntp_data->newsrc_len = 1;
+    nntp_data->newsrc_ent[0].first = 1;
+    nntp_data->newsrc_ent[0].last = nntp_data->lastMessage;
+  }
+  nntp_data->unread = 0;
+  if (Context && Context->data == nntp_data)
+  {
+    unsigned int i;
+
+    for (i = 0; i < Context->msgcount; i++)
+      mutt_set_flag (Context, Context->hdrs[i], MUTT_READ, 1);
+  }
+  return nntp_data;
+}
+
+/* Uncatchup newsgroup */
+NNTP_DATA *mutt_newsgroup_uncatchup (NNTP_SERVER *nserv, char *group)
+{
+  NNTP_DATA *nntp_data;
+
+  if (!nserv || !nserv->groups_hash || !group || !*group)
+    return NULL;
+
+  nntp_data = hash_find (nserv->groups_hash, group);
+  if (!nntp_data)
+    return NULL;
+
+  if (nntp_data->newsrc_ent)
+  {
+    safe_realloc (&nntp_data->newsrc_ent, sizeof (NEWSRC_ENTRY));
+    nntp_data->newsrc_len = 1;
+    nntp_data->newsrc_ent[0].first = 1;
+    nntp_data->newsrc_ent[0].last = nntp_data->firstMessage - 1;
+  }
+  if (Context && Context->data == nntp_data)
+  {
+    unsigned int i;
+
+    nntp_data->unread = Context->msgcount;
+    for (i = 0; i < Context->msgcount; i++)
+      mutt_set_flag (Context, Context->hdrs[i], MUTT_READ, 0);
+  }
+  else
+    nntp_data->unread = nntp_data->lastMessage - nntp_data->newsrc_ent[0].last;
+  return nntp_data;
+}
+
+/* Get first newsgroup with new messages */
+void nntp_buffy (char *buf, size_t len)
+{
+  unsigned int i;
+
+  for (i = 0; i < CurrentNewsSrv->groups_num; i++)
+  {
+    NNTP_DATA *nntp_data = CurrentNewsSrv->groups_list[i];
+
+    if (!nntp_data || !nntp_data->subscribed || !nntp_data->unread)
+      continue;
+
+    if (Context && Context->magic == MUTT_NNTP &&
+	!mutt_strcmp (nntp_data->group, ((NNTP_DATA *)Context->data)->group))
+    {
+      unsigned int i, unread = 0;
+
+      for (i = 0; i < Context->msgcount; i++)
+	if (!Context->hdrs[i]->read && !Context->hdrs[i]->deleted)
+	  unread++;
+      if (!unread)
+	continue;
+    }
+    strfcpy (buf, nntp_data->group, len);
+    break;
+  }
+}
diff --git c/nntp.c w/nntp.c
new file mode 100644
index 0000000..182d068
--- /dev/null
+++ w/nntp.c
@@ -0,0 +1,2455 @@
+/*
+ * Copyright (C) 1998 Brandon Long <blong@fiction.net>
+ * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>
+ * Copyright (C) 2000-2012 Vsevolod Volkov <vvv@mutt.org.ua>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mutt_curses.h"
+#include "sort.h"
+#include "mx.h"
+#include "mime.h"
+#include "rfc1524.h"
+#include "rfc2047.h"
+#include "mailbox.h"
+#include "mutt_crypt.h"
+#include "nntp.h"
+
+#if defined(USE_SSL)
+#include "mutt_ssl.h"
+#endif
+
+#ifdef HAVE_PGP
+#include "pgp.h"
+#endif
+
+#ifdef HAVE_SMIME
+#include "smime.h"
+#endif
+
+#if USE_HCACHE
+#include "hcache.h"
+#endif
+
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+
+#ifdef USE_SASL
+#include <sasl/sasl.h>
+#include <sasl/saslutil.h>
+
+#include "mutt_sasl.h"
+#endif
+
+static int nntp_connect_error (NNTP_SERVER *nserv)
+{
+  nserv->status = NNTP_NONE;
+  mutt_error _("Server closed connection!");
+  mutt_sleep (2);
+  return -1;
+}
+
+/* Get capabilities:
+ * -1 - error, connection is closed
+ *  0 - mode is reader, capabilities setted up
+ *  1 - need to switch to reader mode */
+static int nntp_capabilities (NNTP_SERVER *nserv)
+{
+  CONNECTION *conn = nserv->conn;
+  unsigned int mode_reader = 0;
+  char buf[LONG_STRING];
+  char authinfo[LONG_STRING] = "";
+
+  nserv->hasCAPABILITIES = 0;
+  nserv->hasSTARTTLS = 0;
+  nserv->hasDATE = 0;
+  nserv->hasLIST_NEWSGROUPS = 0;
+  nserv->hasLISTGROUP = 0;
+  nserv->hasLISTGROUPrange = 0;
+  nserv->hasOVER = 0;
+  FREE (&nserv->authenticators);
+
+  if (mutt_socket_write (conn, "CAPABILITIES\r\n") < 0 ||
+      mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+    return nntp_connect_error (nserv);
+
+  /* no capabilities */
+  if (mutt_strncmp ("101", buf, 3))
+    return 1;
+  nserv->hasCAPABILITIES = 1;
+
+  /* parse capabilities */
+  do
+  {
+    if (mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+    if (!mutt_strcmp ("STARTTLS", buf))
+      nserv->hasSTARTTLS = 1;
+    else if (!mutt_strcmp ("MODE-READER", buf))
+      mode_reader = 1;
+    else if (!mutt_strcmp ("READER", buf))
+    {
+      nserv->hasDATE = 1;
+      nserv->hasLISTGROUP = 1;
+      nserv->hasLISTGROUPrange = 1;
+    }
+    else if (!mutt_strncmp ("AUTHINFO ", buf, 9))
+    {
+      safe_strcat (buf, sizeof (buf), " ");
+      strfcpy (authinfo, buf + 8, sizeof (authinfo));
+    }
+#ifdef USE_SASL
+    else if (!mutt_strncmp ("SASL ", buf, 5))
+    {
+      char *p = buf + 5;
+      while (*p == ' ')
+	p++;
+      nserv->authenticators = safe_strdup (p);
+    }
+#endif
+    else if (!mutt_strcmp ("OVER", buf))
+      nserv->hasOVER = 1;
+    else if (!mutt_strncmp ("LIST ", buf, 5))
+    {
+      char *p = strstr (buf, " NEWSGROUPS");
+      if (p)
+      {
+	p += 11;
+	if (*p == '\0' || *p == ' ')
+	  nserv->hasLIST_NEWSGROUPS = 1;
+      }
+    }
+  } while (mutt_strcmp (".", buf));
+  *buf = '\0';
+#ifdef USE_SASL
+  if (nserv->authenticators && strcasestr (authinfo, " SASL "))
+    strfcpy (buf, nserv->authenticators, sizeof (buf));
+#endif
+  if (strcasestr (authinfo, " USER "))
+  {
+    if (*buf)
+      safe_strcat (buf, sizeof (buf), " ");
+    safe_strcat (buf, sizeof (buf), "USER");
+  }
+  mutt_str_replace (&nserv->authenticators, buf);
+
+  /* current mode is reader */
+  if (nserv->hasDATE)
+    return 0;
+
+  /* server is mode-switching, need to switch to reader mode */
+  if (mode_reader)
+    return 1;
+
+  mutt_socket_close (conn);
+  nserv->status = NNTP_BYE;
+  mutt_error _("Server doesn't support reader mode.");
+  mutt_sleep (2);
+  return -1;
+}
+
+char *OverviewFmt =
+	"Subject:\0"
+	"From:\0"
+	"Date:\0"
+	"Message-ID:\0"
+	"References:\0"
+	"Content-Length:\0"
+	"Lines:\0"
+	"\0";
+
+/* Detect supported commands */
+static int nntp_attempt_features (NNTP_SERVER *nserv)
+{
+  CONNECTION *conn = nserv->conn;
+  char buf[LONG_STRING];
+
+  /* no CAPABILITIES, trying DATE, LISTGROUP, LIST NEWSGROUPS */
+  if (!nserv->hasCAPABILITIES)
+  {
+    if (mutt_socket_write (conn, "DATE\r\n") < 0 ||
+	mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+    if (mutt_strncmp ("500", buf, 3))
+      nserv->hasDATE = 1;
+
+    if (mutt_socket_write (conn, "LISTGROUP\r\n") < 0 ||
+	mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+    if (mutt_strncmp ("500", buf, 3))
+      nserv->hasLISTGROUP = 1;
+
+    if (mutt_socket_write (conn, "LIST NEWSGROUPS +\r\n") < 0 ||
+	mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+    if (mutt_strncmp ("500", buf, 3))
+      nserv->hasLIST_NEWSGROUPS = 1;
+    if (!mutt_strncmp ("215", buf, 3))
+    {
+      do
+      {
+	if (mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+	  return nntp_connect_error (nserv);
+      } while (mutt_strcmp (".", buf));
+    }
+  }
+
+  /* no LIST NEWSGROUPS, trying XGTITLE */
+  if (!nserv->hasLIST_NEWSGROUPS)
+  {
+    if (mutt_socket_write (conn, "XGTITLE\r\n") < 0 ||
+	mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+    if (mutt_strncmp ("500", buf, 3))
+      nserv->hasXGTITLE = 1;
+  }
+
+  /* no OVER, trying XOVER */
+  if (!nserv->hasOVER)
+  {
+    if (mutt_socket_write (conn, "XOVER\r\n") < 0 ||
+	mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+    if (mutt_strncmp ("500", buf, 3))
+      nserv->hasXOVER = 1;
+  }
+
+  /* trying LIST OVERVIEW.FMT */
+  if (nserv->hasOVER || nserv->hasXOVER)
+  {
+    if (mutt_socket_write (conn, "LIST OVERVIEW.FMT\r\n") < 0 ||
+	mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+    if (mutt_strncmp ("215", buf, 3))
+      nserv->overview_fmt = OverviewFmt;
+    else
+    {
+      int chunk, cont = 0;
+      size_t buflen = 2 * LONG_STRING, off = 0, b = 0;
+
+      if (nserv->overview_fmt)
+	FREE (&nserv->overview_fmt);
+      nserv->overview_fmt = safe_malloc (buflen);
+
+      while (1)
+      {
+	if (buflen - off < LONG_STRING)
+	{
+	  buflen *= 2;
+	  safe_realloc (&nserv->overview_fmt, buflen);
+	}
+
+	chunk = mutt_socket_readln (nserv->overview_fmt + off,
+				    buflen - off, conn);
+	if (chunk < 0)
+	{
+	  FREE (&nserv->overview_fmt);
+	  return nntp_connect_error (nserv);
+	}
+
+	if (!cont && !mutt_strcmp (".", nserv->overview_fmt + off))
+	  break;
+
+	cont = chunk >= buflen - off ? 1 : 0;
+	off += strlen (nserv->overview_fmt + off);
+	if (!cont)
+	{
+	  char *colon;
+
+	  if (nserv->overview_fmt[b] == ':')
+	  {
+	    memmove (nserv->overview_fmt + b,
+		     nserv->overview_fmt + b + 1, off - b - 1);
+	    nserv->overview_fmt[off - 1] = ':';
+	  }
+	  colon = strchr (nserv->overview_fmt + b, ':');
+	  if (!colon)
+	    nserv->overview_fmt[off++] = ':';
+	  else if (strcmp (colon + 1, "full"))
+	    off = colon + 1 - nserv->overview_fmt;
+	  if (!strcasecmp (nserv->overview_fmt + b, "Bytes:"))
+	  {
+            int len = strlen (nserv->overview_fmt + b);
+	    strfcpy (nserv->overview_fmt + b, "Content-Length:", len + 1);
+	    off = b + len;
+	  }
+	  nserv->overview_fmt[off++] = '\0';
+	  b = off;
+	}
+      }
+      nserv->overview_fmt[off++] = '\0';
+      safe_realloc (&nserv->overview_fmt, off);
+    }
+  }
+  return 0;
+}
+
+/* Get login, password and authenticate */
+static int nntp_auth (NNTP_SERVER *nserv)
+{
+  CONNECTION *conn = nserv->conn;
+  char buf[LONG_STRING];
+  char authenticators[LONG_STRING] = "USER";
+  char *method, *a, *p;
+  unsigned char flags = conn->account.flags;
+
+  while (1)
+  {
+    /* get login and password */
+    if (mutt_account_getuser (&conn->account) || !conn->account.user[0] ||
+	mutt_account_getpass (&conn->account) || !conn->account.pass[0])
+      break;
+
+    /* get list of authenticators */
+    if (NntpAuthenticators && *NntpAuthenticators)
+      strfcpy (authenticators, NntpAuthenticators, sizeof (authenticators));
+    else if (nserv->hasCAPABILITIES)
+    {
+      strfcpy (authenticators, NONULL (nserv->authenticators),
+	       sizeof (authenticators));
+      p = authenticators;
+      while (*p)
+      {
+	if (*p == ' ')
+	  *p = ':';
+	p++;
+      }
+    }
+    p = authenticators;
+    while (*p)
+    {
+      *p = ascii_toupper (*p);
+      p++;
+    }
+
+    dprint (1, (debugfile,
+		"nntp_auth: available methods: %s\n", nserv->authenticators));
+    a = authenticators;
+    while (1)
+    {
+      if (!a)
+      {
+	mutt_error _("No authenticators available");
+	mutt_sleep (2);
+	break;
+      }
+
+      method = a;
+      a = strchr (a, ':');
+      if (a)
+	*a++ = '\0';
+
+      /* check authenticator */
+      if (nserv->hasCAPABILITIES)
+      {
+	char *m;
+
+	if (!nserv->authenticators)
+	  continue;
+	m = strcasestr (nserv->authenticators, method);
+	if (!m)
+	  continue;
+	if (m > nserv->authenticators && *(m - 1) != ' ')
+	  continue;
+	m += strlen (method);
+	if (*m != '\0' && *m != ' ')
+	  continue;
+      }
+      dprint (1, (debugfile, "nntp_auth: trying method %s\n", method));
+
+      /* AUTHINFO USER authentication */
+      if (!strcmp (method, "USER"))
+      {
+	mutt_message (_("Authenticating (%s)..."), method);
+	snprintf (buf, sizeof (buf), "AUTHINFO USER %s\r\n", conn->account.user);
+	if (mutt_socket_write (conn, buf) < 0 ||
+	    mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+	  break;
+
+	/* authenticated, password is not required */
+	if (!mutt_strncmp ("281", buf, 3))
+	  return 0;
+
+	/* username accepted, sending password */
+	if (!mutt_strncmp ("381", buf, 3))
+	{
+#ifdef DEBUG
+	  if (debuglevel < MUTT_SOCK_LOG_FULL)
+	    dprint (MUTT_SOCK_LOG_CMD, (debugfile,
+		    "%d> AUTHINFO PASS *\n", conn->fd));
+#endif
+	  snprintf (buf, sizeof (buf), "AUTHINFO PASS %s\r\n",
+		    conn->account.pass);
+	  if (mutt_socket_write_d (conn, buf, -1, MUTT_SOCK_LOG_FULL) < 0 ||
+	      mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+	  break;
+
+	  /* authenticated */
+	  if (!mutt_strncmp ("281", buf, 3))
+	    return 0;
+	}
+
+	/* server doesn't support AUTHINFO USER, trying next method */
+	if (*buf == '5')
+	  continue;
+      }
+
+      else
+      {
+#ifdef USE_SASL
+	sasl_conn_t *saslconn;
+	sasl_interact_t *interaction = NULL;
+	int rc;
+	char inbuf[LONG_STRING] = "";
+	const char *mech;
+	const char *client_out = NULL;
+	unsigned int client_len, len;
+
+	if (mutt_sasl_client_new (conn, &saslconn) < 0)
+	{
+	  dprint (1, (debugfile,
+		  "nntp_auth: error allocating SASL connection.\n"));
+	  continue;
+	}
+
+	while (1)
+	{
+	  rc = sasl_client_start (saslconn, method, &interaction,
+				  &client_out, &client_len, &mech);
+	  if (rc != SASL_INTERACT)
+	    break;
+	  mutt_sasl_interact (interaction);
+	}
+	if (rc != SASL_OK && rc != SASL_CONTINUE)
+	{
+	  sasl_dispose (&saslconn);
+	  dprint (1, (debugfile,
+		  "nntp_auth: error starting SASL authentication exchange.\n"));
+	  continue;
+	}
+
+	mutt_message (_("Authenticating (%s)..."), method);
+	snprintf (buf, sizeof (buf), "AUTHINFO SASL %s", method);
+
+	/* looping protocol */
+	while (rc == SASL_CONTINUE || (rc == SASL_OK && client_len))
+	{
+	  /* send out client response */
+	  if (client_len)
+	  {
+#ifdef DEBUG
+	    if (debuglevel >= MUTT_SOCK_LOG_FULL)
+	    {
+	      char tmp[LONG_STRING];
+	      memcpy (tmp, client_out, client_len);
+	      for (p = tmp; p < tmp + client_len; p++)
+	      {
+		if (*p == '\0')
+		  *p = '.';
+	      }
+	      *p = '\0';
+	      dprint (1, (debugfile, "SASL> %s\n", tmp));
+	    }
+#endif
+
+	    if (*buf)
+	      safe_strcat (buf, sizeof (buf), " ");
+	    len = strlen (buf);
+	    if (sasl_encode64 (client_out, client_len,
+		buf + len, sizeof (buf) - len, &len) != SASL_OK)
+	    {
+	      dprint (1, (debugfile,
+		      "nntp_auth: error base64-encoding client response.\n"));
+	      break;
+	    }
+	  }
+
+	  safe_strcat (buf, sizeof (buf), "\r\n");
+#ifdef DEBUG
+	  if (debuglevel < MUTT_SOCK_LOG_FULL)
+	  {
+	    if (strchr (buf, ' '))
+	      dprint (MUTT_SOCK_LOG_CMD, (debugfile, "%d> AUTHINFO SASL %s%s\n",
+		      conn->fd, method, client_len ? " sasl_data" : ""));
+	    else
+	      dprint (MUTT_SOCK_LOG_CMD, (debugfile, "%d> sasl_data\n", conn->fd));
+	  }
+#endif
+	  client_len = 0;
+	  if (mutt_socket_write_d (conn, buf, -1, MUTT_SOCK_LOG_FULL) < 0 ||
+	      mutt_socket_readln_d (inbuf, sizeof (inbuf), conn, MUTT_SOCK_LOG_FULL) < 0)
+	    break;
+	  if (mutt_strncmp (inbuf, "283 ", 4) &&
+	      mutt_strncmp (inbuf, "383 ", 4))
+	  {
+#ifdef DEBUG
+	    if (debuglevel < MUTT_SOCK_LOG_FULL)
+	      dprint (MUTT_SOCK_LOG_CMD, (debugfile, "%d< %s\n", conn->fd, inbuf));
+#endif
+	    break;
+	  }
+#ifdef DEBUG
+	  if (debuglevel < MUTT_SOCK_LOG_FULL)
+	  {
+	    inbuf[3] = '\0';
+	    dprint (MUTT_SOCK_LOG_CMD, (debugfile,
+		    "%d< %s sasl_data\n", conn->fd, inbuf));
+	  }
+#endif
+
+	  if (!strcmp ("=", inbuf + 4))
+	    len = 0;
+	  else if (sasl_decode64 (inbuf + 4, strlen (inbuf + 4),
+		   buf, sizeof (buf) - 1, &len) != SASL_OK)
+	  {
+	    dprint (1, (debugfile,
+		    "nntp_auth: error base64-decoding server response.\n"));
+	    break;
+	  }
+#ifdef DEBUG
+	  else if (debuglevel >= MUTT_SOCK_LOG_FULL)
+	  {
+	    char tmp[LONG_STRING];
+	    memcpy (tmp, buf, len);
+	    for (p = tmp; p < tmp + len; p++)
+	    {
+	      if (*p == '\0')
+		*p = '.';
+	    }
+	    *p = '\0';
+	    dprint (1, (debugfile, "SASL< %s\n", tmp));
+	  }
+#endif
+
+	  while (1)
+	  {
+	    rc = sasl_client_step (saslconn, buf, len,
+				   &interaction, &client_out, &client_len);
+	    if (rc != SASL_INTERACT)
+	      break;
+	    mutt_sasl_interact (interaction);
+	  }
+	  if (*inbuf != '3')
+	    break;
+
+	  *buf = '\0';
+	} /* looping protocol */
+
+	if (rc == SASL_OK && client_len == 0 && *inbuf == '2')
+	{
+	  mutt_sasl_setup_conn (conn, saslconn);
+	  return 0;
+	}
+
+	/* terminate SASL sessoin */
+	sasl_dispose (&saslconn);
+	if (conn->fd < 0)
+	  break;
+	if (!mutt_strncmp (inbuf, "383 ", 4))
+	{
+	  if (mutt_socket_write (conn, "*\r\n") < 0 ||
+	      mutt_socket_readln (inbuf, sizeof (inbuf), conn) < 0)
+	    break;
+	}
+
+	/* server doesn't support AUTHINFO SASL, trying next method */
+	if (*inbuf == '5')
+	  continue;
+#else
+	continue;
+#endif /* USE_SASL */
+      }
+
+      mutt_error (_("%s authentication failed."), method);
+      mutt_sleep (2);
+      break;
+    }
+    break;
+  }
+
+  /* error */
+  nserv->status = NNTP_BYE;
+  conn->account.flags = flags;
+  if (conn->fd < 0)
+  {
+    mutt_error _("Server closed connection!");
+    mutt_sleep (2);
+  }
+  else
+    mutt_socket_close (conn);
+  return -1;
+}
+
+/* Connect to server, authenticate and get capabilities */
+int nntp_open_connection (NNTP_SERVER *nserv)
+{
+  CONNECTION *conn = nserv->conn;
+  char buf[STRING];
+  int cap;
+  unsigned int posting = 0, auth = 1;
+
+  if (nserv->status == NNTP_OK)
+    return 0;
+  if (nserv->status == NNTP_BYE)
+    return -1;
+  nserv->status = NNTP_NONE;
+
+  if (mutt_socket_open (conn) < 0)
+    return -1;
+
+  if (mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+    return nntp_connect_error (nserv);
+
+  if (!mutt_strncmp ("200", buf, 3))
+    posting = 1;
+  else if (mutt_strncmp ("201", buf, 3))
+  {
+    mutt_socket_close (conn);
+    mutt_remove_trailing_ws (buf);
+    mutt_error ("%s", buf);
+    mutt_sleep (2);
+    return -1;
+  }
+
+  /* get initial capabilities */
+  cap = nntp_capabilities (nserv);
+  if (cap < 0)
+    return -1;
+
+  /* tell news server to switch to mode reader if it isn't so */
+  if (cap > 0)
+  {
+    if (mutt_socket_write (conn, "MODE READER\r\n") < 0 ||
+	mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+
+    if (!mutt_strncmp ("200", buf, 3))
+      posting = 1;
+    else if (!mutt_strncmp ("201", buf, 3))
+      posting = 0;
+    /* error if has capabilities, ignore result if no capabilities */
+    else if (nserv->hasCAPABILITIES)
+    {
+      mutt_socket_close (conn);
+      mutt_error _("Could not switch to reader mode.");
+      mutt_sleep (2);
+      return -1;
+    }
+
+    /* recheck capabilities after MODE READER */
+    if (nserv->hasCAPABILITIES)
+    {
+      cap = nntp_capabilities (nserv);
+      if (cap < 0)
+	return -1;
+    }
+  }
+
+  mutt_message (_("Connected to %s. %s"), conn->account.host,
+		posting ? _("Posting is ok.") : _("Posting is NOT ok."));
+  mutt_sleep (1);
+
+#if defined(USE_SSL)
+  /* Attempt STARTTLS if available and desired. */
+  if (nserv->use_tls != 1 && (nserv->hasSTARTTLS || option (OPTSSLFORCETLS)))
+  {
+    if (nserv->use_tls == 0)
+      nserv->use_tls = option (OPTSSLFORCETLS) ||
+			query_quadoption (OPT_SSLSTARTTLS,
+			_("Secure connection with TLS?")) == MUTT_YES ? 2 : 1;
+    if (nserv->use_tls == 2)
+    {
+      if (mutt_socket_write (conn, "STARTTLS\r\n") < 0 ||
+	  mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+	return nntp_connect_error (nserv);
+      if (mutt_strncmp ("382", buf, 3))
+      {
+	nserv->use_tls = 0;
+	mutt_error ("STARTTLS: %s", buf);
+	mutt_sleep (2);
+      }
+      else if (mutt_ssl_starttls (conn))
+      {
+	nserv->use_tls = 0;
+	nserv->status = NNTP_NONE;
+	mutt_socket_close (nserv->conn);
+	mutt_error _("Could not negotiate TLS connection");
+	mutt_sleep (2);
+	return -1;
+      }
+      else
+      {
+	/* recheck capabilities after STARTTLS */
+	cap = nntp_capabilities (nserv);
+	if (cap < 0)
+	  return -1;
+      }
+    }
+  }
+#endif
+
+  /* authentication required? */
+  if (conn->account.flags & MUTT_ACCT_USER)
+  {
+    if (!conn->account.user[0])
+      auth = 0;
+  }
+  else
+  {
+    if (mutt_socket_write (conn, "STAT\r\n") < 0 ||
+	mutt_socket_readln (buf, sizeof (buf), conn) < 0)
+      return nntp_connect_error (nserv);
+    if (mutt_strncmp ("480", buf, 3))
+      auth = 0;
+  }
+
+  /* authenticate */
+  if (auth && nntp_auth (nserv) < 0)
+      return -1;
+
+  /* get final capabilities after authentication */
+  if (nserv->hasCAPABILITIES && (auth || cap > 0))
+  {
+    cap = nntp_capabilities (nserv);
+    if (cap < 0)
+      return -1;
+    if (cap > 0)
+    {
+      mutt_socket_close (conn);
+      mutt_error _("Could not switch to reader mode.");
+      mutt_sleep (2);
+      return -1;
+    }
+  }
+
+  /* attempt features */
+  if (nntp_attempt_features (nserv) < 0)
+    return -1;
+
+  nserv->status = NNTP_OK;
+  return 0;
+}
+
+/* Send data from buffer and receive answer to same buffer */
+static int nntp_query (NNTP_DATA *nntp_data, char *line, size_t linelen)
+{
+  NNTP_SERVER *nserv = nntp_data->nserv;
+  char buf[LONG_STRING];
+
+  if (nserv->status == NNTP_BYE)
+    return -1;
+
+  while (1)
+  {
+    if (nserv->status == NNTP_OK)
+    {
+      int rc = 0;
+
+      if (*line)
+	rc = mutt_socket_write (nserv->conn, line);
+      else if (nntp_data->group)
+      {
+	snprintf (buf, sizeof (buf), "GROUP %s\r\n", nntp_data->group);
+	rc = mutt_socket_write (nserv->conn, buf);
+      }
+      if (rc >= 0)
+	rc = mutt_socket_readln (buf, sizeof (buf), nserv->conn);
+      if (rc >= 0)
+	break;
+    }
+
+    /* reconnect */
+    while (1)
+    {
+      nserv->status = NNTP_NONE;
+      if (nntp_open_connection (nserv) == 0)
+	break;
+
+      snprintf (buf, sizeof (buf), _("Connection to %s lost. Reconnect?"),
+		nserv->conn->account.host);
+      if (mutt_yesorno (buf, MUTT_YES) != MUTT_YES)
+      {
+	nserv->status = NNTP_BYE;
+	return -1;
+      }
+    }
+
+    /* select newsgroup after reconnection */
+    if (nntp_data->group)
+    {
+      snprintf (buf, sizeof (buf), "GROUP %s\r\n", nntp_data->group);
+      if (mutt_socket_write (nserv->conn, buf) < 0 ||
+	  mutt_socket_readln (buf, sizeof (buf), nserv->conn) < 0)
+	return nntp_connect_error (nserv);
+    }
+    if (!*line)
+      break;
+  }
+
+  strfcpy (line, buf, linelen);
+  return 0;
+}
+
+/* This function calls funct(*line, *data) for each received line,
+ * funct(NULL, *data) if rewind(*data) needs, exits when fail or done:
+ *  0 - success
+ *  1 - bad response (answer in query buffer)
+ * -1 - conection lost
+ * -2 - error in funct(*line, *data) */
+static int nntp_fetch_lines (NNTP_DATA *nntp_data, char *query, size_t qlen,
+			char *msg, int (*funct) (char *, void *), void *data)
+{
+  int done = FALSE;
+  int rc;
+
+  while (!done)
+  {
+    char buf[LONG_STRING];
+    char *line;
+    unsigned int lines = 0;
+    size_t off = 0;
+    progress_t progress;
+
+    if (msg)
+      mutt_progress_init (&progress, msg, MUTT_PROGRESS_MSG, ReadInc, -1);
+
+    strfcpy (buf, query, sizeof (buf));
+    if (nntp_query (nntp_data, buf, sizeof (buf)) < 0)
+      return -1;
+    if (buf[0] != '2')
+    {
+      strfcpy (query, buf, qlen);
+      return 1;
+    }
+
+    line = safe_malloc (sizeof (buf));
+    rc = 0;
+
+    while (1)
+    {
+      char *p;
+      int chunk = mutt_socket_readln_d (buf, sizeof (buf),
+		  nntp_data->nserv->conn, MUTT_SOCK_LOG_HDR);
+      if (chunk < 0)
+      {
+	nntp_data->nserv->status = NNTP_NONE;
+	break;
+      }
+
+      p = buf;
+      if (!off && buf[0] == '.')
+      {
+	if (buf[1] == '\0')
+	{
+	  done = TRUE;
+	  break;
+	}
+	if (buf[1] == '.')
+	  p++;
+      }
+
+      strfcpy (line + off, p, sizeof (buf));
+
+      if (chunk >= sizeof (buf))
+	off += strlen (p);
+      else
+      {
+	if (msg)
+	  mutt_progress_update (&progress, ++lines, -1);
+
+	if (rc == 0 && funct (line, data) < 0)
+	  rc = -2;
+	off = 0;
+      }
+
+      safe_realloc (&line, off + sizeof (buf));
+    }
+    FREE (&line);
+    funct (NULL, data);
+  }
+  return rc;
+}
+
+/* Parse newsgroup description */
+static int fetch_description (char *line, void *data)
+{
+  NNTP_SERVER *nserv = data;
+  NNTP_DATA *nntp_data;
+  char *desc;
+
+  if (!line)
+    return 0;
+
+  desc = strpbrk (line, " \t");
+  if (desc)
+  {
+    *desc++ = '\0';
+    desc += strspn (desc, " \t");
+  }
+  else
+    desc = strchr (line, '\0');
+
+  nntp_data = hash_find (nserv->groups_hash, line);
+  if (nntp_data && mutt_strcmp (desc, nntp_data->desc))
+  {
+    mutt_str_replace (&nntp_data->desc, desc);
+    dprint (2, (debugfile, "group: %s, desc: %s\n", line, desc));
+  }
+  return 0;
+}
+
+/* Fetch newsgroups descriptions.
+ * Returns the same code as nntp_fetch_lines() */
+static int get_description (NNTP_DATA *nntp_data, char *wildmat, char *msg)
+{
+  NNTP_SERVER *nserv;
+  char buf[STRING];
+  char *cmd;
+  int rc;
+
+  /* get newsgroup description, if possible */
+  nserv = nntp_data->nserv;
+  if (!wildmat)
+    wildmat = nntp_data->group;
+  if (nserv->hasLIST_NEWSGROUPS)
+    cmd = "LIST NEWSGROUPS";
+  else if (nserv->hasXGTITLE)
+    cmd = "XGTITLE";
+  else
+    return 0;
+
+  snprintf (buf, sizeof (buf), "%s %s\r\n", cmd, wildmat);
+  rc = nntp_fetch_lines (nntp_data, buf, sizeof (buf), msg,
+			 fetch_description, nserv);
+  if (rc > 0)
+  {
+    mutt_error ("%s: %s", cmd, buf);
+    mutt_sleep (2);
+  }
+  return rc;
+}
+
+/* Update read flag and set article number if empty */
+static void nntp_parse_xref (CONTEXT *ctx, HEADER *hdr)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  char *buf, *p;
+
+  buf = p = safe_strdup (hdr->env->xref);
+  while (p)
+  {
+    char *grp, *colon;
+    anum_t anum;
+
+    /* skip to next word */
+    p += strspn (p, " \t");
+    grp = p;
+
+    /* skip to end of word */
+    p = strpbrk (p, " \t");
+    if (p)
+      *p++ = '\0';
+
+    /* find colon */
+    colon = strchr (grp, ':');
+    if (!colon)
+      continue;
+    *colon++ = '\0';
+    if (sscanf (colon, ANUM, &anum) != 1)
+      continue;
+
+    nntp_article_status (ctx, hdr, grp, anum);
+    if (hdr && !NHDR (hdr)->article_num && !mutt_strcmp (nntp_data->group, grp))
+      NHDR (hdr)->article_num = anum;
+  }
+  FREE (&buf);
+}
+
+/* Write line to temporarily file */
+static int fetch_tempfile (char *line, void *data)
+{
+  FILE *fp = data;
+
+  if (!line)
+    rewind (fp);
+  else if (fputs (line, fp) == EOF || fputc ('\n', fp) == EOF)
+    return -1;
+  return 0;
+}
+
+typedef struct
+{
+  CONTEXT *ctx;
+  anum_t first;
+  anum_t last;
+  int restore;
+  unsigned char *messages;
+  progress_t progress;
+#ifdef USE_HCACHE
+  header_cache_t *hc;
+#endif
+} FETCH_CTX;
+
+/* Parse article number */
+static int fetch_numbers (char *line, void *data)
+{
+  FETCH_CTX *fc = data;
+  anum_t anum;
+
+  if (!line)
+    return 0;
+  if (sscanf (line, ANUM, &anum) != 1)
+    return 0;
+  if (anum < fc->first || anum > fc->last)
+    return 0;
+  fc->messages[anum - fc->first] = 1;
+  return 0;
+}
+
+/* Parse overview line */
+static int parse_overview_line (char *line, void *data)
+{
+  FETCH_CTX *fc = data;
+  CONTEXT *ctx = fc->ctx;
+  NNTP_DATA *nntp_data = ctx->data;
+  HEADER *hdr;
+  FILE *fp;
+  char tempfile[_POSIX_PATH_MAX];
+  char *header, *field;
+  int save = 1;
+  anum_t anum;
+
+  if (!line)
+    return 0;
+
+  /* parse article number */
+  field = strchr (line, '\t');
+  if (field)
+    *field++ = '\0';
+  if (sscanf (line, ANUM, &anum) != 1)
+    return 0;
+  dprint (2, (debugfile, "parse_overview_line: " ANUM "\n", anum));
+
+  /* out of bounds */
+  if (anum < fc->first || anum > fc->last)
+    return 0;
+
+  /* not in LISTGROUP */
+  if (!fc->messages[anum - fc->first])
+  {
+    /* progress */
+    if (!ctx->quiet)
+      mutt_progress_update (&fc->progress, anum - fc->first + 1, -1);
+    return 0;
+  }
+
+  /* convert overview line to header */
+  mutt_mktemp (tempfile, sizeof (tempfile));
+  fp = safe_fopen (tempfile, "w+");
+  if (!fp)
+    return -1;
+
+  header = nntp_data->nserv->overview_fmt;
+  while (field)
+  {
+    char *b = field;
+
+    if (*header)
+    {
+      if (strstr (header, ":full") == NULL && fputs (header, fp) == EOF)
+      {
+	fclose (fp);
+	unlink (tempfile);
+	return -1;
+      }
+      header = strchr (header, '\0') + 1;
+    }
+
+    field = strchr (field, '\t');
+    if (field)
+      *field++ = '\0';
+    if (fputs (b, fp) == EOF || fputc ('\n', fp) == EOF)
+    {
+      fclose (fp);
+      unlink (tempfile);
+      return -1;
+    }
+  }
+  rewind (fp);
+
+  /* allocate memory for headers */
+  if (ctx->msgcount >= ctx->hdrmax)
+    mx_alloc_memory (ctx);
+
+  /* parse header */
+  hdr = ctx->hdrs[ctx->msgcount] = mutt_new_header ();
+  hdr->env = mutt_read_rfc822_header (fp, hdr, 0, 0);
+  hdr->env->newsgroups = safe_strdup (nntp_data->group);
+  hdr->received = hdr->date_sent;
+  fclose (fp);
+  unlink (tempfile);
+
+#ifdef USE_HCACHE
+  if (fc->hc)
+  {
+    void *hdata;
+    char buf[16];
+
+    /* try to replace with header from cache */
+    snprintf (buf, sizeof (buf), "%d", anum);
+    hdata = mutt_hcache_fetch (fc->hc, buf, strlen);
+    if (hdata)
+    {
+      dprint (2, (debugfile,
+		  "parse_overview_line: mutt_hcache_fetch %s\n", buf));
+      mutt_free_header (&hdr);
+      ctx->hdrs[ctx->msgcount] =
+      hdr = mutt_hcache_restore (hdata, NULL);
+      FREE (&hdata);
+      hdr->data = 0;
+      hdr->read = 0;
+      hdr->old = 0;
+
+      /* skip header marked as deleted in cache */
+      if (hdr->deleted && !fc->restore)
+      {
+	if (nntp_data->bcache)
+	{
+	  dprint (2, (debugfile,
+		      "parse_overview_line: mutt_bcache_del %s\n", buf));
+	  mutt_bcache_del (nntp_data->bcache, buf);
+	}
+	save = 0;
+      }
+    }
+
+    /* not chached yet, store header */
+    else
+    {
+      dprint (2, (debugfile,
+		  "parse_overview_line: mutt_hcache_store %s\n", buf));
+      mutt_hcache_store (fc->hc, buf, hdr, 0, strlen, MUTT_GENERATE_UIDVALIDITY);
+    }
+  }
+#endif
+
+  if (save)
+  {
+    hdr->index = ctx->msgcount++;
+    hdr->read = 0;
+    hdr->old = 0;
+    hdr->deleted = 0;
+    hdr->data = safe_calloc (1, sizeof (NNTP_HEADER_DATA));
+    NHDR (hdr)->article_num = anum;
+    if (fc->restore)
+      hdr->changed = 1;
+    else
+    {
+      nntp_article_status (ctx, hdr, NULL, anum);
+      if (!hdr->read)
+	nntp_parse_xref (ctx, hdr);
+    }
+    if (anum > nntp_data->lastLoaded)
+      nntp_data->lastLoaded = anum;
+  }
+  else
+    mutt_free_header (&hdr);
+
+  /* progress */
+  if (!ctx->quiet)
+    mutt_progress_update (&fc->progress, anum - fc->first + 1, -1);
+  return 0;
+}
+
+/* Fetch headers */
+static int nntp_fetch_headers (CONTEXT *ctx, void *hc,
+			       anum_t first, anum_t last, int restore)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  FETCH_CTX fc;
+  HEADER *hdr;
+  char buf[HUGE_STRING];
+  int rc = 0;
+  int oldmsgcount = ctx->msgcount;
+  anum_t current;
+  anum_t first_over = first;
+#ifdef USE_HCACHE
+  void *hdata;
+#endif
+
+  /* if empty group or nothing to do */
+  if (!last || first > last)
+    return 0;
+
+  /* init fetch context */
+  fc.ctx = ctx;
+  fc.first = first;
+  fc.last = last;
+  fc.restore = restore;
+  fc.messages = safe_calloc (last - first + 1, sizeof (unsigned char));
+#ifdef USE_HCACHE
+  fc.hc = hc;
+#endif
+
+  /* fetch list of articles */
+  if (option (OPTLISTGROUP) && nntp_data->nserv->hasLISTGROUP &&
+      !nntp_data->deleted)
+  {
+    if (!ctx->quiet)
+      mutt_message _("Fetching list of articles...");
+    if (nntp_data->nserv->hasLISTGROUPrange)
+      snprintf (buf, sizeof (buf), "LISTGROUP %s %d-%d\r\n", nntp_data->group,
+		first, last);
+    else
+      snprintf (buf, sizeof (buf), "LISTGROUP %s\r\n", nntp_data->group);
+    rc = nntp_fetch_lines (nntp_data, buf, sizeof (buf), NULL,
+			   fetch_numbers, &fc);
+    if (rc > 0)
+    {
+      mutt_error ("LISTGROUP: %s", buf);
+      mutt_sleep (2);
+    }
+    if (rc == 0)
+    {
+      for (current = first; current <= last && rc == 0; current++)
+      {
+	if (fc.messages[current - first])
+	  continue;
+
+	snprintf (buf, sizeof (buf), "%d", current);
+	if (nntp_data->bcache)
+	{
+	  dprint (2, (debugfile,
+		      "nntp_fetch_headers: mutt_bcache_del %s\n", buf));
+	  mutt_bcache_del (nntp_data->bcache, buf);
+	}
+
+#ifdef USE_HCACHE
+	if (fc.hc)
+	{
+	  dprint (2, (debugfile,
+		      "nntp_fetch_headers: mutt_hcache_delete %s\n", buf));
+	  mutt_hcache_delete (fc.hc, buf, strlen);
+	}
+#endif
+      }
+    }
+  }
+  else
+    for (current = first; current <= last; current++)
+      fc.messages[current - first] = 1;
+
+  /* fetching header from cache or server, or fallback to fetch overview */
+  if (!ctx->quiet)
+    mutt_progress_init (&fc.progress, _("Fetching message headers..."),
+			MUTT_PROGRESS_MSG, ReadInc, last - first + 1);
+  for (current = first; current <= last && rc == 0; current++)
+  {
+    if (!ctx->quiet)
+      mutt_progress_update (&fc.progress, current - first + 1, -1);
+
+#ifdef USE_HCACHE
+    snprintf (buf, sizeof (buf), "%d", current);
+#endif
+
+    /* delete header from cache that does not exist on server */
+    if (!fc.messages[current - first])
+      continue;
+
+    /* allocate memory for headers */
+    if (ctx->msgcount >= ctx->hdrmax)
+      mx_alloc_memory (ctx);
+
+#ifdef USE_HCACHE
+    /* try to fetch header from cache */
+    hdata = mutt_hcache_fetch (fc.hc, buf, strlen);
+    if (hdata)
+    {
+      dprint (2, (debugfile,
+		  "nntp_fetch_headers: mutt_hcache_fetch %s\n", buf));
+      ctx->hdrs[ctx->msgcount] =
+      hdr = mutt_hcache_restore (hdata, NULL);
+      FREE (&hdata);
+      hdr->data = 0;
+
+      /* skip header marked as deleted in cache */
+      if (hdr->deleted && !restore)
+      {
+	mutt_free_header (&hdr);
+	if (nntp_data->bcache)
+	{
+	  dprint (2, (debugfile,
+		      "nntp_fetch_headers: mutt_bcache_del %s\n", buf));
+	  mutt_bcache_del (nntp_data->bcache, buf);
+	}
+	continue;
+      }
+
+      hdr->read = 0;
+      hdr->old = 0;
+    }
+    else
+#endif
+
+    /* don't try to fetch header from removed newsgroup */
+    if (nntp_data->deleted)
+      continue;
+
+    /* fallback to fetch overview */
+    else if (nntp_data->nserv->hasOVER || nntp_data->nserv->hasXOVER)
+      if (option (OPTLISTGROUP) && nntp_data->nserv->hasLISTGROUP)
+	break;
+      else
+	continue;
+
+    /* fetch header from server */
+    else
+    {
+      FILE *fp;
+      char tempfile[_POSIX_PATH_MAX];
+
+      mutt_mktemp (tempfile, sizeof (tempfile));
+      fp = safe_fopen (tempfile, "w+");
+      if (!fp)
+      {
+	mutt_perror (tempfile);
+	mutt_sleep (2);
+	unlink (tempfile);
+	rc = -1;
+	break;
+      }
+
+      snprintf (buf, sizeof (buf), "HEAD %d\r\n", current);
+      rc = nntp_fetch_lines (nntp_data, buf, sizeof (buf), NULL,
+			     fetch_tempfile, fp);
+      if (rc)
+      {
+	fclose (fp);
+	unlink (tempfile);
+	if (rc < 0)
+	  break;
+
+	/* invalid response */
+	if (mutt_strncmp ("423", buf, 3))
+	{
+	  mutt_error ("HEAD: %s", buf);
+	  mutt_sleep (2);
+	  break;
+	}
+
+	/* no such article */
+	if (nntp_data->bcache)
+	{
+	  snprintf (buf, sizeof (buf), "%d", current);
+	  dprint (2, (debugfile,
+		      "nntp_fetch_headers: mutt_bcache_del %s\n", buf));
+	  mutt_bcache_del (nntp_data->bcache, buf);
+	}
+	rc = 0;
+	continue;
+      }
+
+      /* parse header */
+      hdr = ctx->hdrs[ctx->msgcount] = mutt_new_header ();
+      hdr->env = mutt_read_rfc822_header (fp, hdr, 0, 0);
+      hdr->received = hdr->date_sent;
+      fclose (fp);
+      unlink (tempfile);
+    }
+
+    /* save header in context */
+    hdr->index = ctx->msgcount++;
+    hdr->read = 0;
+    hdr->old = 0;
+    hdr->deleted = 0;
+    hdr->data = safe_calloc (1, sizeof (NNTP_HEADER_DATA));
+    NHDR (hdr)->article_num = current;
+    if (restore)
+      hdr->changed = 1;
+    else
+    {
+      nntp_article_status (ctx, hdr, NULL, NHDR (hdr)->article_num);
+      if (!hdr->read)
+	nntp_parse_xref (ctx, hdr);
+    }
+    if (current > nntp_data->lastLoaded)
+      nntp_data->lastLoaded = current;
+    first_over = current + 1;
+  }
+
+  if (!option (OPTLISTGROUP) || !nntp_data->nserv->hasLISTGROUP)
+    current = first_over;
+
+  /* fetch overview information */
+  if (current <= last && rc == 0 && !nntp_data->deleted) {
+    char *cmd = nntp_data->nserv->hasOVER ? "OVER" : "XOVER";
+    snprintf (buf, sizeof (buf), "%s %d-%d\r\n", cmd, current, last);
+    rc = nntp_fetch_lines (nntp_data, buf, sizeof (buf), NULL,
+	 parse_overview_line, &fc);
+    if (rc > 0)
+    {
+      mutt_error ("%s: %s", cmd, buf);
+      mutt_sleep (2);
+    }
+  }
+
+  if (ctx->msgcount > oldmsgcount)
+    mx_update_context (ctx, ctx->msgcount - oldmsgcount);
+
+  FREE (&fc.messages);
+  if (rc != 0)
+    return -1;
+  mutt_clear_error ();
+  return 0;
+}
+
+/* Open newsgroup */
+int nntp_open_mailbox (CONTEXT *ctx)
+{
+  NNTP_SERVER *nserv;
+  NNTP_DATA *nntp_data;
+  char buf[HUGE_STRING];
+  char server[LONG_STRING];
+  char *group;
+  int rc;
+  void *hc = NULL;
+  anum_t first, last, count = 0;
+  ciss_url_t url;
+
+  strfcpy (buf, ctx->path, sizeof (buf));
+  if (url_parse_ciss (&url, buf) < 0 || !url.path ||
+     !(url.scheme == U_NNTP || url.scheme == U_NNTPS))
+  {
+    mutt_error (_("%s is an invalid newsgroup specification!"), ctx->path);
+    mutt_sleep (2);
+    return -1;
+  }
+
+  group = url.path;
+  url.path = strchr (url.path, '\0');
+  url_ciss_tostring (&url, server, sizeof (server), 0);
+  nserv = nntp_select_server (server, 1);
+  if (!nserv)
+    return -1;
+  CurrentNewsSrv = nserv;
+
+  /* find news group data structure */
+  nntp_data = hash_find (nserv->groups_hash, group);
+  if (!nntp_data)
+  {
+    nntp_newsrc_close (nserv);
+    mutt_error (_("Newsgroup %s not found on the server."), group);
+    mutt_sleep (2);
+    return -1;
+  }
+
+  mutt_bit_unset (ctx->rights, MUTT_ACL_INSERT);
+  if (!nntp_data->newsrc_ent && !nntp_data->subscribed &&
+      !option (OPTSAVEUNSUB))
+    ctx->readonly = 1;
+
+  /* select newsgroup */
+  mutt_message (_("Selecting %s..."), group);
+  buf[0] = '\0';
+  if (nntp_query (nntp_data, buf, sizeof (buf)) < 0)
+  {
+    nntp_newsrc_close (nserv);
+    return -1;
+  }
+
+  /* newsgroup not found, remove it */
+  if (!mutt_strncmp ("411", buf, 3))
+  {
+    mutt_error (_("Newsgroup %s has been removed from the server."),
+		nntp_data->group);
+    if (!nntp_data->deleted)
+    {
+      nntp_data->deleted = 1;
+      nntp_active_save_cache (nserv);
+    }
+    if (nntp_data->newsrc_ent && !nntp_data->subscribed &&
+	!option (OPTSAVEUNSUB))
+    {
+      FREE (&nntp_data->newsrc_ent);
+      nntp_data->newsrc_len = 0;
+      nntp_delete_group_cache (nntp_data);
+      nntp_newsrc_update (nserv);
+    }
+    mutt_sleep (2);
+  }
+
+  /* parse newsgroup info */
+  else {
+    if (sscanf (buf, "211 " ANUM " " ANUM " " ANUM, &count, &first, &last) != 3)
+    {
+      nntp_newsrc_close (nserv);
+      mutt_error ("GROUP: %s", buf);
+      mutt_sleep (2);
+      return -1;
+    }
+    nntp_data->firstMessage = first;
+    nntp_data->lastMessage = last;
+    nntp_data->deleted = 0;
+
+    /* get description if empty */
+    if (option (OPTLOADDESC) && !nntp_data->desc)
+    {
+      if (get_description (nntp_data, NULL, NULL) < 0)
+      {
+	nntp_newsrc_close (nserv);
+	return -1;
+      }
+      if (nntp_data->desc)
+	nntp_active_save_cache (nserv);
+    }
+  }
+
+  time (&nserv->check_time);
+  ctx->data = nntp_data;
+  // QWQ
+  // ctx->mx_close = nntp_fastclose_mailbox;
+  if (!nntp_data->bcache && (nntp_data->newsrc_ent ||
+      nntp_data->subscribed || option (OPTSAVEUNSUB)))
+    nntp_data->bcache = mutt_bcache_open (&nserv->conn->account,
+			nntp_data->group);
+
+  /* strip off extra articles if adding context is greater than $nntp_context */
+  first = nntp_data->firstMessage;
+  if (NntpContext && nntp_data->lastMessage - first + 1 > NntpContext)
+    first = nntp_data->lastMessage - NntpContext + 1;
+  nntp_data->lastLoaded = first ? first - 1 : 0;
+  count = nntp_data->firstMessage;
+  nntp_data->firstMessage = first;
+  nntp_bcache_update (nntp_data);
+  nntp_data->firstMessage = count;
+#ifdef USE_HCACHE
+  hc = nntp_hcache_open (nntp_data);
+  nntp_hcache_update (nntp_data, hc);
+#endif
+  if (!hc)
+  {
+    mutt_bit_unset (ctx->rights, MUTT_ACL_WRITE);
+    mutt_bit_unset (ctx->rights, MUTT_ACL_DELETE);
+  }
+  nntp_newsrc_close (nserv);
+  rc = nntp_fetch_headers (ctx, hc, first, nntp_data->lastMessage, 0);
+#ifdef USE_HCACHE
+  mutt_hcache_close (hc);
+#endif
+  if (rc < 0)
+    return -1;
+  nntp_data->lastLoaded = nntp_data->lastMessage;
+  nserv->newsrc_modified = 0;
+  return 0;
+}
+
+/* Fetch message */
+int nntp_fetch_message (CONTEXT *ctx, MESSAGE *msg, int msgno)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  NNTP_ACACHE *acache;
+  HEADER *hdr = ctx->hdrs[msgno];
+  char buf[_POSIX_PATH_MAX];
+  char article[16];
+  char *fetch_msg = _("Fetching message...");
+  int rc;
+
+  /* try to get article from cache */
+  acache = &nntp_data->acache[hdr->index % NNTP_ACACHE_LEN];
+  if (acache->path)
+  {
+    if (acache->index == hdr->index)
+    {
+      msg->fp = fopen (acache->path, "r");
+      if (msg->fp)
+	return 0;
+    }
+    /* clear previous entry */
+    else
+    {
+      unlink (acache->path);
+      FREE (&acache->path);
+    }
+  }
+  snprintf (article, sizeof (article), "%d", NHDR (hdr)->article_num);
+  msg->fp = mutt_bcache_get (nntp_data->bcache, article);
+  if (msg->fp)
+  {
+    if (NHDR (hdr)->parsed)
+      return 0;
+  }
+  else
+  {
+    /* don't try to fetch article from removed newsgroup */
+    if (nntp_data->deleted)
+      return -1;
+
+    /* create new cache file */
+    mutt_message (fetch_msg);
+    msg->fp = mutt_bcache_put (nntp_data->bcache, article, 1);
+    if (!msg->fp)
+    {
+      mutt_mktemp (buf, sizeof (buf));
+      acache->path = safe_strdup (buf);
+      acache->index = hdr->index;
+      msg->fp = safe_fopen (acache->path, "w+");
+      if (!msg->fp)
+      {
+	mutt_perror (acache->path);
+	unlink (acache->path);
+	FREE (&acache->path);
+	return -1;
+      }
+    }
+
+    /* fetch message to cache file */
+    snprintf (buf, sizeof (buf), "ARTICLE %s\r\n",
+	      NHDR (hdr)->article_num ? article : hdr->env->message_id);
+    rc = nntp_fetch_lines (nntp_data, buf, sizeof (buf), fetch_msg,
+			   fetch_tempfile, msg->fp);
+    if (rc)
+    {
+      safe_fclose (&msg->fp);
+      if (acache->path)
+      {
+	unlink (acache->path);
+	FREE (&acache->path);
+      }
+      if (rc > 0)
+      {
+	if (!mutt_strncmp (NHDR (hdr)->article_num ? "423" : "430", buf, 3))
+	  mutt_error (_("Article %d not found on the server."),
+		      NHDR (hdr)->article_num ? article : hdr->env->message_id);
+	else
+	  mutt_error ("ARTICLE: %s", buf);
+      }
+      return -1;
+    }
+
+    if (!acache->path)
+      mutt_bcache_commit (nntp_data->bcache, article);
+  }
+
+  /* replace envelope with new one
+   * hash elements must be updated because pointers will be changed */
+  if (ctx->id_hash && hdr->env->message_id)
+    hash_delete (ctx->id_hash, hdr->env->message_id, hdr, NULL);
+  if (ctx->subj_hash && hdr->env->real_subj)
+    hash_delete (ctx->subj_hash, hdr->env->real_subj, hdr, NULL);
+
+  mutt_free_envelope (&hdr->env);
+  hdr->env = mutt_read_rfc822_header (msg->fp, hdr, 0, 0);
+
+  if (ctx->id_hash && hdr->env->message_id)
+    hash_insert (ctx->id_hash, hdr->env->message_id, hdr, 0);
+  if (ctx->subj_hash && hdr->env->real_subj)
+    hash_insert (ctx->subj_hash, hdr->env->real_subj, hdr, 1);
+
+  /* fix content length */
+  fseek (msg->fp, 0, SEEK_END);
+  hdr->content->length = ftell (msg->fp) - hdr->content->offset;
+
+  /* this is called in mutt before the open which fetches the message,
+   * which is probably wrong, but we just call it again here to handle
+   * the problem instead of fixing it */
+  NHDR (hdr)->parsed = 1;
+  mutt_parse_mime_message (ctx, hdr);
+
+  /* these would normally be updated in mx_update_context(), but the
+   * full headers aren't parsed with overview, so the information wasn't
+   * available then */
+  if (WithCrypto)
+    hdr->security = crypt_query (hdr->content);
+
+  rewind (msg->fp);
+  mutt_clear_error();
+  return 0;
+}
+
+/* Close message */
+static int nntp_close_message (CONTEXT *ctx, MESSAGE *msg)
+{
+  return safe_fclose (&msg->fp);
+}
+
+/* Post article */
+int nntp_post (const char *msg) {
+  NNTP_DATA *nntp_data, nntp_tmp;
+  FILE *fp;
+  char buf[LONG_STRING];
+  size_t len;
+
+  if (Context && Context->magic == MUTT_NNTP)
+    nntp_data = Context->data;
+  else
+  {
+    CurrentNewsSrv = nntp_select_server (NewsServer, 0);
+    if (!CurrentNewsSrv)
+      return -1;
+
+    nntp_data = &nntp_tmp;
+    nntp_data->nserv = CurrentNewsSrv;
+    nntp_data->group = NULL;
+  }
+
+  fp = safe_fopen (msg, "r");
+  if (!fp)
+  {
+    mutt_perror (msg);
+    return -1;
+  }
+
+  strfcpy (buf, "POST\r\n", sizeof (buf));
+  if (nntp_query (nntp_data, buf, sizeof (buf)) < 0)
+    return -1;
+  if (buf[0] != '3')
+  {
+    mutt_error (_("Can't post article: %s"), buf);
+    return -1;
+  }
+
+  buf[0] = '.';
+  buf[1] = '\0';
+  while (fgets (buf + 1, sizeof (buf) - 2, fp))
+  {
+    len = strlen (buf);
+    if (buf[len - 1] == '\n')
+    {
+      buf[len - 1] = '\r';
+      buf[len] = '\n';
+      len++;
+      buf[len] = '\0';
+    }
+    if (mutt_socket_write_d (nntp_data->nserv->conn,
+	buf[1] == '.' ? buf : buf + 1, -1, MUTT_SOCK_LOG_HDR) < 0)
+      return nntp_connect_error (nntp_data->nserv);
+  }
+  fclose (fp);
+
+  if ((buf[strlen (buf) - 1] != '\n' &&
+      mutt_socket_write_d (nntp_data->nserv->conn, "\r\n", -1, MUTT_SOCK_LOG_HDR) < 0) ||
+      mutt_socket_write_d (nntp_data->nserv->conn, ".\r\n", -1, MUTT_SOCK_LOG_HDR) < 0 ||
+      mutt_socket_readln (buf, sizeof (buf), nntp_data->nserv->conn) < 0)
+    return nntp_connect_error (nntp_data->nserv);
+  if (buf[0] != '2')
+  {
+    mutt_error (_("Can't post article: %s"), buf);
+    return -1;
+  }
+  return 0;
+}
+
+/* Save changes to .newsrc and cache */
+int nntp_sync_mailbox (CONTEXT *ctx)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  int rc, i;
+#ifdef USE_HCACHE
+  header_cache_t *hc;
+#endif
+
+  /* check for new articles */
+  nntp_data->nserv->check_time = 0;
+  rc = nntp_check_mailbox (ctx, NULL);
+  if (rc)
+    return rc;
+
+#ifdef USE_HCACHE
+  nntp_data->lastCached = 0;
+  hc = nntp_hcache_open (nntp_data);
+#endif
+
+  nntp_data->unread = ctx->unread;
+  for (i = 0; i < ctx->msgcount; i++)
+  {
+    HEADER *hdr = ctx->hdrs[i];
+    char buf[16];
+
+    snprintf (buf, sizeof (buf), "%d", NHDR (hdr)->article_num);
+    if (nntp_data->bcache && hdr->deleted)
+    {
+      dprint (2, (debugfile, "nntp_sync_mailbox: mutt_bcache_del %s\n", buf));
+      mutt_bcache_del (nntp_data->bcache, buf);
+    }
+
+#ifdef USE_HCACHE
+    if (hc && (hdr->changed || hdr->deleted))
+    {
+      if (hdr->deleted && !hdr->read)
+	nntp_data->unread--;
+      dprint (2, (debugfile, "nntp_sync_mailbox: mutt_hcache_store %s\n", buf));
+      mutt_hcache_store (hc, buf, hdr, 0, strlen, MUTT_GENERATE_UIDVALIDITY);
+    }
+#endif
+  }
+
+#ifdef USE_HCACHE
+  if (hc)
+  {
+    mutt_hcache_close (hc);
+    nntp_data->lastCached = nntp_data->lastLoaded;
+  }
+#endif
+
+  /* save .newsrc entries */
+  nntp_newsrc_gen_entries (ctx);
+  nntp_newsrc_update (nntp_data->nserv);
+  nntp_newsrc_close (nntp_data->nserv);
+  return 0;
+}
+
+/* Free up memory associated with the newsgroup context */
+int nntp_fastclose_mailbox (CONTEXT *ctx)
+{
+  NNTP_DATA *nntp_data = ctx->data, *nntp_tmp;
+
+  if (!nntp_data)
+    return 0;
+
+  nntp_acache_free (nntp_data);
+  if (!nntp_data->nserv || !nntp_data->nserv->groups_hash || !nntp_data->group)
+    return 0;
+
+  nntp_tmp = hash_find (nntp_data->nserv->groups_hash, nntp_data->group);
+  if (nntp_tmp == NULL || nntp_tmp != nntp_data)
+    nntp_data_free (nntp_data);
+  return 0;
+}
+
+/* Get date and time from server */
+int nntp_date (NNTP_SERVER *nserv, time_t *now)
+{
+  if (nserv->hasDATE)
+  {
+    NNTP_DATA nntp_data;
+    char buf[LONG_STRING];
+    struct tm tm;
+
+    nntp_data.nserv = nserv;
+    nntp_data.group = NULL;
+    strfcpy (buf, "DATE\r\n", sizeof (buf));
+    if (nntp_query (&nntp_data, buf, sizeof (buf)) < 0)
+      return -1;
+
+    if (sscanf (buf, "111 %4d%2d%2d%2d%2d%2d%*s", &tm.tm_year, &tm.tm_mon,
+		&tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec) == 6)
+    {
+      tm.tm_year -= 1900;
+      tm.tm_mon--;
+      *now = timegm (&tm);
+      if (*now >= 0)
+      {
+	dprint (1, (debugfile, "nntp_date: server time is %d\n", *now));
+	return 0;
+      }
+    }
+  }
+  time (now);
+  return 0;
+}
+
+/* Fetch list of all newsgroups from server */
+int nntp_active_fetch (NNTP_SERVER *nserv)
+{
+  NNTP_DATA nntp_data;
+  char msg[SHORT_STRING];
+  char buf[LONG_STRING];
+  unsigned int i;
+  int rc;
+
+  snprintf (msg, sizeof (msg), _("Loading list of groups from server %s..."),
+	    nserv->conn->account.host);
+  mutt_message (msg);
+  if (nntp_date (nserv, &nserv->newgroups_time) < 0)
+    return -1;
+
+  nntp_data.nserv = nserv;
+  nntp_data.group = NULL;
+  strfcpy (buf, "LIST\r\n", sizeof (buf));
+  rc = nntp_fetch_lines (&nntp_data, buf, sizeof (buf), msg,
+			 nntp_add_group, nserv);
+  if (rc)
+  {
+    if (rc > 0)
+    {
+      mutt_error ("LIST: %s", buf);
+      mutt_sleep (2);
+    }
+    return -1;
+  }
+
+  if (option (OPTLOADDESC) &&
+      get_description (&nntp_data, "*", _("Loading descriptions...")) < 0)
+    return -1;
+
+  for (i = 0; i < nserv->groups_num; i++)
+  {
+    NNTP_DATA *nntp_data = nserv->groups_list[i];
+
+    if (nntp_data && nntp_data->deleted && !nntp_data->newsrc_ent)
+    {
+      nntp_delete_group_cache (nntp_data);
+      hash_delete (nserv->groups_hash, nntp_data->group, NULL, nntp_data_free);
+      nserv->groups_list[i] = NULL;
+    }
+  }
+  nntp_active_save_cache (nserv);
+  mutt_clear_error ();
+  return 0;
+}
+
+/* Check newsgroup for new articles:
+ *  1 - new articles found
+ *  0 - no change
+ * -1 - lost connection */
+static int nntp_group_poll (NNTP_DATA *nntp_data, int update_stat)
+{
+  char buf[LONG_STRING] = "";
+  anum_t count, first, last;
+
+  /* use GROUP command to poll newsgroup */
+  if (nntp_query (nntp_data, buf, sizeof (buf)) < 0)
+    return -1;
+  if (sscanf (buf, "211 " ANUM " " ANUM " " ANUM, &count, &first, &last) != 3)
+    return 0;
+  if (first == nntp_data->firstMessage && last == nntp_data->lastMessage)
+    return 0;
+
+  /* articles have been renumbered */
+  if (last < nntp_data->lastMessage)
+  {
+    nntp_data->lastCached = 0;
+    if (nntp_data->newsrc_len)
+    {
+      safe_realloc (&nntp_data->newsrc_ent, sizeof (NEWSRC_ENTRY));
+      nntp_data->newsrc_len = 1;
+      nntp_data->newsrc_ent[0].first = 1;
+      nntp_data->newsrc_ent[0].last = 0;
+    }
+  }
+  nntp_data->firstMessage = first;
+  nntp_data->lastMessage = last;
+  if (!update_stat)
+    return 1;
+
+  /* update counters */
+  else if (!last || (!nntp_data->newsrc_ent && !nntp_data->lastCached))
+    nntp_data->unread = count;
+  else
+    nntp_group_unread_stat (nntp_data);
+  return 1;
+}
+
+/* Check current newsgroup for new articles:
+ *  MUTT_REOPENED	- articles have been renumbered or removed from server
+ *  MUTT_NEW_MAIL	- new articles found
+ *  0		- no change
+ * -1		- lost connection */
+int nntp_check_mailbox (CONTEXT *ctx, int *index_hint)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  NNTP_SERVER *nserv = nntp_data->nserv;
+  time_t now = time (NULL);
+  int i, j;
+  int rc, ret = 0;
+  void *hc = NULL;
+
+  if (nserv->check_time + NewsPollTimeout > now)
+    return 0;
+
+  mutt_message _("Checking for new messages...");
+  if (nntp_newsrc_parse (nserv) < 0)
+    return -1;
+
+  nserv->check_time = now;
+  rc = nntp_group_poll (nntp_data, 0);
+  if (rc < 0)
+  {
+    nntp_newsrc_close (nserv);
+    return -1;
+  }
+  if (rc)
+    nntp_active_save_cache (nserv);
+
+  /* articles have been renumbered, remove all headers */
+  if (nntp_data->lastMessage < nntp_data->lastLoaded)
+  {
+    for (i = 0; i < ctx->msgcount; i++)
+      mutt_free_header (&ctx->hdrs[i]);
+    ctx->msgcount = 0;
+    ctx->tagged = 0;
+
+    if (nntp_data->lastMessage < nntp_data->lastLoaded)
+    {
+      nntp_data->lastLoaded = nntp_data->firstMessage - 1;
+      if (NntpContext && nntp_data->lastMessage - nntp_data->lastLoaded >
+	  NntpContext)
+	nntp_data->lastLoaded = nntp_data->lastMessage - NntpContext;
+    }
+    ret = MUTT_REOPENED;
+  }
+
+  /* .newsrc has been externally modified */
+  if (nserv->newsrc_modified)
+  {
+    anum_t anum;
+#ifdef USE_HCACHE
+    unsigned char *messages;
+    char buf[16];
+    void *hdata;
+    HEADER *hdr;
+    anum_t first = nntp_data->firstMessage;
+
+    if (NntpContext && nntp_data->lastMessage - first + 1 > NntpContext)
+      first = nntp_data->lastMessage - NntpContext + 1;
+    messages = safe_calloc (nntp_data->lastLoaded - first + 1,
+			    sizeof (unsigned char));
+    hc = nntp_hcache_open (nntp_data);
+    nntp_hcache_update (nntp_data, hc);
+#endif
+
+    /* update flags according to .newsrc */
+    for (i = j = 0; i < ctx->msgcount; i++)
+    {
+      int flagged = 0;
+      anum = NHDR (ctx->hdrs[i])->article_num;
+
+#ifdef USE_HCACHE
+      /* check hcache for flagged and deleted flags */
+      if (hc)
+      {
+	if (anum >= first && anum <= nntp_data->lastLoaded)
+	  messages[anum - first] = 1;
+
+	snprintf (buf, sizeof (buf), "%d", anum);
+	hdata = mutt_hcache_fetch (hc, buf, strlen);
+	if (hdata)
+	{
+	  int deleted;
+
+	  dprint (2, (debugfile,
+		      "nntp_check_mailbox: mutt_hcache_fetch %s\n", buf));
+	  hdr = mutt_hcache_restore (hdata, NULL);
+	  FREE (&hdata);
+	  hdr->data = 0;
+	  deleted = hdr->deleted;
+	  flagged = hdr->flagged;
+	  mutt_free_header (&hdr);
+
+	  /* header marked as deleted, removing from context */
+	  if (deleted)
+	  {
+	    mutt_set_flag (ctx, ctx->hdrs[i], MUTT_TAG, 0);
+	    mutt_free_header (&ctx->hdrs[i]);
+	    continue;
+	  }
+	}
+      }
+#endif
+
+      if (!ctx->hdrs[i]->changed)
+      {
+	ctx->hdrs[i]->flagged = flagged;
+	ctx->hdrs[i]->read = 0;
+	ctx->hdrs[i]->old = 0;
+	nntp_article_status (ctx, ctx->hdrs[i], NULL, anum);
+	if (!ctx->hdrs[i]->read)
+	  nntp_parse_xref (ctx, ctx->hdrs[i]);
+      }
+      ctx->hdrs[j++] = ctx->hdrs[i];
+    }
+
+#ifdef USE_HCACHE
+    ctx->msgcount = j;
+
+    /* restore headers without "deleted" flag */
+    for (anum = first; anum <= nntp_data->lastLoaded; anum++)
+    {
+      if (messages[anum - first])
+	continue;
+
+      snprintf (buf, sizeof (buf), "%d", anum);
+      hdata = mutt_hcache_fetch (hc, buf, strlen);
+      if (hdata)
+      {
+	dprint (2, (debugfile,
+		    "nntp_check_mailbox: mutt_hcache_fetch %s\n", buf));
+	if (ctx->msgcount >= ctx->hdrmax)
+	  mx_alloc_memory (ctx);
+
+	ctx->hdrs[ctx->msgcount] =
+	hdr = mutt_hcache_restore (hdata, NULL);
+	FREE (&hdata);
+	hdr->data = 0;
+	if (hdr->deleted)
+	{
+	  mutt_free_header (&hdr);
+	  if (nntp_data->bcache)
+	  {
+	    dprint (2, (debugfile,
+			"nntp_check_mailbox: mutt_bcache_del %s\n", buf));
+	    mutt_bcache_del (nntp_data->bcache, buf);
+	  }
+	  continue;
+	}
+
+	ctx->msgcount++;
+	hdr->read = 0;
+	hdr->old = 0;
+	hdr->data = safe_calloc (1, sizeof (NNTP_HEADER_DATA));
+	NHDR (hdr)->article_num = anum;
+	nntp_article_status (ctx, hdr, NULL, anum);
+	if (!hdr->read)
+	  nntp_parse_xref (ctx, hdr);
+      }
+    }
+    FREE (&messages);
+#endif
+
+    nserv->newsrc_modified = 0;
+    ret = MUTT_REOPENED;
+  }
+
+  /* some headers were removed, context must be updated */
+  if (ret == MUTT_REOPENED)
+  {
+    if (ctx->subj_hash)
+      hash_destroy (&ctx->subj_hash, NULL);
+    if (ctx->id_hash)
+      hash_destroy (&ctx->id_hash, NULL);
+    mutt_clear_threads (ctx);
+
+    ctx->vcount = 0;
+    ctx->deleted = 0;
+    ctx->new = 0;
+    ctx->unread = 0;
+    ctx->flagged = 0;
+    ctx->changed = 0;
+    ctx->id_hash = NULL;
+    ctx->subj_hash = NULL;
+    mx_update_context (ctx, ctx->msgcount);
+  }
+
+  /* fetch headers of new articles */
+  if (nntp_data->lastMessage > nntp_data->lastLoaded)
+  {
+    int oldmsgcount = ctx->msgcount;
+    int quiet = ctx->quiet;
+    ctx->quiet = 1;
+#ifdef USE_HCACHE
+    if (!hc)
+    {
+      hc = nntp_hcache_open (nntp_data);
+      nntp_hcache_update (nntp_data, hc);
+    }
+#endif
+    rc = nntp_fetch_headers (ctx, hc, nntp_data->lastLoaded + 1,
+			     nntp_data->lastMessage, 0);
+    ctx->quiet = quiet;
+    if (rc >= 0)
+      nntp_data->lastLoaded = nntp_data->lastMessage;
+    if (ret == 0 && ctx->msgcount > oldmsgcount)
+      ret = MUTT_NEW_MAIL;
+  }
+
+#ifdef USE_HCACHE
+  mutt_hcache_close (hc);
+#endif
+  /* If there's an error, or we've been called from nntp_sync_mailbox() */
+  if (ret || !index_hint)
+    nntp_newsrc_close (nserv);
+  mutt_clear_error ();
+  return ret;
+}
+
+/* Check for new groups and new articles in subscribed groups:
+ *  1 - new groups found
+ *  0 - no new groups
+ * -1 - error */
+int nntp_check_new_groups (NNTP_SERVER *nserv)
+{
+  NNTP_DATA nntp_data;
+  time_t now;
+  struct tm *tm;
+  char buf[LONG_STRING];
+  char *msg = _("Checking for new newsgroups...");
+  unsigned int i;
+  int rc, update_active = FALSE;
+
+  if (!nserv || !nserv->newgroups_time)
+    return -1;
+
+  /* check subscribed newsgroups for new articles */
+  if (option (OPTSHOWNEWNEWS))
+  {
+    mutt_message _("Checking for new messages...");
+    for (i = 0; i < nserv->groups_num; i++)
+    {
+      NNTP_DATA *nntp_data = nserv->groups_list[i];
+
+      if (nntp_data && nntp_data->subscribed)
+      {
+	rc = nntp_group_poll (nntp_data, 1);
+	if (rc < 0)
+	  return -1;
+	if (rc > 0)
+	  update_active = TRUE;
+      }
+    }
+    /* select current newsgroup */
+    if (Context && Context->magic == MUTT_NNTP)
+    {
+      buf[0] = '\0';
+      if (nntp_query ((NNTP_DATA *)Context->data, buf, sizeof (buf)) < 0)
+	return -1;
+    }
+  }
+  else if (nserv->newgroups_time)
+    return 0;
+
+  /* get list of new groups */
+  mutt_message (msg);
+  if (nntp_date (nserv, &now) < 0)
+    return -1;
+  nntp_data.nserv = nserv;
+  if (Context && Context->magic == MUTT_NNTP)
+    nntp_data.group = ((NNTP_DATA *)Context->data)->group;
+  else
+    nntp_data.group = NULL;
+  i = nserv->groups_num;
+  tm = gmtime (&nserv->newgroups_time);
+  snprintf (buf, sizeof (buf), "NEWGROUPS %02d%02d%02d %02d%02d%02d GMT\r\n",
+	    tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday,
+	    tm->tm_hour, tm->tm_min, tm->tm_sec);
+  rc = nntp_fetch_lines (&nntp_data, buf, sizeof (buf), msg,
+			 nntp_add_group, nserv);
+  if (rc)
+  {
+    if (rc > 0)
+    {
+      mutt_error ("NEWGROUPS: %s", buf);
+      mutt_sleep (2);
+    }
+    return -1;
+  }
+
+  /* new groups found */
+  rc = 0;
+  if (nserv->groups_num != i)
+  {
+    nserv->newgroups_time = now;
+
+    /* loading descriptions */
+    if (option (OPTLOADDESC))
+    {
+      unsigned int count = 0;
+      progress_t progress;
+
+      mutt_progress_init (&progress, _("Loading descriptions..."),
+			  MUTT_PROGRESS_MSG, ReadInc, nserv->groups_num - i);
+      for (; i < nserv->groups_num; i++)
+      {
+	NNTP_DATA *nntp_data = nserv->groups_list[i];
+
+	if (get_description (nntp_data, NULL, NULL) < 0)
+	  return -1;
+	mutt_progress_update (&progress, ++count, -1);
+      }
+    }
+    update_active = TRUE;
+    rc = 1;
+  }
+  if (update_active)
+    nntp_active_save_cache (nserv);
+  mutt_clear_error ();
+  return rc;
+}
+
+/* Fetch article by Message-ID:
+ *  0 - success
+ *  1 - no such article
+ * -1 - error */
+int nntp_check_msgid (CONTEXT *ctx, const char *msgid)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  HEADER *hdr;
+  FILE *fp;
+  char tempfile[_POSIX_PATH_MAX];
+  char buf[LONG_STRING];
+  int rc;
+
+  mutt_mktemp (tempfile, sizeof (tempfile));
+  fp = safe_fopen (tempfile, "w+");
+  if (!fp)
+  {
+    mutt_perror (tempfile);
+    unlink (tempfile);
+    return -1;
+  }
+
+  snprintf (buf, sizeof (buf), "HEAD %s\r\n", msgid);
+  rc = nntp_fetch_lines (nntp_data, buf, sizeof (buf), NULL,
+			 fetch_tempfile, fp);
+  if (rc)
+  {
+    fclose (fp);
+    unlink (tempfile);
+    if (rc < 0)
+      return -1;
+    if (!mutt_strncmp ("430", buf, 3))
+      return 1;
+    mutt_error ("HEAD: %s", buf);
+    return -1;
+  }
+
+  /* parse header */
+  if (ctx->msgcount == ctx->hdrmax)
+    mx_alloc_memory (ctx);
+  hdr = ctx->hdrs[ctx->msgcount] = mutt_new_header ();
+  hdr->data = safe_calloc (1, sizeof (NNTP_HEADER_DATA));
+  hdr->env = mutt_read_rfc822_header (fp, hdr, 0, 0);
+  fclose (fp);
+  unlink (tempfile);
+
+  /* get article number */
+  if (hdr->env->xref)
+    nntp_parse_xref (ctx, hdr);
+  else
+  {
+    snprintf (buf, sizeof (buf), "STAT %s\r\n", msgid);
+    if (nntp_query (nntp_data, buf, sizeof (buf)) < 0)
+    {
+      mutt_free_header (&hdr);
+      return -1;
+    }
+    sscanf (buf + 4, ANUM, &NHDR (hdr)->article_num);
+  }
+
+  /* reset flags */
+  hdr->read = 0;
+  hdr->old = 0;
+  hdr->deleted = 0;
+  hdr->changed = 1;
+  hdr->received = hdr->date_sent;
+  hdr->index = ctx->msgcount++;
+  mx_update_context (ctx, 1);
+  return 0;
+}
+
+typedef struct
+{
+  CONTEXT *ctx;
+  unsigned int num;
+  unsigned int max;
+  anum_t *child;
+} CHILD_CTX;
+
+/* Parse XPAT line */
+static int fetch_children (char *line, void *data)
+{
+  CHILD_CTX *cc = data;
+  anum_t anum;
+  unsigned int i;
+
+  if (!line || sscanf (line, ANUM, &anum) != 1)
+    return 0;
+  for (i = 0; i < cc->ctx->msgcount; i++)
+    if (NHDR (cc->ctx->hdrs[i])->article_num == anum)
+      return 0;
+  if (cc->num >= cc->max)
+  {
+    cc->max *= 2;
+    safe_realloc (&cc->child, sizeof (anum_t) * cc->max);
+  }
+  cc->child[cc->num++] = anum;
+  return 0;
+}
+
+/* Fetch children of article with the Message-ID */
+int nntp_check_children (CONTEXT *ctx, const char *msgid)
+{
+  NNTP_DATA *nntp_data = ctx->data;
+  CHILD_CTX cc;
+  char buf[STRING];
+  int i, rc, quiet;
+  void *hc = NULL;
+
+  if (!nntp_data || !nntp_data->nserv)
+    return -1;
+  if (nntp_data->firstMessage > nntp_data->lastLoaded)
+    return 0;
+
+  /* init context */
+  cc.ctx = ctx;
+  cc.num = 0;
+  cc.max = 10;
+  cc.child = safe_malloc (sizeof (anum_t) * cc.max);
+
+  /* fetch numbers of child messages */
+  snprintf (buf, sizeof (buf), "XPAT References %d-%d *%s*\r\n",
+	    nntp_data->firstMessage, nntp_data->lastLoaded, msgid);
+  rc = nntp_fetch_lines (nntp_data, buf, sizeof (buf), NULL,
+			 fetch_children, &cc);
+  if (rc)
+  {
+    FREE (&cc.child);
+    if (rc > 0) {
+      if (mutt_strncmp ("500", buf, 3))
+	mutt_error ("XPAT: %s", buf);
+      else
+	mutt_error _("Unable to find child articles because server does not support XPAT command.");
+    }
+    return -1;
+  }
+
+  /* fetch all found messages */
+  quiet = ctx->quiet;
+  ctx->quiet = 1;
+#ifdef USE_HCACHE
+  hc = nntp_hcache_open (nntp_data);
+#endif
+  for (i = 0; i < cc.num; i++)
+  {
+    rc = nntp_fetch_headers (ctx, hc, cc.child[i], cc.child[i], 1);
+    if (rc < 0)
+      break;
+  }
+#ifdef USE_HCACHE
+  mutt_hcache_close (hc);
+#endif
+  ctx->quiet = quiet;
+  FREE (&cc.child);
+  return rc < 0 ? -1 : 0;
+}
+
+struct mx_ops mx_nntp_ops = {
+  .open         = nntp_open_mailbox,
+  .open_append  = NULL,
+  .close        = nntp_fastclose_mailbox,
+  .check        = nntp_check_mailbox,
+  .open_msg     = nntp_fetch_message,
+  .close_msg    = nntp_close_message,
+  .commit_msg   = NULL,
+  .open_new_msg = NULL
+};
+
diff --git c/nntp.h w/nntp.h
new file mode 100644
index 0000000..9db9ef5
--- /dev/null
+++ w/nntp.h
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 1998 Brandon Long <blong@fiction.net>
+ * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>
+ * Copyright (C) 2000-2012 Vsevolod Volkov <vvv@mutt.org.ua>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _NNTP_H_
+#define _NNTP_H_ 1
+
+#include "mutt_socket.h"
+#include "mailbox.h"
+#include "bcache.h"
+
+#if USE_HCACHE
+#include "hcache.h"
+#endif
+
+#include <time.h>
+#include <sys/types.h>
+#include <stdint.h>
+
+#define NNTP_PORT 119
+#define NNTP_SSL_PORT 563
+
+/* number of entries in article cache */
+#define NNTP_ACACHE_LEN 10
+
+/* article number type and format */
+#define anum_t uint32_t
+#define ANUM "%u"
+
+enum
+{
+  NNTP_NONE = 0,
+  NNTP_OK,
+  NNTP_BYE
+};
+
+typedef struct
+{
+  unsigned int hasCAPABILITIES : 1;
+  unsigned int hasSTARTTLS : 1;
+  unsigned int hasDATE : 1;
+  unsigned int hasLIST_NEWSGROUPS : 1;
+  unsigned int hasXGTITLE : 1;
+  unsigned int hasLISTGROUP : 1;
+  unsigned int hasLISTGROUPrange : 1;
+  unsigned int hasOVER : 1;
+  unsigned int hasXOVER : 1;
+  unsigned int use_tls : 3;
+  unsigned int status : 3;
+  unsigned int cacheable : 1;
+  unsigned int newsrc_modified : 1;
+  FILE *newsrc_fp;
+  char *newsrc_file;
+  char *authenticators;
+  char *overview_fmt;
+  off_t size;
+  time_t mtime;
+  time_t newgroups_time;
+  time_t check_time;
+  unsigned int groups_num;
+  unsigned int groups_max;
+  void **groups_list;
+  HASH *groups_hash;
+  CONNECTION *conn;
+} NNTP_SERVER;
+
+typedef struct
+{
+  anum_t first;
+  anum_t last;
+} NEWSRC_ENTRY;
+
+typedef struct
+{
+  unsigned int index;
+  char *path;
+} NNTP_ACACHE;
+
+typedef struct
+{
+  char *group;
+  char *desc;
+  anum_t firstMessage;
+  anum_t lastMessage;
+  anum_t lastLoaded;
+  anum_t lastCached;
+  anum_t unread;
+  unsigned int subscribed : 1;
+  unsigned int new : 1;
+  unsigned int allowed : 1;
+  unsigned int deleted : 1;
+  unsigned int newsrc_len;
+  NEWSRC_ENTRY *newsrc_ent;
+  NNTP_SERVER *nserv;
+  NNTP_ACACHE acache[NNTP_ACACHE_LEN];
+  body_cache_t *bcache;
+} NNTP_DATA;
+
+typedef struct
+{
+  anum_t article_num;
+  unsigned int parsed : 1;
+} NNTP_HEADER_DATA;
+
+#define NHDR(hdr) ((NNTP_HEADER_DATA*)((hdr)->data))
+
+/* internal functions */
+int nntp_add_group (char *, void *);
+int nntp_active_save_cache (NNTP_SERVER *);
+int nntp_check_new_groups (NNTP_SERVER *);
+int nntp_fastclose_mailbox (CONTEXT *);
+int nntp_open_connection (NNTP_SERVER *);
+void nntp_newsrc_gen_entries (CONTEXT *);
+void nntp_bcache_update (NNTP_DATA *);
+void nntp_article_status (CONTEXT *, HEADER *, char *, anum_t);
+void nntp_group_unread_stat (NNTP_DATA *);
+void nntp_data_free (void *);
+void nntp_acache_free (NNTP_DATA *);
+void nntp_delete_group_cache (NNTP_DATA *);
+
+/* exposed interface */
+NNTP_SERVER *nntp_select_server (char *, int);
+NNTP_DATA *mutt_newsgroup_subscribe (NNTP_SERVER *, char *);
+NNTP_DATA *mutt_newsgroup_unsubscribe (NNTP_SERVER *, char *);
+NNTP_DATA *mutt_newsgroup_catchup (NNTP_SERVER *, char *);
+NNTP_DATA *mutt_newsgroup_uncatchup (NNTP_SERVER *, char *);
+int nntp_active_fetch (NNTP_SERVER *);
+int nntp_newsrc_update (NNTP_SERVER *);
+int nntp_open_mailbox (CONTEXT *);
+int nntp_sync_mailbox (CONTEXT *);
+int nntp_check_mailbox (CONTEXT *, int*);
+int nntp_fetch_message (CONTEXT *, MESSAGE *, int);
+int nntp_post (const char *);
+int nntp_check_msgid (CONTEXT *, const char *);
+int nntp_check_children (CONTEXT *, const char *);
+int nntp_newsrc_parse (NNTP_SERVER *);
+void nntp_newsrc_close (NNTP_SERVER *);
+void nntp_buffy (char *, size_t);
+void nntp_expand_path (char *, size_t, ACCOUNT *);
+void nntp_clear_cache (NNTP_SERVER *);
+const char *nntp_format_str (char *, size_t, size_t, int, char, const char *,
+			     const char *, const char *, const char *,
+			     unsigned long, format_flag);
+
+NNTP_SERVER *CurrentNewsSrv INITVAL (NULL);
+
+#ifdef USE_HCACHE
+header_cache_t *nntp_hcache_open (NNTP_DATA *);
+void nntp_hcache_update (NNTP_DATA *, header_cache_t *);
+#endif
+
+extern struct mx_ops mx_nntp_ops;
+
+#endif /* _NNTP_H_ */
diff --git c/pager.c w/pager.c
index d7674eb..b2e360d 100644
--- c/pager.c
+++ w/pager.c
@@ -29,6 +29,7 @@
 #include "pager.h"
 #include "attach.h"
 #include "mbyte.h"
+#include "mailbox.h"
 #ifdef USE_SIDEBAR
 #include "sidebar.h"
 #endif
@@ -65,7 +66,7 @@ static HEADER *OldHdr = NULL;
 				break; \
 			}
 
-#define CHECK_READONLY	if (Context->readonly) \
+#define CHECK_READONLY	if (!Context || Context->readonly) \
 			{ \
 				mutt_flushinp (); \
 				mutt_error _(Mailbox_is_read_only);	\
@@ -80,7 +81,7 @@ static HEADER *OldHdr = NULL;
 		     }
 
 #define CHECK_ACL(aclbit,action) \
-		if (!mutt_bit_isset(Context->rights,aclbit)) { \
+		if (!Context || !mutt_bit_isset(Context->rights,aclbit)) { \
 			mutt_flushinp(); \
         /* L10N: %s is one of the CHECK_ACL entries below. */ \
 			mutt_error (_("%s: Operation not permitted by ACL"), action); \
@@ -901,6 +902,68 @@ resolve_types (char *buf, char *raw, struct line_t *lineInfo, int n, int last,
     if (nl > 0)
       buf[nl] = '\n';
   }
+
+  /* attachment patterns */
+  if (lineInfo[n].type == MT_COLOR_ATTACHMENT)
+  {
+    size_t nl;
+
+    /* don't consider line endings part of the buffer for regex matching */
+    nl = mutt_strlen (buf);
+    if ((nl > 0) && (buf[nl - 1] == '\n'))
+      buf[nl - 1] = 0;
+
+    i = 0;
+    offset = 0;
+    lineInfo[n].chunks = 0;
+    do
+    {
+      if (!buf[offset])
+	break;
+
+      found = 0;
+      null_rx = 0;
+      for (color_line = ColorAttachList; color_line; color_line = color_line->next)
+      {
+	if (regexec (&color_line->rx, buf + offset, 1, pmatch,
+		     (offset ? REG_NOTBOL : 0)) == 0)
+	{
+	  if (pmatch[0].rm_eo != pmatch[0].rm_so)
+	  {
+	    if (!found)
+	    {
+	      if (++(lineInfo[n].chunks) > 1)
+		safe_realloc (&(lineInfo[n].syntax),
+			      (lineInfo[n].chunks) * sizeof (struct syntax_t));
+	    }
+	    i = lineInfo[n].chunks - 1;
+	    pmatch[0].rm_so += offset;
+	    pmatch[0].rm_eo += offset;
+	    if (!found ||
+		 pmatch[0].rm_so <  (lineInfo[n].syntax)[i].first ||
+		(pmatch[0].rm_so == (lineInfo[n].syntax)[i].first &&
+		 pmatch[0].rm_eo >  (lineInfo[n].syntax)[i].last))
+	    {
+	      (lineInfo[n].syntax)[i].color = color_line->pair;
+	      (lineInfo[n].syntax)[i].first = pmatch[0].rm_so;
+	      (lineInfo[n].syntax)[i].last  = pmatch[0].rm_eo;
+	    }
+	    found = 1;
+	    null_rx = 0;
+	  }
+	  else
+	    null_rx = 1; /* empty regexp; don't add it, but keep looking */
+	}
+      }
+
+      if (null_rx)
+	offset++; /* avoid degenerate cases */
+      else
+	offset = (lineInfo[n].syntax)[i].last;
+    } while (found || null_rx);
+    if (nl > 0)
+      buf[nl] = '\n';
+  }
 }
 
 static int is_ansi (unsigned char *buf)
@@ -1092,6 +1155,11 @@ fill_buffer (FILE *f, LOFF_T *last_pos, LOFF_T offset, unsigned char **buf,
   return b_read;
 }
 
+#ifdef USE_NNTP
+#include "mx.h"
+#include "nntp.h"
+#endif
+
 
 static int format_line (struct line_t **lineInfo, int n, unsigned char *buf,
 			int flags, ansi_attr *pa, int cnt,
@@ -1563,6 +1631,16 @@ static const struct mapping_t PagerHelpExtra[] = {
   { NULL,	0 }
 };
 
+#ifdef USE_NNTP
+static struct mapping_t PagerNewsHelpExtra[] = {
+  { N_("Post"),     OP_POST },
+  { N_("Followup"), OP_FOLLOWUP },
+  { N_("Del"),      OP_DELETE },
+  { N_("Next"),     OP_MAIN_NEXT_UNDELETED },
+  { NULL,           0 }
+};
+#endif
+
 void mutt_clear_pager_position (void)
 {
   TopLine = 0;
@@ -1607,6 +1685,13 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
   int indicator = indexlen / 3; 	/* the indicator line of the PI */
   int old_PagerIndexLines;		/* some people want to resize it
   					 * while inside the pager... */
+  int index_hint = 0;			/* used to restore cursor position */
+  int oldcount = -1;
+  int check;
+
+#ifdef USE_NNTP
+  char *followup_to;
+#endif
 
   if (!(flags & MUTT_SHOWCOLOR))
     flags |= MUTT_SHOWFLAT;
@@ -1627,7 +1712,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 
   /* Initialize variables */
 
-  if (IsHeader (extra) && !extra->hdr->read)
+  if (Context && IsHeader (extra) && !extra->hdr->read)
   {
     Context->msgnotreadyet = extra->hdr->msgno;
     mutt_set_flag (Context, extra->hdr, MUTT_READ, 1);
@@ -1647,7 +1732,11 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
   if (IsHeader (extra))
   {
     strfcpy (tmphelp, helpstr, sizeof (tmphelp));
-    mutt_compile_help (buffer, sizeof (buffer), MENU_PAGER, PagerHelpExtra);
+    mutt_compile_help (buffer, sizeof (buffer), MENU_PAGER,
+#ifdef USE_NNTP
+	(Context && (Context->magic == MUTT_NNTP)) ? PagerNewsHelpExtra :
+#endif
+	PagerHelpExtra);
     snprintf (helpstr, sizeof (helpstr), "%s %s", tmphelp, buffer);
   }
   if (!InHelp)
@@ -1676,7 +1765,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
       move (0, 0);
       clrtobot ();
 
-      if (IsHeader (extra) && Context->vcount + 1 < PagerIndexLines)
+      if (IsHeader (extra) && Context && ((Context->vcount + 1) < PagerIndexLines))
 	indexlen = Context->vcount + 1;
       else
 	indexlen = PagerIndexLines;
@@ -1739,7 +1828,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
       }
 #endif
 
-      if (IsHeader (extra) && PagerIndexLines)
+      if (IsHeader (extra))
       {
 	if (index == NULL)
 	{
@@ -1748,7 +1837,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 	  index = mutt_new_menu(MENU_MAIN);
 	  index->make_entry = index_make_entry;
 	  index->color = index_color;
-	  index->max = Context->vcount;
+	  index->max = Context ? Context->vcount : 0;
 	  index->current = extra->hdr->virtual;
           index->indexwin = index_window;
           index->statuswin = index_status_window;
@@ -1860,16 +1949,20 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 	size_t l2 = sizeof (buffer);
 	hfi.hdr = (IsHeader (extra)) ? extra->hdr : extra->bdy->hdr;
 	mutt_make_string_info (buffer, l1 < l2 ? l1 : l2, pager_status_window->cols, NONULL (PagerFmt), &hfi, MUTT_FORMAT_MAKEPRINT);
-	mutt_paddstr (pager_status_window->cols, buffer);
+	mutt_draw_statusline (pager_status_window->cols, buffer, l2);
       }
       else
       {
 	char bn[STRING];
 	snprintf (bn, sizeof (bn), "%s (%s)", banner, pager_progress_str);
-	mutt_paddstr (pager_status_window->cols, bn);
+	mutt_draw_statusline (pager_status_window->cols, bn, sizeof (bn));
       }
       NORMAL_COLOR;
-      if (option(OPTTSENABLED) && TSSupported)
+
+      /*
+       * update terminal status line
+       */
+      if (option(OPTTSENABLED) && TSSupported && index)
       {
 	menu_status_line (buffer, sizeof (buffer), index, NONULL (TSStatusFormat));
 	mutt_ts_status(buffer);
@@ -1878,12 +1971,11 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
       }
     }
 
-    if ((redraw & REDRAW_INDEX) && index)
+    /* redraw the pager_index indicator, because the
+     * flags for this message might have changed. */
+    if ((redraw & REDRAW_INDEX) && index && (index_window->rows > 0))
     {
-      /* redraw the pager_index indicator, because the
-       * flags for this message might have changed. */
-      if (index_window->rows > 0)
-        menu_redraw_current (index);
+      menu_redraw_current (index);
 
       /* print out the index status bar */
       menu_status_line (buffer, sizeof (buffer), index, NONULL(Status));
@@ -1922,6 +2014,40 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
       mutt_clear_error ();
     mutt_curs_set (1);
 
+    if (Context && !option (OPTATTACHMSG))
+    {
+      /* check for new mail */
+      check = mx_check_mailbox (Context, &index_hint);
+      if (check < 0)
+      {
+        if (!Context->path)
+        {
+          /* fatal error occurred */
+          FREE (&Context);
+          redraw = REDRAW_FULL;
+          ch = -1;
+        }
+      }
+      else if ((check == MUTT_NEW_MAIL) || (check == MUTT_REOPENED) || (check == MUTT_FLAGS))
+      {
+        oldcount = Context ? Context->msgcount : 0;
+        update_index (index, Context, check, oldcount, index_hint);
+      }
+      /* notify user of newly arrived mail */
+      if (mutt_buffy_notify())
+      {
+        redraw |= REDRAW_STATUS;
+        if (option (OPTBEEPNEW))
+          beep();
+        if (NewMailCmd)
+        {
+          char cmd[LONG_STRING];
+          menu_status_line (cmd, sizeof (cmd), index, NONULL (NewMailCmd));
+          mutt_system (cmd);
+        }
+      }
+    }
+
     if (SigInt)
     {
       mutt_query_exit ();
@@ -2307,11 +2433,11 @@ search_next:
 	  int dretval = 0;
 	  int new_topline = topline;
 
-	  while ((new_topline < lastLine ||
+	  while (((new_topline + SkipQuotedOffset) < lastLine ||
 		  (0 == (dretval = display_line (fp, &last_pos, &lineInfo,
 			 new_topline, &lastLine, &maxLine, MUTT_TYPES | (flags & MUTT_PAGER_NOWRAP),
                          &QuoteList, &q_level, &force_redraw, &SearchRE, pager_window))))
-		 && lineInfo[new_topline].type != MT_COLOR_QUOTED)
+		 && lineInfo[new_topline + SkipQuotedOffset].type != MT_COLOR_QUOTED)
 	    new_topline++;
 
 	  if (dretval < 0)
@@ -2320,11 +2446,11 @@ search_next:
 	    break;
 	  }
 
-	  while ((new_topline < lastLine ||
+	  while (((new_topline + SkipQuotedOffset) < lastLine ||
 		  (0 == (dretval = display_line (fp, &last_pos, &lineInfo,
 			 new_topline, &lastLine, &maxLine, MUTT_TYPES | (flags & MUTT_PAGER_NOWRAP),
                          &QuoteList, &q_level, &force_redraw, &SearchRE, pager_window))))
-		 && lineInfo[new_topline].type == MT_COLOR_QUOTED)
+		 && lineInfo[new_topline + SkipQuotedOffset].type == MT_COLOR_QUOTED)
 	    new_topline++;
 
 	  if (dretval < 0)
@@ -2389,6 +2515,11 @@ search_next:
         redraw = REDRAW_FULL;
         break;
 
+      case OP_COMPOSE_TO_SENDER:
+	mutt_compose_to_sender (extra->hdr);
+	redraw = REDRAW_FULL;
+	break;
+
       case OP_CHECK_TRADITIONAL:
         CHECK_MODE (IsHeader (extra));
         if (!(WithCrypto & APPLICATION_PGP))
@@ -2444,19 +2575,26 @@ search_next:
 
       case OP_DELETE_THREAD:
       case OP_DELETE_SUBTHREAD:
+      case OP_PURGE_THREAD:
 	CHECK_MODE(IsHeader (extra));
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
 	CHECK_ACL(MUTT_ACL_DELETE, _("Cannot delete message(s)"));
 
-	r = mutt_thread_set_flag (extra->hdr, MUTT_DELETE, 1,
-				  ch == OP_DELETE_THREAD ? 0 : 1);
-
-	if (r != -1)
 	{
+	  int subthread = (ch == OP_DELETE_SUBTHREAD);
+	  r = mutt_thread_set_flag (extra->hdr, MUTT_DELETE, 1, subthread);
+	  if (r == -1)
+	    break;
+	  if (ch == OP_PURGE_THREAD)
+	  {
+	    r = mutt_thread_set_flag (extra->hdr, MUTT_PURGE, 1, subthread);
+	    if (r == -1)
+	      break;
+	  }
+
 	  if (option (OPTDELETEUNTAG))
-	    mutt_thread_set_flag (extra->hdr, MUTT_TAG, 0,
-				  ch == OP_DELETE_THREAD ? 0 : 1);
+	    mutt_thread_set_flag (extra->hdr, MUTT_TAG, 0, subthread);
 	  if (option (OPTRESOLVE))
 	  {
 	    rc = OP_MAIN_NEXT_UNDELETED;
@@ -2603,6 +2741,60 @@ search_next:
 	redraw = REDRAW_FULL;
 	break;
 
+#ifdef USE_NNTP
+      case OP_POST:
+	CHECK_MODE(IsHeader (extra) && !IsAttach (extra));
+	CHECK_ATTACH;
+	if (extra->ctx && extra->ctx->magic == MUTT_NNTP &&
+	    !((NNTP_DATA *)extra->ctx->data)->allowed &&
+	    query_quadoption (OPT_TOMODERATED,_("Posting to this group not allowed, may be moderated. Continue?")) != MUTT_YES)
+	  break;
+	ci_send_message (SENDNEWS, NULL, NULL, extra->ctx, NULL);
+	redraw = REDRAW_FULL;
+	break;
+
+      case OP_FORWARD_TO_GROUP:
+	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra));
+	CHECK_ATTACH;
+	if (extra->ctx && extra->ctx->magic == MUTT_NNTP &&
+	    !((NNTP_DATA *)extra->ctx->data)->allowed &&
+	    query_quadoption (OPT_TOMODERATED,_("Posting to this group not allowed, may be moderated. Continue?")) != MUTT_YES)
+	  break;
+	if (IsMsgAttach (extra))
+	  mutt_attach_forward (extra->fp, extra->hdr, extra->idx,
+			       extra->idxlen, extra->bdy, SENDNEWS);
+	else
+	  ci_send_message (SENDNEWS|SENDFORWARD, NULL, NULL, extra->ctx, extra->hdr);
+	redraw = REDRAW_FULL;
+	break;
+
+      case OP_FOLLOWUP:
+	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra));
+	CHECK_ATTACH;
+
+	if (IsMsgAttach (extra))
+	  followup_to = extra->bdy->hdr->env->followup_to;
+	else
+	  followup_to = extra->hdr->env->followup_to;
+
+	if (!followup_to || mutt_strcasecmp (followup_to, "poster") ||
+	    query_quadoption (OPT_FOLLOWUPTOPOSTER,_("Reply by mail as poster prefers?")) != MUTT_YES)
+	{
+	  if (extra->ctx && extra->ctx->magic == MUTT_NNTP &&
+	      !((NNTP_DATA *)extra->ctx->data)->allowed &&
+	      query_quadoption (OPT_TOMODERATED,_("Posting to this group not allowed, may be moderated. Continue?")) != MUTT_YES)
+	    break;
+	  if (IsMsgAttach (extra))
+	    mutt_attach_reply (extra->fp, extra->hdr, extra->idx,
+			       extra->idxlen, extra->bdy, SENDNEWS|SENDREPLY);
+	  else
+	    ci_send_message (SENDNEWS|SENDREPLY, NULL, NULL,
+			     extra->ctx, extra->hdr);
+	  redraw = REDRAW_FULL;
+	  break;
+	}
+#endif
+
       case OP_REPLY:
 	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra));
         CHECK_ATTACH;      
@@ -2649,7 +2841,7 @@ search_next:
         CHECK_ATTACH;
         if (IsMsgAttach (extra))
 	  mutt_attach_forward (extra->fp, extra->hdr, extra->idx,
-			       extra->idxlen, extra->bdy);
+			       extra->idxlen, extra->bdy, 0);
         else
 	  ci_send_message (SENDFORWARD, NULL, NULL, extra->ctx, extra->hdr);
 	redraw = REDRAW_FULL;
@@ -2707,11 +2899,14 @@ search_next:
 
       case OP_TAG:
 	CHECK_MODE(IsHeader (extra));
-	mutt_set_flag (Context, extra->hdr, MUTT_TAG, !extra->hdr->tagged);
+	if (Context)
+	{
+	  mutt_set_flag (Context, extra->hdr, MUTT_TAG, !extra->hdr->tagged);
 
-	Context->last_tag = extra->hdr->tagged ? extra->hdr :
-	  ((Context->last_tag == extra->hdr && !extra->hdr->tagged)
-	   ? NULL : Context->last_tag);
+	  Context->last_tag = extra->hdr->tagged ? extra->hdr :
+	    ((Context->last_tag == extra->hdr && !extra->hdr->tagged)
+	    ? NULL : Context->last_tag);
+	}
 
 	redraw = REDRAW_STATUS | REDRAW_INDEX;
 	if (option (OPTRESOLVE))
@@ -2802,11 +2997,24 @@ search_next:
 	}
 	CHECK_MODE(IsHeader (extra));
 	mutt_view_attachments (extra->hdr);
-	if (extra->hdr->attach_del)
+	if (Context && extra->hdr->attach_del)
 	  Context->changed = 1;
 	redraw = REDRAW_FULL;
 	break;
 
+     case OP_EDIT_LABEL:
+        CHECK_MODE(IsHeader (extra));
+        rc = mutt_label_message(extra->hdr);
+        if (rc > 0) {
+	  if (Context)
+	    Context->changed = 1;
+          redraw = REDRAW_FULL;
+          mutt_message ("%d label%s changed.", rc, rc == 1 ? "" : "s");
+        }
+        else {
+          mutt_message _("No labels changed.");
+        }
+        break;
 
       case OP_MAIL_KEY:
         if (!(WithCrypto & APPLICATION_PGP))
@@ -2866,13 +3074,18 @@ search_next:
   safe_fclose (&fp);
   if (IsHeader (extra))
   {
-    Context->msgnotreadyet = -1;
-    if (rc == -1)
-      OldHdr = NULL;
-    else
+    if (Context)
+      Context->msgnotreadyet = -1;
+    switch (rc)
     {
-      TopLine = topline;
-      OldHdr = extra->hdr;
+      case -1:
+      case OP_DISPLAY_HEADERS:
+        mutt_clear_pager_position ();
+        break;
+      default:
+        TopLine = topline;
+        OldHdr = extra->hdr;
+        break;
     }
   }
     
diff --git c/pager.h w/pager.h
index 36c8725..ae8866f 100644
--- c/pager.h
+++ w/pager.h
@@ -48,3 +48,4 @@ typedef struct
 
 int mutt_do_pager (const char *, const char *, int, pager_t *);
 int mutt_pager (const char *, const char *, int, pager_t *);
+void update_index (MUTTMENU *menu, CONTEXT *ctx, int check, int oldcount, int index_hint);
diff --git c/parse.c w/parse.c
index 92cfeb0..c75a8b1 100644
--- c/parse.c
+++ w/parse.c
@@ -94,7 +94,7 @@ char *mutt_read_rfc822_line (FILE *f, char *line, size_t *linelen)
   /* not reached */
 }
 
-static LIST *mutt_parse_references (char *s, int in_reply_to)
+LIST *mutt_parse_references (char *s, int in_reply_to)
 {
   LIST *t, *lst = NULL;
   char *m;
@@ -981,6 +981,7 @@ int mutt_parse_rfc822_line (ENVELOPE *e, HEADER *hdr, char *line, char *p, short
 {
   int matched = 0;
   LIST *last = NULL;
+  int kwtype = 0;
   
   if (lastp)
     last = *lastp;
@@ -1077,6 +1078,17 @@ int mutt_parse_rfc822_line (ENVELOPE *e, HEADER *hdr, char *line, char *p, short
       e->from = rfc822_parse_adrlist (e->from, p);
       matched = 1;
     }
+#ifdef USE_NNTP
+    else if (!ascii_strcasecmp (line+1, "ollowup-to"))
+    {
+      if (!e->followup_to)
+      {
+	mutt_remove_trailing_ws (p);
+	e->followup_to = safe_strdup (mutt_skip_whitespace (p));
+      }
+      matched = 1;
+    }
+#endif
     break;
     
     case 'i':
@@ -1087,7 +1099,14 @@ int mutt_parse_rfc822_line (ENVELOPE *e, HEADER *hdr, char *line, char *p, short
       matched = 1;
     }
     break;
-    
+
+    case 'k':
+    if (!ascii_strcasecmp (line+1, "eywords"))
+    {
+      kwtype = MUTT_KEYWORDS;
+    }
+    break;
+
     case 'l':
     if (!ascii_strcasecmp (line + 1, "ines"))
     {
@@ -1159,6 +1178,27 @@ int mutt_parse_rfc822_line (ENVELOPE *e, HEADER *hdr, char *line, char *p, short
     }
     break;
     
+#ifdef USE_NNTP
+    case 'n':
+    if (!ascii_strcasecmp (line + 1, "ewsgroups"))
+    {
+      FREE (&e->newsgroups);
+      mutt_remove_trailing_ws (p);
+      e->newsgroups = safe_strdup (mutt_skip_whitespace (p));
+      matched = 1;
+    }
+    break;
+#endif
+
+    case 'o':
+    /* field `Organization:' saves only for pager! */
+    if (!ascii_strcasecmp (line + 1, "rganization"))
+    {
+      if (!e->organization && ascii_strcasecmp (p, "unknown"))
+	e->organization = safe_strdup (p);
+    }
+    break;
+
     case 'r':
     if (!ascii_strcasecmp (line + 1, "eferences"))
     {
@@ -1267,15 +1307,40 @@ int mutt_parse_rfc822_line (ENVELOPE *e, HEADER *hdr, char *line, char *p, short
     }
     else if (ascii_strcasecmp (line+1, "-label") == 0)
     {
-      FREE(&e->x_label);
-      e->x_label = safe_strdup(p);
+      kwtype = MUTT_X_LABEL;
+    }
+    else if (!ascii_strcasecmp (line+1, "-keywords"))
+    {
+      kwtype = MUTT_X_KEYWORDS;
+    }
+    else if (!ascii_strcasecmp (line+1, "-mozilla-keys"))
+    {
+      kwtype = MUTT_X_MOZILLA_KEYS;
+    }
+#ifdef USE_NNTP
+    else if (!ascii_strcasecmp (line + 1, "-comment-to"))
+    {
+      if (!e->x_comment_to)
+	e->x_comment_to = safe_strdup (p);
       matched = 1;
     }
-    
+    else if (!ascii_strcasecmp (line + 1, "ref"))
+    {
+      if (!e->xref)
+	e->xref = safe_strdup (p);
+      matched = 1;
+    }
+#endif
+    else if (!ascii_strcasecmp (line + 1, "-original-to"))
+    {
+      e->x_original_to = rfc822_parse_adrlist (e->x_original_to, p);
+      matched = 1;
+    }
+
     default:
     break;
   }
-  
+
   /* Keep track of the user-defined headers */
   if (!matched && user_hdrs)
   {
@@ -1298,12 +1363,59 @@ int mutt_parse_rfc822_line (ENVELOPE *e, HEADER *hdr, char *line, char *p, short
       rfc2047_decode (&last->data);
   }
 
+  if (kwtype)
+  {
+    char *last, *label;
+    char *text = safe_strdup(p);
+    char *sep;
+
+    if (kwtype == MUTT_KEYWORDS)
+      sep = ",";
+    else if (kwtype == MUTT_X_LABEL)
+      sep = XlabelDelim;
+    else
+      sep = " ";
+
+    rfc2047_decode(&text);
+    if (sep == NULL || *sep == '\0')
+    {
+      SKIPWS(text);
+      if (!mutt_find_list(e->labels, text))
+      {
+        if (e->labels)
+          mutt_add_list(e->labels, text);
+        else
+        {
+          e->labels = mutt_new_list();
+          e->labels->data = safe_strdup(text);
+        }
+      }
+    }
+    else for (label = strtok_r(text, sep, &last); label;
+              label = strtok_r(NULL, sep, &last))
+    {
+      SKIPWS(label);
+      if (mutt_find_list(e->labels, label))
+        continue;
+      if (e->labels)
+        mutt_add_list(e->labels, label);
+      else
+      {
+        e->labels = mutt_new_list();
+        e->labels->data = safe_strdup(label);
+      }
+    }
+    e->kwtypes |= kwtype;
+    kwtype = 0;
+    matched = 1;
+  }
+
   done:
   
   *lastp = last;
   return matched;
 }
-  
+
   
 /* mutt_read_rfc822_header() -- parses a RFC822 header
  *
@@ -1441,7 +1553,7 @@ ENVELOPE *mutt_read_rfc822_header (FILE *f, HEADER *hdr, short user_hdrs,
     rfc2047_decode_adrlist (e->mail_followup_to);
     rfc2047_decode_adrlist (e->return_path);
     rfc2047_decode_adrlist (e->sender);
-    rfc2047_decode (&e->x_label);
+    rfc2047_decode_adrlist (e->x_original_to);
 
     if (e->subject)
     {
@@ -1455,6 +1567,12 @@ ENVELOPE *mutt_read_rfc822_header (FILE *f, HEADER *hdr, short user_hdrs,
 	e->real_subj = e->subject;
     }
 
+    if (hdr->received < 0)
+    {
+      dprint(1,(debugfile,"read_rfc822_header(): resetting invalid received time to 0\n"));
+      hdr->received = 0;
+    }
+
     /* check for missing or invalid date */
     if (hdr->date_sent <= 0)
     {
diff --git c/patchlist.sh w/patchlist.sh
index 2914b87..d2dab1f 100755
--- c/patchlist.sh
+++ w/patchlist.sh
@@ -29,7 +29,7 @@ void mutt_print_patchlist (void)
 {
 EOF
 
-list_patches | while read patch ; do
+cat - | while read patch ; do
 	echo "  puts (\"${patch}\");"
 done
 
diff --git c/pattern.c w/pattern.c
index 85d38b5..c225377 100644
--- c/pattern.c
+++ w/pattern.c
@@ -42,6 +42,10 @@
 #include "imap/imap.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 static int eat_regexp (pattern_t *pat, BUFFER *, BUFFER *);
 static int eat_date (pattern_t *pat, BUFFER *, BUFFER *);
 static int eat_range (pattern_t *pat, BUFFER *, BUFFER *);
@@ -92,9 +96,15 @@ Flags[] =
   { 'U', MUTT_UNREAD,		0,		NULL },
   { 'v', MUTT_COLLAPSED,		0,		NULL },
   { 'V', MUTT_CRYPT_VERIFIED,	0,		NULL },
+#ifdef USE_NNTP
+  { 'w', MUTT_NEWSGROUPS,		0,		eat_regexp },
+#endif
   { 'x', MUTT_REFERENCE,		0,		eat_regexp },
   { 'X', MUTT_MIMEATTACH,		0,		eat_range },
   { 'y', MUTT_XLABEL,		0,		eat_regexp },
+#ifdef USE_NOTMUCH
+  { 'Y', MUTT_NOTMUCH_LABEL,	0,		eat_regexp },
+#endif
   { 'z', MUTT_SIZE,		0,		eat_range },
   { '=', MUTT_DUPLICATED,		0,		NULL },
   { '$', MUTT_UNREFERENCED,	0,		NULL },
@@ -144,16 +154,21 @@ int mutt_which_case (const char *s)
 static int
 msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
 {
-  char tempfile[_POSIX_PATH_MAX];
   MESSAGE *msg = NULL;
   STATE s;
-  struct stat st;
   FILE *fp = NULL;
   long lng = 0;
   int match = 0;
   HEADER *h = ctx->hdrs[msgno];
   char *buf;
   size_t blen;
+#ifdef USE_FMEMOPEN
+  char *temp;
+  size_t tempsize;
+#else
+  char tempfile[_POSIX_PATH_MAX];
+  struct stat st;
+#endif
 
   if ((msg = mx_open_message (ctx, msgno)) != NULL)
   {
@@ -163,12 +178,20 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
       memset (&s, 0, sizeof (s));
       s.fpin = msg->fp;
       s.flags = MUTT_CHARCONV;
+#ifdef USE_FMEMOPEN
+      s.fpout = open_memstream (&temp, &tempsize);
+      if (!s.fpout) {
+	mutt_perror ("Error opening memstream");
+	return 0;
+      }
+#else
       mutt_mktemp (tempfile, sizeof (tempfile));
       if ((s.fpout = safe_fopen (tempfile, "w+")) == NULL)
       {
 	mutt_perror (tempfile);
 	return (0);
       }
+#endif
 
       if (pat->op != MUTT_BODY)
 	mutt_copy_header (msg->fp, h, s.fpout, CH_FROM | CH_DECODE, NULL);
@@ -184,7 +207,11 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
 	  if (s.fpout)
 	  {
 	    safe_fclose (&s.fpout);
+#ifdef USE_FMEMOPEN
+            FREE(&temp);
+#else
 	    unlink (tempfile);
+#endif
 	  }
 	  return (0);
 	}
@@ -193,11 +220,30 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
 	mutt_body_handler (h->content, &s);
       }
 
+#ifdef USE_FMEMOPEN
+      fclose (s.fpout);
+      lng = tempsize;
+
+      if (tempsize) {
+        fp = fmemopen (temp, tempsize, "r");
+        if (!fp) {
+          mutt_perror ("Error re-opening memstream");
+          return 0;
+        }
+      } else { /* fmemopen cannot handle empty buffers */
+        fp = safe_fopen ("/dev/null", "r");
+        if (!fp) {
+          mutt_perror ("Error opening /dev/null");
+          return 0;
+        }
+      }
+#else
       fp = s.fpout;
       fflush (fp);
       fseek (fp, 0, 0);
       fstat (fileno (fp), &st);
       lng = (long) st.st_size;
+#endif
     }
     else
     {
@@ -244,7 +290,12 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
     if (option (OPTTHOROUGHSRC))
     {
       safe_fclose (&fp);
+#ifdef USE_FMEMOPEN
+      if (tempsize)
+        FREE(&temp);
+#else
       unlink (tempfile);
+#endif
     }
   }
 
@@ -1142,6 +1193,7 @@ mutt_pattern_exec (struct pattern_t *pat, pattern_exec_flag flags, CONTEXT *ctx,
       /*
        * ctx can be NULL in certain cases, such as when replying to a message from the attachment menu and
        * the user has a reply-hook using "~h" (bug #2190).
+       * This is also the case when message scoring.
        */
       if (!ctx)
 	      return 0;
@@ -1209,12 +1261,34 @@ mutt_pattern_exec (struct pattern_t *pat, pattern_exec_flag flags, CONTEXT *ctx,
        break;
      return (pat->not ^ ((h->security & APPLICATION_PGP) && (h->security & PGPKEY)));
     case MUTT_XLABEL:
+      {
+        LIST *label;
+        int result = 0;
+        for (label = h->env->labels; label; label = label->next)
+        {
+          if (label->data == NULL)
+            continue;
+          result = patmatch (pat, label->data) == 0;
+          if (result)
+            break;
+        }
+        return pat->not ^ result;
+      }
       return (pat->not ^ (h->env->x_label && patmatch (pat, h->env->x_label) == 0));
+#ifdef USE_NOTMUCH
+    case MUTT_NOTMUCH_LABEL:
+      {
+      char *tags = nm_header_get_tags(h);
+      return (pat->not ^ (tags && patmatch (pat, tags) == 0));
+      }
+#endif
     case MUTT_HORMEL:
       return (pat->not ^ (h->env->spam && h->env->spam->data && patmatch (pat, h->env->spam->data) == 0));
     case MUTT_DUPLICATED:
       return (pat->not ^ (h->thread && h->thread->duplicate_thread));
     case MUTT_MIMEATTACH:
+      if (!ctx)
+        return 0;
       {
       int count = mutt_count_body_parts (ctx, h);
       return (pat->not ^ (count >= pat->min && (pat->max == MUTT_MAXRANGE ||
@@ -1222,6 +1296,10 @@ mutt_pattern_exec (struct pattern_t *pat, pattern_exec_flag flags, CONTEXT *ctx,
       }
     case MUTT_UNREFERENCED:
       return (pat->not ^ (h->thread && !h->thread->child));
+#ifdef USE_NNTP
+    case MUTT_NEWSGROUPS:
+      return (pat->not ^ (h->env->newsgroups && patmatch (pat, h->env->newsgroups) == 0));
+#endif
   }
   mutt_error (_("error: unknown op %d (report this error)."), pat->op);
   return (-1);
@@ -1294,6 +1372,76 @@ void mutt_check_simple (char *s, size_t len, const char *simple)
   }
 }
 
+/**
+ * top_of_thread - Find the first email in the current thread
+ * @h: Header of current email
+ *
+ * Returns:
+ *  THREAD*: success, email found
+ *  NULL:    on error
+ */
+static THREAD *
+top_of_thread (HEADER *h)
+{
+  THREAD *t;
+
+  if (!h)
+    return NULL;
+
+  t = h->thread;
+
+  while (t && t->parent)
+    t = t->parent;
+
+  return t;
+}
+
+/**
+ * mutt_limit_current_thread - Limit the email view to the current thread
+ * @h: Header of current email
+ *
+ * Returns:
+ *  1: Success
+ *  0: Failure
+ */
+int
+mutt_limit_current_thread (HEADER *h)
+{
+  int i;
+  THREAD *me;
+
+  if (!h)
+    return 0;
+
+  me = top_of_thread (h);
+  if (!me)
+    return 0;
+
+  Context->vcount    = 0;
+  Context->vsize     = 0;
+  Context->collapsed = 0;
+
+  for (i = 0; i < Context->msgcount; i++)
+  {
+    Context->hdrs[i]->virtual    = -1;
+    Context->hdrs[i]->limited    = 0;
+    Context->hdrs[i]->collapsed  = 0;
+    Context->hdrs[i]->num_hidden = 0;
+
+    if (top_of_thread (Context->hdrs[i]) == me)
+    {
+      BODY *body = Context->hdrs[i]->content;
+
+      Context->hdrs[i]->virtual = Context->vcount;
+      Context->hdrs[i]->limited = 1;
+      Context->v2r[Context->vcount] = i;
+      Context->vcount++;
+      Context->vsize += (body->length + body->offset - body->hdr_offset);
+    }
+  }
+  return 1;
+}
+
 int mutt_pattern_func (int op, char *prompt)
 {
   pattern_t *pat;
@@ -1303,6 +1451,7 @@ int mutt_pattern_func (int op, char *prompt)
   progress_t progress;
 
   strfcpy (buf, NONULL (Context->pattern), sizeof (buf));
+  if (prompt || op != MUTT_LIMIT)
   if (mutt_get_field (prompt, buf, sizeof (buf), MUTT_PATTERN | MUTT_CLEAR) != 0 || !buf[0])
     return (-1);
 
diff --git c/pgpkey.c w/pgpkey.c
index 46661b7..36a92ae 100644
--- c/pgpkey.c
+++ w/pgpkey.c
@@ -195,15 +195,14 @@ static const char *pgp_entry_fmt (char *dest,
 	}
 	*p = 0;
 
-	if (do_locales && Locale)
-	  setlocale (LC_TIME, Locale);
 
 	tm = localtime (&key->gen_time);
 
-	strftime (buf2, sizeof (buf2), dest, tm);
-
-	if (do_locales)
-	  setlocale (LC_TIME, "C");
+        if (!do_locales)
+          setlocale (LC_TIME, "C");
+        strftime (buf2, sizeof (buf2), dest, tm);
+        if (!do_locales)
+          setlocale (LC_TIME, "");
 
 	snprintf (fmt, sizeof (fmt), "%%%ss", prefix);
 	snprintf (dest, destlen, fmt, buf2);
diff --git c/pgppubring.c w/pgppubring.c
index 8da3bbb..b045518 100644
--- c/pgppubring.c
+++ w/pgppubring.c
@@ -341,19 +341,15 @@ static pgp_key_t pgp_parse_pgp3_key (unsigned char *buff, size_t l)
   p->algorithm = pgp_pkalgbytype (alg);
   p->flags |= pgp_get_abilities (alg);
 
-  if (alg == 17)
-    skip_bignum (buff, l, j, &j, 3);
-  else if (alg == 16 || alg == 20)
-    skip_bignum (buff, l, j, &j, 2);
-
   len = (buff[j] << 8) + buff[j + 1];
   p->keylen = len;
 
-
   if (alg >= 1 && alg <= 3)
     skip_bignum (buff, l, j, &j, 2);
-  else if (alg == 17 || alg == 16 || alg == 20)
-    skip_bignum (buff, l, j, &j, 1);
+  else if (alg == 16 || alg == 20)
+    skip_bignum (buff, l, j, &j, 3);
+  else if (alg == 17)
+    skip_bignum (buff, l, j, &j, 4);
 
   pgp_make_pgp3_fingerprint (buff, j, digest);
   if (dump_fingerprints)
diff --git c/po/POTFILES.in w/po/POTFILES.in
index 2d01add..1e499ec 100644
--- c/po/POTFILES.in
+++ w/po/POTFILES.in
@@ -8,6 +8,7 @@ charset.c
 color.c
 commands.c
 compose.c
+compress.c
 crypt-gpgme.c
 crypt.c
 cryptglue.c
@@ -46,6 +47,8 @@ mutt_ssl_gnutls.c
 mutt_tunnel.c
 muttlib.c
 mx.c
+newsrc.c
+nntp.c
 pager.c
 parse.c
 pattern.c
diff --git c/po/de.po w/po/de.po
index f0d7589..afc6e62 100644
--- c/po/de.po
+++ w/po/de.po
@@ -1371,6 +1371,7 @@ msgstr ""
 "PGP (v)erschl., (s)ign., sign. (a)ls, (b)eides, s/(m)ime, (u)nverschl.?"
 
 #: crypt-gpgme.c:4733
+#, fuzzy
 msgid "samfco"
 msgstr ""
 
@@ -1407,6 +1408,7 @@ msgstr ""
 "S/MIME (v)erschl., (s)ign., sign. (a)ls, (b)eides, (p)gp, (u)nverschl.?"
 
 #: crypt-gpgme.c:4764
+#, fuzzy
 msgid "esabpfc"
 msgstr "vsabpku"
 
@@ -1417,6 +1419,7 @@ msgstr ""
 "PGP (v)erschl., (s)ign., sign. (a)ls, (b)eides, s/(m)ime, (u)nverschl.?"
 
 #: crypt-gpgme.c:4770
+#, fuzzy
 msgid "esabmfc"
 msgstr "vsabmku"
 
diff --git c/po/es.po w/po/es.po
index ca1e402..0cfcb23 100644
--- c/po/es.po
+++ w/po/es.po
@@ -1419,6 +1419,7 @@ msgid "PGP (s)ign, sign (a)s, s/(m)ime, (c)lear, or (o)ppenc mode off? "
 msgstr "co(d)ificar, f(i)rmar (c)omo, amb(o)s, inc(l)uido, o ca(n)celar? "
 
 #: crypt-gpgme.c:4733
+#, fuzzy
 msgid "samfco"
 msgstr ""
 
diff --git c/po/it.po w/po/it.po
index bbbb6ed..0054a92 100644
--- c/po/it.po
+++ w/po/it.po
@@ -1358,6 +1358,7 @@ msgstr ""
 #. Alternatively, you may duplicate the letter 'c' is translated to.
 #. This comment also applies to the five following letter sequences.
 #: crypt-gpgme.c:4727
+#, fuzzy
 msgid "sapfco"
 msgstr ""
 
@@ -1368,6 +1369,7 @@ msgstr ""
 "PGP: cifra(e), firma(s), firma (c)ome, entram(b)i, s/(m)ime, annullare(c)?"
 
 #: crypt-gpgme.c:4733
+#, fuzzy
 msgid "samfco"
 msgstr ""
 
@@ -1404,6 +1406,7 @@ msgstr ""
 "S/MIME cifra(e), firma(s), firma (c)ome, entram(b)i, (p)gp, annullare(c)?"
 
 #: crypt-gpgme.c:4764
+#, fuzzy
 msgid "esabpfc"
 msgstr "esabpfc"
 
@@ -1414,6 +1417,7 @@ msgstr ""
 "PGP: cifra(e), firma(s), firma (c)ome, entram(b)i, s/(m)ime, annullare(c)?"
 
 #: crypt-gpgme.c:4770
+#, fuzzy
 msgid "esabmfc"
 msgstr "esabmfc"
 
diff --git c/postpone.c w/postpone.c
index 525a72f..ba4f6a4 100644
--- c/postpone.c
+++ w/postpone.c
@@ -125,15 +125,26 @@ int mutt_num_postponed (int force)
 
   if (LastModify < st.st_mtime)
   {
+#ifdef USE_NNTP
+    int optnews = option (OPTNEWS);
+#endif
     LastModify = st.st_mtime;
 
     if (access (Postponed, R_OK | F_OK) != 0)
       return (PostCount = 0);
+#ifdef USE_NNTP
+    if (optnews)
+	unset_option (OPTNEWS);
+#endif
     if (mx_open_mailbox (Postponed, MUTT_NOSORT | MUTT_QUIET, &ctx) == NULL)
       PostCount = 0;
     else
       PostCount = ctx.msgcount;
     mx_fastclose_mailbox (&ctx);
+#ifdef USE_NNTP
+    if (optnews)
+	set_option (OPTNEWS);
+#endif
   }
 
   return (PostCount);
@@ -535,9 +546,17 @@ int mutt_parse_crypt_hdr (const char *p, int set_empty_signas, int crypt_app)
 }
 
 
-
+/* args:
+ *     fp      If not NULL, file containing the template
+ *     ctx     If fp is NULL, the context containing the header with the template
+ *     newhdr  The template is read into this HEADER
+ *     hdr     The message to recall/resend
+ *     resend  Set if resending (as opposed to recalling a postponed msg).
+ *             Resent messages enable header weeding, and also
+ *             discard any existing Message-ID and Mail-Followup-To.
+ */
 int mutt_prepare_template (FILE *fp, CONTEXT *ctx, HEADER *newhdr, HEADER *hdr,
-			       short weed)
+                           short resend)
 {
   MESSAGE *msg = NULL;
   char file[_POSIX_PATH_MAX];
@@ -560,15 +579,16 @@ int mutt_prepare_template (FILE *fp, CONTEXT *ctx, HEADER *newhdr, HEADER *hdr,
 
   fseeko (fp, hdr->offset, 0);
   newhdr->offset = hdr->offset;
-  newhdr->env = mutt_read_rfc822_header (fp, newhdr, 1, weed);
+  /* enable header weeding for resent messages */
+  newhdr->env = mutt_read_rfc822_header (fp, newhdr, 1, resend);
   newhdr->content->length = hdr->content->length;
   mutt_parse_part (fp, newhdr->content);
 
-  /* If message_id is set, then we are resending a message and don't want
-   * message_id or mail_followup_to. Otherwise, we are resuming a
-   * postponed message, and want to keep the mail_followup_to.
+  /* If resending a message, don't keep message_id or mail_followup_to.
+   * Otherwise, we are resuming a postponed message, and want to keep those
+   * headers if they exist.
    */
-  if (newhdr->env->message_id != NULL)
+  if (resend)
   {
     FREE (&newhdr->env->message_id);
     FREE (&newhdr->env->mail_followup_to);
diff --git c/protos.h w/protos.h
index 19d6400..f00a905 100644
--- c/protos.h
+++ w/protos.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 1996-2000,2007,2010,2013 Michael R. Elkins <me@mutt.org>
+ * Copyright (C) 2013 Karel Zak <kzak@redhat.com>
  * 
  *     This program is free software; you can redistribute it and/or modify
  *     it under the terms of the GNU General Public License as published by
@@ -36,6 +37,11 @@ struct hdr_format_info
   const char *pager_progress;
 };
 
+typedef enum {
+  kXDGConfigHome,  /* $XDG_CONFIG_HOME */
+  kXDGConfigDirs,  /* $XDG_CONFIG_DIRS */
+} XDGType;
+
 void mutt_make_string_info (char *, size_t, int, const char *, struct hdr_format_info *, format_flag);
 
 int mutt_extract_token (BUFFER *, BUFFER *, int);
@@ -79,6 +85,9 @@ void mutt_generate_boundary (PARAMETER **);
 void mutt_delete_parameter (const char *attribute, PARAMETER **p);
 void mutt_set_parameter (const char *, const char *, PARAMETER **);
 
+#ifdef USE_NOTMUCH
+int mutt_parse_virtual_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *err);
+#endif
 
 FILE *mutt_open_read (const char *, pid_t *);
 
@@ -111,6 +120,7 @@ HASH *mutt_make_id_hash (CONTEXT *);
 HASH *mutt_make_subj_hash (CONTEXT *);
 
 LIST *mutt_make_references(ENVELOPE *e);
+LIST *mutt_parse_references (char *, int);
 
 char *mutt_read_rfc822_line (FILE *, char *, size_t *);
 ENVELOPE *mutt_read_rfc822_header (FILE *, HEADER *, short, short);
@@ -149,6 +159,8 @@ const char *mutt_get_name (ADDRESS *);
 char *mutt_get_parameter (const char *, PARAMETER *);
 LIST *mutt_crypt_hook (ADDRESS *);
 char *mutt_make_date (char *, size_t);
+void mutt_timeout_hook (void);
+int mutt_set_xdg_path(const XDGType type, char *buf, size_t bufsize);
 
 const char *mutt_make_version (void);
 
@@ -182,10 +194,17 @@ void mutt_decode_base64 (STATE *s, long len, int istext, iconv_t cd);
 void mutt_default_save (char *, size_t, HEADER *);
 void mutt_display_address (ENVELOPE *);
 void mutt_display_sanitize (char *);
+void mutt_draw_statusline (int cols, const char *buf, int buflen);
 void mutt_edit_content_type (HEADER *, BODY *, FILE *);
 void mutt_edit_file (const char *, const char *);
 void mutt_edit_headers (const char *, const char *, HEADER *, char *, size_t);
 int mutt_filter_unprintable (char **);
+void mutt_label_ref_dec(ENVELOPE *);
+void mutt_label_ref_inc(ENVELOPE *);
+int mutt_label_message (HEADER *);
+void mutt_scan_labels (CONTEXT *);
+int mutt_label_complete (char *, size_t, int, int);
+char *mutt_labels(char *, int, ENVELOPE *, char *);
 void mutt_curses_error (const char *, ...);
 void mutt_curses_message (const char *, ...);
 void mutt_encode_descriptions (BODY *, short);
@@ -286,6 +305,10 @@ int mutt_check_overwrite (const char *, const char *, char *, size_t, int *, cha
 int mutt_check_traditional_pgp (HEADER *, int *);
 int mutt_command_complete (char *, size_t, int, int);
 int mutt_var_value_complete (char *, size_t, int);
+#if USE_NOTMUCH
+int mutt_nm_query_complete (char *buffer, size_t len, int pos, int numtabs);
+int mutt_nm_tag_complete (char *buffer, size_t len, int pos, int numtabs);
+#endif
 int mutt_complete (char *, size_t);
 int mutt_compose_attachment (BODY *a);
 int mutt_copy_body (FILE *, BODY **, BODY *);
@@ -301,8 +324,11 @@ int mutt_chscmp (const char *s, const char *chs);
 int mutt_parent_message (CONTEXT *, HEADER *);
 int mutt_prepare_template(FILE*, CONTEXT *, HEADER *, HEADER *, short);
 int mutt_resend_message (FILE *, CONTEXT *, HEADER *);
-#define mutt_enter_fname(A,B,C,D,E) _mutt_enter_fname(A,B,C,D,E,0,NULL,NULL)
-int _mutt_enter_fname (const char *, char *, size_t, int *, int, int, char ***, int *);
+int mutt_compose_to_sender (HEADER *);
+#define mutt_enter_fname(A,B,C,D,E) _mutt_enter_fname(A,B,C,D,E,0,NULL,NULL,0)
+#define mutt_enter_vfolder(A,B,C,D,E) _mutt_enter_fname(A,B,C,D,E,0,NULL,NULL,MUTT_SEL_VFOLDER)
+
+int _mutt_enter_fname (const char *, char *, size_t, int *, int, int, char ***, int *, int);
 int  mutt_enter_string (char *buf, size_t buflen, int col, int flags);
 int _mutt_enter_string (char *, size_t, int, int, int, char ***, int *, ENTER_STATE *);
 #define mutt_get_field(A,B,C,D) _mutt_get_field(A,B,C,D,0,NULL,NULL)
@@ -367,7 +393,8 @@ int mutt_user_is_recipient (HEADER *);
 void mutt_update_num_postponed (void);
 int mutt_wait_filter (pid_t);
 int mutt_which_case (const char *);
-int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int, char *);
+int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int, char *, char **);
+int mutt_write_multiple_fcc (const char *path, HEADER *hdr, const char *msgid, int, char *, char **);
 int mutt_write_mime_body (BODY *, FILE *);
 int mutt_write_mime_header (BODY *, FILE *);
 int mutt_write_one_header (FILE *fp, const char *tag, const char *value, const char *pfx, int wraplen, int flags);
@@ -377,6 +404,15 @@ int mutt_yesorno (const char *, int);
 void mutt_set_header_color(CONTEXT *, HEADER *);
 void mutt_sleep (short);
 int mutt_save_confirm (const char  *, struct stat *);
+void mutt_randbuf(void *out, size_t len);
+
+void mutt_browser_select_dir (char *f);
+void mutt_get_parent_path (char *output, char *path, size_t olen);
+
+#define MUTT_RANDTAG_LEN (16)
+void mutt_rand_base32(void *out, size_t len);
+uint32_t mutt_rand32(void);
+uint64_t mutt_rand64(void);
 
 int mh_valid_message (const char *);
 
@@ -424,16 +460,6 @@ void mutt_pattern_free (pattern_t **pat);
 #define LONGLONG long
 #endif
 
-#ifdef HAVE_SRAND48
-#define LRAND lrand48
-#define SRAND srand48
-#define DRAND drand48
-#else
-#define LRAND rand
-#define SRAND srand
-#define DRAND (double)rand
-#endif /* HAVE_SRAND48 */
-
 /* HP-UX, ConvexOS and UNIXware don't have this macro */
 #ifndef S_ISLNK
 #define S_ISLNK(x) (((x) & S_IFMT) == S_IFLNK ? 1 : 0)
@@ -567,3 +593,11 @@ char *strcasestr (const char *, const char *);
 #ifndef HAVE_MKDTEMP
 char *mkdtemp (char *tmpl);
 #endif
+
+#ifndef HAVE_STRNLEN
+size_t strnlen(const char *s, size_t maxlen);
+#endif
+
+#ifndef strndup
+char *strndup(const char *s, size_t n);
+#endif
diff --git c/recvattach.c w/recvattach.c
index fb31318..39a26c0 100644
--- c/recvattach.c
+++ w/recvattach.c
@@ -1121,6 +1121,15 @@ void mutt_view_attachments (HEADER *hdr)
 	}
 #endif
 
+#ifdef USE_NNTP
+	if (Context->magic == MUTT_NNTP)
+	{
+	  mutt_flushinp ();
+	  mutt_error _("Can't delete attachment from news server.");
+	  break;
+	}
+#endif
+
         if (WithCrypto && (hdr->security & ENCRYPT))
         {
           mutt_message _(
@@ -1215,10 +1224,33 @@ void mutt_view_attachments (HEADER *hdr)
       case OP_FORWARD_MESSAGE:
         CHECK_ATTACH;
         mutt_attach_forward (fp, hdr, idx, idxlen,
-			     menu->tagprefix ? NULL : idx[menu->current]->content);
+			     menu->tagprefix ? NULL : idx[menu->current]->content, 0);
         menu->redraw = REDRAW_FULL;
         break;
       
+#ifdef USE_NNTP
+      case OP_FORWARD_TO_GROUP:
+	CHECK_ATTACH;
+	mutt_attach_forward (fp, hdr, idx, idxlen,
+		menu->tagprefix ? NULL : idx[menu->current]->content, SENDNEWS);
+	menu->redraw = REDRAW_FULL;
+	break;
+
+      case OP_FOLLOWUP:
+	CHECK_ATTACH;
+
+	if (!idx[menu->current]->content->hdr->env->followup_to ||
+	    mutt_strcasecmp (idx[menu->current]->content->hdr->env->followup_to, "poster") ||
+	    query_quadoption (OPT_FOLLOWUPTOPOSTER,_("Reply by mail as poster prefers?")) != MUTT_YES)
+	{
+	  mutt_attach_reply (fp, hdr, idx, idxlen,
+		menu->tagprefix ? NULL : idx[menu->current]->content,
+		SENDNEWS|SENDREPLY);
+	  menu->redraw = REDRAW_FULL;
+	  break;
+	}
+#endif
+
       case OP_REPLY:
       case OP_GROUP_REPLY:
       case OP_LIST_REPLY:
diff --git c/recvcmd.c w/recvcmd.c
index cd19e9f..7f310be 100644
--- c/recvcmd.c
+++ w/recvcmd.c
@@ -401,7 +401,7 @@ static BODY ** copy_problematic_attachments (FILE *fp,
 static void attach_forward_bodies (FILE * fp, HEADER * hdr,
 				   ATTACHPTR ** idx, short idxlen,
 				   BODY * cur,
-				   short nattach)
+				   short nattach, int flags)
 {
   short i;
   short mime_fwd_all = 0;
@@ -547,7 +547,7 @@ _("Can't decode all tagged attachments.  MIME-forward the others?"))) == -1)
   tmpfp = NULL;
 
   /* now that we have the template, send it. */
-  ci_send_message (0, tmphdr, tmpbody, NULL, parent);
+  ci_send_message (flags, tmphdr, tmpbody, NULL, parent);
   return;
   
   bail:
@@ -574,7 +574,7 @@ _("Can't decode all tagged attachments.  MIME-forward the others?"))) == -1)
  */
 
 static void attach_forward_msgs (FILE * fp, HEADER * hdr, 
-	       ATTACHPTR ** idx, short idxlen, BODY * cur)
+	       ATTACHPTR ** idx, short idxlen, BODY * cur, int flags)
 {
   HEADER *curhdr = NULL;
   HEADER *tmphdr;
@@ -679,23 +679,23 @@ static void attach_forward_msgs (FILE * fp, HEADER * hdr,
   else
     mutt_free_header (&tmphdr);
 
-  ci_send_message (0, tmphdr, *tmpbody ? tmpbody : NULL, 
+  ci_send_message (flags, tmphdr, *tmpbody ? tmpbody : NULL, 
 		   NULL, curhdr);
 
 }
 
 void mutt_attach_forward (FILE * fp, HEADER * hdr, 
-			  ATTACHPTR ** idx, short idxlen, BODY * cur)
+			  ATTACHPTR ** idx, short idxlen, BODY * cur, int flags)
 {
   short nattach;
   
 
   if (check_all_msg (idx, idxlen, cur, 0) == 0)
-    attach_forward_msgs (fp, hdr, idx, idxlen, cur);
+    attach_forward_msgs (fp, hdr, idx, idxlen, cur, flags);
   else
   {
     nattach = count_tagged (idx, idxlen);
-    attach_forward_bodies (fp, hdr, idx, idxlen, cur, nattach);
+    attach_forward_bodies (fp, hdr, idx, idxlen, cur, nattach, flags);
   }
 }
 
@@ -753,28 +753,40 @@ attach_reply_envelope_defaults (ENVELOPE *env, ATTACHPTR **idx, short idxlen,
     return -1;
   }
 
-  if (parent)
+#ifdef USE_NNTP
+  if ((flags & SENDNEWS))
   {
-    if (mutt_fetch_recips (env, curenv, flags) == -1)
-      return -1;
+    /* in case followup set Newsgroups: with Followup-To: if it present */
+    if (!env->newsgroups && curenv &&
+	mutt_strcasecmp (curenv->followup_to, "poster"))
+      env->newsgroups = safe_strdup (curenv->followup_to);
   }
   else
+#endif
   {
-    for (i = 0; i < idxlen; i++)
+    if (parent)
     {
-      if (idx[i]->content->tagged
-	  && mutt_fetch_recips (env, idx[i]->content->hdr->env, flags) == -1)
+      if (mutt_fetch_recips (env, curenv, flags) == -1)
 	return -1;
     }
+    else
+    {
+      for (i = 0; i < idxlen; i++)
+      {
+	if (idx[i]->content->tagged
+	    && mutt_fetch_recips (env, idx[i]->content->hdr->env, flags) == -1)
+	  return -1;
+      }
+    }
+
+    if ((flags & SENDLISTREPLY) && !env->to)
+    {
+      mutt_error _("No mailing lists found!");
+      return (-1);
+    }
+
+    mutt_fix_reply_recipients (env);
   }
-  
-  if ((flags & SENDLISTREPLY) && !env->to)
-  {
-    mutt_error _("No mailing lists found!");
-    return (-1);
-  }
-  
-  mutt_fix_reply_recipients (env);
   mutt_make_misc_reply_headers (env, Context, curhdr, curenv);
 
   if (parent)
@@ -835,6 +847,13 @@ void mutt_attach_reply (FILE * fp, HEADER * hdr,
   char prefix[SHORT_STRING];
   int rc;
   
+#ifdef USE_NNTP
+  if (flags & SENDNEWS)
+    set_option (OPTNEWSSEND);
+  else
+    unset_option (OPTNEWSSEND);
+#endif
+
   if (check_all_msg (idx, idxlen, cur, 0) == -1)
   {
     nattach = count_tagged (idx, idxlen);
diff --git c/send.c w/send.c
index d54d495..e5a7bf3 100644
--- c/send.c
+++ w/send.c
@@ -34,6 +34,7 @@
 
 #include <ctype.h>
 #include <stdlib.h>
+#include <locale.h>
 #include <unistd.h>
 #include <string.h>
 #include <errno.h>
@@ -44,10 +45,18 @@
 #include <sys/types.h>
 #include <utime.h>
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#include "mx.h"
+#endif
+
 #ifdef MIXMASTER
 #include "remailer.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
 
 static void append_signature (FILE *f)
 {
@@ -213,17 +222,55 @@ static int edit_address (ADDRESS **a, /* const */ char *field)
   return 0;
 }
 
-static int edit_envelope (ENVELOPE *en)
+static int edit_envelope (ENVELOPE *en, int flags)
 {
   char buf[HUGE_STRING];
   LIST *uh = UserHeader;
 
-  if (edit_address (&en->to, "To: ") == -1 || en->to == NULL)
-    return (-1);
-  if (option (OPTASKCC) && edit_address (&en->cc, "Cc: ") == -1)
-    return (-1);
-  if (option (OPTASKBCC) && edit_address (&en->bcc, "Bcc: ") == -1)
-    return (-1);
+#ifdef USE_NNTP
+  if (option (OPTNEWSSEND))
+  {
+    if (en->newsgroups)
+      strfcpy (buf, en->newsgroups, sizeof (buf));
+    else
+      buf[0] = 0;
+    if (mutt_get_field ("Newsgroups: ", buf, sizeof (buf), 0) != 0)
+      return (-1);
+    FREE (&en->newsgroups);
+    en->newsgroups = safe_strdup (buf);
+
+    if (en->followup_to)
+      strfcpy (buf, en->followup_to, sizeof (buf));
+    else
+      buf[0] = 0;
+    if (option (OPTASKFOLLOWUP) && mutt_get_field ("Followup-To: ", buf, sizeof (buf), 0) != 0)
+      return (-1);
+    FREE (&en->followup_to);
+    en->followup_to = safe_strdup (buf);
+
+    if (en->x_comment_to)
+      strfcpy (buf, en->x_comment_to, sizeof (buf));
+    else
+      buf[0] = 0;
+    if (option (OPTXCOMMENTTO) && option (OPTASKXCOMMENTTO) && mutt_get_field ("X-Comment-To: ", buf, sizeof (buf), 0) != 0)
+      return (-1);
+    FREE (&en->x_comment_to);
+    en->x_comment_to = safe_strdup (buf);
+  }
+  else
+#endif
+  {
+    if (edit_address (&en->to, "To: ") == -1 || en->to == NULL)
+      return (-1);
+    if (option (OPTASKCC) && edit_address (&en->cc, "Cc: ") == -1)
+      return (-1);
+    if (option (OPTASKBCC) && edit_address (&en->bcc, "Bcc: ") == -1)
+      return (-1);
+    if (option (OPTREPLYWITHXORIG) &&
+	(flags & (SENDREPLY|SENDLISTREPLY|SENDGROUPREPLY)) &&
+	(edit_address (&en->from, "From: ") == -1))
+      return (-1);
+  }
 
   if (en->subject)
   {
@@ -258,6 +305,14 @@ static int edit_envelope (ENVELOPE *en)
   return 0;
 }
 
+#ifdef USE_NNTP
+char *nntp_get_header (const char *s)
+{
+  SKIPWS (s);
+  return safe_strdup (s);
+}
+#endif
+
 static void process_user_recips (ENVELOPE *env)
 {
   LIST *uh = UserHeader;
@@ -270,6 +325,14 @@ static void process_user_recips (ENVELOPE *env)
       env->cc = rfc822_parse_adrlist (env->cc, uh->data + 3);
     else if (ascii_strncasecmp ("bcc:", uh->data, 4) == 0)
       env->bcc = rfc822_parse_adrlist (env->bcc, uh->data + 4);
+#ifdef USE_NNTP
+    else if (ascii_strncasecmp ("newsgroups:", uh->data, 11) == 0)
+      env->newsgroups = nntp_get_header (uh->data + 11);
+    else if (ascii_strncasecmp ("followup-to:", uh->data, 12) == 0)
+      env->followup_to = nntp_get_header (uh->data + 12);
+    else if (ascii_strncasecmp ("x-comment-to:", uh->data, 13) == 0)
+      env->x_comment_to = nntp_get_header (uh->data + 13);
+#endif
   }
 }
 
@@ -308,6 +371,12 @@ static void process_user_header (ENVELOPE *env)
     else if (ascii_strncasecmp ("to:", uh->data, 3) != 0 &&
 	     ascii_strncasecmp ("cc:", uh->data, 3) != 0 &&
 	     ascii_strncasecmp ("bcc:", uh->data, 4) != 0 &&
+#ifdef USE_NNTP
+	     ascii_strncasecmp ("newsgroups:", uh->data, 11) != 0 &&
+	     ascii_strncasecmp ("followup-to:", uh->data, 12) != 0 &&
+	     ascii_strncasecmp ("x-comment-to:", uh->data, 13) != 0 &&
+#endif
+	     ascii_strncasecmp ("supersedes:", uh->data, 11) != 0 &&
 	     ascii_strncasecmp ("subject:", uh->data, 8) != 0 &&
 	     ascii_strncasecmp ("return-path:", uh->data, 12) != 0)
     {
@@ -323,26 +392,6 @@ static void process_user_header (ENVELOPE *env)
   }
 }
 
-LIST *mutt_copy_list (LIST *p)
-{
-  LIST *t, *r=NULL, *l=NULL;
-
-  for (; p; p = p->next)
-  {
-    t = (LIST *) safe_malloc (sizeof (LIST));
-    t->data = safe_strdup (p->data);
-    t->next = NULL;
-    if (l)
-    {
-      r->next = t;
-      r = r->next;
-    }
-    else
-      l = r = t;
-  }
-  return (l);
-}
-
 void mutt_forward_intro (FILE *fp, HEADER *cur)
 {
   char buffer[STRING];
@@ -401,7 +450,9 @@ void mutt_make_attribution (CONTEXT *ctx, HEADER *cur, FILE *out)
   char buffer[LONG_STRING];
   if (Attribution)
   {
+    setlocale (LC_TIME, NONULL (AttributionLocale));
     mutt_make_string (buffer, sizeof (buffer), Attribution, ctx, cur);
+    setlocale (LC_TIME, "");
     fputs (buffer, out);
     fputc ('\n', out);
   }
@@ -659,6 +710,10 @@ void mutt_add_to_reference_headers (ENVELOPE *env, ENVELOPE *curenv, LIST ***pp,
   if (pp) *pp = p;
   if (qq) *qq = q;
   
+#ifdef USE_NNTP
+  if (option (OPTNEWSSEND) && option (OPTXCOMMENTTO) && curenv->from)
+    env->x_comment_to = safe_strdup (mutt_get_name (curenv->from));
+#endif
 }
 
 static void 
@@ -721,6 +776,16 @@ envelope_defaults (ENVELOPE *env, CONTEXT *ctx, HEADER *cur, int flags)
 
   if (flags & SENDREPLY)
   {
+#ifdef USE_NNTP
+    if ((flags & SENDNEWS))
+    {
+      /* in case followup set Newsgroups: with Followup-To: if it present */
+      if (!env->newsgroups && curenv &&
+	  mutt_strcasecmp (curenv->followup_to, "poster"))
+	env->newsgroups = safe_strdup (curenv->followup_to);
+    }
+    else
+#endif
     if (tag)
     {
       HEADER *h;
@@ -867,7 +932,18 @@ void mutt_set_followup_to (ENVELOPE *e)
    * it hasn't already been set
    */
 
-  if (option (OPTFOLLOWUPTO) && !e->mail_followup_to)
+  if (!option (OPTFOLLOWUPTO))
+    return;
+#ifdef USE_NNTP
+  if (option (OPTNEWSSEND))
+  {
+    if (!e->followup_to && e->newsgroups && (strrchr (e->newsgroups, ',')))
+      e->followup_to = safe_strdup (e->newsgroups);
+    return;
+  }
+#endif
+
+  if (!e->mail_followup_to)
   {
     if (mutt_is_list_cc (0, e->to, e->cc))
     {
@@ -1029,6 +1105,9 @@ static int send_message (HEADER *msg)
 #endif
 
 #if USE_SMTP
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
   if (SmtpUrl)
       return mutt_smtp_send (msg->env->from, msg->env->to, msg->env->cc,
                              msg->env->bcc, tempfile,
@@ -1086,6 +1165,27 @@ static void fix_end_of_file (const char *data)
   safe_fclose (&fp);
 }
 
+int mutt_compose_to_sender (HEADER *hdr)
+{
+  HEADER *msg = mutt_new_header();
+
+  msg->env = mutt_new_envelope();
+  if (!hdr)
+  {
+    int i;
+    for (i = 0; i < Context->vcount; i++)
+    {
+      hdr = Context->hdrs[Context->v2r[(i)]];
+      if (hdr->tagged)
+        rfc822_append (&msg->env->to, hdr->env->from, 0);
+    }
+  }
+  else
+    msg->env->to = rfc822_cpy_adr (hdr->env->from, 0);
+
+  return ci_send_message (0, msg, NULL, NULL, NULL);
+}
+
 int mutt_resend_message (FILE *fp, CONTEXT *ctx, HEADER *cur)
 {
   HEADER *msg = mutt_new_header ();
@@ -1136,6 +1236,33 @@ static int has_recips (ADDRESS *a)
   return c;
 }
 
+int
+mutt_search_attach_keyword (char *filename)
+{
+  /* Search for the regex in AttachKeyword within a file */
+  if (!AttachKeyword.rx)
+    return 0;
+
+  FILE *attf = safe_fopen (filename, "r");
+  if (!attf)
+    return 0;
+
+  char *inputline = safe_malloc (LONG_STRING);
+  int found = 0;
+  while (!feof (attf))
+  {
+    fgets (inputline, LONG_STRING, attf);
+    if (regexec (AttachKeyword.rx, inputline, 0, NULL, 0) == 0)
+    {
+      found = 1;
+      break;
+    }
+  }
+  FREE (&inputline);
+  safe_fclose (&attf);
+  return found;
+}
+
 /*
  * Returns 0 if the message was successfully sent
  *        -1 if the message was aborted or an error occurred
@@ -1164,9 +1291,17 @@ ci_send_message (int flags,		/* send mode */
   char *smime_default_key = NULL;
   char *tag = NULL, *err = NULL;
   char *ctype;
+  char *finalpath = NULL;
 
   int rv = -1;
   
+#ifdef USE_NNTP
+  if (flags & SENDNEWS)
+    set_option (OPTNEWSSEND);
+  else
+    unset_option (OPTNEWSSEND);
+#endif
+
   if (!flags && !msg && quadoption (OPT_RECALL) != MUTT_NO &&
       mutt_num_postponed (1))
   {
@@ -1202,6 +1337,22 @@ ci_send_message (int flags,		/* send mode */
     {
       if ((flags = mutt_get_postponed (ctx, msg, &cur, fcc, sizeof (fcc))) < 0)
 	goto cleanup;
+#ifdef USE_NNTP
+      /*
+       * If postponed message is a news article, it have
+       * a "Newsgroups:" header line, then set appropriate flag.
+       */
+      if (msg->env->newsgroups)
+      {
+	flags |= SENDNEWS;
+	set_option (OPTNEWSSEND);
+      }
+      else
+      {
+	flags &= ~SENDNEWS;
+	unset_option (OPTNEWSSEND);
+      }
+#endif
     }
 
     if (flags & (SENDPOSTPONED|SENDRESEND))
@@ -1284,8 +1435,29 @@ ci_send_message (int flags,		/* send mode */
      * have their aliases expanded.
      */
 
+    if (msg->env->from)
+        dprint (5, (debugfile, "ci_send_message: msg->env->from before set_reverse_name: %s\n", msg->env->from->mailbox));
     msg->env->from = set_reverse_name (cur->env);
   }
+  if (cur && option (OPTREPLYWITHXORIG) && !(flags & (SENDPOSTPONED|SENDRESEND|SENDFORWARD)))
+  {
+    /* We shouldn't have to worry about freeing `msg->env->from' before
+     * setting it here since this code will only execute when doing some
+     * sort of reply. The pointer will only be set when using the -H command
+     * line option.
+     *
+     * If there is already a from address recorded in `msg->env->from',
+     * then it theoretically comes from OPTREVNAME handling, and we don't use
+     * the `X-Orig-To header'.
+     */
+    if (cur->env->x_original_to && !msg->env->from)
+    {
+      msg->env->from = cur->env->x_original_to;
+      /* Not more than one from address */
+      msg->env->from->next = NULL;
+      dprint (5, (debugfile, "ci_send_message: msg->env->from extracted from X-Original-To: header: %s\n", msg->env->from->mailbox));
+    }
+  }
 
   if (! (flags & (SENDPOSTPONED|SENDRESEND)) &&
       ! ((flags & SENDDRAFTFILE) && option (OPTRESUMEDRAFTFILES)))
@@ -1303,11 +1475,16 @@ ci_send_message (int flags,		/* send mode */
     if (flags & SENDREPLY)
       mutt_fix_reply_recipients (msg->env);
 
+#ifdef USE_NNTP
+    if ((flags & SENDNEWS) && ctx && ctx->magic == MUTT_NNTP && !msg->env->newsgroups)
+      msg->env->newsgroups = safe_strdup (((NNTP_DATA *)ctx->data)->group);
+#endif
+
     if (! (flags & (SENDMAILX|SENDBATCH)) &&
 	! (option (OPTAUTOEDIT) && option (OPTEDITHDRS)) &&
 	! ((flags & SENDREPLY) && option (OPTFASTREPLY)))
     {
-      if (edit_envelope (msg->env) == -1)
+      if (edit_envelope (msg->env, flags) == -1)
 	goto cleanup;
     }
 
@@ -1606,6 +1783,11 @@ main_loop:
     if (i == -1)
     {
       /* abort */
+#ifdef USE_NNTP
+      if (flags & SENDNEWS)
+	mutt_message _("Article not posted.");
+      else
+#endif
       mutt_message _("Mail not sent.");
       goto cleanup;
     }
@@ -1647,7 +1829,9 @@ main_loop:
       mutt_prepare_envelope (msg->env, 0);
       mutt_env_to_intl (msg->env, NULL, NULL);	/* Handle bad IDNAs the next time. */
 
-      if (!Postponed || mutt_write_fcc (NONULL (Postponed), msg, (cur && (flags & SENDREPLY)) ? cur->env->message_id : NULL, 1, fcc) < 0)
+      if (!Postponed || mutt_write_fcc (NONULL (Postponed), msg,
+	                    (cur && (flags & SENDREPLY)) ?
+			             cur->env->message_id : NULL, 1, fcc, NULL) < 0)
       {
 	msg->content = mutt_remove_multipart (msg->content);
 	decode_descriptions (msg->content);
@@ -1661,6 +1845,9 @@ main_loop:
     }
   }
 
+#ifdef USE_NNTP
+  if (!(flags & SENDNEWS))
+#endif
   if (!has_recips (msg->env->to) && !has_recips (msg->env->cc) &&
       !has_recips (msg->env->bcc))
   {
@@ -1694,6 +1881,32 @@ main_loop:
       mutt_error _("No subject specified.");
     goto main_loop;
   }
+#ifdef USE_NNTP
+  if ((flags & SENDNEWS) && !msg->env->subject)
+  {
+    mutt_error _("No subject specified.");
+    goto main_loop;
+  }
+
+  if ((flags & SENDNEWS) && !msg->env->newsgroups)
+  {
+    mutt_error _("No newsgroup specified.");
+    goto main_loop;
+  }
+#endif
+
+  if (mutt_search_attach_keyword (msg->content->filename) &&
+         !msg->content->next &&
+         query_quadoption (OPT_ATTACH, _("No attachments, cancel sending?")) != MUTT_NO)
+  {
+    /* if the abort is automatic, print an error message */
+    if (quadoption (OPT_ATTACH) == MUTT_YES)
+    {
+      mutt_error _("Message contains text matching \"attach_keyword\". Not sending.");
+    }
+    goto main_loop;
+  }
+
 
   if (msg->content->next)
     msg->content = mutt_make_multipart (msg->content);
@@ -1831,7 +2044,7 @@ full_fcc:
        * message was first postponed.
        */
       msg->received = time (NULL);
-      if (mutt_write_fcc (fcc, msg, NULL, 0, NULL) == -1)
+      if (mutt_write_multiple_fcc (fcc, msg, NULL, 0, NULL, &finalpath) == -1)
       {
 	/*
 	 * Error writing FCC, we should abort sending.
@@ -1892,6 +2105,7 @@ full_fcc:
       msg->content = mutt_remove_multipart (msg->content);
       decode_descriptions (msg->content);
       mutt_unprepare_envelope (msg->env);
+      FREE(&finalpath);
       goto main_loop;
     }
     else
@@ -1900,8 +2114,18 @@ full_fcc:
       goto cleanup;
     }
   }
-  else if (!option (OPTNOCURSES) && ! (flags & SENDMAILX))
-    mutt_message (i == 0 ? _("Mail sent.") : _("Sending in background."));
+  else if (!option (OPTNOCURSES) && ! (flags & SENDMAILX)) {
+    mutt_message (i != 0 ? _("Sending in background.") :
+#ifdef USE_NNTP
+		  (flags & SENDNEWS) ? _("Article posted.") : _("Mail sent."));
+#else
+		  _("Mail sent."));
+#endif
+#ifdef USE_NOTMUCH
+    if (option(OPTNOTMUCHRECORD))
+      nm_record_message(ctx, finalpath, cur);
+#endif
+  }
 
   if (WithCrypto && (msg->security & ENCRYPT))
     FREE (&pgpkeylist);
@@ -1946,7 +2170,8 @@ cleanup:
   safe_fclose (&tempfp);
   if (! (flags & SENDNOFREEHEADER))
     mutt_free_header (&msg);
-  
+
+  FREE(&finalpath);
   return rv;
 }
 
diff --git c/sendlib.c w/sendlib.c
index 771eae2..cbc546a 100644
--- c/sendlib.c
+++ w/sendlib.c
@@ -46,6 +46,10 @@
 #include <sys/wait.h>
 #include <fcntl.h>
 
+#ifdef USE_NNTP
+#include "nntp.h"
+#endif
+
 #ifdef HAVE_SYSEXITS_H
 #include <sysexits.h>
 #else /* Make sure EX_OK is defined <philiph@pobox.com> */
@@ -73,8 +77,6 @@ const char B64Chars[64] = {
   '8', '9', '+', '/'
 };
 
-static char MsgIdPfx = 'A';
-
 static void transform_to_7bit (BODY *a, FILE *fpin);
 
 static void encode_quoted (FGETCONV * fc, FILE *fout, int istext)
@@ -272,6 +274,10 @@ static void encode_base64 (FGETCONV * fc, FILE *fout, int istext)
 
   while ((ch = fgetconv (fc)) != EOF)
   {
+    if (SigInt == 1) {
+      SigInt = 0;
+      return;
+    }
     if (istext && ch == '\n' && ch1 != '\r')
       b64_putc('\r', fout);
     b64_putc(ch, fout);
@@ -285,8 +291,13 @@ static void encode_8bit (FGETCONV *fc, FILE *fout, int istext)
 {
   int ch;
 
-  while ((ch = fgetconv (fc)) != EOF)
+  while ((ch = fgetconv (fc)) != EOF) {
+    if (SigInt == 1) {
+      SigInt = 0;
+      return;
+    }
     fputc (ch, fout);
+  }
 }
 
 
@@ -463,6 +474,7 @@ int mutt_write_mime_body (BODY *a, FILE *f)
   else
     fc = fgetconv_open (fpin, 0, 0, 0);
 
+  mutt_allow_interrupt (1);
   if (a->encoding == ENCQUOTEDPRINTABLE)
     encode_quoted (fc, f, write_as_text_part (a));
   else if (a->encoding == ENCBASE64)
@@ -471,27 +483,26 @@ int mutt_write_mime_body (BODY *a, FILE *f)
     encode_8bit (fc, f, write_as_text_part (a));
   else
     mutt_copy_stream (fpin, f);
+  mutt_allow_interrupt (0);
 
   fgetconv_close (&fc);
   safe_fclose (&fpin);
 
+  if (SigInt == 1) {
+    SigInt = 0;
+    return -1;
+  }
   return (ferror (f) ? -1 : 0);
 }
 
 #undef write_as_text_part
 
-#define BOUNDARYLEN 16
 void mutt_generate_boundary (PARAMETER **parm)
 {
-  char rs[BOUNDARYLEN + 1];
-  char *p = rs;
-  int i;
-
-  rs[BOUNDARYLEN] = 0;
-  for (i=0;i<BOUNDARYLEN;i++)
-    *p++ = B64Chars[LRAND() % sizeof (B64Chars)];
-  *p = 0;
+  char rs[MUTT_RANDTAG_LEN + 1];
 
+  mutt_rand_base32(rs, sizeof(rs) - 1);
+  rs[MUTT_RANDTAG_LEN] = 0;
   mutt_set_parameter ("boundary", rs, parm);
 }
 
@@ -1546,6 +1557,14 @@ void mutt_write_references (LIST *r, FILE *f, int trim)
 {
   LIST **ref = NULL;
   int refcnt = 0, refmax = 0;
+  int multiline = 1;
+  int space = 0;
+
+  if (trim < 0)
+  {
+    trim = -trim;
+    multiline = 0;
+  }
 
   for ( ; (trim == 0 || refcnt < trim) && r ; r = r->next)
   {
@@ -1556,9 +1575,11 @@ void mutt_write_references (LIST *r, FILE *f, int trim)
 
   while (refcnt-- > 0)
   {
-    fputc (' ', f);
+    if (multiline || space)
+      fputc (' ', f);
+    space = 1;
     fputs (ref[refcnt]->data, f);
-    if (refcnt >= 1)
+    if (multiline && refcnt >= 1)
       fputc ('\n', f);
   }
 
@@ -1972,6 +1993,9 @@ int mutt_write_rfc822_header (FILE *fp, ENVELOPE *env, BODY *attach,
     mutt_write_address_list (env->to, fp, 4, 0);
   }
   else if (mode > 0)
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
     fputs ("To: \n", fp);
 
   if (env->cc)
@@ -1980,6 +2004,9 @@ int mutt_write_rfc822_header (FILE *fp, ENVELOPE *env, BODY *attach,
     mutt_write_address_list (env->cc, fp, 4, 0);
   }
   else if (mode > 0)
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
     fputs ("Cc: \n", fp);
 
   if (env->bcc)
@@ -1991,8 +2018,28 @@ int mutt_write_rfc822_header (FILE *fp, ENVELOPE *env, BODY *attach,
     }
   }
   else if (mode > 0)
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
     fputs ("Bcc: \n", fp);
 
+#ifdef USE_NNTP
+  if (env->newsgroups)
+    fprintf (fp, "Newsgroups: %s\n", env->newsgroups);
+  else if (mode == 1 && option (OPTNEWSSEND))
+    fputs ("Newsgroups: \n", fp);
+
+  if (env->followup_to)
+    fprintf (fp, "Followup-To: %s\n", env->followup_to);
+  else if (mode == 1 && option (OPTNEWSSEND))
+    fputs ("Followup-To: \n", fp);
+
+  if (env->x_comment_to)
+    fprintf (fp, "X-Comment-To: %s\n", env->x_comment_to);
+  else if (mode == 1 && option (OPTNEWSSEND) && option (OPTXCOMMENTTO))
+    fputs ("X-Comment-To: \n", fp);
+#endif
+
   if (env->subject)
     mutt_write_one_header (fp, "Subject", env->subject, NULL, 0, 0);
   else if (mode == 1)
@@ -2011,6 +2058,9 @@ int mutt_write_rfc822_header (FILE *fp, ENVELOPE *env, BODY *attach,
     fputs ("Reply-To: \n", fp);
 
   if (env->mail_followup_to)
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+#endif
   {
     fputs ("Mail-Followup-To: ", fp);
     mutt_write_address_list (env->mail_followup_to, fp, 18, 0);
@@ -2072,7 +2122,7 @@ int mutt_write_rfc822_header (FILE *fp, ENVELOPE *env, BODY *attach,
   if (mode == 0 && !privacy && option (OPTXMAILER) && !has_agent)
   {
     /* Add a vanity header */
-    fprintf (fp, "User-Agent: Mutt/%s (%s)\n", MUTT_VERSION, ReleaseDate);
+    fprintf (fp, "User-Agent: NeoMutt/%s (%s)\n", PACKAGE_VERSION, OldMuttVer);
   }
 
   return (ferror (fp) == 0 ? 0 : -1);
@@ -2136,16 +2186,18 @@ char *mutt_gen_msgid (void)
   time_t now;
   struct tm *tm;
   const char *fqdn;
+  unsigned char rndid[MUTT_RANDTAG_LEN + 1];
 
+  mutt_rand_base32(rndid, sizeof(rndid) - 1);
+  rndid[MUTT_RANDTAG_LEN] = 0;
   now = time (NULL);
   tm = gmtime (&now);
   if(!(fqdn = mutt_fqdn(0)))
     fqdn = NONULL(Hostname);
 
-  snprintf (buf, sizeof (buf), "<%d%02d%02d%02d%02d%02d.G%c%u@%s>",
+  snprintf (buf, sizeof (buf), "<%d%02d%02d%02d%02d%02d.%s@%s>",
 	    tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour,
-	    tm->tm_min, tm->tm_sec, MsgIdPfx, (unsigned int)getpid (), fqdn);
-  MsgIdPfx = (MsgIdPfx == 'Z') ? 'A' : MsgIdPfx + 1;
+	    tm->tm_min, tm->tm_sec, rndid, fqdn);
   return (safe_strdup (buf));
 }
 
@@ -2354,6 +2406,23 @@ mutt_invoke_sendmail (ADDRESS *from,	/* the sender */
   size_t argslen = 0, argsmax = 0;
   int i;
 
+#ifdef USE_NNTP
+  if (option (OPTNEWSSEND))
+  {
+    char cmd[LONG_STRING];
+
+    mutt_FormatString (cmd, sizeof (cmd), 0, MuttIndexWindow->cols, NONULL (Inews), nntp_format_str, 0, 0);
+    if (!*cmd)
+    {
+      i = nntp_post (msg);
+      unlink (msg);
+      return i;
+    }
+
+    s = safe_strdup (cmd);
+  }
+#endif
+
   /* ensure that $sendmail is set to avoid a crash. http://dev.mutt.org/trac/ticket/3548 */
   if (!s)
   {
@@ -2384,6 +2453,10 @@ mutt_invoke_sendmail (ADDRESS *from,	/* the sender */
     i++;
   }
 
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND))
+  {
+#endif
   if (eightbit && option (OPTUSE8BITMIME))
     args = add_option (args, &argslen, &argsmax, "-B8BITMIME");
 
@@ -2415,6 +2488,9 @@ mutt_invoke_sendmail (ADDRESS *from,	/* the sender */
   args = add_args (args, &argslen, &argsmax, to);
   args = add_args (args, &argslen, &argsmax, cc);
   args = add_args (args, &argslen, &argsmax, bcc);
+#ifdef USE_NNTP
+  }
+#endif
 
   if (argslen == argsmax)
     safe_realloc (&args, sizeof (char *) * (++argsmax));
@@ -2492,9 +2568,11 @@ void mutt_prepare_envelope (ENVELOPE *env, int final)
   rfc2047_encode_adrlist (env->from, "From");
   rfc2047_encode_adrlist (env->mail_followup_to, "Mail-Followup-To");
   rfc2047_encode_adrlist (env->reply_to, "Reply-To");
-  rfc2047_encode_string (&env->x_label);
 
   if (env->subject)
+#ifdef USE_NNTP
+  if (!option (OPTNEWSSEND) || option (OPTMIMESUBJECT))
+#endif
   {
     rfc2047_encode_string (&env->subject);
   }
@@ -2517,7 +2595,6 @@ void mutt_unprepare_envelope (ENVELOPE *env)
   rfc2047_decode_adrlist (env->from);
   rfc2047_decode_adrlist (env->reply_to);
   rfc2047_decode (&env->subject);
-  rfc2047_decode (&env->x_label);
 }
 
 static int _mutt_bounce_message (FILE *fp, HEADER *h, ADDRESS *to, const char *resent_from,
@@ -2562,9 +2639,12 @@ static int _mutt_bounce_message (FILE *fp, HEADER *h, ADDRESS *to, const char *r
     mutt_copy_header (fp, h, f, ch_flags, NULL);
     fputc ('\n', f);
     mutt_copy_bytes (fp, f, h->content->length);
-    safe_fclose (&f);
     FREE (&msgid_str);
-
+    if (safe_fclose (&f) != 0) {
+      mutt_perror(tempfile);
+      unlink(tempfile);
+      return -1;
+    }
 #if USE_SMTP
     if (SmtpUrl)
       ret = mutt_smtp_send (env_from, to, NULL, NULL, tempfile,
@@ -2615,6 +2695,10 @@ int mutt_bounce_message (FILE *fp, HEADER *h, ADDRESS *to)
   }
   rfc822_write_address (resent_from, sizeof (resent_from), from, 0);
 
+#ifdef USE_NNTP
+  unset_option (OPTNEWSSEND);
+#endif
+
   /*
    * prepare recipient list. idna conversion appears to happen before this
    * function is called, since the user receives confirmation of the address
@@ -2690,7 +2774,44 @@ static void set_noconv_flags (BODY *b, short flag)
   }
 }
 
-int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int post, char *fcc)
+/* Handle a Fcc with multiple, comma separated entries. */
+int mutt_write_multiple_fcc (const char *path, HEADER *hdr, const char *msgid,
+        int post, char *fcc, char **finalpath)
+{
+  char fcc_tok[_POSIX_PATH_MAX];
+  char fcc_expanded[_POSIX_PATH_MAX];
+  char *tok = NULL;
+  int status;
+
+  strfcpy(fcc_tok, path, sizeof (fcc_tok));
+
+  tok = strtok(fcc_tok, ",");
+  dprint(1, (debugfile, "Fcc: initial mailbox = '%s'\n", tok));
+  /* mutt_expand_path already called above for the first token */
+  status = mutt_write_fcc (tok, hdr, msgid, post, fcc, finalpath);
+  if (status != 0)
+    return status;
+
+  while ((tok = strtok (NULL, ",")) != NULL)
+  {
+    if (!*tok)
+      continue;
+
+    /* Only call mutt_expand_path iff tok has some data */
+    dprint (1, (debugfile, "Fcc: additional mailbox token = '%s'\n", tok));
+    strfcpy (fcc_expanded, tok, sizeof (fcc_expanded));
+    mutt_expand_path (fcc_expanded, sizeof (fcc_expanded));
+    dprint (1, (debugfile, "     Additional mailbox expanded = '%s'\n", fcc_expanded));
+    status = mutt_write_fcc (fcc_expanded, hdr, msgid, post, fcc, finalpath);
+    if (status != 0)
+      return status;
+  }
+
+  return 0;
+}
+
+int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid,
+		    int post, char *fcc, char **finalpath)
 {
   CONTEXT f;
   MESSAGE *msg;
@@ -2879,6 +3000,8 @@ int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int post,
 
   if (mx_commit_message (msg, &f) != 0)
     r = -1;
+  else if (finalpath)
+    *finalpath = safe_strdup(msg->commited_path);
   mx_close_message (&f, &msg);
   mx_close_mailbox (&f, NULL);
 
diff --git c/sidebar.c w/sidebar.c
index 5b7edaf..a0162cd 100644
--- c/sidebar.c
+++ w/sidebar.c
@@ -27,7 +27,9 @@
 #include "keymap.h"
 #include "mutt_curses.h"
 #include "mutt_menu.h"
+#include "mx.h"
 #include "sort.h"
+#include "sidebar.h"
 
 /* Previous values for some sidebar config */
 static short PreviousSort = SORT_ORDER;  /* sidebar_sort_method */
@@ -54,6 +56,39 @@ static int BotIndex = -1;    /* Last mailbox visible in sidebar */
 static int select_next (void);
 
 
+enum {
+	SB_SRC_NONE = 0,
+	SB_SRC_VIRT,
+	SB_SRC_INCOMING
+};
+static int sidebar_source = SB_SRC_NONE;
+
+static BUFFY *
+get_incoming (void)
+{
+	switch (sidebar_source) {
+	case SB_SRC_NONE:
+		sidebar_source = SB_SRC_INCOMING;
+
+#ifdef USE_NOTMUCH
+		if (option (OPTVIRTSPOOLFILE) && VirtIncoming) {
+			sidebar_source = SB_SRC_VIRT;
+			return VirtIncoming;
+		}
+		break;
+	case SB_SRC_VIRT:
+		if (VirtIncoming) {
+			return VirtIncoming;
+		}
+		break;
+#endif
+	case SB_SRC_INCOMING:
+		break;
+	}
+
+	return Incoming;	/* default */
+}
+
 /**
  * cb_format_str - Create the string to show in the sidebar
  * @dest:        Buffer in which to save string
@@ -202,7 +237,7 @@ static const char *cb_format_str(char *dest, size_t destlen, size_t col, int col
  * @buflen:  Buffer length
  * @width:   Desired width in screen cells
  * @box:     Mailbox name
- * @b:       Mailbox object
+ * @sbe:     Mailbox object
  *
  * Take all the relevant mailbox data and the desired screen width and then get
  * mutt_FormatString to do the actual work. mutt_FormatString will callback to
@@ -263,11 +298,14 @@ static int cb_qsort_sbe (const void *a, const void *b)
     case SORT_COUNT_NEW:
       result = (b2->msg_unread - b1->msg_unread);
       break;
+    case SORT_DESC:
+      result = mutt_strcmp (b1->desc, b2->desc);
+      break;
     case SORT_FLAGGED:
       result = (b2->msg_flagged - b1->msg_flagged);
       break;
     case SORT_PATH:
-      result = mutt_strcasecmp (b1->path, b2->path);
+      result = mutt_strcoll (b1->path, b2->path);
       break;
   }
 
@@ -324,7 +362,7 @@ static void update_entries_visibility (void)
  */
 static void unsort_entries (void)
 {
-  BUFFY *cur = Incoming;
+  BUFFY *cur = get_incoming();
   int i = 0, j;
   SBENTRY *tmp;
 
@@ -487,10 +525,17 @@ static int draw_divider (int num_rows, int num_cols)
 
   SETCOLOR(MT_COLOR_DIVIDER);
 
+  int col;
+  if (option (OPTSIDEBARONRIGHT)) {
+    col = 0;
+  } else {
+    col = SidebarWidth - delim_len;
+  }
+
   int i;
   for (i = 0; i < num_rows; i++)
   {
-    mutt_window_move (MuttSidebarWindow, i, SidebarWidth - delim_len);	//RAR 0 for rhs
+    mutt_window_move (MuttSidebarWindow, i, col);
     addstr (NONULL(SidebarDividerChar));
   }
 
@@ -501,21 +546,26 @@ static int draw_divider (int num_rows, int num_cols)
  * fill_empty_space - Wipe the remaining Sidebar space
  * @first_row:  Window line to start (0-based)
  * @num_rows:   Number of rows to fill
- * @width:      Width of the Sidebar (minus the divider)
+ * @div_width:  Width in screen characters taken by the divider
+ * @num_cols:   Number of columns to fill
  *
  * Write spaces over the area the sidebar isn't using.
  */
-static void fill_empty_space (int first_row, int num_rows, int width)
+static void fill_empty_space (int first_row, int num_rows, int div_width, int num_cols)
 {
   /* Fill the remaining rows with blank space */
   SETCOLOR(MT_COLOR_NORMAL);
 
+  if (!option (OPTSIDEBARONRIGHT))
+    div_width = 0;
+
   int r;
   for (r = 0; r < num_rows; r++)
   {
-    mutt_window_move (MuttSidebarWindow, first_row + r, 0);	//RAR rhs
+    mutt_window_move (MuttSidebarWindow, first_row + r, div_width);
+
     int i;
-    for (i = 0; i < width; i++)
+    for (i = 0; i < num_cols; i++)
       addch (' ');
   }
 }
@@ -575,9 +625,19 @@ static void draw_sidebar (int num_rows, int num_cols, int div_width)
     else if (b->msg_flagged > 0)
       SETCOLOR(MT_COLOR_FLAGGED);
     else
-      SETCOLOR(MT_COLOR_NORMAL);
+    {
+      if (ColorDefs[MT_COLOR_ORDINARY] != 0)
+        SETCOLOR(MT_COLOR_ORDINARY);
+      else
+        SETCOLOR(MT_COLOR_NORMAL);
+    }
 
-    mutt_window_move (MuttSidebarWindow, row, 0);
+    int col = 0;
+    if (option (OPTSIDEBARONRIGHT)) {
+      col = div_width;
+    }
+
+    mutt_window_move (MuttSidebarWindow, row, col);
     if (Context && Context->realpath &&
         !mutt_strcmp (b->realpath, Context->realpath))
     {
@@ -644,6 +704,12 @@ static void draw_sidebar (int num_rows, int num_cols, int div_width)
         safe_strcat (sidebar_folder_name, sfn_len, tmp_folder_name);
       }
     }
+#ifdef USE_NOTMUCH
+    else if (b->magic == MUTT_NOTMUCH)
+    {
+      sidebar_folder_name = b->desc;
+    }
+#endif
     char str[STRING];
     make_sidebar_entry (str, sizeof (str), w, sidebar_folder_name, entry);
     printw ("%s", str);
@@ -652,7 +718,7 @@ static void draw_sidebar (int num_rows, int num_cols, int div_width)
     row++;
   }
 
-  fill_empty_space (row, num_rows - row, w);
+  fill_empty_space (row, num_rows - row, div_width, w);
 }
 
 
@@ -667,6 +733,14 @@ void mutt_sb_draw (void)
   if (!option (OPTSIDEBAR))
     return;
 
+#ifdef USE_SLANG_CURSES
+  int x = SLsmg_get_column();
+  int y = SLsmg_get_row();
+#else
+  int x = getcurx (stdscr);
+  int y = getcury (stdscr);
+#endif
+
   int num_rows  = MuttSidebarWindow->rows;
   int num_cols  = MuttSidebarWindow->cols;
 
@@ -674,9 +748,14 @@ void mutt_sb_draw (void)
   if (div_width < 0)
     return;
 
-  if (!Incoming)
+  BUFFY *b;
+  if (Entries == NULL)
+    for (b = get_incoming(); b; b = b->next)
+      mutt_sb_notify_mailbox (b, 1);
+
+  if (!get_incoming())
   {
-    fill_empty_space (0, num_rows, SidebarWidth - div_width);
+    fill_empty_space (0, num_rows, div_width, num_cols - div_width);
     return;
   }
 
@@ -684,6 +763,7 @@ void mutt_sb_draw (void)
     return;
 
   draw_sidebar (num_rows, num_cols, div_width);
+  move (y, x);
 }
 
 /**
@@ -918,7 +998,7 @@ void mutt_sb_set_buffystats (const CONTEXT *ctx)
 {
   /* Even if the sidebar's hidden,
    * we should take note of the new data. */
-  BUFFY *b = Incoming;
+  BUFFY *b = get_incoming();
   if (!ctx || !b)
     return;
 
@@ -995,6 +1075,9 @@ void mutt_sb_notify_mailbox (BUFFY *b, int created)
   if (!b)
     return;
 
+  if (sidebar_source == SB_SRC_NONE)
+    return;
+
   /* Any new/deleted mailboxes will cause a refresh.  As long as
    * they're valid, our pointers will be updated in prepare_sidebar() */
 
@@ -1045,3 +1128,36 @@ void mutt_sb_notify_mailbox (BUFFY *b, int created)
 
   SidebarNeedsRedraw = 1;
 }
+
+/**
+ * mutt_sb_toggle_virtual - Switch between regular and virtual folders
+ */
+void
+mutt_sb_toggle_virtual (void)
+{
+	if (sidebar_source == -1)
+		get_incoming();
+
+#ifdef USE_NOTMUCH
+	if ((sidebar_source == SB_SRC_INCOMING) && VirtIncoming)
+		sidebar_source = SB_SRC_VIRT;
+	else
+#endif
+		sidebar_source = SB_SRC_INCOMING;
+
+	TopIndex = -1;
+	OpnIndex = -1;
+	HilIndex = -1;
+	BotIndex = -1;
+
+	BUFFY *b;
+
+	EntryCount = 0;
+	FREE(&Entries);
+	EntryLen = 0;
+	for (b = get_incoming(); b; b = b->next)
+		mutt_sb_notify_mailbox (b, 1);
+
+	SidebarNeedsRedraw = 1;
+}
+
diff --git c/sidebar.h w/sidebar.h
index 3a04c5e..0ec1239 100644
--- c/sidebar.h
+++ w/sidebar.h
@@ -28,6 +28,7 @@ void         mutt_sb_draw (void);
 const char * mutt_sb_get_highlight (void);
 void         mutt_sb_notify_mailbox (BUFFY *b, int created);
 void         mutt_sb_set_buffystats (const CONTEXT *ctx);
-BUFFY *      mutt_sb_set_open_buffy (void);
+void         mutt_sb_set_open_buffy (void);
+void         mutt_sb_toggle_virtual (void);
 
 #endif /* SIDEBAR_H */
diff --git c/sort.c w/sort.c
index 76e9e79..9b1db9f 100644
--- c/sort.c
+++ w/sort.c
@@ -24,6 +24,11 @@
 #include "sort.h"
 #include "mutt_idna.h"
 
+#ifdef USE_NNTP
+#include "mx.h"
+#include "nntp.h"
+#endif
+
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
@@ -151,6 +156,17 @@ static int compare_order (const void *a, const void *b)
   HEADER **ha = (HEADER **) a;
   HEADER **hb = (HEADER **) b;
 
+#ifdef USE_NNTP
+  if (Context && Context->magic == MUTT_NNTP)
+  {
+    anum_t na = NHDR (*ha)->article_num;
+    anum_t nb = NHDR (*hb)->article_num;
+    int result = na == nb ? 0 : na > nb ? 1 : -1;
+    AUXSORT (result, a, b);
+    return (SORTCODE (result));
+  }
+  else
+#endif
   /* no need to auxsort because you will never have equality here */
   return (SORTCODE ((*ha)->index - (*hb)->index));
 }
@@ -210,6 +226,46 @@ static int compare_spam (const void *a, const void *b)
   return (SORTCODE(result));
 }
 
+int compare_label (const void *a, const void *b)
+{
+  HEADER **ppa = (HEADER **) a;
+  HEADER **ppb = (HEADER **) b;
+  int     ahas, bhas, result = 0;
+  LIST *la, *lb;
+
+  /* As with compare_spam, not all messages will have the x-label
+   * property.  Blank X-Labels are treated as null in the index
+   * display, so we'll consider them as null for sort, too.       */
+  ahas = (*ppa)->env && (*ppa)->env->labels;
+  bhas = (*ppb)->env && (*ppb)->env->labels;
+
+  /* First we bias toward a message with a label, if the other does not. */
+  if (ahas && !bhas)
+    return (SORTCODE(-1));
+  if (!ahas && bhas)
+    return (SORTCODE(1));
+
+  /* If neither has a label, use aux sort. */
+  if (!ahas && !bhas)
+  {
+    AUXSORT(result, a, b);
+    return (SORTCODE(result));
+  }
+
+  /* If both have a label, we just do a lexical compare. */
+  for (la = (*ppa)->env->labels, lb = (*ppb)->env->labels;
+       la && la->data && lb && lb->data && result == 0;
+       la = la->next, lb = lb->next)
+  {
+    result = mutt_strcasecmp(la->data, lb->data);
+  }
+  if (result == 0 && la == NULL)
+    return (SORTCODE(-1));
+  if (result == 0 && lb == NULL)
+    return (SORTCODE(1));
+  return (SORTCODE(result));
+}
+
 sort_t *mutt_get_sort_func (int method)
 {
   switch (method & SORT_MASK)
@@ -232,6 +288,8 @@ sort_t *mutt_get_sort_func (int method)
       return (compare_score);
     case SORT_SPAM:
       return (compare_spam);
+    case SORT_LABEL:
+      return (compare_label);
     default:
       return (NULL);
   }
diff --git c/sort.h w/sort.h
index 26afdc6..4242e9d 100644
--- c/sort.h
+++ w/sort.h
@@ -35,10 +35,22 @@
 #define SORT_COUNT_NEW	16
 #define SORT_FLAGGED	17
 #define SORT_PATH	18
+#define SORT_DESC	19
+#define SORT_LABEL	20
 
-/* dgc: Sort & SortAux are shorts, so I'm bumping these bitflags up from
- * bits 4 & 5 to bits 8 & 9 to make room for more sort keys in the future. */
-#define SORT_MASK	0xff
+/* Sort and sort_aux are shorts, and are a composite of a
+ * constant sort operation number and a set of compounded
+ * bitflags.
+ *
+ * Everything below SORT_MASK is a constant. There's room for
+ * SORT_MASK constant SORT_ values.
+ *
+ * Everything above is a bitflag. It's OK to move SORT_MASK
+ * down by powers of 2 if we need more, so long as we don't
+ * collide with the constants above. (Or we can just expand
+ * sort and sort_aux to uint32_t.)
+ */
+#define SORT_MASK	((1<<8) - 1)
 #define SORT_REVERSE	(1<<8)
 #define SORT_LAST	(1<<9)
 
diff --git c/status.c w/status.c
index a8921a9..ec09093 100644
--- c/status.c
+++ w/status.c
@@ -27,6 +27,10 @@
 #include "mapping.h"
 #include "mx.h"
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include <string.h>
 #include <ctype.h>
 #include <unistd.h>
@@ -95,7 +99,20 @@ status_format_str (char *buf, size_t buflen, size_t col, int cols, char op, cons
       break;
 
     case 'f':
-      snprintf (fmt, sizeof(fmt), "%%%ss", prefix);
+    {
+#ifdef USE_NOTMUCH
+      char *p;
+      if (Context && Context->magic == MUTT_NOTMUCH &&
+                   (p = nm_get_description(Context)))
+	  strfcpy(tmp, p, sizeof (tmp));
+      else
+#endif
+#ifdef USE_COMPRESSED
+      if (Context && Context->compress_info && Context->realpath) {
+	 strfcpy (tmp, Context->realpath, sizeof (tmp));
+	 mutt_pretty_mailbox (tmp, sizeof (tmp));
+      } else
+#endif
       if (Context && Context->path)
       {
 	strfcpy (tmp, Context->path, sizeof (tmp));
@@ -103,9 +120,11 @@ status_format_str (char *buf, size_t buflen, size_t col, int cols, char op, cons
       }
       else
 	strfcpy (tmp, _("(no mailbox)"), sizeof (tmp));
+
+      snprintf (fmt, sizeof(fmt), "%%%ss", prefix);
       snprintf (buf, buflen, fmt, tmp);
       break;
-
+    }
     case 'F':
       if (!optional)
       {
@@ -266,8 +285,8 @@ status_format_str (char *buf, size_t buflen, size_t col, int cols, char op, cons
       break;
 
     case 'v':
-      snprintf (fmt, sizeof (fmt), "Mutt %%s");
-      snprintf (buf, buflen, fmt, MUTT_VERSION);
+      snprintf (fmt, sizeof (fmt), "NeoMutt %%s");
+      snprintf (buf, buflen, fmt, PACKAGE_VERSION);
       break;
 
     case 'V':
diff --git c/strndup.c w/strndup.c
new file mode 100644
index 0000000..f130730
--- /dev/null
+++ w/strndup.c
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2013 Karel Zak <kzak@redhat.com>
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+
+char *strndup(const char *s, size_t n)
+{
+	size_t len = strnlen(s, n);
+	char *new = malloc((len + 1) * sizeof(char));
+	if (!new)
+		return NULL;
+	new[len] = '\0';
+	return (char *) memcpy(new, s, len);
+}
diff --git c/strnlen.c w/strnlen.c
new file mode 100644
index 0000000..278a988
--- /dev/null
+++ w/strnlen.c
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2013 Karel Zak <kzak@redhat.com>
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+
+size_t strnlen(const char *s, size_t maxlen)
+{
+        int i;
+
+        for (i = 0; i < maxlen; i++) {
+                if (s[i] == '\0')
+                        return i + 1;
+        }
+        return maxlen;
+}
diff --git c/thread.c w/thread.c
index cf77bdb..6d97be0 100644
--- c/thread.c
+++ w/thread.c
@@ -752,6 +752,7 @@ void mutt_sort_threads (CONTEXT *ctx, int init)
   HEADER *cur;
   int i, oldsort, using_refs = 0;
   THREAD *thread, *new, *tmp, top;
+  memset (&top, 0, sizeof (top));
   LIST *ref = NULL;
   
   /* set Sort to the secondary method to support the set sort_aux=reverse-*
diff --git c/url.c w/url.c
index 42a6e09..2abad4b 100644
--- c/url.c
+++ w/url.c
@@ -29,6 +29,7 @@
 #include "url.h"
 
 #include "mime.h"
+#include "rfc2047.h"
 
 #include <ctype.h>
 
@@ -39,13 +40,18 @@ static const struct mapping_t UrlMap[] =
   { "imaps", 	U_IMAPS },
   { "pop",  	U_POP },
   { "pops", 	U_POPS },
+  { "news",	U_NNTP },
+  { "snews",	U_NNTPS },
   { "mailto",	U_MAILTO },
+#ifdef USE_NOTMUCH
+  { "notmuch",  U_NOTMUCH },
+#endif
   { "smtp",     U_SMTP },
   { "smtps",    U_SMTPS },
   { NULL,	U_UNKNOWN }
 };
 
-static int url_pct_decode (char *s)
+int url_pct_decode (char *s)
 {
   char *d;
 
@@ -214,7 +220,7 @@ int url_ciss_tostring (ciss_url_t* ciss, char* dest, size_t len, int flags)
       safe_strcat (dest, len, "//");
     len -= (l = strlen (dest)); dest += l;
 
-    if (ciss->user)
+    if (ciss->user && (ciss->user[0] || !(flags & U_PATH)))
     {
       char u[STRING];
       url_pct_encode (u, sizeof (u), ciss->user);
@@ -309,12 +315,24 @@ int url_parse_mailto (ENVELOPE *e, char **body, const char *src)
 	safe_asprintf (&scratch, "%s: %s", tag, value);
 	scratch[taglen] = 0; /* overwrite the colon as mutt_parse_rfc822_line expects */
 	value = skip_email_wsp(&scratch[taglen + 1]);
-	mutt_parse_rfc822_line (e, NULL, scratch, value, 1, 0, 0, &last);
+	mutt_parse_rfc822_line (e, NULL, scratch, value, 1, 0, 1, &last);
 	FREE (&scratch);
       }
     }
   }
 
+  /* RFC2047 decode after the RFC822 parsing */
+  rfc2047_decode_adrlist (e->from);
+  rfc2047_decode_adrlist (e->to);
+  rfc2047_decode_adrlist (e->cc);
+  rfc2047_decode_adrlist (e->bcc);
+  rfc2047_decode_adrlist (e->reply_to);
+  rfc2047_decode_adrlist (e->mail_followup_to);
+  rfc2047_decode_adrlist (e->return_path);
+  rfc2047_decode_adrlist (e->sender);
+  rfc2047_decode (&e->x_label);
+  rfc2047_decode (&e->subject);
+
   rc = 0;
 
 out:
diff --git c/url.h w/url.h
index 926416e..d07150f 100644
--- c/url.h
+++ w/url.h
@@ -8,9 +8,14 @@ typedef enum url_scheme
   U_POPS,
   U_IMAP,
   U_IMAPS,
+  U_NNTP,
+  U_NNTPS,
   U_SMTP,
   U_SMTPS,
   U_MAILTO,
+#ifdef USE_NOTMUCH
+  U_NOTMUCH,
+#endif
   U_UNKNOWN
 }
 url_scheme_t;
@@ -34,5 +39,6 @@ int url_parse_file (char *d, const char *src, size_t dl);
 int url_parse_ciss (ciss_url_t *ciss, char *src);
 int url_ciss_tostring (ciss_url_t* ciss, char* dest, size_t len, int flags);
 int url_parse_mailto (ENVELOPE *e, char **body, const char *src);
+int url_pct_decode (char *s);
 
 #endif
diff --git c/version.c w/version.c
new file mode 100644
index 0000000..fd3d12f
--- /dev/null
+++ w/version.c
@@ -0,0 +1,527 @@
+/**
+ * Copyright (C) 1996-2007 Michael R. Elkins <me@mutt.org>
+ * Copyright (C) 1999-2007 Thomas Roessler <roessler@does-not-exist.org>
+ * Copyright (C) 2016 Richard Russon
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <sys/utsname.h>
+
+#ifdef HAVE_STRINGPREP_H
+#include <stringprep.h>
+#elif defined (HAVE_IDN_STRINGPREP_H)
+#include <idn/stringprep.h>
+#endif
+#ifdef USE_SLANG_CURSES
+#include "slang.h"
+#endif
+
+#include "lib.h"
+
+/* #include "protos.h" */
+const char * mutt_make_version (void);
+void mutt_print_patchlist (void);
+
+/* #include "hcache.h" */
+const char * mutt_hcache_backend (void);
+
+const int SCREEN_WIDTH = 80;
+
+extern const char cc_version[];
+extern const char cc_cflags[];
+extern const char configure_options[];
+
+static const char *Copyright = N_(
+  "Copyright (C) 1996-2016 Michael R. Elkins <me@mutt.org>\n"
+  "Copyright (C) 1996-2002 Brandon Long <blong@fiction.net>\n"
+  "Copyright (C) 1997-2009 Thomas Roessler <roessler@does-not-exist.org>\n"
+  "Copyright (C) 1998-2005 Werner Koch <wk@isil.d.shuttle.de>\n"
+  "Copyright (C) 1999-2014 Brendan Cully <brendan@kublai.com>\n"
+  "Copyright (C) 1999-2002 Tommi Komulainen <Tommi.Komulainen@iki.fi>\n"
+  "Copyright (C) 2000-2004 Edmund Grimley Evans <edmundo@rano.org>\n"
+  "Copyright (C) 2006-2009 Rocco Rutte <pdmef@gmx.net>\n"
+  "Copyright (C) 2014-2016 Kevin J. McCarthy <kevin@8t8.us>\n"
+  "\n"
+  "Many others not mentioned here contributed code, fixes,\n"
+  "and suggestions.\n"
+);
+
+static const char *License = N_(
+  "    This program is free software; you can redistribute it and/or modify\n"
+  "    it under the terms of the GNU General Public License as published by\n"
+  "    the Free Software Foundation; either version 2 of the License, or\n"
+  "    (at your option) any later version.\n"
+  "\n"
+  "    This program is distributed in the hope that it will be useful,\n"
+  "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
+  "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
+  "    GNU General Public License for more details.\n"
+);
+
+static const char *Obtaining = N_(
+  "    You should have received a copy of the GNU General Public License\n"
+  "    along with this program; if not, write to the Free Software\n"
+  "    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
+);
+
+static const char *ReachingUs = N_(
+  "To learn more about NeoMutt, visit: http://www.neomutt.org/\n"
+  "If you find a bug in NeoMutt, please raise an issue at:\n"
+  "    https://github.com/neomutt/neomutt/issues\n"
+  "or send an email to: <neomutt-devel@neomutt.org>\n"
+);
+
+static const char *Notice = N_(
+  "Copyright (C) 1996-2016 Michael R. Elkins and others.\n"
+  "Mutt comes with ABSOLUTELY NO WARRANTY; for details type `mutt -vv'.\n"
+  "Mutt is free software, and you are welcome to redistribute it\n"
+  "under certain conditions; type `mutt -vv' for details.\n"
+);
+
+struct compile_options
+{
+  const char *name;
+  int enabled;
+};
+
+static struct compile_options comp_opts[] =
+{
+#ifdef CRYPT_BACKEND_CLASSIC_PGP
+  { "CRYPT_BACKEND_CLASSIC_PGP", 1 },
+#else
+  { "CRYPT_BACKEND_CLASSIC_PGP", 0 },
+#endif
+#ifdef CRYPT_BACKEND_CLASSIC_SMIME
+  { "CRYPT_BACKEND_CLASSIC_SMIME", 1 },
+#else
+  { "CRYPT_BACKEND_CLASSIC_SMIME", 0 },
+#endif
+#ifdef CRYPT_BACKEND_GPGME
+  { "CRYPT_BACKEND_GPGME", 1 },
+#else
+  { "CRYPT_BACKEND_GPGME", 0 },
+#endif
+#ifdef DEBUG
+  { "DEBUG", 1 },
+#else
+  { "DEBUG", 0 },
+#endif
+#ifdef DL_STANDALONE
+  { "DL_STANDALONE", 1 },
+#else
+  { "DL_STANDALONE", 0 },
+#endif
+#ifdef ENABLE_NLS
+  { "ENABLE_NLS", 1 },
+#else
+  { "ENABLE_NLS", 0 },
+#endif
+#ifdef EXACT_ADDRESS
+  { "EXACT_ADDRESS", 1 },
+#else
+  { "EXACT_ADDRESS", 0 },
+#endif
+#ifdef HOMESPOOL
+  { "HOMESPOOL", 1 },
+#else
+  { "HOMESPOOL", 0 },
+#endif
+#ifdef LOCALES_HACK
+  { "LOCALES_HACK", 1 },
+#else
+  { "LOCALES_HACK", 0 },
+#endif
+#ifdef SUN_ATTACHMENT
+  { "SUN_ATTACHMENT", 1 },
+#else
+  { "SUN_ATTACHMENT", 0 },
+#endif
+#ifdef HAVE_BKGDSET
+  { "HAVE_BKGDSET", 1 },
+#else
+  { "HAVE_BKGDSET", 0 },
+#endif
+#ifdef HAVE_COLOR
+  { "HAVE_COLOR", 1 },
+#else
+  { "HAVE_COLOR", 0 },
+#endif
+#ifdef HAVE_CURS_SET
+  { "HAVE_CURS_SET", 1 },
+#else
+  { "HAVE_CURS_SET", 0 },
+#endif
+#ifdef HAVE_GETADDRINFO
+  { "HAVE_GETADDRINFO", 1 },
+#else
+  { "HAVE_GETADDRINFO", 0 },
+#endif
+#ifdef HAVE_GETSID
+  { "HAVE_GETSID", 1 },
+#else
+  { "HAVE_GETSID", 0 },
+#endif
+#ifdef HAVE_ICONV
+  { "HAVE_ICONV", 1 },
+#else
+  { "HAVE_ICONV", 0 },
+#endif
+#ifdef HAVE_LANGINFO_CODESET
+  { "HAVE_LANGINFO_CODESET", 1 },
+#else
+  { "HAVE_LANGINFO_CODESET", 0 },
+#endif
+#ifdef HAVE_LANGINFO_YESEXPR
+  { "HAVE_LANGINFO_YESEXPR", 1 },
+#else
+  { "HAVE_LANGINFO_YESEXPR", 0 },
+#endif
+#ifdef HAVE_LIBIDN
+  { "HAVE_LIBIDN", 1 },
+#else
+  { "HAVE_LIBIDN", 0 },
+#endif
+#ifdef HAVE_META
+  { "HAVE_META", 1 },
+#else
+  { "HAVE_META", 0 },
+#endif
+#ifdef HAVE_REGCOMP
+  { "HAVE_REGCOMP", 1 },
+#else
+  { "HAVE_REGCOMP", 0 },
+#endif
+#ifdef HAVE_RESIZETERM
+  { "HAVE_RESIZETERM", 1 },
+#else
+  { "HAVE_RESIZETERM", 0 },
+#endif
+#ifdef HAVE_START_COLOR
+  { "HAVE_START_COLOR", 1 },
+#else
+  { "HAVE_START_COLOR", 0 },
+#endif
+#ifdef HAVE_TYPEAHEAD
+  { "HAVE_TYPEAHEAD", 1 },
+#else
+  { "HAVE_TYPEAHEAD", 0 },
+#endif
+#ifdef HAVE_WC_FUNCS
+  { "HAVE_WC_FUNCS", 1 },
+#else
+  { "HAVE_WC_FUNCS", 0 },
+#endif
+#ifdef ICONV_NONTRANS
+  { "ICONV_NONTRANS", 1 },
+#else
+  { "ICONV_NONTRANS", 0 },
+#endif
+#ifdef USE_COMPRESSED
+  { "USE_COMPRESSED", 1 },
+#else
+  { "USE_COMPRESSED", 0 },
+#endif
+#ifdef USE_DOTLOCK
+  { "USE_DOTLOCK", 1 },
+#else
+  { "USE_DOTLOCK", 0 },
+#endif
+#ifdef USE_FCNTL
+  { "USE_FCNTL", 1 },
+#else
+  { "USE_FCNTL", 0 },
+#endif
+#ifdef USE_FLOCK
+  { "USE_FLOCK", 1 },
+#else
+  { "USE_FLOCK", 0 },
+#endif
+#ifdef USE_FMEMOPEN
+  { "USE_FMEMOPEN", 1 },
+#else
+  { "USE_FMEMOPEN", 0 },
+#endif
+#ifdef USE_GNU_REGEX
+  { "USE_GNU_REGEX", 1 },
+#else
+  { "USE_GNU_REGEX", 0 },
+#endif
+#ifdef USE_GSS
+  { "USE_GSS", 1 },
+#else
+  { "USE_GSS", 0 },
+#endif
+#ifdef USE_HCACHE
+  { "USE_HCACHE", 1 },
+#else
+  { "USE_HCACHE", 0 },
+#endif
+#ifdef USE_IMAP
+  { "USE_IMAP", 1 },
+#else
+  { "USE_IMAP", 0 },
+#endif
+#ifdef USE_NOTMUCH
+  { "USE_NOTMUCH", 1 },
+#else
+  { "USE_NOTMUCH", 0 },
+#endif
+#ifdef USE_NNTP
+  { "USE_NNTP", 1 },
+#else
+  { "USE_NNTP", 0 },
+#endif
+#ifdef USE_POP
+  { "USE_POP", 1 },
+#else
+  { "USE_POP", 0 },
+#endif
+#ifdef USE_SASL
+  { "USE_SASL", 1 },
+#else
+  { "USE_SASL", 0 },
+#endif
+#ifdef USE_SETGID
+  { "USE_SETGID", 1 },
+#else
+  { "USE_SETGID", 0 },
+#endif
+#ifdef USE_SIDEBAR
+  { "USE_SIDEBAR", 1 },
+#else
+  { "USE_SIDEBAR", 0 },
+#endif
+#ifdef USE_SMTP
+  { "USE_SMTP", 1 },
+#else
+  { "USE_SMTP", 0 },
+#endif
+#ifdef USE_SSL_GNUTLS
+  { "USE_SSL_GNUTLS", 1 },
+#else
+  { "USE_SSL_GNUTLS", 0 },
+#endif
+#ifdef USE_SSL_OPENSSL
+  { "USE_SSL_OPENSSL", 1 },
+#else
+  { "USE_SSL_OPENSSL", 0 },
+#endif
+  { NULL, 0 }
+};
+
+/**
+ * print_compile_options - Print a list of enabled/disabled features
+ *
+ * The configure script lets uses enable/disable features.
+ * This shows the Mutt user which features are/aren't available.
+ *
+ * The output is of the form: "+ENABLED_FEATURE -DISABLED_FEATURE" and is
+ * wrapped to SCREEN_WIDTH characters.
+ */
+static void
+print_compile_options (void)
+{
+  int i;
+  char c;
+  int len;
+  int used = 0;
+
+  for (i = 0; comp_opts[i].name; i++)
+  {
+    len = strlen (comp_opts[i].name) + 2;   /* +/- and a space */
+    if ((used + len) > SCREEN_WIDTH)
+    {
+      used = 0;
+      puts ("");
+    }
+    used += len;
+    c = comp_opts[i].enabled ? '+' : '-';
+    printf ("%c%s ", c, comp_opts[i].name);
+  }
+  puts ("");
+}
+
+/**
+ * rstrip_in_place - Strip a trailing carriage return
+ * @s:  String to be modified
+ *
+ * The string has its last carriage return set to NUL.
+ * Returns:
+ *      The modified string
+ */
+static char *
+rstrip_in_place (char *s)
+{
+  if (!s)
+    return NULL;
+
+  char *p;
+
+  p = &s[strlen (s)];
+  if (p == s)
+    return s;
+  p--;
+  while ((p >= s) && ((*p == '\n') || (*p == '\r')))
+    *p-- = '\0';
+  return s;
+}
+
+/**
+ * print_version - Print system and compile info
+ *
+ * Print information about the current system Mutt is running on.
+ * Also print a list of all the compile-time information.
+ */
+void
+print_version (void)
+{
+  struct utsname uts;
+
+  puts (mutt_make_version());
+  puts (_(Notice));
+
+  uname (&uts);
+
+#ifdef _AIX
+  printf ("System: %s %s.%s", uts.sysname, uts.version, uts.release);
+#elif defined (SCO)
+  printf ("System: SCO %s", uts.release);
+#else
+  printf ("System: %s %s", uts.sysname, uts.release);
+#endif
+
+  printf (" (%s)", uts.machine);
+
+#ifdef NCURSES_VERSION
+  printf ("\nncurses: %s (compiled with %s)", curses_version(), NCURSES_VERSION);
+#elif defined (USE_SLANG_CURSES)
+  printf ("\nslang: %d", SLANG_VERSION);
+#endif
+
+#ifdef _LIBICONV_VERSION
+  printf ("\nlibiconv: %d.%d", _LIBICONV_VERSION >> 8,
+    _LIBICONV_VERSION & 0xff);
+#endif
+
+#ifdef HAVE_LIBIDN
+  printf ("\nlibidn: %s (compiled with %s)", stringprep_check_version (NULL),
+    STRINGPREP_VERSION);
+#endif
+
+#ifdef USE_HCACHE
+  printf ("\nhcache backend: %s", mutt_hcache_backend());
+#endif
+
+  puts ("\n\nCompiler:");
+  rstrip_in_place ((char *) cc_version);
+  puts (cc_version);
+
+  rstrip_in_place ((char *) configure_options);
+  printf ("\nConfigure options: %s\n", configure_options);
+
+  rstrip_in_place ((char *) cc_cflags);
+  printf ("\nCompilation CFLAGS: %s\n", cc_cflags);
+
+  puts (_("\nCompile options:"));
+  print_compile_options();
+
+#ifdef DOMAIN
+  printf ("DOMAIN=\"%s\"\n", DOMAIN);
+#else
+  puts ("-DOMAIN");
+#endif
+
+#ifdef MIXMASTER
+  printf ("MIXMASTER=\"%s\"\n", MIXMASTER);
+#else
+  puts ("-MIXMASTER");
+#endif
+
+#ifdef ISPELL
+  printf ("ISPELL=\"%s\"\n", ISPELL);
+#else
+  puts ("-ISPELL");
+#endif
+
+  printf ("SENDMAIL=\"%s\"\n", SENDMAIL);
+  printf ("MAILPATH=\"%s\"\n", MAILPATH);
+  printf ("PKGDATADIR=\"%s\"\n", PKGDATADIR);
+  printf ("SYSCONFDIR=\"%s\"\n", SYSCONFDIR);
+  printf ("EXECSHELL=\"%s\"\n", EXECSHELL);
+
+  puts ("");
+  mutt_print_patchlist();
+
+  puts ("");
+  puts (_(ReachingUs));
+}
+
+/**
+ * print_copyright - Print copyright message
+ *
+ * Print the authors' copyright messages, the GPL license and some contact
+ * information for the Mutt project.
+ */
+void
+print_copyright (void)
+{
+  puts (mutt_make_version());
+  puts (_(Copyright));
+  puts (_(License));
+  puts (_(Obtaining));
+  puts (_(ReachingUs));
+}
+
+/**
+ * feature_enabled - Test is a compile-time feature is enabled
+ * @name:  Compile-time symbol of the feature
+ *
+ * Many of the larger features of mutt can be disabled at compile time.
+ * They define a symbol and use #ifdef's around their code.
+ * The symbols are mirrored in "struct compile_options comp_opts[]" in this
+ * file.
+ *
+ * This function checks if one of these symbols is present in the code.
+ *
+ * These symbols are also seen in the output of "mutt -v".
+ *
+ * Returns:
+ *      1: Feature enables
+ *      0: Feature not enabled, or not compiled in
+ */
+int
+feature_enabled (const char *name)
+{
+  if (!name)
+    return 0;
+
+  int i;
+  for (i = 0; comp_opts[i].name; i++)
+  {
+    if (mutt_strcmp (name, comp_opts[i].name) == 0)
+    {
+      return 1;
+    }
+  }
+  return 0;
+}
+
diff --git c/version.h w/version.h
new file mode 100644
index 0000000..b46ebf8
--- /dev/null
+++ w/version.h
@@ -0,0 +1,26 @@
+/**
+ * Copyright (C) 2016 Richard Russon
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef _VERSION_H_
+#define _VERSION_H_
+
+void print_version (void);
+void print_copyright (void);
+int feature_enabled (const char *name);
+
+#endif /* _VERSION_H_ */
diff --git c/version.sh w/version.sh
deleted file mode 100644
index d7988df..0000000
--- c/version.sh
+++ /dev/null
@@ -1,68 +0,0 @@
-#!/bin/sh
-
-HG=hg
-
-# Switch to directory where this script lives so that further commands are run
-# from the root directory of the source.  The script path and srcdir are double
-# quoted to allow the space character to appear in the path.
-srcdir=`dirname "$0"` && cd "$srcdir" || exit 1
-
-# Ensure that we have a repo here and that mercurial is installed.  If
-# not, just cat the VERSION file; it contains the latest release number.
-{ [ -d ".hg" ] && $HG >/dev/null 2>&1; } \
-|| exec cat VERSION
-
-# This is a mercurial repo and we have the hg command.
-
-# Get essential properties of the current working copy
-set -- `$HG parents --template='{rev} {node|short}\n'`
-rev="$1"
-node="$2"
-
-# translate release tags into ##.##.## notation
-cleantag () {
-	case "$1" in
-		mutt-*-rel) echo "$1" | sed -e 's/mutt-//' -e 's/-rel//' | tr - . ;;
-		*)          echo "$1" ;;
-	esac
-}
-
-getdistance_old () {
-	# fudge it
-	set -- `$HG tags | sort -n -k 2 | egrep 'mutt-.*rel' | tail -1 | cut -d: -f1`
-	latesttag="$1"
-	latestrev="$2"
-	distance=`expr $rev - $latestrev`
-	echo $latesttag $distance
-}
-
-getdistance_new () {
-	$HG parents --template='{latesttag} {latesttagdistance}\n'
-}
-
-
-# latesttag appeared in hg 1.4.  Test for it.
-[ "`$HG log -r . --template='{latesttag}'`" = '' ] && 
-set -- `getdistance_old` ||
-set -- `getdistance_new`
-
-tag=`cleantag "$1"`
-dist=$2
-
-if [ $dist -eq 0 ]; then
-	dist=
-else
-	dist="+$dist"
-fi
-
-# if we have mq patches applied, mention it
-qparent=`$HG log -r qparent --template='{rev}\n' 2>/dev/null || echo $rev`
-qdelta=`expr $rev - $qparent`
-if [ $qdelta -eq 0 ]; then
-	qdist=""
-else
-	qdist=",mq+$qdelta"
-fi
-
-echo "$tag$dist$qdist ($node)"
-exit 0
